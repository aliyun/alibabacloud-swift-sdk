import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ClientNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskType: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("amount") {
            self.amount = dict["amount"] as! Int64
        }
        if dict.keys.contains("disk") {
            self.disk = dict["disk"] as! Int64
        }
        if dict.keys.contains("diskType") {
            self.diskType = dict["diskType"] as! String
        }
        if dict.keys.contains("spec") {
            self.spec = dict["spec"] as! String
        }
    }
}

public class CollectorDeployMachine : Tea.TeaModel {
    public class Machines : Tea.TeaModel {
        public var agentStatus: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentStatus != nil {
                map["agentStatus"] = self.agentStatus!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("agentStatus") {
                self.agentStatus = dict["agentStatus"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
        }
    }
    public var configType: String?

    public var groupId: String?

    public var instanceId: String?

    public var machines: [CollectorDeployMachine.Machines]?

    public var successPodsCount: String?

    public var totalPodsCount: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configType != nil {
            map["configType"] = self.configType!
        }
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.machines != nil {
            var tmp : [Any] = []
            for k in self.machines! {
                tmp.append(k.toMap())
            }
            map["machines"] = tmp
        }
        if self.successPodsCount != nil {
            map["successPodsCount"] = self.successPodsCount!
        }
        if self.totalPodsCount != nil {
            map["totalPodsCount"] = self.totalPodsCount!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("configType") {
            self.configType = dict["configType"] as! String
        }
        if dict.keys.contains("groupId") {
            self.groupId = dict["groupId"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("machines") {
            var tmp : [CollectorDeployMachine.Machines] = []
            for v in dict["machines"] as! [Any] {
                var model = CollectorDeployMachine.Machines()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.machines = tmp
        }
        if dict.keys.contains("successPodsCount") {
            self.successPodsCount = dict["successPodsCount"] as! String
        }
        if dict.keys.contains("totalPodsCount") {
            self.totalPodsCount = dict["totalPodsCount"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class CollectorKibanaInstance : Tea.TeaModel {
    public var configType: String?

    public var host: String?

    public var instanceId: String?

    public var kibanaHost: String?

    public var password: String?

    public var protocol_: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configType != nil {
            map["configType"] = self.configType!
        }
        if self.host != nil {
            map["host"] = self.host!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.kibanaHost != nil {
            map["kibanaHost"] = self.kibanaHost!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("configType") {
            self.configType = dict["configType"] as! String
        }
        if dict.keys.contains("host") {
            self.host = dict["host"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("kibanaHost") {
            self.kibanaHost = dict["kibanaHost"] as! String
        }
        if dict.keys.contains("password") {
            self.password = dict["password"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("userName") {
            self.userName = dict["userName"] as! String
        }
    }
}

public class CollectorTargetInstance : Tea.TeaModel {
    public var configType: String?

    public var enableMonitoring: Bool?

    public var hosts: [String]?

    public var instanceId: String?

    public var instanceType: String?

    public var password: String?

    public var protocol_: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configType != nil {
            map["configType"] = self.configType!
        }
        if self.enableMonitoring != nil {
            map["enableMonitoring"] = self.enableMonitoring!
        }
        if self.hosts != nil {
            map["hosts"] = self.hosts!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("configType") {
            self.configType = dict["configType"] as! String
        }
        if dict.keys.contains("enableMonitoring") {
            self.enableMonitoring = dict["enableMonitoring"] as! Bool
        }
        if dict.keys.contains("hosts") {
            self.hosts = dict["hosts"] as! [String]
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("instanceType") {
            self.instanceType = dict["instanceType"] as! String
        }
        if dict.keys.contains("password") {
            self.password = dict["password"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("userName") {
            self.userName = dict["userName"] as! String
        }
    }
}

public class DictInfo : Tea.TeaModel {
    public var fileSize: Int64?

    public var name: String?

    public var sourceType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSize != nil {
            map["fileSize"] = self.fileSize!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("fileSize") {
            self.fileSize = dict["fileSize"] as! Int64
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("sourceType") {
            self.sourceType = dict["sourceType"] as! String
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class ElasticDataNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskEncryption: Bool?

    public var diskType: String?

    public var performanceLevel: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskEncryption != nil {
            map["diskEncryption"] = self.diskEncryption!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.performanceLevel != nil {
            map["performanceLevel"] = self.performanceLevel!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("amount") {
            self.amount = dict["amount"] as! Int64
        }
        if dict.keys.contains("disk") {
            self.disk = dict["disk"] as! Int64
        }
        if dict.keys.contains("diskEncryption") {
            self.diskEncryption = dict["diskEncryption"] as! Bool
        }
        if dict.keys.contains("diskType") {
            self.diskType = dict["diskType"] as! String
        }
        if dict.keys.contains("performanceLevel") {
            self.performanceLevel = dict["performanceLevel"] as! String
        }
        if dict.keys.contains("spec") {
            self.spec = dict["spec"] as! String
        }
    }
}

public class Elasticsearch : Tea.TeaModel {
    public class AdvancedSetting : Tea.TeaModel {
        public var gcName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gcName != nil {
                map["gcName"] = self.gcName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gcName") {
                self.gcName = dict["gcName"] as! String
            }
        }
    }
    public var advancedDedicateMaster: Bool?

    public var advancedSetting: Elasticsearch.AdvancedSetting?

    public var aliwsDicts: [DictInfo]?

    public var clientNodeConfiguration: ClientNodeConfiguration?

    public var createdAt: String?

    public var dataNode: Bool?

    public var dedicateMaster: Bool?

    public var description_: String?

    public var dictList: [DictInfo]?

    public var domain: String?

    public var elasticDataNodeConfiguration: ElasticDataNodeConfiguration?

    public var enableKibanaPrivateNetwork: Bool?

    public var enableKibanaPublicNetwork: Bool?

    public var enablePublic: Bool?

    public var endTime: Int64?

    public var esConfig: [String: String]?

    public var esIPWhitelist: [String]?

    public var esVersion: String?

    public var extendConfigs: [[String: Any]]?

    public var haveClientNode: Bool?

    public var haveElasticDataNode: Bool?

    public var haveKibana: Bool?

    public var ikHotDicts: [DictInfo]?

    public var instanceId: String?

    public var kibanaConfiguration: KibanaNodeConfiguration?

    public var kibanaDomain: String?

    public var kibanaIPWhitelist: [String]?

    public var kibanaPort: Int64?

    public var kibanaPrivateDomain: String?

    public var kibanaPrivateIPWhitelist: [String]?

    public var kibanaPrivatePort: Int64?

    public var kibanaProtocol: String?

    public var masterConfiguration: MasterNodeConfiguration?

    public var networkConfig: NetworkConfig?

    public var nodeAmount: Int64?

    public var nodeSpec: NodeSpec?

    public var paymentType: String?

    public var port: Int64?

    public var privateNetworkIpWhiteList: [String]?

    public var productType: String?

    public var protocol_: String?

    public var publicDomain: String?

    public var publicIpWhitelist: [String]?

    public var publicPort: Int64?

    public var readWritePolicy: ReadWritePolicy?

    public var resourceGroupId: String?

    public var serviceVpc: Bool?

    public var status: String?

    public var synonymsDicts: [DictInfo]?

    public var tags: [Tag]?

    public var updatedAt: String?

    public var warmNode: Bool?

    public var warmNodeConfiguration: WarmNodeConfiguration?

    public var zoneCount: Int64?

    public var zoneInfos: [ZoneInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.advancedSetting?.validate()
        try self.clientNodeConfiguration?.validate()
        try self.elasticDataNodeConfiguration?.validate()
        try self.kibanaConfiguration?.validate()
        try self.masterConfiguration?.validate()
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
        try self.readWritePolicy?.validate()
        try self.warmNodeConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedDedicateMaster != nil {
            map["advancedDedicateMaster"] = self.advancedDedicateMaster!
        }
        if self.advancedSetting != nil {
            map["advancedSetting"] = self.advancedSetting?.toMap()
        }
        if self.aliwsDicts != nil {
            var tmp : [Any] = []
            for k in self.aliwsDicts! {
                tmp.append(k.toMap())
            }
            map["aliwsDicts"] = tmp
        }
        if self.clientNodeConfiguration != nil {
            map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
        }
        if self.createdAt != nil {
            map["createdAt"] = self.createdAt!
        }
        if self.dataNode != nil {
            map["dataNode"] = self.dataNode!
        }
        if self.dedicateMaster != nil {
            map["dedicateMaster"] = self.dedicateMaster!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.dictList != nil {
            var tmp : [Any] = []
            for k in self.dictList! {
                tmp.append(k.toMap())
            }
            map["dictList"] = tmp
        }
        if self.domain != nil {
            map["domain"] = self.domain!
        }
        if self.elasticDataNodeConfiguration != nil {
            map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
        }
        if self.enableKibanaPrivateNetwork != nil {
            map["enableKibanaPrivateNetwork"] = self.enableKibanaPrivateNetwork!
        }
        if self.enableKibanaPublicNetwork != nil {
            map["enableKibanaPublicNetwork"] = self.enableKibanaPublicNetwork!
        }
        if self.enablePublic != nil {
            map["enablePublic"] = self.enablePublic!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.esConfig != nil {
            map["esConfig"] = self.esConfig!
        }
        if self.esIPWhitelist != nil {
            map["esIPWhitelist"] = self.esIPWhitelist!
        }
        if self.esVersion != nil {
            map["esVersion"] = self.esVersion!
        }
        if self.extendConfigs != nil {
            map["extendConfigs"] = self.extendConfigs!
        }
        if self.haveClientNode != nil {
            map["haveClientNode"] = self.haveClientNode!
        }
        if self.haveElasticDataNode != nil {
            map["haveElasticDataNode"] = self.haveElasticDataNode!
        }
        if self.haveKibana != nil {
            map["haveKibana"] = self.haveKibana!
        }
        if self.ikHotDicts != nil {
            var tmp : [Any] = []
            for k in self.ikHotDicts! {
                tmp.append(k.toMap())
            }
            map["ikHotDicts"] = tmp
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.kibanaConfiguration != nil {
            map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
        }
        if self.kibanaDomain != nil {
            map["kibanaDomain"] = self.kibanaDomain!
        }
        if self.kibanaIPWhitelist != nil {
            map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
        }
        if self.kibanaPort != nil {
            map["kibanaPort"] = self.kibanaPort!
        }
        if self.kibanaPrivateDomain != nil {
            map["kibanaPrivateDomain"] = self.kibanaPrivateDomain!
        }
        if self.kibanaPrivateIPWhitelist != nil {
            map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
        }
        if self.kibanaPrivatePort != nil {
            map["kibanaPrivatePort"] = self.kibanaPrivatePort!
        }
        if self.kibanaProtocol != nil {
            map["kibanaProtocol"] = self.kibanaProtocol!
        }
        if self.masterConfiguration != nil {
            map["masterConfiguration"] = self.masterConfiguration?.toMap()
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.port != nil {
            map["port"] = self.port!
        }
        if self.privateNetworkIpWhiteList != nil {
            map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
        }
        if self.productType != nil {
            map["productType"] = self.productType!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.publicDomain != nil {
            map["publicDomain"] = self.publicDomain!
        }
        if self.publicIpWhitelist != nil {
            map["publicIpWhitelist"] = self.publicIpWhitelist!
        }
        if self.publicPort != nil {
            map["publicPort"] = self.publicPort!
        }
        if self.readWritePolicy != nil {
            map["readWritePolicy"] = self.readWritePolicy?.toMap()
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.serviceVpc != nil {
            map["serviceVpc"] = self.serviceVpc!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.synonymsDicts != nil {
            var tmp : [Any] = []
            for k in self.synonymsDicts! {
                tmp.append(k.toMap())
            }
            map["synonymsDicts"] = tmp
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.updatedAt != nil {
            map["updatedAt"] = self.updatedAt!
        }
        if self.warmNode != nil {
            map["warmNode"] = self.warmNode!
        }
        if self.warmNodeConfiguration != nil {
            map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
        }
        if self.zoneCount != nil {
            map["zoneCount"] = self.zoneCount!
        }
        if self.zoneInfos != nil {
            var tmp : [Any] = []
            for k in self.zoneInfos! {
                tmp.append(k.toMap())
            }
            map["zoneInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("advancedDedicateMaster") {
            self.advancedDedicateMaster = dict["advancedDedicateMaster"] as! Bool
        }
        if dict.keys.contains("advancedSetting") {
            var model = Elasticsearch.AdvancedSetting()
            model.fromMap(dict["advancedSetting"] as! [String: Any])
            self.advancedSetting = model
        }
        if dict.keys.contains("aliwsDicts") {
            var tmp : [DictInfo] = []
            for v in dict["aliwsDicts"] as! [Any] {
                var model = DictInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.aliwsDicts = tmp
        }
        if dict.keys.contains("clientNodeConfiguration") {
            var model = ClientNodeConfiguration()
            model.fromMap(dict["clientNodeConfiguration"] as! [String: Any])
            self.clientNodeConfiguration = model
        }
        if dict.keys.contains("createdAt") {
            self.createdAt = dict["createdAt"] as! String
        }
        if dict.keys.contains("dataNode") {
            self.dataNode = dict["dataNode"] as! Bool
        }
        if dict.keys.contains("dedicateMaster") {
            self.dedicateMaster = dict["dedicateMaster"] as! Bool
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("dictList") {
            var tmp : [DictInfo] = []
            for v in dict["dictList"] as! [Any] {
                var model = DictInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dictList = tmp
        }
        if dict.keys.contains("domain") {
            self.domain = dict["domain"] as! String
        }
        if dict.keys.contains("elasticDataNodeConfiguration") {
            var model = ElasticDataNodeConfiguration()
            model.fromMap(dict["elasticDataNodeConfiguration"] as! [String: Any])
            self.elasticDataNodeConfiguration = model
        }
        if dict.keys.contains("enableKibanaPrivateNetwork") {
            self.enableKibanaPrivateNetwork = dict["enableKibanaPrivateNetwork"] as! Bool
        }
        if dict.keys.contains("enableKibanaPublicNetwork") {
            self.enableKibanaPublicNetwork = dict["enableKibanaPublicNetwork"] as! Bool
        }
        if dict.keys.contains("enablePublic") {
            self.enablePublic = dict["enablePublic"] as! Bool
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("esConfig") {
            self.esConfig = dict["esConfig"] as! [String: String]
        }
        if dict.keys.contains("esIPWhitelist") {
            self.esIPWhitelist = dict["esIPWhitelist"] as! [String]
        }
        if dict.keys.contains("esVersion") {
            self.esVersion = dict["esVersion"] as! String
        }
        if dict.keys.contains("extendConfigs") {
            self.extendConfigs = dict["extendConfigs"] as! [[String: Any]]
        }
        if dict.keys.contains("haveClientNode") {
            self.haveClientNode = dict["haveClientNode"] as! Bool
        }
        if dict.keys.contains("haveElasticDataNode") {
            self.haveElasticDataNode = dict["haveElasticDataNode"] as! Bool
        }
        if dict.keys.contains("haveKibana") {
            self.haveKibana = dict["haveKibana"] as! Bool
        }
        if dict.keys.contains("ikHotDicts") {
            var tmp : [DictInfo] = []
            for v in dict["ikHotDicts"] as! [Any] {
                var model = DictInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.ikHotDicts = tmp
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("kibanaConfiguration") {
            var model = KibanaNodeConfiguration()
            model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
            self.kibanaConfiguration = model
        }
        if dict.keys.contains("kibanaDomain") {
            self.kibanaDomain = dict["kibanaDomain"] as! String
        }
        if dict.keys.contains("kibanaIPWhitelist") {
            self.kibanaIPWhitelist = dict["kibanaIPWhitelist"] as! [String]
        }
        if dict.keys.contains("kibanaPort") {
            self.kibanaPort = dict["kibanaPort"] as! Int64
        }
        if dict.keys.contains("kibanaPrivateDomain") {
            self.kibanaPrivateDomain = dict["kibanaPrivateDomain"] as! String
        }
        if dict.keys.contains("kibanaPrivateIPWhitelist") {
            self.kibanaPrivateIPWhitelist = dict["kibanaPrivateIPWhitelist"] as! [String]
        }
        if dict.keys.contains("kibanaPrivatePort") {
            self.kibanaPrivatePort = dict["kibanaPrivatePort"] as! Int64
        }
        if dict.keys.contains("kibanaProtocol") {
            self.kibanaProtocol = dict["kibanaProtocol"] as! String
        }
        if dict.keys.contains("masterConfiguration") {
            var model = MasterNodeConfiguration()
            model.fromMap(dict["masterConfiguration"] as! [String: Any])
            self.masterConfiguration = model
        }
        if dict.keys.contains("networkConfig") {
            var model = NetworkConfig()
            model.fromMap(dict["networkConfig"] as! [String: Any])
            self.networkConfig = model
        }
        if dict.keys.contains("nodeAmount") {
            self.nodeAmount = dict["nodeAmount"] as! Int64
        }
        if dict.keys.contains("nodeSpec") {
            var model = NodeSpec()
            model.fromMap(dict["nodeSpec"] as! [String: Any])
            self.nodeSpec = model
        }
        if dict.keys.contains("paymentType") {
            self.paymentType = dict["paymentType"] as! String
        }
        if dict.keys.contains("port") {
            self.port = dict["port"] as! Int64
        }
        if dict.keys.contains("privateNetworkIpWhiteList") {
            self.privateNetworkIpWhiteList = dict["privateNetworkIpWhiteList"] as! [String]
        }
        if dict.keys.contains("productType") {
            self.productType = dict["productType"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("publicDomain") {
            self.publicDomain = dict["publicDomain"] as! String
        }
        if dict.keys.contains("publicIpWhitelist") {
            self.publicIpWhitelist = dict["publicIpWhitelist"] as! [String]
        }
        if dict.keys.contains("publicPort") {
            self.publicPort = dict["publicPort"] as! Int64
        }
        if dict.keys.contains("readWritePolicy") {
            var model = ReadWritePolicy()
            model.fromMap(dict["readWritePolicy"] as! [String: Any])
            self.readWritePolicy = model
        }
        if dict.keys.contains("resourceGroupId") {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("serviceVpc") {
            self.serviceVpc = dict["serviceVpc"] as! Bool
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("synonymsDicts") {
            var tmp : [DictInfo] = []
            for v in dict["synonymsDicts"] as! [Any] {
                var model = DictInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.synonymsDicts = tmp
        }
        if dict.keys.contains("tags") {
            var tmp : [Tag] = []
            for v in dict["tags"] as! [Any] {
                var model = Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("updatedAt") {
            self.updatedAt = dict["updatedAt"] as! String
        }
        if dict.keys.contains("warmNode") {
            self.warmNode = dict["warmNode"] as! Bool
        }
        if dict.keys.contains("warmNodeConfiguration") {
            var model = WarmNodeConfiguration()
            model.fromMap(dict["warmNodeConfiguration"] as! [String: Any])
            self.warmNodeConfiguration = model
        }
        if dict.keys.contains("zoneCount") {
            self.zoneCount = dict["zoneCount"] as! Int64
        }
        if dict.keys.contains("zoneInfos") {
            var tmp : [ZoneInfo] = []
            for v in dict["zoneInfos"] as! [Any] {
                var model = ZoneInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zoneInfos = tmp
        }
    }
}

public class KibanaNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("amount") {
            self.amount = dict["amount"] as! Int64
        }
        if dict.keys.contains("disk") {
            self.disk = dict["disk"] as! Int64
        }
        if dict.keys.contains("spec") {
            self.spec = dict["spec"] as! String
        }
    }
}

public class Logstash : Tea.TeaModel {
    public class EndpointList : Tea.TeaModel {
        public var host: String?

        public var port: Int64?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int64
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public class NetworkConfig : Tea.TeaModel {
        public var type: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
            if dict.keys.contains("vsArea") {
                self.vsArea = dict["vsArea"] as! String
            }
            if dict.keys.contains("vswitchId") {
                self.vswitchId = dict["vswitchId"] as! String
            }
        }
    }
    public class NodeSpec : Tea.TeaModel {
        public var disk: Int64?

        public var diskType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                map["disk"] = self.disk!
            }
            if self.diskType != nil {
                map["diskType"] = self.diskType!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("disk") {
                self.disk = dict["disk"] as! Int64
            }
            if dict.keys.contains("diskType") {
                self.diskType = dict["diskType"] as! String
            }
            if dict.keys.contains("spec") {
                self.spec = dict["spec"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["tagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["tagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tagKey") {
                self.tagKey = dict["tagKey"] as! String
            }
            if dict.keys.contains("tagValue") {
                self.tagValue = dict["tagValue"] as! String
            }
        }
    }
    public class ZoneInfos : Tea.TeaModel {
        public var status: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public var config: [String: String]?

    public var createdAt: String?

    public var dataNode: Bool?

    public var description_: String?

    public var endTime: Int64?

    public var endpointList: [Logstash.EndpointList]?

    public var instanceId: String?

    public var networkConfig: Logstash.NetworkConfig?

    public var nodeAmount: Int64?

    public var nodeSpec: Logstash.NodeSpec?

    public var paymentType: String?

    public var protocol_: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: [Logstash.Tags]?

    public var updatedAt: String?

    public var version: String?

    public var zoneCount: Int64?

    public var zoneInfos: [Logstash.ZoneInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["config"] = self.config!
        }
        if self.createdAt != nil {
            map["createdAt"] = self.createdAt!
        }
        if self.dataNode != nil {
            map["dataNode"] = self.dataNode!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.endpointList != nil {
            var tmp : [Any] = []
            for k in self.endpointList! {
                tmp.append(k.toMap())
            }
            map["endpointList"] = tmp
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.updatedAt != nil {
            map["updatedAt"] = self.updatedAt!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        if self.zoneCount != nil {
            map["zoneCount"] = self.zoneCount!
        }
        if self.zoneInfos != nil {
            var tmp : [Any] = []
            for k in self.zoneInfos! {
                tmp.append(k.toMap())
            }
            map["zoneInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("config") {
            self.config = dict["config"] as! [String: String]
        }
        if dict.keys.contains("createdAt") {
            self.createdAt = dict["createdAt"] as! String
        }
        if dict.keys.contains("dataNode") {
            self.dataNode = dict["dataNode"] as! Bool
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("endpointList") {
            var tmp : [Logstash.EndpointList] = []
            for v in dict["endpointList"] as! [Any] {
                var model = Logstash.EndpointList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.endpointList = tmp
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("networkConfig") {
            var model = Logstash.NetworkConfig()
            model.fromMap(dict["networkConfig"] as! [String: Any])
            self.networkConfig = model
        }
        if dict.keys.contains("nodeAmount") {
            self.nodeAmount = dict["nodeAmount"] as! Int64
        }
        if dict.keys.contains("nodeSpec") {
            var model = Logstash.NodeSpec()
            model.fromMap(dict["nodeSpec"] as! [String: Any])
            self.nodeSpec = model
        }
        if dict.keys.contains("paymentType") {
            self.paymentType = dict["paymentType"] as! String
        }
        if dict.keys.contains("protocol") {
            self.protocol_ = dict["protocol"] as! String
        }
        if dict.keys.contains("resourceGroupId") {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("tags") {
            var tmp : [Logstash.Tags] = []
            for v in dict["tags"] as! [Any] {
                var model = Logstash.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("updatedAt") {
            self.updatedAt = dict["updatedAt"] as! String
        }
        if dict.keys.contains("version") {
            self.version = dict["version"] as! String
        }
        if dict.keys.contains("zoneCount") {
            self.zoneCount = dict["zoneCount"] as! Int64
        }
        if dict.keys.contains("zoneInfos") {
            var tmp : [Logstash.ZoneInfos] = []
            for v in dict["zoneInfos"] as! [Any] {
                var model = Logstash.ZoneInfos()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.zoneInfos = tmp
        }
    }
}

public class MasterNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskType: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("amount") {
            self.amount = dict["amount"] as! Int64
        }
        if dict.keys.contains("disk") {
            self.disk = dict["disk"] as! Int64
        }
        if dict.keys.contains("diskType") {
            self.diskType = dict["diskType"] as! String
        }
        if dict.keys.contains("spec") {
            self.spec = dict["spec"] as! String
        }
    }
}

public class MigrationJob : Tea.TeaModel {
    public class SourceCluster : Tea.TeaModel {
        public var instanceId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public class StatusResult : Tea.TeaModel {
        public var code: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.success != nil {
                map["success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("code") {
                self.code = dict["code"] as! String
            }
            if dict.keys.contains("success") {
                self.success = dict["success"] as! Bool
            }
        }
    }
    public class TargetCluster : Tea.TeaModel {
        public var instanceId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var currentState: String?

    public var disableSourceClusterAuth: Bool?

    public var disableTargetClusterAuth: Bool?

    public var endTime: Int64?

    public var migrationJobId: String?

    public var phase: String?

    public var sourceCluster: MigrationJob.SourceCluster?

    public var startTime: Int64?

    public var statusResult: [MigrationJob.StatusResult]?

    public var targetCluster: MigrationJob.TargetCluster?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceCluster?.validate()
        try self.targetCluster?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentState != nil {
            map["currentState"] = self.currentState!
        }
        if self.disableSourceClusterAuth != nil {
            map["disableSourceClusterAuth"] = self.disableSourceClusterAuth!
        }
        if self.disableTargetClusterAuth != nil {
            map["disableTargetClusterAuth"] = self.disableTargetClusterAuth!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.migrationJobId != nil {
            map["migrationJobId"] = self.migrationJobId!
        }
        if self.phase != nil {
            map["phase"] = self.phase!
        }
        if self.sourceCluster != nil {
            map["sourceCluster"] = self.sourceCluster?.toMap()
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.statusResult != nil {
            var tmp : [Any] = []
            for k in self.statusResult! {
                tmp.append(k.toMap())
            }
            map["statusResult"] = tmp
        }
        if self.targetCluster != nil {
            map["targetCluster"] = self.targetCluster?.toMap()
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("currentState") {
            self.currentState = dict["currentState"] as! String
        }
        if dict.keys.contains("disableSourceClusterAuth") {
            self.disableSourceClusterAuth = dict["disableSourceClusterAuth"] as! Bool
        }
        if dict.keys.contains("disableTargetClusterAuth") {
            self.disableTargetClusterAuth = dict["disableTargetClusterAuth"] as! Bool
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("migrationJobId") {
            self.migrationJobId = dict["migrationJobId"] as! String
        }
        if dict.keys.contains("phase") {
            self.phase = dict["phase"] as! String
        }
        if dict.keys.contains("sourceCluster") {
            var model = MigrationJob.SourceCluster()
            model.fromMap(dict["sourceCluster"] as! [String: Any])
            self.sourceCluster = model
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("statusResult") {
            var tmp : [MigrationJob.StatusResult] = []
            for v in dict["statusResult"] as! [Any] {
                var model = MigrationJob.StatusResult()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.statusResult = tmp
        }
        if dict.keys.contains("targetCluster") {
            var model = MigrationJob.TargetCluster()
            model.fromMap(dict["targetCluster"] as! [String: Any])
            self.targetCluster = model
        }
        if dict.keys.contains("updateTime") {
            self.updateTime = dict["updateTime"] as! Int64
        }
    }
}

public class NetworkConfig : Tea.TeaModel {
    public var type: String?

    public var vpcId: String?

    public var vsArea: String?

    public var vswitchId: String?

    public var whiteIpGroupList: [WhiteIpGroup]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        if self.vsArea != nil {
            map["vsArea"] = self.vsArea!
        }
        if self.vswitchId != nil {
            map["vswitchId"] = self.vswitchId!
        }
        if self.whiteIpGroupList != nil {
            var tmp : [Any] = []
            for k in self.whiteIpGroupList! {
                tmp.append(k.toMap())
            }
            map["whiteIpGroupList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
        if dict.keys.contains("vsArea") {
            self.vsArea = dict["vsArea"] as! String
        }
        if dict.keys.contains("vswitchId") {
            self.vswitchId = dict["vswitchId"] as! String
        }
        if dict.keys.contains("whiteIpGroupList") {
            var tmp : [WhiteIpGroup] = []
            for v in dict["whiteIpGroupList"] as! [Any] {
                var model = WhiteIpGroup()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.whiteIpGroupList = tmp
        }
    }
}

public class NodeInfo : Tea.TeaModel {
    public var host: String?

    public var hostName: String?

    public var port: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["host"] = self.host!
        }
        if self.hostName != nil {
            map["hostName"] = self.hostName!
        }
        if self.port != nil {
            map["port"] = self.port!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("host") {
            self.host = dict["host"] as! String
        }
        if dict.keys.contains("hostName") {
            self.hostName = dict["hostName"] as! String
        }
        if dict.keys.contains("port") {
            self.port = dict["port"] as! Int64
        }
        if dict.keys.contains("zoneId") {
            self.zoneId = dict["zoneId"] as! String
        }
    }
}

public class NodeSpec : Tea.TeaModel {
    public var disk: Int32?

    public var diskEncryption: Bool?

    public var diskType: String?

    public var performanceLevel: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskEncryption != nil {
            map["diskEncryption"] = self.diskEncryption!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.performanceLevel != nil {
            map["performanceLevel"] = self.performanceLevel!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("disk") {
            self.disk = dict["disk"] as! Int32
        }
        if dict.keys.contains("diskEncryption") {
            self.diskEncryption = dict["diskEncryption"] as! Bool
        }
        if dict.keys.contains("diskType") {
            self.diskType = dict["diskType"] as! String
        }
        if dict.keys.contains("performanceLevel") {
            self.performanceLevel = dict["performanceLevel"] as! String
        }
        if dict.keys.contains("spec") {
            self.spec = dict["spec"] as! String
        }
    }
}

public class PaymentInfo : Tea.TeaModel {
    public var autoRenewDuration: Int64?

    public var duration: Int64?

    public var isAutoRenew: Bool?

    public var pricingCycle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenewDuration != nil {
            map["autoRenewDuration"] = self.autoRenewDuration!
        }
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.isAutoRenew != nil {
            map["isAutoRenew"] = self.isAutoRenew!
        }
        if self.pricingCycle != nil {
            map["pricingCycle"] = self.pricingCycle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("autoRenewDuration") {
            self.autoRenewDuration = dict["autoRenewDuration"] as! Int64
        }
        if dict.keys.contains("duration") {
            self.duration = dict["duration"] as! Int64
        }
        if dict.keys.contains("isAutoRenew") {
            self.isAutoRenew = dict["isAutoRenew"] as! Bool
        }
        if dict.keys.contains("pricingCycle") {
            self.pricingCycle = dict["pricingCycle"] as! String
        }
    }
}

public class ReadWritePolicy : Tea.TeaModel {
    public var autoGeneratePk: Bool?

    public var writeHa: Bool?

    public var writePolicy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoGeneratePk != nil {
            map["autoGeneratePk"] = self.autoGeneratePk!
        }
        if self.writeHa != nil {
            map["writeHa"] = self.writeHa!
        }
        if self.writePolicy != nil {
            map["writePolicy"] = self.writePolicy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("autoGeneratePk") {
            self.autoGeneratePk = dict["autoGeneratePk"] as! Bool
        }
        if dict.keys.contains("writeHa") {
            self.writeHa = dict["writeHa"] as! Bool
        }
        if dict.keys.contains("writePolicy") {
            self.writePolicy = dict["writePolicy"] as! String
        }
    }
}

public class Tag : Tea.TeaModel {
    public var tagKey: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tagKey != nil {
            map["tagKey"] = self.tagKey!
        }
        if self.tagValue != nil {
            map["tagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("tagKey") {
            self.tagKey = dict["tagKey"] as! String
        }
        if dict.keys.contains("tagValue") {
            self.tagValue = dict["tagValue"] as! String
        }
    }
}

public class WarmNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskEncryption: Bool?

    public var diskType: String?

    public var performanceLevel: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskEncryption != nil {
            map["diskEncryption"] = self.diskEncryption!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.performanceLevel != nil {
            map["performanceLevel"] = self.performanceLevel!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("amount") {
            self.amount = dict["amount"] as! Int64
        }
        if dict.keys.contains("disk") {
            self.disk = dict["disk"] as! Int64
        }
        if dict.keys.contains("diskEncryption") {
            self.diskEncryption = dict["diskEncryption"] as! Bool
        }
        if dict.keys.contains("diskType") {
            self.diskType = dict["diskType"] as! String
        }
        if dict.keys.contains("performanceLevel") {
            self.performanceLevel = dict["performanceLevel"] as! String
        }
        if dict.keys.contains("spec") {
            self.spec = dict["spec"] as! String
        }
    }
}

public class WhiteIpGroup : Tea.TeaModel {
    public var whiteIpType: String?

    public var groupName: String?

    public var ips: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.whiteIpType != nil {
            map["WhiteIpType"] = self.whiteIpType!
        }
        if self.groupName != nil {
            map["groupName"] = self.groupName!
        }
        if self.ips != nil {
            map["ips"] = self.ips!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("WhiteIpType") {
            self.whiteIpType = dict["WhiteIpType"] as! String
        }
        if dict.keys.contains("groupName") {
            self.groupName = dict["groupName"] as! String
        }
        if dict.keys.contains("ips") {
            self.ips = dict["ips"] as! [String]
        }
    }
}

public class ZoneInfo : Tea.TeaModel {
    public var status: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("status") {
            self.status = dict["status"] as! String
        }
        if dict.keys.contains("zoneId") {
            self.zoneId = dict["zoneId"] as! String
        }
    }
}

public class ResultSpecInfoMapValue : Tea.TeaModel {
    public var cpuCount: String?

    public var memorySize: String?

    public var enable: String?

    public var spec: String?

    public var specGroupType: String?

    public var disk: String?

    public var diskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuCount != nil {
            map["cpuCount"] = self.cpuCount!
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.enable != nil {
            map["enable"] = self.enable!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        if self.specGroupType != nil {
            map["specGroupType"] = self.specGroupType!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("cpuCount") {
            self.cpuCount = dict["cpuCount"] as! String
        }
        if dict.keys.contains("memorySize") {
            self.memorySize = dict["memorySize"] as! String
        }
        if dict.keys.contains("enable") {
            self.enable = dict["enable"] as! String
        }
        if dict.keys.contains("spec") {
            self.spec = dict["spec"] as! String
        }
        if dict.keys.contains("specGroupType") {
            self.specGroupType = dict["specGroupType"] as! String
        }
        if dict.keys.contains("disk") {
            self.disk = dict["disk"] as! String
        }
        if dict.keys.contains("diskType") {
            self.diskType = dict["diskType"] as! String
        }
    }
}

public class ActivateZonesRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ActivateZonesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ActivateZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ActivateZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddConnectableClusterRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class AddConnectableClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class AddConnectableClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddConnectableClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddConnectableClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddSnapshotRepoRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class AddSnapshotRepoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class AddSnapshotRepoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSnapshotRepoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddSnapshotRepoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelDeletionRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class CancelDeletionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CancelDeletionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelDeletionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelDeletionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelLogstashDeletionRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class CancelLogstashDeletionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CancelLogstashDeletionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelLogstashDeletionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelLogstashDeletionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.taskType != nil {
            map["taskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("taskType") {
            self.taskType = dict["taskType"] as! String
        }
    }
}

public class CancelTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CancelTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CapacityPlanRequest : Tea.TeaModel {
    public class DataInfo : Tea.TeaModel {
        public var code: String?

        public var size: Int64?

        public var totalCount: Int32?

        public var type: String?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.totalCount != nil {
                map["totalCount"] = self.totalCount!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.unit != nil {
                map["unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("code") {
                self.code = dict["code"] as! String
            }
            if dict.keys.contains("size") {
                self.size = dict["size"] as! Int64
            }
            if dict.keys.contains("totalCount") {
                self.totalCount = dict["totalCount"] as! Int32
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("unit") {
                self.unit = dict["unit"] as! String
            }
        }
    }
    public class Metric : Tea.TeaModel {
        public var averageQps: Int32?

        public var code: String?

        public var concurrent: Int64?

        public var peakQps: Int32?

        public var responseTime: Int32?

        public var throughput: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.averageQps != nil {
                map["averageQps"] = self.averageQps!
            }
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.concurrent != nil {
                map["concurrent"] = self.concurrent!
            }
            if self.peakQps != nil {
                map["peakQps"] = self.peakQps!
            }
            if self.responseTime != nil {
                map["responseTime"] = self.responseTime!
            }
            if self.throughput != nil {
                map["throughput"] = self.throughput!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("averageQps") {
                self.averageQps = dict["averageQps"] as! Int32
            }
            if dict.keys.contains("code") {
                self.code = dict["code"] as! String
            }
            if dict.keys.contains("concurrent") {
                self.concurrent = dict["concurrent"] as! Int64
            }
            if dict.keys.contains("peakQps") {
                self.peakQps = dict["peakQps"] as! Int32
            }
            if dict.keys.contains("responseTime") {
                self.responseTime = dict["responseTime"] as! Int32
            }
            if dict.keys.contains("throughput") {
                self.throughput = dict["throughput"] as! Int64
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var complexQueryAvailable: Bool?

    public var dataInfo: [CapacityPlanRequest.DataInfo]?

    public var metric: [CapacityPlanRequest.Metric]?

    public var usageScenario: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complexQueryAvailable != nil {
            map["complexQueryAvailable"] = self.complexQueryAvailable!
        }
        if self.dataInfo != nil {
            var tmp : [Any] = []
            for k in self.dataInfo! {
                tmp.append(k.toMap())
            }
            map["dataInfo"] = tmp
        }
        if self.metric != nil {
            var tmp : [Any] = []
            for k in self.metric! {
                tmp.append(k.toMap())
            }
            map["metric"] = tmp
        }
        if self.usageScenario != nil {
            map["usageScenario"] = self.usageScenario!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("complexQueryAvailable") {
            self.complexQueryAvailable = dict["complexQueryAvailable"] as! Bool
        }
        if dict.keys.contains("dataInfo") {
            var tmp : [CapacityPlanRequest.DataInfo] = []
            for v in dict["dataInfo"] as! [Any] {
                var model = CapacityPlanRequest.DataInfo()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataInfo = tmp
        }
        if dict.keys.contains("metric") {
            var tmp : [CapacityPlanRequest.Metric] = []
            for v in dict["metric"] as! [Any] {
                var model = CapacityPlanRequest.Metric()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metric = tmp
        }
        if dict.keys.contains("usageScenario") {
            self.usageScenario = dict["usageScenario"] as! String
        }
    }
}

public class CapacityPlanResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ExtendConfigs : Tea.TeaModel {
            public var configType: String?

            public var disk: Int64?

            public var diskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["ConfigType"] = self.configType!
                }
                if self.disk != nil {
                    map["Disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ConfigType") {
                    self.configType = dict["ConfigType"] as! String
                }
                if dict.keys.contains("Disk") {
                    self.disk = dict["Disk"] as! Int64
                }
                if dict.keys.contains("DiskType") {
                    self.diskType = dict["DiskType"] as! String
                }
            }
        }
        public class NodeConfigurations : Tea.TeaModel {
            public var amount: Int64?

            public var cpu: Int64?

            public var disk: Int64?

            public var diskType: String?

            public var memory: Int64?

            public var nodeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.disk != nil {
                    map["Disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Amount") {
                    self.amount = dict["Amount"] as! Int64
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Int64
                }
                if dict.keys.contains("Disk") {
                    self.disk = dict["Disk"] as! Int64
                }
                if dict.keys.contains("DiskType") {
                    self.diskType = dict["DiskType"] as! String
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Int64
                }
                if dict.keys.contains("NodeType") {
                    self.nodeType = dict["NodeType"] as! String
                }
            }
        }
        public var extendConfigs: [CapacityPlanResponseBody.Result.ExtendConfigs]?

        public var instanceCategory: String?

        public var nodeConfigurations: [CapacityPlanResponseBody.Result.NodeConfigurations]?

        public var oversizedCluster: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["ExtendConfigs"] = tmp
            }
            if self.instanceCategory != nil {
                map["InstanceCategory"] = self.instanceCategory!
            }
            if self.nodeConfigurations != nil {
                var tmp : [Any] = []
                for k in self.nodeConfigurations! {
                    tmp.append(k.toMap())
                }
                map["NodeConfigurations"] = tmp
            }
            if self.oversizedCluster != nil {
                map["OversizedCluster"] = self.oversizedCluster!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExtendConfigs") {
                var tmp : [CapacityPlanResponseBody.Result.ExtendConfigs] = []
                for v in dict["ExtendConfigs"] as! [Any] {
                    var model = CapacityPlanResponseBody.Result.ExtendConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.extendConfigs = tmp
            }
            if dict.keys.contains("InstanceCategory") {
                self.instanceCategory = dict["InstanceCategory"] as! String
            }
            if dict.keys.contains("NodeConfigurations") {
                var tmp : [CapacityPlanResponseBody.Result.NodeConfigurations] = []
                for v in dict["NodeConfigurations"] as! [Any] {
                    var model = CapacityPlanResponseBody.Result.NodeConfigurations()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeConfigurations = tmp
            }
            if dict.keys.contains("OversizedCluster") {
                self.oversizedCluster = dict["OversizedCluster"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: CapacityPlanResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CapacityPlanResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CapacityPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CapacityPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CapacityPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseDiagnosisRequest : Tea.TeaModel {
    public var clientToken: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class CloseDiagnosisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CloseDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseDiagnosisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseHttpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class CloseHttpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CloseHttpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseHttpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseHttpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CloseManagedIndexRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class CloseManagedIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CloseManagedIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseManagedIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CloseManagedIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCollectorRequest : Tea.TeaModel {
    public class Configs : Tea.TeaModel {
        public var content: String?

        public var fileName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.fileName != nil {
                map["fileName"] = self.fileName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("fileName") {
                self.fileName = dict["fileName"] as! String
            }
        }
    }
    public var collectorPaths: [String]?

    public var configs: [CreateCollectorRequest.Configs]?

    public var dryRun: Bool?

    public var extendConfigs: [[String: Any]]?

    public var name: String?

    public var resType: String?

    public var resVersion: String?

    public var vpcId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectorPaths != nil {
            map["collectorPaths"] = self.collectorPaths!
        }
        if self.configs != nil {
            var tmp : [Any] = []
            for k in self.configs! {
                tmp.append(k.toMap())
            }
            map["configs"] = tmp
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        if self.extendConfigs != nil {
            map["extendConfigs"] = self.extendConfigs!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.resType != nil {
            map["resType"] = self.resType!
        }
        if self.resVersion != nil {
            map["resVersion"] = self.resVersion!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("collectorPaths") {
            self.collectorPaths = dict["collectorPaths"] as! [String]
        }
        if dict.keys.contains("configs") {
            var tmp : [CreateCollectorRequest.Configs] = []
            for v in dict["configs"] as! [Any] {
                var model = CreateCollectorRequest.Configs()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configs = tmp
        }
        if dict.keys.contains("dryRun") {
            self.dryRun = dict["dryRun"] as! Bool
        }
        if dict.keys.contains("extendConfigs") {
            self.extendConfigs = dict["extendConfigs"] as! [[String: Any]]
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("resType") {
            self.resType = dict["resType"] as! String
        }
        if dict.keys.contains("resVersion") {
            self.resVersion = dict["resVersion"] as! String
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class CreateCollectorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var resId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("resId") {
                self.resId = dict["resId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateCollectorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateCollectorResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateComponentIndexRequest : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var aliases: [String: Any]?

        public var mappings: [String: Any]?

        public var settings: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliases != nil {
                map["aliases"] = self.aliases!
            }
            if self.mappings != nil {
                map["mappings"] = self.mappings!
            }
            if self.settings != nil {
                map["settings"] = self.settings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aliases") {
                self.aliases = dict["aliases"] as! [String: Any]
            }
            if dict.keys.contains("mappings") {
                self.mappings = dict["mappings"] as! [String: Any]
            }
            if dict.keys.contains("settings") {
                self.settings = dict["settings"] as! [String: Any]
            }
        }
    }
    public var meta: [String: Any]?

    public var template: CreateComponentIndexRequest.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.meta != nil {
            map["_meta"] = self.meta!
        }
        if self.template != nil {
            map["template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("_meta") {
            self.meta = dict["_meta"] as! [String: Any]
        }
        if dict.keys.contains("template") {
            var model = CreateComponentIndexRequest.Template()
            model.fromMap(dict["template"] as! [String: Any])
            self.template = model
        }
    }
}

public class CreateComponentIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CreateComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateComponentIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDataStreamRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class CreateDataStreamResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateDataStreamResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateDataStreamResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateDataStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDataStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateILMPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class CreateILMPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreateILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateILMPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateIndexTemplateRequest : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var aliases: String?

        public var mappings: String?

        public var settings: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliases != nil {
                map["aliases"] = self.aliases!
            }
            if self.mappings != nil {
                map["mappings"] = self.mappings!
            }
            if self.settings != nil {
                map["settings"] = self.settings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aliases") {
                self.aliases = dict["aliases"] as! String
            }
            if dict.keys.contains("mappings") {
                self.mappings = dict["mappings"] as! String
            }
            if dict.keys.contains("settings") {
                self.settings = dict["settings"] as! String
            }
        }
    }
    public var clientToken: String?

    public var dataStream: Bool?

    public var ilmPolicy: String?

    public var indexPatterns: [String]?

    public var indexTemplate: String?

    public var priority: Int32?

    public var template: CreateIndexTemplateRequest.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataStream != nil {
            map["dataStream"] = self.dataStream!
        }
        if self.ilmPolicy != nil {
            map["ilmPolicy"] = self.ilmPolicy!
        }
        if self.indexPatterns != nil {
            map["indexPatterns"] = self.indexPatterns!
        }
        if self.indexTemplate != nil {
            map["indexTemplate"] = self.indexTemplate!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.template != nil {
            map["template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("dataStream") {
            self.dataStream = dict["dataStream"] as! Bool
        }
        if dict.keys.contains("ilmPolicy") {
            self.ilmPolicy = dict["ilmPolicy"] as! String
        }
        if dict.keys.contains("indexPatterns") {
            self.indexPatterns = dict["indexPatterns"] as! [String]
        }
        if dict.keys.contains("indexTemplate") {
            self.indexTemplate = dict["indexTemplate"] as! String
        }
        if dict.keys.contains("priority") {
            self.priority = dict["priority"] as! Int32
        }
        if dict.keys.contains("template") {
            var model = CreateIndexTemplateRequest.Template()
            model.fromMap(dict["template"] as! [String: Any])
            self.template = model
        }
    }
}

public class CreateIndexTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class CreateIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateIndexTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLogstashRequest : Tea.TeaModel {
    public class NetworkConfig : Tea.TeaModel {
        public var type: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
            if dict.keys.contains("vsArea") {
                self.vsArea = dict["vsArea"] as! String
            }
            if dict.keys.contains("vswitchId") {
                self.vswitchId = dict["vswitchId"] as! String
            }
        }
    }
    public class NodeSpec : Tea.TeaModel {
        public var disk: Int64?

        public var diskType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                map["disk"] = self.disk!
            }
            if self.diskType != nil {
                map["diskType"] = self.diskType!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("disk") {
                self.disk = dict["disk"] as! Int64
            }
            if dict.keys.contains("diskType") {
                self.diskType = dict["diskType"] as! String
            }
            if dict.keys.contains("spec") {
                self.spec = dict["spec"] as! String
            }
        }
    }
    public class PaymentInfo : Tea.TeaModel {
        public var autoRenewDuration: Int64?

        public var duration: Int64?

        public var isAutoRenew: Bool?

        public var pricingCycle: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRenewDuration != nil {
                map["autoRenewDuration"] = self.autoRenewDuration!
            }
            if self.duration != nil {
                map["duration"] = self.duration!
            }
            if self.isAutoRenew != nil {
                map["isAutoRenew"] = self.isAutoRenew!
            }
            if self.pricingCycle != nil {
                map["pricingCycle"] = self.pricingCycle!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("autoRenewDuration") {
                self.autoRenewDuration = dict["autoRenewDuration"] as! Int64
            }
            if dict.keys.contains("duration") {
                self.duration = dict["duration"] as! Int64
            }
            if dict.keys.contains("isAutoRenew") {
                self.isAutoRenew = dict["isAutoRenew"] as! Bool
            }
            if dict.keys.contains("pricingCycle") {
                self.pricingCycle = dict["pricingCycle"] as! String
            }
        }
    }
    public var description_: String?

    public var networkConfig: CreateLogstashRequest.NetworkConfig?

    public var nodeAmount: Int32?

    public var nodeSpec: CreateLogstashRequest.NodeSpec?

    public var paymentInfo: CreateLogstashRequest.PaymentInfo?

    public var paymentType: String?

    public var resourceGroupId: String?

    public var version: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
        try self.paymentInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentInfo != nil {
            map["paymentInfo"] = self.paymentInfo?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("networkConfig") {
            var model = CreateLogstashRequest.NetworkConfig()
            model.fromMap(dict["networkConfig"] as! [String: Any])
            self.networkConfig = model
        }
        if dict.keys.contains("nodeAmount") {
            self.nodeAmount = dict["nodeAmount"] as! Int32
        }
        if dict.keys.contains("nodeSpec") {
            var model = CreateLogstashRequest.NodeSpec()
            model.fromMap(dict["nodeSpec"] as! [String: Any])
            self.nodeSpec = model
        }
        if dict.keys.contains("paymentInfo") {
            var model = CreateLogstashRequest.PaymentInfo()
            model.fromMap(dict["paymentInfo"] as! [String: Any])
            self.paymentInfo = model
        }
        if dict.keys.contains("paymentType") {
            self.paymentType = dict["paymentType"] as! String
        }
        if dict.keys.contains("resourceGroupId") {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("version") {
            self.version = dict["version"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class CreateLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Logstash?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = Logstash()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLogstashResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePipelinesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var batchDelay: Int32?

        public var batchSize: Int32?

        public var config: String?

        public var description_: String?

        public var pipelineId: String?

        public var queueCheckPointWrites: Int32?

        public var queueMaxBytes: Int32?

        public var queueType: String?

        public var workers: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchDelay != nil {
                map["batchDelay"] = self.batchDelay!
            }
            if self.batchSize != nil {
                map["batchSize"] = self.batchSize!
            }
            if self.config != nil {
                map["config"] = self.config!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.queueCheckPointWrites != nil {
                map["queueCheckPointWrites"] = self.queueCheckPointWrites!
            }
            if self.queueMaxBytes != nil {
                map["queueMaxBytes"] = self.queueMaxBytes!
            }
            if self.queueType != nil {
                map["queueType"] = self.queueType!
            }
            if self.workers != nil {
                map["workers"] = self.workers!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("batchDelay") {
                self.batchDelay = dict["batchDelay"] as! Int32
            }
            if dict.keys.contains("batchSize") {
                self.batchSize = dict["batchSize"] as! Int32
            }
            if dict.keys.contains("config") {
                self.config = dict["config"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! String
            }
            if dict.keys.contains("queueCheckPointWrites") {
                self.queueCheckPointWrites = dict["queueCheckPointWrites"] as! Int32
            }
            if dict.keys.contains("queueMaxBytes") {
                self.queueMaxBytes = dict["queueMaxBytes"] as! Int32
            }
            if dict.keys.contains("queueType") {
                self.queueType = dict["queueType"] as! String
            }
            if dict.keys.contains("workers") {
                self.workers = dict["workers"] as! Int32
            }
        }
    }
    public var clientToken: String?

    public var body: [CreatePipelinesRequest.Body]?

    public var trigger: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            var tmp : [CreatePipelinesRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = CreatePipelinesRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
        if dict.keys.contains("trigger") {
            self.trigger = dict["trigger"] as! Bool
        }
    }
}

public class CreatePipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CreatePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnapshotRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class CreateSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class CreateSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpcEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceId: String?

    public var zoneId: String?

    public var dryRun: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("serviceId") {
            self.serviceId = dict["serviceId"] as! String
        }
        if dict.keys.contains("zoneId") {
            self.zoneId = dict["zoneId"] as! String
        }
        if dict.keys.contains("dryRun") {
            self.dryRun = dict["dryRun"] as! Bool
        }
    }
}

public class CreateVpcEndpointResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var endpointDomain: String?

        public var endpointId: String?

        public var endpointName: String?

        public var serviceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointDomain != nil {
                map["endpointDomain"] = self.endpointDomain!
            }
            if self.endpointId != nil {
                map["endpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["endpointName"] = self.endpointName!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("endpointDomain") {
                self.endpointDomain = dict["endpointDomain"] as! String
            }
            if dict.keys.contains("endpointId") {
                self.endpointId = dict["endpointId"] as! String
            }
            if dict.keys.contains("endpointName") {
                self.endpointName = dict["endpointName"] as! String
            }
            if dict.keys.contains("serviceId") {
                self.serviceId = dict["serviceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: CreateVpcEndpointResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = CreateVpcEndpointResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class CreateVpcEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpcEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactivateZonesRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class DeactivateZonesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeactivateZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeactivateZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DeleteCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteComponentIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteComponentIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteConnectedClusterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectedInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.connectedInstanceId != nil {
            map["connectedInstanceId"] = self.connectedInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("connectedInstanceId") {
            self.connectedInstanceId = dict["connectedInstanceId"] as! String
        }
    }
}

public class DeleteConnectedClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteConnectedClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConnectedClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteConnectedClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataStreamRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DeleteDataStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteDataStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDataTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("taskId") {
            self.taskId = dict["taskId"] as! String
        }
    }
}

public class DeleteDataTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteDataTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDataTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDeprecatedTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteDeprecatedTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeprecatedTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDeprecatedTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteILMPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteILMPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteIndexTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteIndexTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var deleteType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.deleteType != nil {
            map["deleteType"] = self.deleteType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("deleteType") {
            self.deleteType = dict["deleteType"] as! String
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLogstashRequest : Tea.TeaModel {
    public var clientToken: String?

    public var deleteType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.deleteType != nil {
            map["deleteType"] = self.deleteType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("deleteType") {
            self.deleteType = dict["deleteType"] as! String
        }
    }
}

public class DeleteLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLogstashResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePipelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var pipelineIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.pipelineIds != nil {
            map["pipelineIds"] = self.pipelineIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("pipelineIds") {
            self.pipelineIds = dict["pipelineIds"] as! String
        }
    }
}

public class DeletePipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeletePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnapshotRepoRequest : Tea.TeaModel {
    public var clientToken: String?

    public var repoPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("repoPath") {
            self.repoPath = dict["repoPath"] as! String
        }
    }
}

public class DeleteSnapshotRepoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteSnapshotRepoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotRepoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnapshotRepoResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpcEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class DeleteVpcEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DeleteVpcEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpcEndpointResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAckOperatorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var status: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAckOperatorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeAckOperatorResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeAckOperatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAckOperatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAckOperatorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeApmResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var apmServerDomain: String?

        public var createdAt: String?

        public var deployedReplica: Int64?

        public var description_: String?

        public var endTime: Int64?

        public var instanceId: String?

        public var nodeAmount: Int64?

        public var outputES: String?

        public var outputESUserName: String?

        public var ownerId: String?

        public var paymentType: String?

        public var region: String?

        public var replica: Int32?

        public var resourceSpec: String?

        public var status: String?

        public var version: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apmServerDomain != nil {
                map["apmServerDomain"] = self.apmServerDomain!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.deployedReplica != nil {
                map["deployedReplica"] = self.deployedReplica!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.outputES != nil {
                map["outputES"] = self.outputES!
            }
            if self.outputESUserName != nil {
                map["outputESUserName"] = self.outputESUserName!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.region != nil {
                map["region"] = self.region!
            }
            if self.replica != nil {
                map["replica"] = self.replica!
            }
            if self.resourceSpec != nil {
                map["resourceSpec"] = self.resourceSpec!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("apmServerDomain") {
                self.apmServerDomain = dict["apmServerDomain"] as! String
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("deployedReplica") {
                self.deployedReplica = dict["deployedReplica"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("endTime") {
                self.endTime = dict["endTime"] as! Int64
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int64
            }
            if dict.keys.contains("outputES") {
                self.outputES = dict["outputES"] as! String
            }
            if dict.keys.contains("outputESUserName") {
                self.outputESUserName = dict["outputESUserName"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! String
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("region") {
                self.region = dict["region"] as! String
            }
            if dict.keys.contains("replica") {
                self.replica = dict["replica"] as! Int32
            }
            if dict.keys.contains("resourceSpec") {
                self.resourceSpec = dict["resourceSpec"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
            if dict.keys.contains("vsArea") {
                self.vsArea = dict["vsArea"] as! String
            }
            if dict.keys.contains("vswitchId") {
                self.vswitchId = dict["vswitchId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeApmResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeApmResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeApmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCollectorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("agentStatus") {
                        self.agentStatus = dict["agentStatus"] as! String
                    }
                    if dict.keys.contains("instanceId") {
                        self.instanceId = dict["instanceId"] as! String
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [DescribeCollectorResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("configType") {
                    self.configType = dict["configType"] as! String
                }
                if dict.keys.contains("enableMonitoring") {
                    self.enableMonitoring = dict["enableMonitoring"] as! Bool
                }
                if dict.keys.contains("groupId") {
                    self.groupId = dict["groupId"] as! String
                }
                if dict.keys.contains("host") {
                    self.host = dict["host"] as! String
                }
                if dict.keys.contains("hosts") {
                    self.hosts = dict["hosts"] as! [String]
                }
                if dict.keys.contains("instanceId") {
                    self.instanceId = dict["instanceId"] as! String
                }
                if dict.keys.contains("instanceType") {
                    self.instanceType = dict["instanceType"] as! String
                }
                if dict.keys.contains("kibanaHost") {
                    self.kibanaHost = dict["kibanaHost"] as! String
                }
                if dict.keys.contains("machines") {
                    var tmp : [DescribeCollectorResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in dict["machines"] as! [Any] {
                        var model = DescribeCollectorResponseBody.Result.ExtendConfigs.Machines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.machines = tmp
                }
                if dict.keys.contains("protocol") {
                    self.protocol_ = dict["protocol"] as! String
                }
                if dict.keys.contains("successPodsCount") {
                    self.successPodsCount = dict["successPodsCount"] as! String
                }
                if dict.keys.contains("totalPodsCount") {
                    self.totalPodsCount = dict["totalPodsCount"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("userName") {
                    self.userName = dict["userName"] as! String
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [DescribeCollectorResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [DescribeCollectorResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("collectorPaths") {
                self.collectorPaths = dict["collectorPaths"] as! [String]
            }
            if dict.keys.contains("configs") {
                var tmp : [DescribeCollectorResponseBody.Result.Configs] = []
                for v in dict["configs"] as! [Any] {
                    var model = DescribeCollectorResponseBody.Result.Configs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configs = tmp
            }
            if dict.keys.contains("dryRun") {
                self.dryRun = dict["dryRun"] as! Bool
            }
            if dict.keys.contains("extendConfigs") {
                var tmp : [DescribeCollectorResponseBody.Result.ExtendConfigs] = []
                for v in dict["extendConfigs"] as! [Any] {
                    var model = DescribeCollectorResponseBody.Result.ExtendConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.extendConfigs = tmp
            }
            if dict.keys.contains("gmtCreatedTime") {
                self.gmtCreatedTime = dict["gmtCreatedTime"] as! String
            }
            if dict.keys.contains("gmtUpdateTime") {
                self.gmtUpdateTime = dict["gmtUpdateTime"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! String
            }
            if dict.keys.contains("resId") {
                self.resId = dict["resId"] as! String
            }
            if dict.keys.contains("resType") {
                self.resType = dict["resType"] as! String
            }
            if dict.keys.contains("resVersion") {
                self.resVersion = dict["resVersion"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeCollectorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeCollectorResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeComponentIndexResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: [String: Any]?

            public var mappings: [String: Any]?

            public var settings: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliases") {
                    self.aliases = dict["aliases"] as! [String: Any]
                }
                if dict.keys.contains("mappings") {
                    self.mappings = dict["mappings"] as! [String: Any]
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! [String: Any]
                }
            }
        }
        public var meta: [String: Any]?

        public var template: DescribeComponentIndexResponseBody.Result.Template?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.meta != nil {
                map["_meta"] = self.meta!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("_meta") {
                self.meta = dict["_meta"] as! [String: Any]
            }
            if dict.keys.contains("template") {
                var model = DescribeComponentIndexResponseBody.Result.Template()
                model.fromMap(dict["template"] as! [String: Any])
                self.template = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeComponentIndexResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeComponentIndexResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeComponentIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeConnectableClustersRequest : Tea.TeaModel {
    public var alreadySetItems: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alreadySetItems != nil {
            map["alreadySetItems"] = self.alreadySetItems!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("alreadySetItems") {
            self.alreadySetItems = dict["alreadySetItems"] as! Bool
        }
    }
}

public class DescribeConnectableClustersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var instances: String?

        public var networkType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instances != nil {
                map["instances"] = self.instances!
            }
            if self.networkType != nil {
                map["networkType"] = self.networkType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instances") {
                self.instances = dict["instances"] as! String
            }
            if dict.keys.contains("networkType") {
                self.networkType = dict["networkType"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeConnectableClustersResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeConnectableClustersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeConnectableClustersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeConnectableClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConnectableClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeConnectableClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeprecatedTemplateResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliases") {
                    self.aliases = dict["aliases"] as! String
                }
                if dict.keys.contains("mappings") {
                    self.mappings = dict["mappings"] as! String
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! String
                }
            }
        }
        public var dataStream: Bool?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var order: Int64?

        public var template: DescribeDeprecatedTemplateResponseBody.Result.Template?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataStream") {
                self.dataStream = dict["dataStream"] as! Bool
            }
            if dict.keys.contains("indexPatterns") {
                self.indexPatterns = dict["indexPatterns"] as! [String]
            }
            if dict.keys.contains("indexTemplate") {
                self.indexTemplate = dict["indexTemplate"] as! String
            }
            if dict.keys.contains("order") {
                self.order = dict["order"] as! Int64
            }
            if dict.keys.contains("template") {
                var model = DescribeDeprecatedTemplateResponseBody.Result.Template()
                model.fromMap(dict["template"] as! [String: Any])
                self.template = model
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDeprecatedTemplateResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeDeprecatedTemplateResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeDeprecatedTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeprecatedTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDeprecatedTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnoseReportRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class DescribeDiagnoseReportResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DiagnoseItems : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var desc: String?

                public var name: String?

                public var result: String?

                public var suggest: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desc != nil {
                        map["desc"] = self.desc!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.result != nil {
                        map["result"] = self.result!
                    }
                    if self.suggest != nil {
                        map["suggest"] = self.suggest!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("desc") {
                        self.desc = dict["desc"] as! String
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("result") {
                        self.result = dict["result"] as! String
                    }
                    if dict.keys.contains("suggest") {
                        self.suggest = dict["suggest"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                }
            }
            public var detail: DescribeDiagnoseReportResponseBody.Result.DiagnoseItems.Detail?

            public var health: String?

            public var item: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail?.toMap()
                }
                if self.health != nil {
                    map["health"] = self.health!
                }
                if self.item != nil {
                    map["item"] = self.item!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("detail") {
                    var model = DescribeDiagnoseReportResponseBody.Result.DiagnoseItems.Detail()
                    model.fromMap(dict["detail"] as! [String: Any])
                    self.detail = model
                }
                if dict.keys.contains("health") {
                    self.health = dict["health"] as! String
                }
                if dict.keys.contains("item") {
                    self.item = dict["item"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var diagnoseItems: [DescribeDiagnoseReportResponseBody.Result.DiagnoseItems]?

        public var health: String?

        public var instanceId: String?

        public var reportId: String?

        public var state: String?

        public var trigger: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.diagnoseItems != nil {
                var tmp : [Any] = []
                for k in self.diagnoseItems! {
                    tmp.append(k.toMap())
                }
                map["diagnoseItems"] = tmp
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.reportId != nil {
                map["reportId"] = self.reportId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.trigger != nil {
                map["trigger"] = self.trigger!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("diagnoseItems") {
                var tmp : [DescribeDiagnoseReportResponseBody.Result.DiagnoseItems] = []
                for v in dict["diagnoseItems"] as! [Any] {
                    var model = DescribeDiagnoseReportResponseBody.Result.DiagnoseItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diagnoseItems = tmp
            }
            if dict.keys.contains("health") {
                self.health = dict["health"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("reportId") {
                self.reportId = dict["reportId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("trigger") {
                self.trigger = dict["trigger"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDiagnoseReportResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeDiagnoseReportResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeDiagnoseReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnoseReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnoseReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosisSettingsRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class DescribeDiagnosisSettingsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var scene: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scene != nil {
                map["scene"] = self.scene!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("scene") {
                self.scene = dict["scene"] as! String
            }
            if dict.keys.contains("updateTime") {
                self.updateTime = dict["updateTime"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDiagnosisSettingsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeDiagnosisSettingsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeDiagnosisSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosisSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosisSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDynamicSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DescribeDynamicSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDynamicSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDynamicSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeElasticsearchHealthResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class DescribeElasticsearchHealthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticsearchHealthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeElasticsearchHealthResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeILMPolicyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var name: String?

        public var phases: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.phases != nil {
                map["phases"] = self.phases!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("phases") {
                self.phases = dict["phases"] as! [String: Any]
            }
        }
    }
    public var requestId: String?

    public var result: DescribeILMPolicyResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeILMPolicyResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeILMPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeIndexTemplateResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliases") {
                    self.aliases = dict["aliases"] as! String
                }
                if dict.keys.contains("mappings") {
                    self.mappings = dict["mappings"] as! String
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! String
                }
            }
        }
        public var dataStream: Bool?

        public var ilmPolicy: String?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var priority: Int32?

        public var template: DescribeIndexTemplateResponseBody.Result.Template?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.ilmPolicy != nil {
                map["ilmPolicy"] = self.ilmPolicy!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataStream") {
                self.dataStream = dict["dataStream"] as! Bool
            }
            if dict.keys.contains("ilmPolicy") {
                self.ilmPolicy = dict["ilmPolicy"] as! String
            }
            if dict.keys.contains("indexPatterns") {
                self.indexPatterns = dict["indexPatterns"] as! [String]
            }
            if dict.keys.contains("indexTemplate") {
                self.indexTemplate = dict["indexTemplate"] as! String
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int32
            }
            if dict.keys.contains("template") {
                var model = DescribeIndexTemplateResponseBody.Result.Template()
                model.fromMap(dict["template"] as! [String: Any])
                self.template = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeIndexTemplateResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeIndexTemplateResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeIndexTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AdvancedSetting : Tea.TeaModel {
            public var gcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gcName != nil {
                    map["gcName"] = self.gcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("gcName") {
                    self.gcName = dict["gcName"] as! String
                }
            }
        }
        public class AliwsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class ClientNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class DictList : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class ElasticDataNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskEncryption") {
                    self.diskEncryption = dict["diskEncryption"] as! Bool
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class IkHotDicts : Tea.TeaModel {
            public var fileSize: Int32?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int32
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("groupName") {
                        self.groupName = dict["groupName"] as! String
                    }
                    if dict.keys.contains("ips") {
                        self.ips = dict["ips"] as! [String]
                    }
                    if dict.keys.contains("whiteIpType") {
                        self.whiteIpType = dict["whiteIpType"] as! String
                    }
                }
            }
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public var whiteIpGroupList: [DescribeInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vsArea") {
                    self.vsArea = dict["vsArea"] as! String
                }
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
                if dict.keys.contains("whiteIpGroupList") {
                    var tmp : [DescribeInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in dict["whiteIpGroupList"] as! [Any] {
                        var model = DescribeInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var performanceLevel: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.performanceLevel != nil {
                    map["performanceLevel"] = self.performanceLevel!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskEncryption") {
                    self.diskEncryption = dict["diskEncryption"] as! Bool
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("performanceLevel") {
                    self.performanceLevel = dict["performanceLevel"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class SynonymsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("tagKey") {
                    self.tagKey = dict["tagKey"] as! String
                }
                if dict.keys.contains("tagValue") {
                    self.tagValue = dict["tagValue"] as! String
                }
            }
        }
        public class WarmNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskEncryption") {
                    self.diskEncryption = dict["diskEncryption"] as! Bool
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class ZoneInfos : Tea.TeaModel {
            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("status") {
                    self.status = dict["status"] as! String
                }
                if dict.keys.contains("zoneId") {
                    self.zoneId = dict["zoneId"] as! String
                }
            }
        }
        public var advancedDedicateMaster: Bool?

        public var advancedSetting: DescribeInstanceResponseBody.Result.AdvancedSetting?

        public var aliwsDicts: [DescribeInstanceResponseBody.Result.AliwsDicts]?

        public var archType: String?

        public var clientNodeConfiguration: DescribeInstanceResponseBody.Result.ClientNodeConfiguration?

        public var createdAt: String?

        public var dedicateMaster: Bool?

        public var description_: String?

        public var dictList: [DescribeInstanceResponseBody.Result.DictList]?

        public var domain: String?

        public var elasticDataNodeConfiguration: DescribeInstanceResponseBody.Result.ElasticDataNodeConfiguration?

        public var enableKibanaPrivateNetwork: Bool?

        public var enableKibanaPublicNetwork: Bool?

        public var enablePublic: Bool?

        public var endtime: Int64?

        public var esConfig: [String: Any]?

        public var esIPBlacklist: [String]?

        public var esIPWhitelist: [String]?

        public var esVersion: String?

        public var extendConfigs: [[String: Any]]?

        public var haveClientNode: Bool?

        public var haveKibana: Bool?

        public var ikHotDicts: [DescribeInstanceResponseBody.Result.IkHotDicts]?

        public var instanceCategory: String?

        public var instanceId: String?

        public var isNewDeployment: Bool?

        public var kibanaConfiguration: DescribeInstanceResponseBody.Result.KibanaConfiguration?

        public var kibanaDomain: String?

        public var kibanaIPWhitelist: [String]?

        public var kibanaPort: Int32?

        public var kibanaPrivateDomain: String?

        public var kibanaPrivateIPWhitelist: [String]?

        public var kibanaPrivatePort: String?

        public var masterConfiguration: DescribeInstanceResponseBody.Result.MasterConfiguration?

        public var networkConfig: DescribeInstanceResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: DescribeInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var port: Int32?

        public var postpaidServiceStatus: String?

        public var privateNetworkIpWhiteList: [String]?

        public var protocol_: String?

        public var publicDomain: String?

        public var publicIpWhitelist: [String]?

        public var publicPort: Int32?

        public var resourceGroupId: String?

        public var serviceVpc: Bool?

        public var status: String?

        public var synonymsDicts: [DescribeInstanceResponseBody.Result.SynonymsDicts]?

        public var tags: [DescribeInstanceResponseBody.Result.Tags]?

        public var updatedAt: String?

        public var vpcInstanceId: String?

        public var warmNode: Bool?

        public var warmNodeConfiguration: DescribeInstanceResponseBody.Result.WarmNodeConfiguration?

        public var zoneCount: Int32?

        public var zoneInfos: [DescribeInstanceResponseBody.Result.ZoneInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.advancedSetting?.validate()
            try self.clientNodeConfiguration?.validate()
            try self.elasticDataNodeConfiguration?.validate()
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
            try self.warmNodeConfiguration?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advancedDedicateMaster != nil {
                map["advancedDedicateMaster"] = self.advancedDedicateMaster!
            }
            if self.advancedSetting != nil {
                map["advancedSetting"] = self.advancedSetting?.toMap()
            }
            if self.aliwsDicts != nil {
                var tmp : [Any] = []
                for k in self.aliwsDicts! {
                    tmp.append(k.toMap())
                }
                map["aliwsDicts"] = tmp
            }
            if self.archType != nil {
                map["archType"] = self.archType!
            }
            if self.clientNodeConfiguration != nil {
                map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.dedicateMaster != nil {
                map["dedicateMaster"] = self.dedicateMaster!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.dictList != nil {
                var tmp : [Any] = []
                for k in self.dictList! {
                    tmp.append(k.toMap())
                }
                map["dictList"] = tmp
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.elasticDataNodeConfiguration != nil {
                map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
            }
            if self.enableKibanaPrivateNetwork != nil {
                map["enableKibanaPrivateNetwork"] = self.enableKibanaPrivateNetwork!
            }
            if self.enableKibanaPublicNetwork != nil {
                map["enableKibanaPublicNetwork"] = self.enableKibanaPublicNetwork!
            }
            if self.enablePublic != nil {
                map["enablePublic"] = self.enablePublic!
            }
            if self.endtime != nil {
                map["endtime"] = self.endtime!
            }
            if self.esConfig != nil {
                map["esConfig"] = self.esConfig!
            }
            if self.esIPBlacklist != nil {
                map["esIPBlacklist"] = self.esIPBlacklist!
            }
            if self.esIPWhitelist != nil {
                map["esIPWhitelist"] = self.esIPWhitelist!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.extendConfigs != nil {
                map["extendConfigs"] = self.extendConfigs!
            }
            if self.haveClientNode != nil {
                map["haveClientNode"] = self.haveClientNode!
            }
            if self.haveKibana != nil {
                map["haveKibana"] = self.haveKibana!
            }
            if self.ikHotDicts != nil {
                var tmp : [Any] = []
                for k in self.ikHotDicts! {
                    tmp.append(k.toMap())
                }
                map["ikHotDicts"] = tmp
            }
            if self.instanceCategory != nil {
                map["instanceCategory"] = self.instanceCategory!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.isNewDeployment != nil {
                map["isNewDeployment"] = self.isNewDeployment!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaDomain != nil {
                map["kibanaDomain"] = self.kibanaDomain!
            }
            if self.kibanaIPWhitelist != nil {
                map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
            }
            if self.kibanaPort != nil {
                map["kibanaPort"] = self.kibanaPort!
            }
            if self.kibanaPrivateDomain != nil {
                map["kibanaPrivateDomain"] = self.kibanaPrivateDomain!
            }
            if self.kibanaPrivateIPWhitelist != nil {
                map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
            }
            if self.kibanaPrivatePort != nil {
                map["kibanaPrivatePort"] = self.kibanaPrivatePort!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.postpaidServiceStatus != nil {
                map["postpaidServiceStatus"] = self.postpaidServiceStatus!
            }
            if self.privateNetworkIpWhiteList != nil {
                map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
            }
            if self.protocol_ != nil {
                map["protocol"] = self.protocol_!
            }
            if self.publicDomain != nil {
                map["publicDomain"] = self.publicDomain!
            }
            if self.publicIpWhitelist != nil {
                map["publicIpWhitelist"] = self.publicIpWhitelist!
            }
            if self.publicPort != nil {
                map["publicPort"] = self.publicPort!
            }
            if self.resourceGroupId != nil {
                map["resourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceVpc != nil {
                map["serviceVpc"] = self.serviceVpc!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.synonymsDicts != nil {
                var tmp : [Any] = []
                for k in self.synonymsDicts! {
                    tmp.append(k.toMap())
                }
                map["synonymsDicts"] = tmp
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.vpcInstanceId != nil {
                map["vpcInstanceId"] = self.vpcInstanceId!
            }
            if self.warmNode != nil {
                map["warmNode"] = self.warmNode!
            }
            if self.warmNodeConfiguration != nil {
                map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
            }
            if self.zoneCount != nil {
                map["zoneCount"] = self.zoneCount!
            }
            if self.zoneInfos != nil {
                var tmp : [Any] = []
                for k in self.zoneInfos! {
                    tmp.append(k.toMap())
                }
                map["zoneInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("advancedDedicateMaster") {
                self.advancedDedicateMaster = dict["advancedDedicateMaster"] as! Bool
            }
            if dict.keys.contains("advancedSetting") {
                var model = DescribeInstanceResponseBody.Result.AdvancedSetting()
                model.fromMap(dict["advancedSetting"] as! [String: Any])
                self.advancedSetting = model
            }
            if dict.keys.contains("aliwsDicts") {
                var tmp : [DescribeInstanceResponseBody.Result.AliwsDicts] = []
                for v in dict["aliwsDicts"] as! [Any] {
                    var model = DescribeInstanceResponseBody.Result.AliwsDicts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.aliwsDicts = tmp
            }
            if dict.keys.contains("archType") {
                self.archType = dict["archType"] as! String
            }
            if dict.keys.contains("clientNodeConfiguration") {
                var model = DescribeInstanceResponseBody.Result.ClientNodeConfiguration()
                model.fromMap(dict["clientNodeConfiguration"] as! [String: Any])
                self.clientNodeConfiguration = model
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("dedicateMaster") {
                self.dedicateMaster = dict["dedicateMaster"] as! Bool
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("dictList") {
                var tmp : [DescribeInstanceResponseBody.Result.DictList] = []
                for v in dict["dictList"] as! [Any] {
                    var model = DescribeInstanceResponseBody.Result.DictList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dictList = tmp
            }
            if dict.keys.contains("domain") {
                self.domain = dict["domain"] as! String
            }
            if dict.keys.contains("elasticDataNodeConfiguration") {
                var model = DescribeInstanceResponseBody.Result.ElasticDataNodeConfiguration()
                model.fromMap(dict["elasticDataNodeConfiguration"] as! [String: Any])
                self.elasticDataNodeConfiguration = model
            }
            if dict.keys.contains("enableKibanaPrivateNetwork") {
                self.enableKibanaPrivateNetwork = dict["enableKibanaPrivateNetwork"] as! Bool
            }
            if dict.keys.contains("enableKibanaPublicNetwork") {
                self.enableKibanaPublicNetwork = dict["enableKibanaPublicNetwork"] as! Bool
            }
            if dict.keys.contains("enablePublic") {
                self.enablePublic = dict["enablePublic"] as! Bool
            }
            if dict.keys.contains("endtime") {
                self.endtime = dict["endtime"] as! Int64
            }
            if dict.keys.contains("esConfig") {
                self.esConfig = dict["esConfig"] as! [String: Any]
            }
            if dict.keys.contains("esIPBlacklist") {
                self.esIPBlacklist = dict["esIPBlacklist"] as! [String]
            }
            if dict.keys.contains("esIPWhitelist") {
                self.esIPWhitelist = dict["esIPWhitelist"] as! [String]
            }
            if dict.keys.contains("esVersion") {
                self.esVersion = dict["esVersion"] as! String
            }
            if dict.keys.contains("extendConfigs") {
                self.extendConfigs = dict["extendConfigs"] as! [[String: Any]]
            }
            if dict.keys.contains("haveClientNode") {
                self.haveClientNode = dict["haveClientNode"] as! Bool
            }
            if dict.keys.contains("haveKibana") {
                self.haveKibana = dict["haveKibana"] as! Bool
            }
            if dict.keys.contains("ikHotDicts") {
                var tmp : [DescribeInstanceResponseBody.Result.IkHotDicts] = []
                for v in dict["ikHotDicts"] as! [Any] {
                    var model = DescribeInstanceResponseBody.Result.IkHotDicts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ikHotDicts = tmp
            }
            if dict.keys.contains("instanceCategory") {
                self.instanceCategory = dict["instanceCategory"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("isNewDeployment") {
                self.isNewDeployment = dict["isNewDeployment"] as! Bool
            }
            if dict.keys.contains("kibanaConfiguration") {
                var model = DescribeInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
                self.kibanaConfiguration = model
            }
            if dict.keys.contains("kibanaDomain") {
                self.kibanaDomain = dict["kibanaDomain"] as! String
            }
            if dict.keys.contains("kibanaIPWhitelist") {
                self.kibanaIPWhitelist = dict["kibanaIPWhitelist"] as! [String]
            }
            if dict.keys.contains("kibanaPort") {
                self.kibanaPort = dict["kibanaPort"] as! Int32
            }
            if dict.keys.contains("kibanaPrivateDomain") {
                self.kibanaPrivateDomain = dict["kibanaPrivateDomain"] as! String
            }
            if dict.keys.contains("kibanaPrivateIPWhitelist") {
                self.kibanaPrivateIPWhitelist = dict["kibanaPrivateIPWhitelist"] as! [String]
            }
            if dict.keys.contains("kibanaPrivatePort") {
                self.kibanaPrivatePort = dict["kibanaPrivatePort"] as! String
            }
            if dict.keys.contains("masterConfiguration") {
                var model = DescribeInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(dict["masterConfiguration"] as! [String: Any])
                self.masterConfiguration = model
            }
            if dict.keys.contains("networkConfig") {
                var model = DescribeInstanceResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int32
            }
            if dict.keys.contains("nodeSpec") {
                var model = DescribeInstanceResponseBody.Result.NodeSpec()
                model.fromMap(dict["nodeSpec"] as! [String: Any])
                self.nodeSpec = model
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
            if dict.keys.contains("postpaidServiceStatus") {
                self.postpaidServiceStatus = dict["postpaidServiceStatus"] as! String
            }
            if dict.keys.contains("privateNetworkIpWhiteList") {
                self.privateNetworkIpWhiteList = dict["privateNetworkIpWhiteList"] as! [String]
            }
            if dict.keys.contains("protocol") {
                self.protocol_ = dict["protocol"] as! String
            }
            if dict.keys.contains("publicDomain") {
                self.publicDomain = dict["publicDomain"] as! String
            }
            if dict.keys.contains("publicIpWhitelist") {
                self.publicIpWhitelist = dict["publicIpWhitelist"] as! [String]
            }
            if dict.keys.contains("publicPort") {
                self.publicPort = dict["publicPort"] as! Int32
            }
            if dict.keys.contains("resourceGroupId") {
                self.resourceGroupId = dict["resourceGroupId"] as! String
            }
            if dict.keys.contains("serviceVpc") {
                self.serviceVpc = dict["serviceVpc"] as! Bool
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("synonymsDicts") {
                var tmp : [DescribeInstanceResponseBody.Result.SynonymsDicts] = []
                for v in dict["synonymsDicts"] as! [Any] {
                    var model = DescribeInstanceResponseBody.Result.SynonymsDicts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.synonymsDicts = tmp
            }
            if dict.keys.contains("tags") {
                var tmp : [DescribeInstanceResponseBody.Result.Tags] = []
                for v in dict["tags"] as! [Any] {
                    var model = DescribeInstanceResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("vpcInstanceId") {
                self.vpcInstanceId = dict["vpcInstanceId"] as! String
            }
            if dict.keys.contains("warmNode") {
                self.warmNode = dict["warmNode"] as! Bool
            }
            if dict.keys.contains("warmNodeConfiguration") {
                var model = DescribeInstanceResponseBody.Result.WarmNodeConfiguration()
                model.fromMap(dict["warmNodeConfiguration"] as! [String: Any])
                self.warmNodeConfiguration = model
            }
            if dict.keys.contains("zoneCount") {
                self.zoneCount = dict["zoneCount"] as! Int32
            }
            if dict.keys.contains("zoneInfos") {
                var tmp : [DescribeInstanceResponseBody.Result.ZoneInfos] = []
                for v in dict["zoneInfos"] as! [Any] {
                    var model = DescribeInstanceResponseBody.Result.ZoneInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.zoneInfos = tmp
            }
        }
    }
    public var requestId: String?

    public var result: DescribeInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeInstanceResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeKibanaSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String: Any]
        }
    }
}

public class DescribeKibanaSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKibanaSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeKibanaSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLogstashResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("tagKey") {
                    self.tagKey = dict["tagKey"] as! String
                }
                if dict.keys.contains("tagValue") {
                    self.tagValue = dict["tagValue"] as! String
                }
            }
        }
        public class ZoneInfos : Tea.TeaModel {
            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("status") {
                    self.status = dict["status"] as! String
                }
                if dict.keys.contains("zoneId") {
                    self.zoneId = dict["zoneId"] as! String
                }
            }
        }
        public class EndpointList : Tea.TeaModel {
            public var host: String?

            public var port: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.port != nil {
                    map["port"] = self.port!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("host") {
                    self.host = dict["host"] as! String
                }
                if dict.keys.contains("port") {
                    self.port = dict["port"] as! String
                }
                if dict.keys.contains("zoneId") {
                    self.zoneId = dict["zoneId"] as! String
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vsArea") {
                    self.vsArea = dict["vsArea"] as! String
                }
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskEncryption") {
                    self.diskEncryption = dict["diskEncryption"] as! Bool
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public var extendConfigs: [[String: Any]]?

        public var resourceGroupId: String?

        public var tags: [DescribeLogstashResponseBody.Result.Tags]?

        public var zoneInfos: [DescribeLogstashResponseBody.Result.ZoneInfos]?

        public var config: [String: Any]?

        public var createdAt: String?

        public var description_: String?

        public var endpointList: [DescribeLogstashResponseBody.Result.EndpointList]?

        public var instanceId: String?

        public var networkConfig: DescribeLogstashResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: DescribeLogstashResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var status: String?

        public var updatedAt: String?

        public var version: String?

        public var vpcInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extendConfigs != nil {
                map["ExtendConfigs"] = self.extendConfigs!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.zoneInfos != nil {
                var tmp : [Any] = []
                for k in self.zoneInfos! {
                    tmp.append(k.toMap())
                }
                map["ZoneInfos"] = tmp
            }
            if self.config != nil {
                map["config"] = self.config!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endpointList != nil {
                var tmp : [Any] = []
                for k in self.endpointList! {
                    tmp.append(k.toMap())
                }
                map["endpointList"] = tmp
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            if self.vpcInstanceId != nil {
                map["vpcInstanceId"] = self.vpcInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ExtendConfigs") {
                self.extendConfigs = dict["ExtendConfigs"] as! [[String: Any]]
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeLogstashResponseBody.Result.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeLogstashResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("ZoneInfos") {
                var tmp : [DescribeLogstashResponseBody.Result.ZoneInfos] = []
                for v in dict["ZoneInfos"] as! [Any] {
                    var model = DescribeLogstashResponseBody.Result.ZoneInfos()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.zoneInfos = tmp
            }
            if dict.keys.contains("config") {
                self.config = dict["config"] as! [String: Any]
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("endpointList") {
                var tmp : [DescribeLogstashResponseBody.Result.EndpointList] = []
                for v in dict["endpointList"] as! [Any] {
                    var model = DescribeLogstashResponseBody.Result.EndpointList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.endpointList = tmp
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("networkConfig") {
                var model = DescribeLogstashResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int32
            }
            if dict.keys.contains("nodeSpec") {
                var model = DescribeLogstashResponseBody.Result.NodeSpec()
                model.fromMap(dict["nodeSpec"] as! [String: Any])
                self.nodeSpec = model
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
            if dict.keys.contains("vpcInstanceId") {
                self.vpcInstanceId = dict["vpcInstanceId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeLogstashResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeLogstashResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLogstashResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePipelineResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var batchDelay: Int32?

        public var batchSize: Int32?

        public var config: String?

        public var description_: String?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var pipelineId: String?

        public var pipelineStatus: String?

        public var queueCheckPointWrites: Int32?

        public var queueMaxBytes: Int32?

        public var queueType: String?

        public var workers: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchDelay != nil {
                map["batchDelay"] = self.batchDelay!
            }
            if self.batchSize != nil {
                map["batchSize"] = self.batchSize!
            }
            if self.config != nil {
                map["config"] = self.config!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineStatus != nil {
                map["pipelineStatus"] = self.pipelineStatus!
            }
            if self.queueCheckPointWrites != nil {
                map["queueCheckPointWrites"] = self.queueCheckPointWrites!
            }
            if self.queueMaxBytes != nil {
                map["queueMaxBytes"] = self.queueMaxBytes!
            }
            if self.queueType != nil {
                map["queueType"] = self.queueType!
            }
            if self.workers != nil {
                map["workers"] = self.workers!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("batchDelay") {
                self.batchDelay = dict["batchDelay"] as! Int32
            }
            if dict.keys.contains("batchSize") {
                self.batchSize = dict["batchSize"] as! Int32
            }
            if dict.keys.contains("config") {
                self.config = dict["config"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("gmtCreatedTime") {
                self.gmtCreatedTime = dict["gmtCreatedTime"] as! String
            }
            if dict.keys.contains("gmtUpdateTime") {
                self.gmtUpdateTime = dict["gmtUpdateTime"] as! String
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! String
            }
            if dict.keys.contains("pipelineStatus") {
                self.pipelineStatus = dict["pipelineStatus"] as! String
            }
            if dict.keys.contains("queueCheckPointWrites") {
                self.queueCheckPointWrites = dict["queueCheckPointWrites"] as! Int32
            }
            if dict.keys.contains("queueMaxBytes") {
                self.queueMaxBytes = dict["queueMaxBytes"] as! Int32
            }
            if dict.keys.contains("queueType") {
                self.queueType = dict["queueType"] as! String
            }
            if dict.keys.contains("workers") {
                self.workers = dict["workers"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: DescribePipelineResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribePipelineResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePipelineManagementConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class DescribePipelineManagementConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var endpoints: String?

        public var esInstanceId: String?

        public var pipelineIds: [String]?

        public var pipelineManagementType: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpoints != nil {
                map["endpoints"] = self.endpoints!
            }
            if self.esInstanceId != nil {
                map["esInstanceId"] = self.esInstanceId!
            }
            if self.pipelineIds != nil {
                map["pipelineIds"] = self.pipelineIds!
            }
            if self.pipelineManagementType != nil {
                map["pipelineManagementType"] = self.pipelineManagementType!
            }
            if self.userName != nil {
                map["userName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("endpoints") {
                self.endpoints = dict["endpoints"] as! String
            }
            if dict.keys.contains("esInstanceId") {
                self.esInstanceId = dict["esInstanceId"] as! String
            }
            if dict.keys.contains("pipelineIds") {
                self.pipelineIds = dict["pipelineIds"] as! [String]
            }
            if dict.keys.contains("pipelineManagementType") {
                self.pipelineManagementType = dict["pipelineManagementType"] as! String
            }
            if dict.keys.contains("userName") {
                self.userName = dict["userName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribePipelineManagementConfigResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribePipelineManagementConfigResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribePipelineManagementConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePipelineManagementConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePipelineManagementConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consoleEndpoint: String?

        public var localName: String?

        public var regionEndpoint: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consoleEndpoint != nil {
                map["consoleEndpoint"] = self.consoleEndpoint!
            }
            if self.localName != nil {
                map["localName"] = self.localName!
            }
            if self.regionEndpoint != nil {
                map["regionEndpoint"] = self.regionEndpoint!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("consoleEndpoint") {
                self.consoleEndpoint = dict["consoleEndpoint"] as! String
            }
            if dict.keys.contains("localName") {
                self.localName = dict["localName"] as! String
            }
            if dict.keys.contains("regionEndpoint") {
                self.regionEndpoint = dict["regionEndpoint"] as! String
            }
            if dict.keys.contains("regionId") {
                self.regionId = dict["regionId"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeRegionsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeRegionsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeRegionsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotSettingResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var quartzRegex: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.quartzRegex != nil {
                map["QuartzRegex"] = self.quartzRegex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enable") {
                self.enable = dict["Enable"] as! Bool
            }
            if dict.keys.contains("QuartzRegex") {
                self.quartzRegex = dict["QuartzRegex"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeSnapshotSettingResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeSnapshotSettingResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeSnapshotSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("templateName") {
                self.templateName = dict["templateName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [DescribeTemplatesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = DescribeTemplatesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class DescribeTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeXpackMonitorConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var endpoints: [String]?

        public var esInstanceId: String?

        public var pipelineIds: [String]?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.endpoints != nil {
                map["endpoints"] = self.endpoints!
            }
            if self.esInstanceId != nil {
                map["esInstanceId"] = self.esInstanceId!
            }
            if self.pipelineIds != nil {
                map["pipelineIds"] = self.pipelineIds!
            }
            if self.userName != nil {
                map["userName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enable") {
                self.enable = dict["enable"] as! Bool
            }
            if dict.keys.contains("endpoints") {
                self.endpoints = dict["endpoints"] as! [String]
            }
            if dict.keys.contains("esInstanceId") {
                self.esInstanceId = dict["esInstanceId"] as! String
            }
            if dict.keys.contains("pipelineIds") {
                self.pipelineIds = dict["pipelineIds"] as! [String]
            }
            if dict.keys.contains("userName") {
                self.userName = dict["userName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DescribeXpackMonitorConfigResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DescribeXpackMonitorConfigResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DescribeXpackMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeXpackMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeXpackMonitorConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DiagnoseInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diagnoseItems: [String]?

    public var indices: [String]?

    public var type: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diagnoseItems != nil {
            map["diagnoseItems"] = self.diagnoseItems!
        }
        if self.indices != nil {
            map["indices"] = self.indices!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("diagnoseItems") {
            self.diagnoseItems = dict["diagnoseItems"] as! [String]
        }
        if dict.keys.contains("indices") {
            self.indices = dict["indices"] as! [String]
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class DiagnoseInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: Int64?

        public var instanceId: String?

        public var reportId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.reportId != nil {
                map["reportId"] = self.reportId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("reportId") {
                self.reportId = dict["reportId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: DiagnoseInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = DiagnoseInstanceResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class DiagnoseInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiagnoseInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DiagnoseInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class DisableKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableKibanaPvlNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableKibanaPvlNetworkRequest : Tea.TeaModel {
    public class VSwitchIdsZone : Tea.TeaModel {
        public var vswitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("vswitchId") {
                self.vswitchId = dict["vswitchId"] as! String
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public var endpointName: String?

    public var securityGroups: [String]?

    public var vSwitchIdsZone: [EnableKibanaPvlNetworkRequest.VSwitchIdsZone]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointName != nil {
            map["endpointName"] = self.endpointName!
        }
        if self.securityGroups != nil {
            map["securityGroups"] = self.securityGroups!
        }
        if self.vSwitchIdsZone != nil {
            var tmp : [Any] = []
            for k in self.vSwitchIdsZone! {
                tmp.append(k.toMap())
            }
            map["vSwitchIdsZone"] = tmp
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endpointName") {
            self.endpointName = dict["endpointName"] as! String
        }
        if dict.keys.contains("securityGroups") {
            self.securityGroups = dict["securityGroups"] as! [String]
        }
        if dict.keys.contains("vSwitchIdsZone") {
            var tmp : [EnableKibanaPvlNetworkRequest.VSwitchIdsZone] = []
            for v in dict["vSwitchIdsZone"] as! [Any] {
                var model = EnableKibanaPvlNetworkRequest.VSwitchIdsZone()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.vSwitchIdsZone = tmp
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class EnableKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class EnableKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableKibanaPvlNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EstimatedLogstashRestartTimeRequest : Tea.TeaModel {
    public var body: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("force") {
            self.force = dict["force"] as! Bool
        }
    }
}

public class EstimatedLogstashRestartTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var unit: String?

        public var value: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.unit != nil {
                map["unit"] = self.unit!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("unit") {
                self.unit = dict["unit"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: EstimatedLogstashRestartTimeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = EstimatedLogstashRestartTimeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class EstimatedLogstashRestartTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EstimatedLogstashRestartTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EstimatedLogstashRestartTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EstimatedRestartTimeRequest : Tea.TeaModel {
    public var body: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("force") {
            self.force = dict["force"] as! Bool
        }
    }
}

public class EstimatedRestartTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var unit: String?

        public var value: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.unit != nil {
                map["unit"] = self.unit!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("unit") {
                self.unit = dict["unit"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: EstimatedRestartTimeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = EstimatedRestartTimeResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class EstimatedRestartTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EstimatedRestartTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EstimatedRestartTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetClusterDataInformationRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class GetClusterDataInformationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MetaInfo : Tea.TeaModel {
            public var fields: [String]?

            public var indices: [String]?

            public var mapping: String?

            public var settings: String?

            public var typeName: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fields != nil {
                    map["fields"] = self.fields!
                }
                if self.indices != nil {
                    map["indices"] = self.indices!
                }
                if self.mapping != nil {
                    map["mapping"] = self.mapping!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                if self.typeName != nil {
                    map["typeName"] = self.typeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fields") {
                    self.fields = dict["fields"] as! [String]
                }
                if dict.keys.contains("indices") {
                    self.indices = dict["indices"] as! [String]
                }
                if dict.keys.contains("mapping") {
                    self.mapping = dict["mapping"] as! String
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! String
                }
                if dict.keys.contains("typeName") {
                    self.typeName = dict["typeName"] as! [String]
                }
            }
        }
        public var connectable: Bool?

        public var metaInfo: GetClusterDataInformationResponseBody.Result.MetaInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectable != nil {
                map["connectable"] = self.connectable!
            }
            if self.metaInfo != nil {
                map["metaInfo"] = self.metaInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("connectable") {
                self.connectable = dict["connectable"] as! Bool
            }
            if dict.keys.contains("metaInfo") {
                var model = GetClusterDataInformationResponseBody.Result.MetaInfo()
                model.fromMap(dict["metaInfo"] as! [String: Any])
                self.metaInfo = model
            }
        }
    }
    public var requestId: String?

    public var result: GetClusterDataInformationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetClusterDataInformationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetClusterDataInformationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterDataInformationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetClusterDataInformationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetElastictaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ElasticExpansionTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cronExpression") {
                    self.cronExpression = dict["cronExpression"] as! String
                }
                if dict.keys.contains("elasticNodeCount") {
                    self.elasticNodeCount = dict["elasticNodeCount"] as! Int32
                }
                if dict.keys.contains("replicaCount") {
                    self.replicaCount = dict["replicaCount"] as! Int32
                }
                if dict.keys.contains("targetIndices") {
                    self.targetIndices = dict["targetIndices"] as! [String]
                }
                if dict.keys.contains("triggerType") {
                    self.triggerType = dict["triggerType"] as! String
                }
            }
        }
        public class ElasticShrinkTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cronExpression") {
                    self.cronExpression = dict["cronExpression"] as! String
                }
                if dict.keys.contains("elasticNodeCount") {
                    self.elasticNodeCount = dict["elasticNodeCount"] as! Int32
                }
                if dict.keys.contains("replicaCount") {
                    self.replicaCount = dict["replicaCount"] as! Int32
                }
                if dict.keys.contains("targetIndices") {
                    self.targetIndices = dict["targetIndices"] as! [String]
                }
                if dict.keys.contains("triggerType") {
                    self.triggerType = dict["triggerType"] as! String
                }
            }
        }
        public var elasticExpansionTask: GetElastictaskResponseBody.Result.ElasticExpansionTask?

        public var elasticShrinkTask: GetElastictaskResponseBody.Result.ElasticShrinkTask?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.elasticExpansionTask?.validate()
            try self.elasticShrinkTask?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticExpansionTask != nil {
                map["elasticExpansionTask"] = self.elasticExpansionTask?.toMap()
            }
            if self.elasticShrinkTask != nil {
                map["elasticShrinkTask"] = self.elasticShrinkTask?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("elasticExpansionTask") {
                var model = GetElastictaskResponseBody.Result.ElasticExpansionTask()
                model.fromMap(dict["elasticExpansionTask"] as! [String: Any])
                self.elasticExpansionTask = model
            }
            if dict.keys.contains("elasticShrinkTask") {
                var model = GetElastictaskResponseBody.Result.ElasticShrinkTask()
                model.fromMap(dict["elasticShrinkTask"] as! [String: Any])
                self.elasticShrinkTask = model
            }
        }
    }
    public var requestId: String?

    public var result: GetElastictaskResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetElastictaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetElastictaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetElastictaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetElastictaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEmonGrafanaAlertsRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class GetEmonGrafanaAlertsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetEmonGrafanaAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEmonGrafanaAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEmonGrafanaAlertsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEmonGrafanaDashboardsRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class GetEmonGrafanaDashboardsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetEmonGrafanaDashboardsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEmonGrafanaDashboardsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEmonGrafanaDashboardsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetEmonMonitorDataRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class GetEmonMonitorDataResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var dps: [String: Any]?

        public var integrity: Double?

        public var messageWatermark: Int64?

        public var metric: String?

        public var summary: Double?

        public var tags: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dps != nil {
                map["dps"] = self.dps!
            }
            if self.integrity != nil {
                map["integrity"] = self.integrity!
            }
            if self.messageWatermark != nil {
                map["messageWatermark"] = self.messageWatermark!
            }
            if self.metric != nil {
                map["metric"] = self.metric!
            }
            if self.summary != nil {
                map["summary"] = self.summary!
            }
            if self.tags != nil {
                map["tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dps") {
                self.dps = dict["dps"] as! [String: Any]
            }
            if dict.keys.contains("integrity") {
                self.integrity = dict["integrity"] as! Double
            }
            if dict.keys.contains("messageWatermark") {
                self.messageWatermark = dict["messageWatermark"] as! Int64
            }
            if dict.keys.contains("metric") {
                self.metric = dict["metric"] as! String
            }
            if dict.keys.contains("summary") {
                self.summary = dict["summary"] as! Double
            }
            if dict.keys.contains("tags") {
                self.tags = dict["tags"] as! [String: Any]
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: [GetEmonMonitorDataResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [GetEmonMonitorDataResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = GetEmonMonitorDataResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class GetEmonMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEmonMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetEmonMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetOpenStoreUsageResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var currentUsage: Int64?

        public var lastDayUsage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentUsage != nil {
                map["currentUsage"] = self.currentUsage!
            }
            if self.lastDayUsage != nil {
                map["lastDayUsage"] = self.lastDayUsage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("currentUsage") {
                self.currentUsage = dict["currentUsage"] as! Int64
            }
            if dict.keys.contains("lastDayUsage") {
                self.lastDayUsage = dict["lastDayUsage"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: GetOpenStoreUsageResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetOpenStoreUsageResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetOpenStoreUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpenStoreUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetOpenStoreUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRegionConfigurationRequest : Tea.TeaModel {
    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("zoneId") {
            self.zoneId = dict["zoneId"] as! String
        }
    }
}

public class GetRegionConfigurationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ClientNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("maxAmount") {
                    self.maxAmount = dict["maxAmount"] as! Int32
                }
                if dict.keys.contains("minAmount") {
                    self.minAmount = dict["minAmount"] as! Int32
                }
            }
        }
        public class ClientNodeDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("maxSize") {
                    self.maxSize = dict["maxSize"] as! Int32
                }
                if dict.keys.contains("minSize") {
                    self.minSize = dict["minSize"] as! Int32
                }
                if dict.keys.contains("scaleLimit") {
                    self.scaleLimit = dict["scaleLimit"] as! Int32
                }
            }
        }
        public class DataDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var valueLimitSet: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.valueLimitSet != nil {
                    map["valueLimitSet"] = self.valueLimitSet!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("maxSize") {
                    self.maxSize = dict["maxSize"] as! Int32
                }
                if dict.keys.contains("minSize") {
                    self.minSize = dict["minSize"] as! Int32
                }
                if dict.keys.contains("scaleLimit") {
                    self.scaleLimit = dict["scaleLimit"] as! Int32
                }
                if dict.keys.contains("valueLimitSet") {
                    self.valueLimitSet = dict["valueLimitSet"] as! [String]
                }
            }
        }
        public class ElasticNodeProperties : Tea.TeaModel {
            public class AmountRange : Tea.TeaModel {
                public var maxAmount: Int32?

                public var minAmount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxAmount != nil {
                        map["maxAmount"] = self.maxAmount!
                    }
                    if self.minAmount != nil {
                        map["minAmount"] = self.minAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxAmount") {
                        self.maxAmount = dict["maxAmount"] as! Int32
                    }
                    if dict.keys.contains("minAmount") {
                        self.minAmount = dict["minAmount"] as! Int32
                    }
                }
            }
            public class DiskList : Tea.TeaModel {
                public var diskEncryption: Bool?

                public var diskType: String?

                public var maxSize: Int32?

                public var minSize: Int32?

                public var scaleLimit: Int32?

                public var valueLimitSet: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskEncryption != nil {
                        map["diskEncryption"] = self.diskEncryption!
                    }
                    if self.diskType != nil {
                        map["diskType"] = self.diskType!
                    }
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.scaleLimit != nil {
                        map["scaleLimit"] = self.scaleLimit!
                    }
                    if self.valueLimitSet != nil {
                        map["valueLimitSet"] = self.valueLimitSet!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("diskEncryption") {
                        self.diskEncryption = dict["diskEncryption"] as! Bool
                    }
                    if dict.keys.contains("diskType") {
                        self.diskType = dict["diskType"] as! String
                    }
                    if dict.keys.contains("maxSize") {
                        self.maxSize = dict["maxSize"] as! Int32
                    }
                    if dict.keys.contains("minSize") {
                        self.minSize = dict["minSize"] as! Int32
                    }
                    if dict.keys.contains("scaleLimit") {
                        self.scaleLimit = dict["scaleLimit"] as! Int32
                    }
                    if dict.keys.contains("valueLimitSet") {
                        self.valueLimitSet = dict["valueLimitSet"] as! [String]
                    }
                }
            }
            public var amountRange: GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.AmountRange?

            public var diskList: [GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.DiskList]?

            public var spec: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.amountRange?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amountRange != nil {
                    map["amountRange"] = self.amountRange?.toMap()
                }
                if self.diskList != nil {
                    var tmp : [Any] = []
                    for k in self.diskList! {
                        tmp.append(k.toMap())
                    }
                    map["diskList"] = tmp
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amountRange") {
                    var model = GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.AmountRange()
                    model.fromMap(dict["amountRange"] as! [String: Any])
                    self.amountRange = model
                }
                if dict.keys.contains("diskList") {
                    var tmp : [GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.DiskList] = []
                    for v in dict["diskList"] as! [Any] {
                        var model = GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.DiskList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.diskList = tmp
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! [String]
                }
            }
        }
        public class EsVersionsLatestList : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["key"] = self.key!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("key") {
                    self.key = dict["key"] as! String
                }
                if dict.keys.contains("value") {
                    self.value = dict["value"] as! String
                }
            }
        }
        public class JvmConfine : Tea.TeaModel {
            public var memory: Int32?

            public var supportEsVersions: [String]?

            public var supportGcs: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memory != nil {
                    map["memory"] = self.memory!
                }
                if self.supportEsVersions != nil {
                    map["supportEsVersions"] = self.supportEsVersions!
                }
                if self.supportGcs != nil {
                    map["supportGcs"] = self.supportGcs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("memory") {
                    self.memory = dict["memory"] as! Int32
                }
                if dict.keys.contains("supportEsVersions") {
                    self.supportEsVersions = dict["supportEsVersions"] as! [String]
                }
                if dict.keys.contains("supportGcs") {
                    self.supportGcs = dict["supportGcs"] as! [String]
                }
            }
        }
        public class KibanaNodeProperties : Tea.TeaModel {
            public class AmountRange : Tea.TeaModel {
                public var maxAmount: Int32?

                public var minAmount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxAmount != nil {
                        map["maxAmount"] = self.maxAmount!
                    }
                    if self.minAmount != nil {
                        map["minAmount"] = self.minAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxAmount") {
                        self.maxAmount = dict["maxAmount"] as! Int32
                    }
                    if dict.keys.contains("minAmount") {
                        self.minAmount = dict["minAmount"] as! Int32
                    }
                }
            }
            public var amountRange: GetRegionConfigurationResponseBody.Result.KibanaNodeProperties.AmountRange?

            public var spec: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.amountRange?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amountRange != nil {
                    map["amountRange"] = self.amountRange?.toMap()
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amountRange") {
                    var model = GetRegionConfigurationResponseBody.Result.KibanaNodeProperties.AmountRange()
                    model.fromMap(dict["amountRange"] as! [String: Any])
                    self.amountRange = model
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! [String]
                }
            }
        }
        public class MasterDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("maxSize") {
                    self.maxSize = dict["maxSize"] as! Int32
                }
                if dict.keys.contains("minSize") {
                    self.minSize = dict["minSize"] as! Int32
                }
                if dict.keys.contains("scaleLimit") {
                    self.scaleLimit = dict["scaleLimit"] as! Int32
                }
            }
        }
        public class Node : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("maxAmount") {
                    self.maxAmount = dict["maxAmount"] as! Int32
                }
                if dict.keys.contains("minAmount") {
                    self.minAmount = dict["minAmount"] as! Int32
                }
            }
        }
        public class NodeSpecList : Tea.TeaModel {
            public var cpuCount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var enable: Bool?

            public var memorySize: Int32?

            public var spec: String?

            public var specGroupType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCount != nil {
                    map["cpuCount"] = self.cpuCount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.enable != nil {
                    map["enable"] = self.enable!
                }
                if self.memorySize != nil {
                    map["memorySize"] = self.memorySize!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specGroupType != nil {
                    map["specGroupType"] = self.specGroupType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cpuCount") {
                    self.cpuCount = dict["cpuCount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("enable") {
                    self.enable = dict["enable"] as! Bool
                }
                if dict.keys.contains("memorySize") {
                    self.memorySize = dict["memorySize"] as! Int32
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specGroupType") {
                    self.specGroupType = dict["specGroupType"] as! String
                }
            }
        }
        public class SupportVersions : Tea.TeaModel {
            public class SupportVersionList : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["key"] = self.key!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("key") {
                        self.key = dict["key"] as! String
                    }
                    if dict.keys.contains("value") {
                        self.value = dict["value"] as! String
                    }
                }
            }
            public var instanceCategory: String?

            public var supportVersionList: [GetRegionConfigurationResponseBody.Result.SupportVersions.SupportVersionList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceCategory != nil {
                    map["instanceCategory"] = self.instanceCategory!
                }
                if self.supportVersionList != nil {
                    var tmp : [Any] = []
                    for k in self.supportVersionList! {
                        tmp.append(k.toMap())
                    }
                    map["supportVersionList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("instanceCategory") {
                    self.instanceCategory = dict["instanceCategory"] as! String
                }
                if dict.keys.contains("supportVersionList") {
                    var tmp : [GetRegionConfigurationResponseBody.Result.SupportVersions.SupportVersionList] = []
                    for v in dict["supportVersionList"] as! [Any] {
                        var model = GetRegionConfigurationResponseBody.Result.SupportVersions.SupportVersionList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.supportVersionList = tmp
                }
            }
        }
        public class WarmNodeProperties : Tea.TeaModel {
            public class AmountRange : Tea.TeaModel {
                public var maxAmount: Int32?

                public var minAmount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxAmount != nil {
                        map["maxAmount"] = self.maxAmount!
                    }
                    if self.minAmount != nil {
                        map["minAmount"] = self.minAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxAmount") {
                        self.maxAmount = dict["maxAmount"] as! Int32
                    }
                    if dict.keys.contains("minAmount") {
                        self.minAmount = dict["minAmount"] as! Int32
                    }
                }
            }
            public class DiskList : Tea.TeaModel {
                public var diskEncryption: Bool?

                public var diskType: String?

                public var maxSize: Int32?

                public var minSize: Int32?

                public var scaleLimit: Int32?

                public var valueLimitSet: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskEncryption != nil {
                        map["diskEncryption"] = self.diskEncryption!
                    }
                    if self.diskType != nil {
                        map["diskType"] = self.diskType!
                    }
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.scaleLimit != nil {
                        map["scaleLimit"] = self.scaleLimit!
                    }
                    if self.valueLimitSet != nil {
                        map["valueLimitSet"] = self.valueLimitSet!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("diskEncryption") {
                        self.diskEncryption = dict["diskEncryption"] as! Bool
                    }
                    if dict.keys.contains("diskType") {
                        self.diskType = dict["diskType"] as! String
                    }
                    if dict.keys.contains("maxSize") {
                        self.maxSize = dict["maxSize"] as! Int32
                    }
                    if dict.keys.contains("minSize") {
                        self.minSize = dict["minSize"] as! Int32
                    }
                    if dict.keys.contains("scaleLimit") {
                        self.scaleLimit = dict["scaleLimit"] as! Int32
                    }
                    if dict.keys.contains("valueLimitSet") {
                        self.valueLimitSet = dict["valueLimitSet"] as! [String]
                    }
                }
            }
            public var amountRange: GetRegionConfigurationResponseBody.Result.WarmNodeProperties.AmountRange?

            public var diskList: [GetRegionConfigurationResponseBody.Result.WarmNodeProperties.DiskList]?

            public var spec: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.amountRange?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amountRange != nil {
                    map["amountRange"] = self.amountRange?.toMap()
                }
                if self.diskList != nil {
                    var tmp : [Any] = []
                    for k in self.diskList! {
                        tmp.append(k.toMap())
                    }
                    map["diskList"] = tmp
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amountRange") {
                    var model = GetRegionConfigurationResponseBody.Result.WarmNodeProperties.AmountRange()
                    model.fromMap(dict["amountRange"] as! [String: Any])
                    self.amountRange = model
                }
                if dict.keys.contains("diskList") {
                    var tmp : [GetRegionConfigurationResponseBody.Result.WarmNodeProperties.DiskList] = []
                    for v in dict["diskList"] as! [Any] {
                        var model = GetRegionConfigurationResponseBody.Result.WarmNodeProperties.DiskList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.diskList = tmp
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! [String]
                }
            }
        }
        public var clientNodeAmountRange: GetRegionConfigurationResponseBody.Result.ClientNodeAmountRange?

        public var clientNodeDiskList: [GetRegionConfigurationResponseBody.Result.ClientNodeDiskList]?

        public var clientNodeSpec: [String]?

        public var createUrl: String?

        public var dataDiskList: [GetRegionConfigurationResponseBody.Result.DataDiskList]?

        public var elasticNodeProperties: GetRegionConfigurationResponseBody.Result.ElasticNodeProperties?

        public var env: String?

        public var esVersions: [String]?

        public var esVersionsLatestList: [GetRegionConfigurationResponseBody.Result.EsVersionsLatestList]?

        public var instanceSupportNodes: [String]?

        public var jvmConfine: GetRegionConfigurationResponseBody.Result.JvmConfine?

        public var kibanaNodeProperties: GetRegionConfigurationResponseBody.Result.KibanaNodeProperties?

        public var logstashZones: [String]?

        public var masterDiskList: [GetRegionConfigurationResponseBody.Result.MasterDiskList]?

        public var masterSpec: [String]?

        public var node: GetRegionConfigurationResponseBody.Result.Node?

        public var nodeSpecList: [GetRegionConfigurationResponseBody.Result.NodeSpecList]?

        public var regionId: String?

        public var supportVersions: [GetRegionConfigurationResponseBody.Result.SupportVersions]?

        public var warmNodeProperties: GetRegionConfigurationResponseBody.Result.WarmNodeProperties?

        public var zones: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clientNodeAmountRange?.validate()
            try self.elasticNodeProperties?.validate()
            try self.jvmConfine?.validate()
            try self.kibanaNodeProperties?.validate()
            try self.node?.validate()
            try self.warmNodeProperties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientNodeAmountRange != nil {
                map["clientNodeAmountRange"] = self.clientNodeAmountRange?.toMap()
            }
            if self.clientNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.clientNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["clientNodeDiskList"] = tmp
            }
            if self.clientNodeSpec != nil {
                map["clientNodeSpec"] = self.clientNodeSpec!
            }
            if self.createUrl != nil {
                map["createUrl"] = self.createUrl!
            }
            if self.dataDiskList != nil {
                var tmp : [Any] = []
                for k in self.dataDiskList! {
                    tmp.append(k.toMap())
                }
                map["dataDiskList"] = tmp
            }
            if self.elasticNodeProperties != nil {
                map["elasticNodeProperties"] = self.elasticNodeProperties?.toMap()
            }
            if self.env != nil {
                map["env"] = self.env!
            }
            if self.esVersions != nil {
                map["esVersions"] = self.esVersions!
            }
            if self.esVersionsLatestList != nil {
                var tmp : [Any] = []
                for k in self.esVersionsLatestList! {
                    tmp.append(k.toMap())
                }
                map["esVersionsLatestList"] = tmp
            }
            if self.instanceSupportNodes != nil {
                map["instanceSupportNodes"] = self.instanceSupportNodes!
            }
            if self.jvmConfine != nil {
                map["jvmConfine"] = self.jvmConfine?.toMap()
            }
            if self.kibanaNodeProperties != nil {
                map["kibanaNodeProperties"] = self.kibanaNodeProperties?.toMap()
            }
            if self.logstashZones != nil {
                map["logstashZones"] = self.logstashZones!
            }
            if self.masterDiskList != nil {
                var tmp : [Any] = []
                for k in self.masterDiskList! {
                    tmp.append(k.toMap())
                }
                map["masterDiskList"] = tmp
            }
            if self.masterSpec != nil {
                map["masterSpec"] = self.masterSpec!
            }
            if self.node != nil {
                map["node"] = self.node?.toMap()
            }
            if self.nodeSpecList != nil {
                var tmp : [Any] = []
                for k in self.nodeSpecList! {
                    tmp.append(k.toMap())
                }
                map["nodeSpecList"] = tmp
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.supportVersions != nil {
                var tmp : [Any] = []
                for k in self.supportVersions! {
                    tmp.append(k.toMap())
                }
                map["supportVersions"] = tmp
            }
            if self.warmNodeProperties != nil {
                map["warmNodeProperties"] = self.warmNodeProperties?.toMap()
            }
            if self.zones != nil {
                map["zones"] = self.zones!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clientNodeAmountRange") {
                var model = GetRegionConfigurationResponseBody.Result.ClientNodeAmountRange()
                model.fromMap(dict["clientNodeAmountRange"] as! [String: Any])
                self.clientNodeAmountRange = model
            }
            if dict.keys.contains("clientNodeDiskList") {
                var tmp : [GetRegionConfigurationResponseBody.Result.ClientNodeDiskList] = []
                for v in dict["clientNodeDiskList"] as! [Any] {
                    var model = GetRegionConfigurationResponseBody.Result.ClientNodeDiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clientNodeDiskList = tmp
            }
            if dict.keys.contains("clientNodeSpec") {
                self.clientNodeSpec = dict["clientNodeSpec"] as! [String]
            }
            if dict.keys.contains("createUrl") {
                self.createUrl = dict["createUrl"] as! String
            }
            if dict.keys.contains("dataDiskList") {
                var tmp : [GetRegionConfigurationResponseBody.Result.DataDiskList] = []
                for v in dict["dataDiskList"] as! [Any] {
                    var model = GetRegionConfigurationResponseBody.Result.DataDiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataDiskList = tmp
            }
            if dict.keys.contains("elasticNodeProperties") {
                var model = GetRegionConfigurationResponseBody.Result.ElasticNodeProperties()
                model.fromMap(dict["elasticNodeProperties"] as! [String: Any])
                self.elasticNodeProperties = model
            }
            if dict.keys.contains("env") {
                self.env = dict["env"] as! String
            }
            if dict.keys.contains("esVersions") {
                self.esVersions = dict["esVersions"] as! [String]
            }
            if dict.keys.contains("esVersionsLatestList") {
                var tmp : [GetRegionConfigurationResponseBody.Result.EsVersionsLatestList] = []
                for v in dict["esVersionsLatestList"] as! [Any] {
                    var model = GetRegionConfigurationResponseBody.Result.EsVersionsLatestList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.esVersionsLatestList = tmp
            }
            if dict.keys.contains("instanceSupportNodes") {
                self.instanceSupportNodes = dict["instanceSupportNodes"] as! [String]
            }
            if dict.keys.contains("jvmConfine") {
                var model = GetRegionConfigurationResponseBody.Result.JvmConfine()
                model.fromMap(dict["jvmConfine"] as! [String: Any])
                self.jvmConfine = model
            }
            if dict.keys.contains("kibanaNodeProperties") {
                var model = GetRegionConfigurationResponseBody.Result.KibanaNodeProperties()
                model.fromMap(dict["kibanaNodeProperties"] as! [String: Any])
                self.kibanaNodeProperties = model
            }
            if dict.keys.contains("logstashZones") {
                self.logstashZones = dict["logstashZones"] as! [String]
            }
            if dict.keys.contains("masterDiskList") {
                var tmp : [GetRegionConfigurationResponseBody.Result.MasterDiskList] = []
                for v in dict["masterDiskList"] as! [Any] {
                    var model = GetRegionConfigurationResponseBody.Result.MasterDiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.masterDiskList = tmp
            }
            if dict.keys.contains("masterSpec") {
                self.masterSpec = dict["masterSpec"] as! [String]
            }
            if dict.keys.contains("node") {
                var model = GetRegionConfigurationResponseBody.Result.Node()
                model.fromMap(dict["node"] as! [String: Any])
                self.node = model
            }
            if dict.keys.contains("nodeSpecList") {
                var tmp : [GetRegionConfigurationResponseBody.Result.NodeSpecList] = []
                for v in dict["nodeSpecList"] as! [Any] {
                    var model = GetRegionConfigurationResponseBody.Result.NodeSpecList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.nodeSpecList = tmp
            }
            if dict.keys.contains("regionId") {
                self.regionId = dict["regionId"] as! String
            }
            if dict.keys.contains("supportVersions") {
                var tmp : [GetRegionConfigurationResponseBody.Result.SupportVersions] = []
                for v in dict["supportVersions"] as! [Any] {
                    var model = GetRegionConfigurationResponseBody.Result.SupportVersions()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.supportVersions = tmp
            }
            if dict.keys.contains("warmNodeProperties") {
                var model = GetRegionConfigurationResponseBody.Result.WarmNodeProperties()
                model.fromMap(dict["warmNodeProperties"] as! [String: Any])
                self.warmNodeProperties = model
            }
            if dict.keys.contains("zones") {
                self.zones = dict["zones"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var result: GetRegionConfigurationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetRegionConfigurationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetRegionConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRegionConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRegionConfigurationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetRegionalInstanceConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ClientNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("maxAmount") {
                    self.maxAmount = dict["maxAmount"] as! Int32
                }
                if dict.keys.contains("minAmount") {
                    self.minAmount = dict["minAmount"] as! Int32
                }
            }
        }
        public class ClientNodeDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("maxSize") {
                    self.maxSize = dict["maxSize"] as! Int32
                }
                if dict.keys.contains("minSize") {
                    self.minSize = dict["minSize"] as! Int32
                }
                if dict.keys.contains("scaleLimit") {
                    self.scaleLimit = dict["scaleLimit"] as! Int32
                }
            }
        }
        public class DataNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("maxAmount") {
                    self.maxAmount = dict["maxAmount"] as! Int32
                }
                if dict.keys.contains("minAmount") {
                    self.minAmount = dict["minAmount"] as! Int32
                }
            }
        }
        public class DataNodeDiskList : Tea.TeaModel {
            public class SubClassificationConfines : Tea.TeaModel {
                public var maxSize: Int32?

                public var minSize: Int32?

                public var performanceLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.performanceLevel != nil {
                        map["performanceLevel"] = self.performanceLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxSize") {
                        self.maxSize = dict["maxSize"] as! Int32
                    }
                    if dict.keys.contains("minSize") {
                        self.minSize = dict["minSize"] as! Int32
                    }
                    if dict.keys.contains("performanceLevel") {
                        self.performanceLevel = dict["performanceLevel"] as! String
                    }
                }
            }
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var subClassificationConfines: [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList.SubClassificationConfines]?

            public var valueLimitSet: [Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.subClassificationConfines != nil {
                    var tmp : [Any] = []
                    for k in self.subClassificationConfines! {
                        tmp.append(k.toMap())
                    }
                    map["subClassificationConfines"] = tmp
                }
                if self.valueLimitSet != nil {
                    map["valueLimitSet"] = self.valueLimitSet!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("maxSize") {
                    self.maxSize = dict["maxSize"] as! Int32
                }
                if dict.keys.contains("minSize") {
                    self.minSize = dict["minSize"] as! Int32
                }
                if dict.keys.contains("scaleLimit") {
                    self.scaleLimit = dict["scaleLimit"] as! Int32
                }
                if dict.keys.contains("subClassificationConfines") {
                    var tmp : [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList.SubClassificationConfines] = []
                    for v in dict["subClassificationConfines"] as! [Any] {
                        var model = GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList.SubClassificationConfines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subClassificationConfines = tmp
                }
                if dict.keys.contains("valueLimitSet") {
                    self.valueLimitSet = dict["valueLimitSet"] as! [Int32]
                }
            }
        }
        public class MasterDiskList : Tea.TeaModel {
            public class SubClassificationConfines : Tea.TeaModel {
                public var maxSize: Int32?

                public var minSize: Int32?

                public var performanceLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.performanceLevel != nil {
                        map["performanceLevel"] = self.performanceLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxSize") {
                        self.maxSize = dict["maxSize"] as! Int32
                    }
                    if dict.keys.contains("minSize") {
                        self.minSize = dict["minSize"] as! Int32
                    }
                    if dict.keys.contains("performanceLevel") {
                        self.performanceLevel = dict["performanceLevel"] as! String
                    }
                }
            }
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var subClassificationConfines: [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList.SubClassificationConfines]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.subClassificationConfines != nil {
                    var tmp : [Any] = []
                    for k in self.subClassificationConfines! {
                        tmp.append(k.toMap())
                    }
                    map["subClassificationConfines"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("maxSize") {
                    self.maxSize = dict["maxSize"] as! Int32
                }
                if dict.keys.contains("minSize") {
                    self.minSize = dict["minSize"] as! Int32
                }
                if dict.keys.contains("scaleLimit") {
                    self.scaleLimit = dict["scaleLimit"] as! Int32
                }
                if dict.keys.contains("subClassificationConfines") {
                    var tmp : [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList.SubClassificationConfines] = []
                    for v in dict["subClassificationConfines"] as! [Any] {
                        var model = GetRegionalInstanceConfigResponseBody.Result.MasterDiskList.SubClassificationConfines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subClassificationConfines = tmp
                }
            }
        }
        public class WarmNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("maxAmount") {
                    self.maxAmount = dict["maxAmount"] as! Int32
                }
                if dict.keys.contains("minAmount") {
                    self.minAmount = dict["minAmount"] as! Int32
                }
            }
        }
        public class WarmNodeDiskList : Tea.TeaModel {
            public class SubClassificationConfines : Tea.TeaModel {
                public var maxSize: Int32?

                public var minSize: Int32?

                public var performanceLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.performanceLevel != nil {
                        map["performanceLevel"] = self.performanceLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("maxSize") {
                        self.maxSize = dict["maxSize"] as! Int32
                    }
                    if dict.keys.contains("minSize") {
                        self.minSize = dict["minSize"] as! Int32
                    }
                    if dict.keys.contains("performanceLevel") {
                        self.performanceLevel = dict["performanceLevel"] as! String
                    }
                }
            }
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var subClassificationConfines: [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList.SubClassificationConfines]?

            public var valueLimitSet: [Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.subClassificationConfines != nil {
                    var tmp : [Any] = []
                    for k in self.subClassificationConfines! {
                        tmp.append(k.toMap())
                    }
                    map["subClassificationConfines"] = tmp
                }
                if self.valueLimitSet != nil {
                    map["valueLimitSet"] = self.valueLimitSet!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("maxSize") {
                    self.maxSize = dict["maxSize"] as! Int32
                }
                if dict.keys.contains("minSize") {
                    self.minSize = dict["minSize"] as! Int32
                }
                if dict.keys.contains("scaleLimit") {
                    self.scaleLimit = dict["scaleLimit"] as! Int32
                }
                if dict.keys.contains("subClassificationConfines") {
                    var tmp : [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList.SubClassificationConfines] = []
                    for v in dict["subClassificationConfines"] as! [Any] {
                        var model = GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList.SubClassificationConfines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subClassificationConfines = tmp
                }
                if dict.keys.contains("valueLimitSet") {
                    self.valueLimitSet = dict["valueLimitSet"] as! [Int32]
                }
            }
        }
        public var clientNodeAmountRange: GetRegionalInstanceConfigResponseBody.Result.ClientNodeAmountRange?

        public var clientNodeDiskList: [GetRegionalInstanceConfigResponseBody.Result.ClientNodeDiskList]?

        public var clientSpecs: [String]?

        public var dataNodeAmountRange: GetRegionalInstanceConfigResponseBody.Result.DataNodeAmountRange?

        public var dataNodeDiskList: [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList]?

        public var dataNodeSpecs: [String]?

        public var kibanaSpecs: [String]?

        public var masterAmountRange: [String]?

        public var masterDiskList: [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList]?

        public var masterSpecs: [String]?

        public var specInfoMap: [String: ResultSpecInfoMapValue]?

        public var versions: [String]?

        public var warmNodeAmountRange: GetRegionalInstanceConfigResponseBody.Result.WarmNodeAmountRange?

        public var warmNodeDiskList: [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList]?

        public var warmNodeSpecs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clientNodeAmountRange?.validate()
            try self.dataNodeAmountRange?.validate()
            try self.warmNodeAmountRange?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientNodeAmountRange != nil {
                map["clientNodeAmountRange"] = self.clientNodeAmountRange?.toMap()
            }
            if self.clientNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.clientNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["clientNodeDiskList"] = tmp
            }
            if self.clientSpecs != nil {
                map["clientSpecs"] = self.clientSpecs!
            }
            if self.dataNodeAmountRange != nil {
                map["dataNodeAmountRange"] = self.dataNodeAmountRange?.toMap()
            }
            if self.dataNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.dataNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["dataNodeDiskList"] = tmp
            }
            if self.dataNodeSpecs != nil {
                map["dataNodeSpecs"] = self.dataNodeSpecs!
            }
            if self.kibanaSpecs != nil {
                map["kibanaSpecs"] = self.kibanaSpecs!
            }
            if self.masterAmountRange != nil {
                map["masterAmountRange"] = self.masterAmountRange!
            }
            if self.masterDiskList != nil {
                var tmp : [Any] = []
                for k in self.masterDiskList! {
                    tmp.append(k.toMap())
                }
                map["masterDiskList"] = tmp
            }
            if self.masterSpecs != nil {
                map["masterSpecs"] = self.masterSpecs!
            }
            if self.specInfoMap != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.specInfoMap! {
                    tmp[k] = v.toMap()
                }
                map["specInfoMap"] = tmp
            }
            if self.versions != nil {
                map["versions"] = self.versions!
            }
            if self.warmNodeAmountRange != nil {
                map["warmNodeAmountRange"] = self.warmNodeAmountRange?.toMap()
            }
            if self.warmNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.warmNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["warmNodeDiskList"] = tmp
            }
            if self.warmNodeSpecs != nil {
                map["warmNodeSpecs"] = self.warmNodeSpecs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clientNodeAmountRange") {
                var model = GetRegionalInstanceConfigResponseBody.Result.ClientNodeAmountRange()
                model.fromMap(dict["clientNodeAmountRange"] as! [String: Any])
                self.clientNodeAmountRange = model
            }
            if dict.keys.contains("clientNodeDiskList") {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.ClientNodeDiskList] = []
                for v in dict["clientNodeDiskList"] as! [Any] {
                    var model = GetRegionalInstanceConfigResponseBody.Result.ClientNodeDiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.clientNodeDiskList = tmp
            }
            if dict.keys.contains("clientSpecs") {
                self.clientSpecs = dict["clientSpecs"] as! [String]
            }
            if dict.keys.contains("dataNodeAmountRange") {
                var model = GetRegionalInstanceConfigResponseBody.Result.DataNodeAmountRange()
                model.fromMap(dict["dataNodeAmountRange"] as! [String: Any])
                self.dataNodeAmountRange = model
            }
            if dict.keys.contains("dataNodeDiskList") {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList] = []
                for v in dict["dataNodeDiskList"] as! [Any] {
                    var model = GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataNodeDiskList = tmp
            }
            if dict.keys.contains("dataNodeSpecs") {
                self.dataNodeSpecs = dict["dataNodeSpecs"] as! [String]
            }
            if dict.keys.contains("kibanaSpecs") {
                self.kibanaSpecs = dict["kibanaSpecs"] as! [String]
            }
            if dict.keys.contains("masterAmountRange") {
                self.masterAmountRange = dict["masterAmountRange"] as! [String]
            }
            if dict.keys.contains("masterDiskList") {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList] = []
                for v in dict["masterDiskList"] as! [Any] {
                    var model = GetRegionalInstanceConfigResponseBody.Result.MasterDiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.masterDiskList = tmp
            }
            if dict.keys.contains("masterSpecs") {
                self.masterSpecs = dict["masterSpecs"] as! [String]
            }
            if dict.keys.contains("specInfoMap") {
                var tmp : [String: ResultSpecInfoMapValue] = [:]
                for (k, v) in dict["specInfoMap"] as! [String: Any] {
                    if v != nil {
                        var model = ResultSpecInfoMapValue()
                        model.fromMap(v as! [String: Any])
                        tmp[k] = model
                    }
                }
                self.specInfoMap = tmp
            }
            if dict.keys.contains("versions") {
                self.versions = dict["versions"] as! [String]
            }
            if dict.keys.contains("warmNodeAmountRange") {
                var model = GetRegionalInstanceConfigResponseBody.Result.WarmNodeAmountRange()
                model.fromMap(dict["warmNodeAmountRange"] as! [String: Any])
                self.warmNodeAmountRange = model
            }
            if dict.keys.contains("warmNodeDiskList") {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList] = []
                for v in dict["warmNodeDiskList"] as! [Any] {
                    var model = GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.warmNodeDiskList = tmp
            }
            if dict.keys.contains("warmNodeSpecs") {
                self.warmNodeSpecs = dict["warmNodeSpecs"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var result: GetRegionalInstanceConfigResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = GetRegionalInstanceConfigResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class GetRegionalInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRegionalInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetRegionalInstanceConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetSuggestShrinkableNodesRequest : Tea.TeaModel {
    public var count: Int32?

    public var ignoreStatus: Bool?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.ignoreStatus != nil {
            map["ignoreStatus"] = self.ignoreStatus!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("count") {
            self.count = dict["count"] as! Int32
        }
        if dict.keys.contains("ignoreStatus") {
            self.ignoreStatus = dict["ignoreStatus"] as! Bool
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
    }
}

public class GetSuggestShrinkableNodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: [GetSuggestShrinkableNodesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [GetSuggestShrinkableNodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = GetSuggestShrinkableNodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class GetSuggestShrinkableNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSuggestShrinkableNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetSuggestShrinkableNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetTransferableNodesRequest : Tea.TeaModel {
    public var count: Int32?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("count") {
            self.count = dict["count"] as! Int32
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
    }
}

public class GetTransferableNodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
        }
    }
    public var requestId: String?

    public var result: [GetTransferableNodesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [GetTransferableNodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = GetTransferableNodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class GetTransferableNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTransferableNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetTransferableNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InitializeOperationRoleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class InitializeOperationRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class InitializeOperationRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitializeOperationRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InitializeOperationRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallAckOperatorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class InstallAckOperatorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class InstallAckOperatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallAckOperatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallAckOperatorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallKibanaSystemPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class InstallKibanaSystemPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class InstallKibanaSystemPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallKibanaSystemPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallKibanaSystemPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallLogstashSystemPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class InstallLogstashSystemPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class InstallLogstashSystemPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallLogstashSystemPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallLogstashSystemPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallSystemPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class InstallSystemPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class InstallSystemPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallSystemPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallSystemPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallUserPluginsRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class InstallUserPluginsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class InstallUserPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallUserPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallUserPluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InterruptElasticsearchTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class InterruptElasticsearchTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class InterruptElasticsearchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InterruptElasticsearchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InterruptElasticsearchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InterruptLogstashTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class InterruptLogstashTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class InterruptLogstashTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InterruptLogstashTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InterruptLogstashTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAckClustersRequest : Tea.TeaModel {
    public var page: Int32?

    public var size: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class ListAckClustersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var clusterId: String?

        public var clusterType: String?

        public var name: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["clusterId"] = self.clusterId!
            }
            if self.clusterType != nil {
                map["clusterType"] = self.clusterType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("clusterId") {
                self.clusterId = dict["clusterId"] as! String
            }
            if dict.keys.contains("clusterType") {
                self.clusterType = dict["clusterType"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListAckClustersResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListAckClustersResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListAckClustersResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListAckClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAckClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAckClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAckNamespacesRequest : Tea.TeaModel {
    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListAckNamespacesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var namespace: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.namespace != nil {
                map["namespace"] = self.namespace!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("namespace") {
                self.namespace = dict["namespace"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListAckNamespacesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListAckNamespacesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListAckNamespacesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListAckNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAckNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAckNamespacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListActionRecordsRequest : Tea.TeaModel {
    public var actionNames: String?

    public var endTime: Int64?

    public var filter: String?

    public var page: Int32?

    public var requestId: String?

    public var size: Int32?

    public var startTime: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionNames != nil {
            map["actionNames"] = self.actionNames!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.filter != nil {
            map["filter"] = self.filter!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("actionNames") {
            self.actionNames = dict["actionNames"] as! String
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("filter") {
            self.filter = dict["filter"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("userId") {
            self.userId = dict["userId"] as! String
        }
    }
}

public class ListActionRecordsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class StatusInfo : Tea.TeaModel {
            public class SubStatusInfo : Tea.TeaModel {
                public var completeNodeCount: Int32?

                public var endTime: Int64?

                public var exception: String?

                public var latencyMills: Int64?

                public var nodeCount: Int32?

                public var process: String?

                public var startTime: Int64?

                public var stateType: String?

                public var subState: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.completeNodeCount != nil {
                        map["completeNodeCount"] = self.completeNodeCount!
                    }
                    if self.endTime != nil {
                        map["endTime"] = self.endTime!
                    }
                    if self.exception != nil {
                        map["exception"] = self.exception!
                    }
                    if self.latencyMills != nil {
                        map["latencyMills"] = self.latencyMills!
                    }
                    if self.nodeCount != nil {
                        map["nodeCount"] = self.nodeCount!
                    }
                    if self.process != nil {
                        map["process"] = self.process!
                    }
                    if self.startTime != nil {
                        map["startTime"] = self.startTime!
                    }
                    if self.stateType != nil {
                        map["stateType"] = self.stateType!
                    }
                    if self.subState != nil {
                        map["subState"] = self.subState!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("completeNodeCount") {
                        self.completeNodeCount = dict["completeNodeCount"] as! Int32
                    }
                    if dict.keys.contains("endTime") {
                        self.endTime = dict["endTime"] as! Int64
                    }
                    if dict.keys.contains("exception") {
                        self.exception = dict["exception"] as! String
                    }
                    if dict.keys.contains("latencyMills") {
                        self.latencyMills = dict["latencyMills"] as! Int64
                    }
                    if dict.keys.contains("nodeCount") {
                        self.nodeCount = dict["nodeCount"] as! Int32
                    }
                    if dict.keys.contains("process") {
                        self.process = dict["process"] as! String
                    }
                    if dict.keys.contains("startTime") {
                        self.startTime = dict["startTime"] as! Int64
                    }
                    if dict.keys.contains("stateType") {
                        self.stateType = dict["stateType"] as! String
                    }
                    if dict.keys.contains("subState") {
                        self.subState = dict["subState"] as! String
                    }
                }
            }
            public var completeNodeCount: Int32?

            public var endTime: Int64?

            public var exception: String?

            public var latencyMills: Int64?

            public var nodeCount: Int32?

            public var process: String?

            public var startTime: Int64?

            public var stateType: String?

            public var subState: String?

            public var subStatusInfo: [ListActionRecordsResponseBody.Result.StatusInfo.SubStatusInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.completeNodeCount != nil {
                    map["completeNodeCount"] = self.completeNodeCount!
                }
                if self.endTime != nil {
                    map["endTime"] = self.endTime!
                }
                if self.exception != nil {
                    map["exception"] = self.exception!
                }
                if self.latencyMills != nil {
                    map["latencyMills"] = self.latencyMills!
                }
                if self.nodeCount != nil {
                    map["nodeCount"] = self.nodeCount!
                }
                if self.process != nil {
                    map["process"] = self.process!
                }
                if self.startTime != nil {
                    map["startTime"] = self.startTime!
                }
                if self.stateType != nil {
                    map["stateType"] = self.stateType!
                }
                if self.subState != nil {
                    map["subState"] = self.subState!
                }
                if self.subStatusInfo != nil {
                    var tmp : [Any] = []
                    for k in self.subStatusInfo! {
                        tmp.append(k.toMap())
                    }
                    map["subStatusInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("completeNodeCount") {
                    self.completeNodeCount = dict["completeNodeCount"] as! Int32
                }
                if dict.keys.contains("endTime") {
                    self.endTime = dict["endTime"] as! Int64
                }
                if dict.keys.contains("exception") {
                    self.exception = dict["exception"] as! String
                }
                if dict.keys.contains("latencyMills") {
                    self.latencyMills = dict["latencyMills"] as! Int64
                }
                if dict.keys.contains("nodeCount") {
                    self.nodeCount = dict["nodeCount"] as! Int32
                }
                if dict.keys.contains("process") {
                    self.process = dict["process"] as! String
                }
                if dict.keys.contains("startTime") {
                    self.startTime = dict["startTime"] as! Int64
                }
                if dict.keys.contains("stateType") {
                    self.stateType = dict["stateType"] as! String
                }
                if dict.keys.contains("subState") {
                    self.subState = dict["subState"] as! String
                }
                if dict.keys.contains("subStatusInfo") {
                    var tmp : [ListActionRecordsResponseBody.Result.StatusInfo.SubStatusInfo] = []
                    for v in dict["subStatusInfo"] as! [Any] {
                        var model = ListActionRecordsResponseBody.Result.StatusInfo.SubStatusInfo()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.subStatusInfo = tmp
                }
            }
        }
        public var actionName: String?

        public var actionParams: [String: Any]?

        public var actionResultAccessList: [String]?

        public var endTime: Int64?

        public var instanceId: String?

        public var metaNow: String?

        public var metaOld: String?

        public var ownerId: String?

        public var process: String?

        public var recordDiff: [String: Any]?

        public var recordIds: [String]?

        public var requestId: String?

        public var startTime: Int64?

        public var stateType: String?

        public var statusInfo: [ListActionRecordsResponseBody.Result.StatusInfo]?

        public var userId: String?

        public var userInfo: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionName != nil {
                map["ActionName"] = self.actionName!
            }
            if self.actionParams != nil {
                map["ActionParams"] = self.actionParams!
            }
            if self.actionResultAccessList != nil {
                map["ActionResultAccessList"] = self.actionResultAccessList!
            }
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.metaNow != nil {
                map["MetaNow"] = self.metaNow!
            }
            if self.metaOld != nil {
                map["MetaOld"] = self.metaOld!
            }
            if self.ownerId != nil {
                map["OwnerId"] = self.ownerId!
            }
            if self.process != nil {
                map["Process"] = self.process!
            }
            if self.recordDiff != nil {
                map["RecordDiff"] = self.recordDiff!
            }
            if self.recordIds != nil {
                map["RecordIds"] = self.recordIds!
            }
            if self.requestId != nil {
                map["RequestId"] = self.requestId!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            if self.stateType != nil {
                map["StateType"] = self.stateType!
            }
            if self.statusInfo != nil {
                var tmp : [Any] = []
                for k in self.statusInfo! {
                    tmp.append(k.toMap())
                }
                map["StatusInfo"] = tmp
            }
            if self.userId != nil {
                map["UserId"] = self.userId!
            }
            if self.userInfo != nil {
                map["UserInfo"] = self.userInfo!
            }
            if self.userType != nil {
                map["UserType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActionName") {
                self.actionName = dict["ActionName"] as! String
            }
            if dict.keys.contains("ActionParams") {
                self.actionParams = dict["ActionParams"] as! [String: Any]
            }
            if dict.keys.contains("ActionResultAccessList") {
                self.actionResultAccessList = dict["ActionResultAccessList"] as! [String]
            }
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! Int64
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MetaNow") {
                self.metaNow = dict["MetaNow"] as! String
            }
            if dict.keys.contains("MetaOld") {
                self.metaOld = dict["MetaOld"] as! String
            }
            if dict.keys.contains("OwnerId") {
                self.ownerId = dict["OwnerId"] as! String
            }
            if dict.keys.contains("Process") {
                self.process = dict["Process"] as! String
            }
            if dict.keys.contains("RecordDiff") {
                self.recordDiff = dict["RecordDiff"] as! [String: Any]
            }
            if dict.keys.contains("RecordIds") {
                self.recordIds = dict["RecordIds"] as! [String]
            }
            if dict.keys.contains("RequestId") {
                self.requestId = dict["RequestId"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! Int64
            }
            if dict.keys.contains("StateType") {
                self.stateType = dict["StateType"] as! String
            }
            if dict.keys.contains("StatusInfo") {
                var tmp : [ListActionRecordsResponseBody.Result.StatusInfo] = []
                for v in dict["StatusInfo"] as! [Any] {
                    var model = ListActionRecordsResponseBody.Result.StatusInfo()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.statusInfo = tmp
            }
            if dict.keys.contains("UserId") {
                self.userId = dict["UserId"] as! String
            }
            if dict.keys.contains("UserInfo") {
                self.userInfo = dict["UserInfo"] as! String
            }
            if dict.keys.contains("UserType") {
                self.userType = dict["UserType"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListActionRecordsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListActionRecordsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListActionRecordsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListActionRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListActionRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListActionRecordsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAllNodeRequest : Tea.TeaModel {
    public var extended: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extended != nil {
            map["extended"] = self.extended!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("extended") {
            self.extended = dict["extended"] as! Bool
        }
    }
}

public class ListAllNodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var cpuPercent: String?

        public var diskUsedPercent: String?

        public var health: String?

        public var heapPercent: String?

        public var host: String?

        public var loadOneM: String?

        public var nodeType: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpuPercent != nil {
                map["cpuPercent"] = self.cpuPercent!
            }
            if self.diskUsedPercent != nil {
                map["diskUsedPercent"] = self.diskUsedPercent!
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.heapPercent != nil {
                map["heapPercent"] = self.heapPercent!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.loadOneM != nil {
                map["loadOneM"] = self.loadOneM!
            }
            if self.nodeType != nil {
                map["nodeType"] = self.nodeType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cpuPercent") {
                self.cpuPercent = dict["cpuPercent"] as! String
            }
            if dict.keys.contains("diskUsedPercent") {
                self.diskUsedPercent = dict["diskUsedPercent"] as! String
            }
            if dict.keys.contains("health") {
                self.health = dict["health"] as! String
            }
            if dict.keys.contains("heapPercent") {
                self.heapPercent = dict["heapPercent"] as! String
            }
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("loadOneM") {
                self.loadOneM = dict["loadOneM"] as! String
            }
            if dict.keys.contains("nodeType") {
                self.nodeType = dict["nodeType"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListAllNodeResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListAllNodeResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListAllNodeResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListAllNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAllNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAlternativeSnapshotReposRequest : Tea.TeaModel {
    public var alreadySetItems: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alreadySetItems != nil {
            map["alreadySetItems"] = self.alreadySetItems!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("alreadySetItems") {
            self.alreadySetItems = dict["alreadySetItems"] as! Bool
        }
    }
}

public class ListAlternativeSnapshotReposResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var instanceId: String?

        public var repoPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.repoPath != nil {
                map["repoPath"] = self.repoPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("repoPath") {
                self.repoPath = dict["repoPath"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListAlternativeSnapshotReposResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListAlternativeSnapshotReposResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListAlternativeSnapshotReposResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListAlternativeSnapshotReposResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlternativeSnapshotReposResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAlternativeSnapshotReposResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListApmRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var output: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.output != nil {
            map["output"] = self.output!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("output") {
            self.output = dict["output"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int64
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int64
        }
    }
}

public class ListApmResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int64
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var deployedReplica: Int64?

        public var description_: String?

        public var instanceId: String?

        public var nodeAmount: Int64?

        public var outputES: String?

        public var outputESUserName: String?

        public var ownerId: String?

        public var paymentType: String?

        public var region: String?

        public var replica: Int64?

        public var resourceSpec: String?

        public var status: String?

        public var version: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.deployedReplica != nil {
                map["deployedReplica"] = self.deployedReplica!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.outputES != nil {
                map["outputES"] = self.outputES!
            }
            if self.outputESUserName != nil {
                map["outputESUserName"] = self.outputESUserName!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.region != nil {
                map["region"] = self.region!
            }
            if self.replica != nil {
                map["replica"] = self.replica!
            }
            if self.resourceSpec != nil {
                map["resourceSpec"] = self.resourceSpec!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("deployedReplica") {
                self.deployedReplica = dict["deployedReplica"] as! Int64
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int64
            }
            if dict.keys.contains("outputES") {
                self.outputES = dict["outputES"] as! String
            }
            if dict.keys.contains("outputESUserName") {
                self.outputESUserName = dict["outputESUserName"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! String
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("region") {
                self.region = dict["region"] as! String
            }
            if dict.keys.contains("replica") {
                self.replica = dict["replica"] as! Int64
            }
            if dict.keys.contains("resourceSpec") {
                self.resourceSpec = dict["resourceSpec"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
            if dict.keys.contains("vsArea") {
                self.vsArea = dict["vsArea"] as! String
            }
            if dict.keys.contains("vswitchId") {
                self.vswitchId = dict["vswitchId"] as! String
            }
        }
    }
    public var headers: ListApmResponseBody.Headers?

    public var requestId: String?

    public var result: [ListApmResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListApmResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListApmResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListApmResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListApmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListAvailableEsInstanceIdsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var endpoint: String?

        public var esInstanceId: String?

        public var kibanaEndpoint: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endpoint != nil {
                map["endpoint"] = self.endpoint!
            }
            if self.esInstanceId != nil {
                map["esInstanceId"] = self.esInstanceId!
            }
            if self.kibanaEndpoint != nil {
                map["kibanaEndpoint"] = self.kibanaEndpoint!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("endpoint") {
                self.endpoint = dict["endpoint"] as! String
            }
            if dict.keys.contains("esInstanceId") {
                self.esInstanceId = dict["esInstanceId"] as! String
            }
            if dict.keys.contains("kibanaEndpoint") {
                self.kibanaEndpoint = dict["kibanaEndpoint"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListAvailableEsInstanceIdsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListAvailableEsInstanceIdsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListAvailableEsInstanceIdsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListAvailableEsInstanceIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvailableEsInstanceIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListAvailableEsInstanceIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListCollectorsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var name: String?

    public var page: Int32?

    public var resId: String?

    public var size: Int32?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.resId != nil {
            map["resId"] = self.resId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("resId") {
            self.resId = dict["resId"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("sourceType") {
            self.sourceType = dict["sourceType"] as! String
        }
    }
}

public class ListCollectorsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("agentStatus") {
                        self.agentStatus = dict["agentStatus"] as! String
                    }
                    if dict.keys.contains("instanceId") {
                        self.instanceId = dict["instanceId"] as! String
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [ListCollectorsResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("configType") {
                    self.configType = dict["configType"] as! String
                }
                if dict.keys.contains("enableMonitoring") {
                    self.enableMonitoring = dict["enableMonitoring"] as! Bool
                }
                if dict.keys.contains("groupId") {
                    self.groupId = dict["groupId"] as! String
                }
                if dict.keys.contains("host") {
                    self.host = dict["host"] as! String
                }
                if dict.keys.contains("hosts") {
                    self.hosts = dict["hosts"] as! [String]
                }
                if dict.keys.contains("instanceId") {
                    self.instanceId = dict["instanceId"] as! String
                }
                if dict.keys.contains("instanceType") {
                    self.instanceType = dict["instanceType"] as! String
                }
                if dict.keys.contains("kibanaHost") {
                    self.kibanaHost = dict["kibanaHost"] as! String
                }
                if dict.keys.contains("machines") {
                    var tmp : [ListCollectorsResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in dict["machines"] as! [Any] {
                        var model = ListCollectorsResponseBody.Result.ExtendConfigs.Machines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.machines = tmp
                }
                if dict.keys.contains("protocol") {
                    self.protocol_ = dict["protocol"] as! String
                }
                if dict.keys.contains("successPodsCount") {
                    self.successPodsCount = dict["successPodsCount"] as! String
                }
                if dict.keys.contains("totalPodsCount") {
                    self.totalPodsCount = dict["totalPodsCount"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("userName") {
                    self.userName = dict["userName"] as! String
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [ListCollectorsResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [ListCollectorsResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("collectorPaths") {
                self.collectorPaths = dict["collectorPaths"] as! [String]
            }
            if dict.keys.contains("configs") {
                var tmp : [ListCollectorsResponseBody.Result.Configs] = []
                for v in dict["configs"] as! [Any] {
                    var model = ListCollectorsResponseBody.Result.Configs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configs = tmp
            }
            if dict.keys.contains("dryRun") {
                self.dryRun = dict["dryRun"] as! Bool
            }
            if dict.keys.contains("extendConfigs") {
                var tmp : [ListCollectorsResponseBody.Result.ExtendConfigs] = []
                for v in dict["extendConfigs"] as! [Any] {
                    var model = ListCollectorsResponseBody.Result.ExtendConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.extendConfigs = tmp
            }
            if dict.keys.contains("gmtCreatedTime") {
                self.gmtCreatedTime = dict["gmtCreatedTime"] as! String
            }
            if dict.keys.contains("gmtUpdateTime") {
                self.gmtUpdateTime = dict["gmtUpdateTime"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! String
            }
            if dict.keys.contains("resId") {
                self.resId = dict["resId"] as! String
            }
            if dict.keys.contains("resType") {
                self.resType = dict["resType"] as! String
            }
            if dict.keys.contains("resVersion") {
                self.resVersion = dict["resVersion"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
        }
    }
    public var headers: ListCollectorsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListCollectorsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListCollectorsResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListCollectorsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListCollectorsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListCollectorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCollectorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListCollectorsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListComponentIndicesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListComponentIndicesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int64
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class Template : Tea.TeaModel {
                public class Settings : Tea.TeaModel {
                    public class Index : Tea.TeaModel {
                        public class Lifecycle : Tea.TeaModel {
                            public var name: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.name != nil {
                                    map["name"] = self.name!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("name") {
                                    self.name = dict["name"] as! String
                                }
                            }
                        }
                        public var codec: String?

                        public var lifecycle: ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index.Lifecycle?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.lifecycle?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.codec != nil {
                                map["codec"] = self.codec!
                            }
                            if self.lifecycle != nil {
                                map["lifecycle"] = self.lifecycle?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("codec") {
                                self.codec = dict["codec"] as! String
                            }
                            if dict.keys.contains("lifecycle") {
                                var model = ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index.Lifecycle()
                                model.fromMap(dict["lifecycle"] as! [String: Any])
                                self.lifecycle = model
                            }
                        }
                    }
                    public var index: ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.index?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.index != nil {
                            map["index"] = self.index?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("index") {
                            var model = ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index()
                            model.fromMap(dict["index"] as! [String: Any])
                            self.index = model
                        }
                    }
                }
                public var settings: ListComponentIndicesResponseBody.Result.Content.Template.Settings?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.settings?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.settings != nil {
                        map["settings"] = self.settings?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("settings") {
                        var model = ListComponentIndicesResponseBody.Result.Content.Template.Settings()
                        model.fromMap(dict["settings"] as! [String: Any])
                        self.settings = model
                    }
                }
            }
            public var meta: [String: Any]?

            public var template: ListComponentIndicesResponseBody.Result.Content.Template?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.template?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.meta != nil {
                    map["_meta"] = self.meta!
                }
                if self.template != nil {
                    map["template"] = self.template?.toMap()
                }
                if self.version != nil {
                    map["version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("_meta") {
                    self.meta = dict["_meta"] as! [String: Any]
                }
                if dict.keys.contains("template") {
                    var model = ListComponentIndicesResponseBody.Result.Content.Template()
                    model.fromMap(dict["template"] as! [String: Any])
                    self.template = model
                }
                if dict.keys.contains("version") {
                    self.version = dict["version"] as! Int64
                }
            }
        }
        public var composed: [String]?

        public var content: ListComponentIndicesResponseBody.Result.Content?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.composed != nil {
                map["composed"] = self.composed!
            }
            if self.content != nil {
                map["content"] = self.content?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("composed") {
                self.composed = dict["composed"] as! [String]
            }
            if dict.keys.contains("content") {
                var model = ListComponentIndicesResponseBody.Result.Content()
                model.fromMap(dict["content"] as! [String: Any])
                self.content = model
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var headers: ListComponentIndicesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListComponentIndicesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListComponentIndicesResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListComponentIndicesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListComponentIndicesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListComponentIndicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListComponentIndicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListComponentIndicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListConnectedClustersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var instances: String?

            public var networkType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instances != nil {
                    map["instances"] = self.instances!
                }
                if self.networkType != nil {
                    map["networkType"] = self.networkType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("instances") {
                    self.instances = dict["instances"] as! String
                }
                if dict.keys.contains("networkType") {
                    self.networkType = dict["networkType"] as! String
                }
            }
        }
        public var result: [ListConnectedClustersResponseBody.Result.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                var tmp : [ListConnectedClustersResponseBody.Result.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = ListConnectedClustersResponseBody.Result.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var requestId: String?

    public var result: ListConnectedClustersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ListConnectedClustersResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListConnectedClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConnectedClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListConnectedClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataStreamsRequest : Tea.TeaModel {
    public var isManaged: Bool?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isManaged != nil {
            map["isManaged"] = self.isManaged!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("isManaged") {
            self.isManaged = dict["isManaged"] as! Bool
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class ListDataStreamsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xManagedCount: Int32?

        public var xManagedStorageSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xManagedCount != nil {
                map["X-Managed-Count"] = self.xManagedCount!
            }
            if self.xManagedStorageSize != nil {
                map["X-Managed-StorageSize"] = self.xManagedStorageSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Managed-Count") {
                self.xManagedCount = dict["X-Managed-Count"] as! Int32
            }
            if dict.keys.contains("X-Managed-StorageSize") {
                self.xManagedStorageSize = dict["X-Managed-StorageSize"] as! Int64
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Indices : Tea.TeaModel {
            public var createTime: String?

            public var health: String?

            public var isManaged: Bool?

            public var managedStatus: String?

            public var name: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.health != nil {
                    map["health"] = self.health!
                }
                if self.isManaged != nil {
                    map["isManaged"] = self.isManaged!
                }
                if self.managedStatus != nil {
                    map["managedStatus"] = self.managedStatus!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.size != nil {
                    map["size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("createTime") {
                    self.createTime = dict["createTime"] as! String
                }
                if dict.keys.contains("health") {
                    self.health = dict["health"] as! String
                }
                if dict.keys.contains("isManaged") {
                    self.isManaged = dict["isManaged"] as! Bool
                }
                if dict.keys.contains("managedStatus") {
                    self.managedStatus = dict["managedStatus"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("size") {
                    self.size = dict["size"] as! Int64
                }
            }
        }
        public var health: String?

        public var ilmPolicyName: String?

        public var indexTemplateName: String?

        public var indices: [ListDataStreamsResponseBody.Result.Indices]?

        public var managedStorageSize: Int64?

        public var name: String?

        public var totalStorageSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.ilmPolicyName != nil {
                map["ilmPolicyName"] = self.ilmPolicyName!
            }
            if self.indexTemplateName != nil {
                map["indexTemplateName"] = self.indexTemplateName!
            }
            if self.indices != nil {
                var tmp : [Any] = []
                for k in self.indices! {
                    tmp.append(k.toMap())
                }
                map["indices"] = tmp
            }
            if self.managedStorageSize != nil {
                map["managedStorageSize"] = self.managedStorageSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.totalStorageSize != nil {
                map["totalStorageSize"] = self.totalStorageSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("health") {
                self.health = dict["health"] as! String
            }
            if dict.keys.contains("ilmPolicyName") {
                self.ilmPolicyName = dict["ilmPolicyName"] as! String
            }
            if dict.keys.contains("indexTemplateName") {
                self.indexTemplateName = dict["indexTemplateName"] as! String
            }
            if dict.keys.contains("indices") {
                var tmp : [ListDataStreamsResponseBody.Result.Indices] = []
                for v in dict["indices"] as! [Any] {
                    var model = ListDataStreamsResponseBody.Result.Indices()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.indices = tmp
            }
            if dict.keys.contains("managedStorageSize") {
                self.managedStorageSize = dict["managedStorageSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("totalStorageSize") {
                self.totalStorageSize = dict["totalStorageSize"] as! Int64
            }
        }
    }
    public var headers: ListDataStreamsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDataStreamsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListDataStreamsResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListDataStreamsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListDataStreamsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListDataStreamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataStreamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataStreamsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDataTasksResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class SinkCluster : Tea.TeaModel {
            public var dataSourceType: String?

            public var endpoint: String?

            public var index: String?

            public var type: String?

            public var vpcId: String?

            public var vpcInstanceId: String?

            public var vpcInstancePort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceType != nil {
                    map["dataSourceType"] = self.dataSourceType!
                }
                if self.endpoint != nil {
                    map["endpoint"] = self.endpoint!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vpcInstanceId != nil {
                    map["vpcInstanceId"] = self.vpcInstanceId!
                }
                if self.vpcInstancePort != nil {
                    map["vpcInstancePort"] = self.vpcInstancePort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dataSourceType") {
                    self.dataSourceType = dict["dataSourceType"] as! String
                }
                if dict.keys.contains("endpoint") {
                    self.endpoint = dict["endpoint"] as! String
                }
                if dict.keys.contains("index") {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vpcInstanceId") {
                    self.vpcInstanceId = dict["vpcInstanceId"] as! String
                }
                if dict.keys.contains("vpcInstancePort") {
                    self.vpcInstancePort = dict["vpcInstancePort"] as! String
                }
            }
        }
        public class SourceCluster : Tea.TeaModel {
            public var dataSourceType: String?

            public var index: String?

            public var mapping: String?

            public var routing: String?

            public var settings: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceType != nil {
                    map["dataSourceType"] = self.dataSourceType!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.mapping != nil {
                    map["mapping"] = self.mapping!
                }
                if self.routing != nil {
                    map["routing"] = self.routing!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("dataSourceType") {
                    self.dataSourceType = dict["dataSourceType"] as! String
                }
                if dict.keys.contains("index") {
                    self.index = dict["index"] as! String
                }
                if dict.keys.contains("mapping") {
                    self.mapping = dict["mapping"] as! String
                }
                if dict.keys.contains("routing") {
                    self.routing = dict["routing"] as! String
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var createTime: String?

        public var sinkCluster: ListDataTasksResponseBody.Result.SinkCluster?

        public var sourceCluster: ListDataTasksResponseBody.Result.SourceCluster?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sinkCluster?.validate()
            try self.sourceCluster?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.sinkCluster != nil {
                map["sinkCluster"] = self.sinkCluster?.toMap()
            }
            if self.sourceCluster != nil {
                map["sourceCluster"] = self.sourceCluster?.toMap()
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("sinkCluster") {
                var model = ListDataTasksResponseBody.Result.SinkCluster()
                model.fromMap(dict["sinkCluster"] as! [String: Any])
                self.sinkCluster = model
            }
            if dict.keys.contains("sourceCluster") {
                var model = ListDataTasksResponseBody.Result.SourceCluster()
                model.fromMap(dict["sourceCluster"] as! [String: Any])
                self.sourceCluster = model
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("taskId") {
                self.taskId = dict["taskId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListDataTasksResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListDataTasksResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListDataTasksResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListDataTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDataTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDefaultCollectorConfigurationsRequest : Tea.TeaModel {
    public var resType: String?

    public var resVersion: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resType != nil {
            map["resType"] = self.resType!
        }
        if self.resVersion != nil {
            map["resVersion"] = self.resVersion!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("resType") {
            self.resType = dict["resType"] as! String
        }
        if dict.keys.contains("resVersion") {
            self.resVersion = dict["resVersion"] as! String
        }
        if dict.keys.contains("sourceType") {
            self.sourceType = dict["sourceType"] as! String
        }
    }
}

public class ListDefaultCollectorConfigurationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var fileName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.fileName != nil {
                map["fileName"] = self.fileName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("fileName") {
                self.fileName = dict["fileName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListDefaultCollectorConfigurationsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListDefaultCollectorConfigurationsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListDefaultCollectorConfigurationsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListDefaultCollectorConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDefaultCollectorConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDefaultCollectorConfigurationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDeprecatedTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListDeprecatedTemplatesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int64
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliases") {
                    self.aliases = dict["aliases"] as! String
                }
                if dict.keys.contains("mappings") {
                    self.mappings = dict["mappings"] as! String
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! String
                }
            }
        }
        public var dataStream: Bool?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var order: Int64?

        public var template: ListDeprecatedTemplatesResponseBody.Result.Template?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataStream") {
                self.dataStream = dict["dataStream"] as! Bool
            }
            if dict.keys.contains("indexPatterns") {
                self.indexPatterns = dict["indexPatterns"] as! [String]
            }
            if dict.keys.contains("indexTemplate") {
                self.indexTemplate = dict["indexTemplate"] as! String
            }
            if dict.keys.contains("order") {
                self.order = dict["order"] as! Int64
            }
            if dict.keys.contains("template") {
                var model = ListDeprecatedTemplatesResponseBody.Result.Template()
                model.fromMap(dict["template"] as! [String: Any])
                self.template = model
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
        }
    }
    public var headers: ListDeprecatedTemplatesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDeprecatedTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListDeprecatedTemplatesResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListDeprecatedTemplatesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListDeprecatedTemplatesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListDeprecatedTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeprecatedTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDeprecatedTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDiagnoseIndicesRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class ListDiagnoseIndicesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class ListDiagnoseIndicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnoseIndicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDiagnoseIndicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDiagnoseReportRequest : Tea.TeaModel {
    public var detail: Bool?

    public var endTime: Int64?

    public var lang: String?

    public var page: Int32?

    public var size: Int32?

    public var startTime: Int64?

    public var trigger: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detail != nil {
            map["detail"] = self.detail!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("detail") {
            self.detail = dict["detail"] as! Bool
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("trigger") {
            self.trigger = dict["trigger"] as! String
        }
    }
}

public class ListDiagnoseReportResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class DiagnoseItems : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var desc: String?

                public var name: String?

                public var result: String?

                public var suggest: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desc != nil {
                        map["desc"] = self.desc!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.result != nil {
                        map["result"] = self.result!
                    }
                    if self.suggest != nil {
                        map["suggest"] = self.suggest!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("desc") {
                        self.desc = dict["desc"] as! String
                    }
                    if dict.keys.contains("name") {
                        self.name = dict["name"] as! String
                    }
                    if dict.keys.contains("result") {
                        self.result = dict["result"] as! String
                    }
                    if dict.keys.contains("suggest") {
                        self.suggest = dict["suggest"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                }
            }
            public var detail: ListDiagnoseReportResponseBody.Result.DiagnoseItems.Detail?

            public var health: String?

            public var item: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail?.toMap()
                }
                if self.health != nil {
                    map["health"] = self.health!
                }
                if self.item != nil {
                    map["item"] = self.item!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("detail") {
                    var model = ListDiagnoseReportResponseBody.Result.DiagnoseItems.Detail()
                    model.fromMap(dict["detail"] as! [String: Any])
                    self.detail = model
                }
                if dict.keys.contains("health") {
                    self.health = dict["health"] as! String
                }
                if dict.keys.contains("item") {
                    self.item = dict["item"] as! String
                }
            }
        }
        public var createTime: Int64?

        public var diagnoseItems: [ListDiagnoseReportResponseBody.Result.DiagnoseItems]?

        public var health: String?

        public var instanceId: String?

        public var reportId: String?

        public var state: String?

        public var trigger: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.diagnoseItems != nil {
                var tmp : [Any] = []
                for k in self.diagnoseItems! {
                    tmp.append(k.toMap())
                }
                map["diagnoseItems"] = tmp
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.reportId != nil {
                map["reportId"] = self.reportId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.trigger != nil {
                map["trigger"] = self.trigger!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! Int64
            }
            if dict.keys.contains("diagnoseItems") {
                var tmp : [ListDiagnoseReportResponseBody.Result.DiagnoseItems] = []
                for v in dict["diagnoseItems"] as! [Any] {
                    var model = ListDiagnoseReportResponseBody.Result.DiagnoseItems()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diagnoseItems = tmp
            }
            if dict.keys.contains("health") {
                self.health = dict["health"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("reportId") {
                self.reportId = dict["reportId"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
            if dict.keys.contains("trigger") {
                self.trigger = dict["trigger"] as! String
            }
        }
    }
    public var headers: ListDiagnoseReportResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDiagnoseReportResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListDiagnoseReportResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListDiagnoseReportResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListDiagnoseReportResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListDiagnoseReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnoseReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDiagnoseReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDiagnoseReportIdsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var lang: String?

    public var page: Int32?

    public var size: Int32?

    public var startTime: Int64?

    public var trigger: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("startTime") {
            self.startTime = dict["startTime"] as! Int64
        }
        if dict.keys.contains("trigger") {
            self.trigger = dict["trigger"] as! String
        }
    }
}

public class ListDiagnoseReportIdsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public var headers: ListDiagnoseReportIdsResponseBody.Headers?

    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListDiagnoseReportIdsResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class ListDiagnoseReportIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnoseReportIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDiagnoseReportIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDiagnosisItemsRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class ListDiagnosisItemsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var key: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("key") {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListDiagnosisItemsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListDiagnosisItemsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListDiagnosisItemsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListDiagnosisItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnosisItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDiagnosisItemsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDictInformationRequest : Tea.TeaModel {
    public var analyzerType: String?

    public var bucketName: String?

    public var key: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analyzerType != nil {
            map["analyzerType"] = self.analyzerType!
        }
        if self.bucketName != nil {
            map["bucketName"] = self.bucketName!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("analyzerType") {
            self.analyzerType = dict["analyzerType"] as! String
        }
        if dict.keys.contains("bucketName") {
            self.bucketName = dict["bucketName"] as! String
        }
        if dict.keys.contains("key") {
            self.key = dict["key"] as! String
        }
    }
}

public class ListDictInformationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class OssObject : Tea.TeaModel {
            public var bucketName: String?

            public var etag: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["bucketName"] = self.bucketName!
                }
                if self.etag != nil {
                    map["etag"] = self.etag!
                }
                if self.key != nil {
                    map["key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("bucketName") {
                    self.bucketName = dict["bucketName"] as! String
                }
                if dict.keys.contains("etag") {
                    self.etag = dict["etag"] as! String
                }
                if dict.keys.contains("key") {
                    self.key = dict["key"] as! String
                }
            }
        }
        public var fileSize: Int64?

        public var ossObject: ListDictInformationResponseBody.Result.OssObject?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ossObject?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.ossObject != nil {
                map["ossObject"] = self.ossObject?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("ossObject") {
                var model = ListDictInformationResponseBody.Result.OssObject()
                model.fromMap(dict["ossObject"] as! [String: Any])
                self.ossObject = model
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: ListDictInformationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ListDictInformationResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ListDictInformationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDictInformationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDictInformationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListDictsRequest : Tea.TeaModel {
    public var analyzerType: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analyzerType != nil {
            map["analyzerType"] = self.analyzerType!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("analyzerType") {
            self.analyzerType = dict["analyzerType"] as! String
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
    }
}

public class ListDictsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var downloadUrl: String?

        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadUrl != nil {
                map["downloadUrl"] = self.downloadUrl!
            }
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("downloadUrl") {
                self.downloadUrl = dict["downloadUrl"] as! String
            }
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var headers: ListDictsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDictsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListDictsResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListDictsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListDictsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListDictsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDictsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListDictsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListEcsInstancesRequest : Tea.TeaModel {
    public var ecsInstanceIds: String?

    public var ecsInstanceName: String?

    public var page: Int32?

    public var size: Int32?

    public var tags: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecsInstanceIds != nil {
            map["ecsInstanceIds"] = self.ecsInstanceIds!
        }
        if self.ecsInstanceName != nil {
            map["ecsInstanceName"] = self.ecsInstanceName!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ecsInstanceIds") {
            self.ecsInstanceIds = dict["ecsInstanceIds"] as! String
        }
        if dict.keys.contains("ecsInstanceName") {
            self.ecsInstanceName = dict["ecsInstanceName"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("tags") {
            self.tags = dict["tags"] as! String
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
    }
}

public class ListEcsInstancesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Collectors : Tea.TeaModel {
            public class Configs : Tea.TeaModel {
                public var content: String?

                public var fileName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.fileName != nil {
                        map["fileName"] = self.fileName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("content") {
                        self.content = dict["content"] as! String
                    }
                    if dict.keys.contains("fileName") {
                        self.fileName = dict["fileName"] as! String
                    }
                }
            }
            public class ExtendConfigs : Tea.TeaModel {
                public class Machines : Tea.TeaModel {
                    public var agentStatus: String?

                    public var instanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.agentStatus != nil {
                            map["agentStatus"] = self.agentStatus!
                        }
                        if self.instanceId != nil {
                            map["instanceId"] = self.instanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("agentStatus") {
                            self.agentStatus = dict["agentStatus"] as! String
                        }
                        if dict.keys.contains("instanceId") {
                            self.instanceId = dict["instanceId"] as! String
                        }
                    }
                }
                public var configType: String?

                public var enableMonitoring: Bool?

                public var groupId: String?

                public var hosts: [String]?

                public var instanceId: String?

                public var instanceType: String?

                public var machines: [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs.Machines]?

                public var protocol_: String?

                public var type: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configType != nil {
                        map["configType"] = self.configType!
                    }
                    if self.enableMonitoring != nil {
                        map["enableMonitoring"] = self.enableMonitoring!
                    }
                    if self.groupId != nil {
                        map["groupId"] = self.groupId!
                    }
                    if self.hosts != nil {
                        map["hosts"] = self.hosts!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    if self.instanceType != nil {
                        map["instanceType"] = self.instanceType!
                    }
                    if self.machines != nil {
                        var tmp : [Any] = []
                        for k in self.machines! {
                            tmp.append(k.toMap())
                        }
                        map["machines"] = tmp
                    }
                    if self.protocol_ != nil {
                        map["protocol"] = self.protocol_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.userName != nil {
                        map["userName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("configType") {
                        self.configType = dict["configType"] as! String
                    }
                    if dict.keys.contains("enableMonitoring") {
                        self.enableMonitoring = dict["enableMonitoring"] as! Bool
                    }
                    if dict.keys.contains("groupId") {
                        self.groupId = dict["groupId"] as! String
                    }
                    if dict.keys.contains("hosts") {
                        self.hosts = dict["hosts"] as! [String]
                    }
                    if dict.keys.contains("instanceId") {
                        self.instanceId = dict["instanceId"] as! String
                    }
                    if dict.keys.contains("instanceType") {
                        self.instanceType = dict["instanceType"] as! String
                    }
                    if dict.keys.contains("machines") {
                        var tmp : [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs.Machines] = []
                        for v in dict["machines"] as! [Any] {
                            var model = ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs.Machines()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.machines = tmp
                    }
                    if dict.keys.contains("protocol") {
                        self.protocol_ = dict["protocol"] as! String
                    }
                    if dict.keys.contains("type") {
                        self.type = dict["type"] as! String
                    }
                    if dict.keys.contains("userName") {
                        self.userName = dict["userName"] as! String
                    }
                }
            }
            public var collectorPaths: [String]?

            public var configs: [ListEcsInstancesResponseBody.Result.Collectors.Configs]?

            public var dryRun: Bool?

            public var extendConfigs: [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs]?

            public var gmtCreatedTime: String?

            public var gmtUpdateTime: String?

            public var name: String?

            public var ownerId: String?

            public var resId: String?

            public var resType: String?

            public var resVersion: String?

            public var status: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.collectorPaths != nil {
                    map["collectorPaths"] = self.collectorPaths!
                }
                if self.configs != nil {
                    var tmp : [Any] = []
                    for k in self.configs! {
                        tmp.append(k.toMap())
                    }
                    map["configs"] = tmp
                }
                if self.dryRun != nil {
                    map["dryRun"] = self.dryRun!
                }
                if self.extendConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.extendConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["extendConfigs"] = tmp
                }
                if self.gmtCreatedTime != nil {
                    map["gmtCreatedTime"] = self.gmtCreatedTime!
                }
                if self.gmtUpdateTime != nil {
                    map["gmtUpdateTime"] = self.gmtUpdateTime!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.resId != nil {
                    map["resId"] = self.resId!
                }
                if self.resType != nil {
                    map["resType"] = self.resType!
                }
                if self.resVersion != nil {
                    map["resVersion"] = self.resVersion!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("collectorPaths") {
                    self.collectorPaths = dict["collectorPaths"] as! [String]
                }
                if dict.keys.contains("configs") {
                    var tmp : [ListEcsInstancesResponseBody.Result.Collectors.Configs] = []
                    for v in dict["configs"] as! [Any] {
                        var model = ListEcsInstancesResponseBody.Result.Collectors.Configs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.configs = tmp
                }
                if dict.keys.contains("dryRun") {
                    self.dryRun = dict["dryRun"] as! Bool
                }
                if dict.keys.contains("extendConfigs") {
                    var tmp : [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs] = []
                    for v in dict["extendConfigs"] as! [Any] {
                        var model = ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.extendConfigs = tmp
                }
                if dict.keys.contains("gmtCreatedTime") {
                    self.gmtCreatedTime = dict["gmtCreatedTime"] as! String
                }
                if dict.keys.contains("gmtUpdateTime") {
                    self.gmtUpdateTime = dict["gmtUpdateTime"] as! String
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("ownerId") {
                    self.ownerId = dict["ownerId"] as! String
                }
                if dict.keys.contains("resId") {
                    self.resId = dict["resId"] as! String
                }
                if dict.keys.contains("resType") {
                    self.resType = dict["resType"] as! String
                }
                if dict.keys.contains("resVersion") {
                    self.resVersion = dict["resVersion"] as! String
                }
                if dict.keys.contains("status") {
                    self.status = dict["status"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
            }
        }
        public class IpAddress : Tea.TeaModel {
            public var host: String?

            public var ipType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.ipType != nil {
                    map["ipType"] = self.ipType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("host") {
                    self.host = dict["host"] as! String
                }
                if dict.keys.contains("ipType") {
                    self.ipType = dict["ipType"] as! String
                }
            }
        }
        public var cloudAssistantStatus: String?

        public var collectors: [ListEcsInstancesResponseBody.Result.Collectors]?

        public var ecsInstanceId: String?

        public var ecsInstanceName: String?

        public var ipAddress: [ListEcsInstancesResponseBody.Result.IpAddress]?

        public var osType: String?

        public var status: String?

        public var tags: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cloudAssistantStatus != nil {
                map["cloudAssistantStatus"] = self.cloudAssistantStatus!
            }
            if self.collectors != nil {
                var tmp : [Any] = []
                for k in self.collectors! {
                    tmp.append(k.toMap())
                }
                map["collectors"] = tmp
            }
            if self.ecsInstanceId != nil {
                map["ecsInstanceId"] = self.ecsInstanceId!
            }
            if self.ecsInstanceName != nil {
                map["ecsInstanceName"] = self.ecsInstanceName!
            }
            if self.ipAddress != nil {
                var tmp : [Any] = []
                for k in self.ipAddress! {
                    tmp.append(k.toMap())
                }
                map["ipAddress"] = tmp
            }
            if self.osType != nil {
                map["osType"] = self.osType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tags != nil {
                map["tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("cloudAssistantStatus") {
                self.cloudAssistantStatus = dict["cloudAssistantStatus"] as! String
            }
            if dict.keys.contains("collectors") {
                var tmp : [ListEcsInstancesResponseBody.Result.Collectors] = []
                for v in dict["collectors"] as! [Any] {
                    var model = ListEcsInstancesResponseBody.Result.Collectors()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.collectors = tmp
            }
            if dict.keys.contains("ecsInstanceId") {
                self.ecsInstanceId = dict["ecsInstanceId"] as! String
            }
            if dict.keys.contains("ecsInstanceName") {
                self.ecsInstanceName = dict["ecsInstanceName"] as! String
            }
            if dict.keys.contains("ipAddress") {
                var tmp : [ListEcsInstancesResponseBody.Result.IpAddress] = []
                for v in dict["ipAddress"] as! [Any] {
                    var model = ListEcsInstancesResponseBody.Result.IpAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipAddress = tmp
            }
            if dict.keys.contains("osType") {
                self.osType = dict["osType"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("tags") {
                self.tags = dict["tags"] as! String
            }
        }
    }
    public var headers: ListEcsInstancesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListEcsInstancesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListEcsInstancesResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListEcsInstancesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListEcsInstancesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListEcsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEcsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListEcsInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListExtendfilesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var filePath: String?

        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("filePath") {
                self.filePath = dict["filePath"] as! String
            }
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListExtendfilesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListExtendfilesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListExtendfilesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListExtendfilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListExtendfilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListExtendfilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListILMPoliciesRequest : Tea.TeaModel {
    public var policyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyName != nil {
            map["policyName"] = self.policyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("policyName") {
            self.policyName = dict["policyName"] as! String
        }
    }
}

public class ListILMPoliciesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var name: String?

        public var phases: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.phases != nil {
                map["phases"] = self.phases!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("phases") {
                self.phases = dict["phases"] as! [String: Any]
            }
        }
    }
    public var requestId: String?

    public var result: [ListILMPoliciesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListILMPoliciesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListILMPoliciesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListILMPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListILMPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListILMPoliciesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListIndexTemplatesRequest : Tea.TeaModel {
    public var indexTemplate: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexTemplate != nil {
            map["indexTemplate"] = self.indexTemplate!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("indexTemplate") {
            self.indexTemplate = dict["indexTemplate"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListIndexTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("aliases") {
                    self.aliases = dict["aliases"] as! String
                }
                if dict.keys.contains("mappings") {
                    self.mappings = dict["mappings"] as! String
                }
                if dict.keys.contains("settings") {
                    self.settings = dict["settings"] as! String
                }
            }
        }
        public var dataStream: Bool?

        public var ilmPolicy: String?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var priority: Int32?

        public var template: ListIndexTemplatesResponseBody.Result.Template?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.ilmPolicy != nil {
                map["ilmPolicy"] = self.ilmPolicy!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("dataStream") {
                self.dataStream = dict["dataStream"] as! Bool
            }
            if dict.keys.contains("ilmPolicy") {
                self.ilmPolicy = dict["ilmPolicy"] as! String
            }
            if dict.keys.contains("indexPatterns") {
                self.indexPatterns = dict["indexPatterns"] as! [String]
            }
            if dict.keys.contains("indexTemplate") {
                self.indexTemplate = dict["indexTemplate"] as! String
            }
            if dict.keys.contains("priority") {
                self.priority = dict["priority"] as! Int32
            }
            if dict.keys.contains("template") {
                var model = ListIndexTemplatesResponseBody.Result.Template()
                model.fromMap(dict["template"] as! [String: Any])
                self.template = model
            }
        }
    }
    public var requestId: String?

    public var result: [ListIndexTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListIndexTemplatesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListIndexTemplatesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListIndexTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIndexTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListIndexTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceRequest : Tea.TeaModel {
    public var description_: String?

    public var esVersion: String?

    public var instanceCategory: String?

    public var instanceId: String?

    public var page: Int32?

    public var paymentType: String?

    public var resourceGroupId: String?

    public var size: Int32?

    public var tags: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.esVersion != nil {
            map["esVersion"] = self.esVersion!
        }
        if self.instanceCategory != nil {
            map["instanceCategory"] = self.instanceCategory!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("esVersion") {
            self.esVersion = dict["esVersion"] as! String
        }
        if dict.keys.contains("instanceCategory") {
            self.instanceCategory = dict["instanceCategory"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("paymentType") {
            self.paymentType = dict["paymentType"] as! String
        }
        if dict.keys.contains("resourceGroupId") {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("tags") {
            self.tags = dict["tags"] as! String
        }
        if dict.keys.contains("vpcId") {
            self.vpcId = dict["vpcId"] as! String
        }
        if dict.keys.contains("zoneId") {
            self.zoneId = dict["zoneId"] as! String
        }
    }
}

public class ListInstanceResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class ClientNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class ElasticDataNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskEncryption") {
                    self.diskEncryption = dict["diskEncryption"] as! Bool
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("groupName") {
                        self.groupName = dict["groupName"] as! String
                    }
                    if dict.keys.contains("ips") {
                        self.ips = dict["ips"] as! [String]
                    }
                    if dict.keys.contains("whiteIpType") {
                        self.whiteIpType = dict["whiteIpType"] as! String
                    }
                }
            }
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public var whiteIpGroupList: [ListInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vsArea") {
                    self.vsArea = dict["vsArea"] as! String
                }
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
                if dict.keys.contains("whiteIpGroupList") {
                    var tmp : [ListInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in dict["whiteIpGroupList"] as! [Any] {
                        var model = ListInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var performanceLevel: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.performanceLevel != nil {
                    map["performanceLevel"] = self.performanceLevel!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskEncryption") {
                    self.diskEncryption = dict["diskEncryption"] as! Bool
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("performanceLevel") {
                    self.performanceLevel = dict["performanceLevel"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
                if dict.keys.contains("specInfo") {
                    self.specInfo = dict["specInfo"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("tagKey") {
                    self.tagKey = dict["tagKey"] as! String
                }
                if dict.keys.contains("tagValue") {
                    self.tagValue = dict["tagValue"] as! String
                }
            }
        }
        public var advancedDedicateMaster: Bool?

        public var archType: String?

        public var clientNodeConfiguration: ListInstanceResponseBody.Result.ClientNodeConfiguration?

        public var createdAt: String?

        public var dedicateMaster: Bool?

        public var description_: String?

        public var elasticDataNodeConfiguration: ListInstanceResponseBody.Result.ElasticDataNodeConfiguration?

        public var endTime: Int64?

        public var esVersion: String?

        public var extendConfigs: [[String: Any]]?

        public var instanceId: String?

        public var isNewDeployment: String?

        public var kibanaConfiguration: ListInstanceResponseBody.Result.KibanaConfiguration?

        public var kibanaIPWhitelist: [String]?

        public var kibanaPrivateIPWhitelist: [String]?

        public var masterConfiguration: ListInstanceResponseBody.Result.MasterConfiguration?

        public var networkConfig: ListInstanceResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: ListInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var postpaidServiceStatus: String?

        public var privateNetworkIpWhiteList: [String]?

        public var publicIpWhitelist: [String]?

        public var resourceGroupId: String?

        public var serviceVpc: Bool?

        public var status: String?

        public var tags: [ListInstanceResponseBody.Result.Tags]?

        public var updatedAt: String?

        public var vpcInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clientNodeConfiguration?.validate()
            try self.elasticDataNodeConfiguration?.validate()
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advancedDedicateMaster != nil {
                map["advancedDedicateMaster"] = self.advancedDedicateMaster!
            }
            if self.archType != nil {
                map["archType"] = self.archType!
            }
            if self.clientNodeConfiguration != nil {
                map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.dedicateMaster != nil {
                map["dedicateMaster"] = self.dedicateMaster!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.elasticDataNodeConfiguration != nil {
                map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.extendConfigs != nil {
                map["extendConfigs"] = self.extendConfigs!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.isNewDeployment != nil {
                map["isNewDeployment"] = self.isNewDeployment!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaIPWhitelist != nil {
                map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
            }
            if self.kibanaPrivateIPWhitelist != nil {
                map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.postpaidServiceStatus != nil {
                map["postpaidServiceStatus"] = self.postpaidServiceStatus!
            }
            if self.privateNetworkIpWhiteList != nil {
                map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
            }
            if self.publicIpWhitelist != nil {
                map["publicIpWhitelist"] = self.publicIpWhitelist!
            }
            if self.resourceGroupId != nil {
                map["resourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceVpc != nil {
                map["serviceVpc"] = self.serviceVpc!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.vpcInstanceId != nil {
                map["vpcInstanceId"] = self.vpcInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("advancedDedicateMaster") {
                self.advancedDedicateMaster = dict["advancedDedicateMaster"] as! Bool
            }
            if dict.keys.contains("archType") {
                self.archType = dict["archType"] as! String
            }
            if dict.keys.contains("clientNodeConfiguration") {
                var model = ListInstanceResponseBody.Result.ClientNodeConfiguration()
                model.fromMap(dict["clientNodeConfiguration"] as! [String: Any])
                self.clientNodeConfiguration = model
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("dedicateMaster") {
                self.dedicateMaster = dict["dedicateMaster"] as! Bool
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("elasticDataNodeConfiguration") {
                var model = ListInstanceResponseBody.Result.ElasticDataNodeConfiguration()
                model.fromMap(dict["elasticDataNodeConfiguration"] as! [String: Any])
                self.elasticDataNodeConfiguration = model
            }
            if dict.keys.contains("endTime") {
                self.endTime = dict["endTime"] as! Int64
            }
            if dict.keys.contains("esVersion") {
                self.esVersion = dict["esVersion"] as! String
            }
            if dict.keys.contains("extendConfigs") {
                self.extendConfigs = dict["extendConfigs"] as! [[String: Any]]
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("isNewDeployment") {
                self.isNewDeployment = dict["isNewDeployment"] as! String
            }
            if dict.keys.contains("kibanaConfiguration") {
                var model = ListInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
                self.kibanaConfiguration = model
            }
            if dict.keys.contains("kibanaIPWhitelist") {
                self.kibanaIPWhitelist = dict["kibanaIPWhitelist"] as! [String]
            }
            if dict.keys.contains("kibanaPrivateIPWhitelist") {
                self.kibanaPrivateIPWhitelist = dict["kibanaPrivateIPWhitelist"] as! [String]
            }
            if dict.keys.contains("masterConfiguration") {
                var model = ListInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(dict["masterConfiguration"] as! [String: Any])
                self.masterConfiguration = model
            }
            if dict.keys.contains("networkConfig") {
                var model = ListInstanceResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int32
            }
            if dict.keys.contains("nodeSpec") {
                var model = ListInstanceResponseBody.Result.NodeSpec()
                model.fromMap(dict["nodeSpec"] as! [String: Any])
                self.nodeSpec = model
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("postpaidServiceStatus") {
                self.postpaidServiceStatus = dict["postpaidServiceStatus"] as! String
            }
            if dict.keys.contains("privateNetworkIpWhiteList") {
                self.privateNetworkIpWhiteList = dict["privateNetworkIpWhiteList"] as! [String]
            }
            if dict.keys.contains("publicIpWhitelist") {
                self.publicIpWhitelist = dict["publicIpWhitelist"] as! [String]
            }
            if dict.keys.contains("resourceGroupId") {
                self.resourceGroupId = dict["resourceGroupId"] as! String
            }
            if dict.keys.contains("serviceVpc") {
                self.serviceVpc = dict["serviceVpc"] as! Bool
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("tags") {
                var tmp : [ListInstanceResponseBody.Result.Tags] = []
                for v in dict["tags"] as! [Any] {
                    var model = ListInstanceResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("vpcInstanceId") {
                self.vpcInstanceId = dict["vpcInstanceId"] as! String
            }
        }
    }
    public var headers: ListInstanceResponseBody.Headers?

    public var requestId: String?

    public var result: [ListInstanceResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListInstanceResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListInstanceResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListInstanceResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceHistoryEventsRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var desc: Bool?

        public var sortField: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["desc"] = self.desc!
            }
            if self.sortField != nil {
                map["sortField"] = self.sortField!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("desc") {
                self.desc = dict["desc"] as! Bool
            }
            if dict.keys.contains("sortField") {
                self.sortField = dict["sortField"] as! String
            }
        }
    }
    public var body: [ListInstanceHistoryEventsRequest.Body]?

    public var eventCreateEndTime: String?

    public var eventCreateStartTime: String?

    public var eventCycleStatus: [String]?

    public var eventExecuteEndTime: String?

    public var eventExecuteStartTime: String?

    public var eventFinashEndTime: String?

    public var eventFinashStartTime: String?

    public var eventLevel: [String]?

    public var eventType: [String]?

    public var instanceId: String?

    public var nodeIP: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.eventCreateEndTime != nil {
            map["eventCreateEndTime"] = self.eventCreateEndTime!
        }
        if self.eventCreateStartTime != nil {
            map["eventCreateStartTime"] = self.eventCreateStartTime!
        }
        if self.eventCycleStatus != nil {
            map["eventCycleStatus"] = self.eventCycleStatus!
        }
        if self.eventExecuteEndTime != nil {
            map["eventExecuteEndTime"] = self.eventExecuteEndTime!
        }
        if self.eventExecuteStartTime != nil {
            map["eventExecuteStartTime"] = self.eventExecuteStartTime!
        }
        if self.eventFinashEndTime != nil {
            map["eventFinashEndTime"] = self.eventFinashEndTime!
        }
        if self.eventFinashStartTime != nil {
            map["eventFinashStartTime"] = self.eventFinashStartTime!
        }
        if self.eventLevel != nil {
            map["eventLevel"] = self.eventLevel!
        }
        if self.eventType != nil {
            map["eventType"] = self.eventType!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.nodeIP != nil {
            map["nodeIP"] = self.nodeIP!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            var tmp : [ListInstanceHistoryEventsRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = ListInstanceHistoryEventsRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
        if dict.keys.contains("eventCreateEndTime") {
            self.eventCreateEndTime = dict["eventCreateEndTime"] as! String
        }
        if dict.keys.contains("eventCreateStartTime") {
            self.eventCreateStartTime = dict["eventCreateStartTime"] as! String
        }
        if dict.keys.contains("eventCycleStatus") {
            self.eventCycleStatus = dict["eventCycleStatus"] as! [String]
        }
        if dict.keys.contains("eventExecuteEndTime") {
            self.eventExecuteEndTime = dict["eventExecuteEndTime"] as! String
        }
        if dict.keys.contains("eventExecuteStartTime") {
            self.eventExecuteStartTime = dict["eventExecuteStartTime"] as! String
        }
        if dict.keys.contains("eventFinashEndTime") {
            self.eventFinashEndTime = dict["eventFinashEndTime"] as! String
        }
        if dict.keys.contains("eventFinashStartTime") {
            self.eventFinashStartTime = dict["eventFinashStartTime"] as! String
        }
        if dict.keys.contains("eventLevel") {
            self.eventLevel = dict["eventLevel"] as! [String]
        }
        if dict.keys.contains("eventType") {
            self.eventType = dict["eventType"] as! [String]
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("nodeIP") {
            self.nodeIP = dict["nodeIP"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListInstanceHistoryEventsShrinkRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var desc: Bool?

        public var sortField: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["desc"] = self.desc!
            }
            if self.sortField != nil {
                map["sortField"] = self.sortField!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("desc") {
                self.desc = dict["desc"] as! Bool
            }
            if dict.keys.contains("sortField") {
                self.sortField = dict["sortField"] as! String
            }
        }
    }
    public var body: [ListInstanceHistoryEventsShrinkRequest.Body]?

    public var eventCreateEndTime: String?

    public var eventCreateStartTime: String?

    public var eventCycleStatusShrink: String?

    public var eventExecuteEndTime: String?

    public var eventExecuteStartTime: String?

    public var eventFinashEndTime: String?

    public var eventFinashStartTime: String?

    public var eventLevelShrink: String?

    public var eventTypeShrink: String?

    public var instanceId: String?

    public var nodeIP: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.eventCreateEndTime != nil {
            map["eventCreateEndTime"] = self.eventCreateEndTime!
        }
        if self.eventCreateStartTime != nil {
            map["eventCreateStartTime"] = self.eventCreateStartTime!
        }
        if self.eventCycleStatusShrink != nil {
            map["eventCycleStatus"] = self.eventCycleStatusShrink!
        }
        if self.eventExecuteEndTime != nil {
            map["eventExecuteEndTime"] = self.eventExecuteEndTime!
        }
        if self.eventExecuteStartTime != nil {
            map["eventExecuteStartTime"] = self.eventExecuteStartTime!
        }
        if self.eventFinashEndTime != nil {
            map["eventFinashEndTime"] = self.eventFinashEndTime!
        }
        if self.eventFinashStartTime != nil {
            map["eventFinashStartTime"] = self.eventFinashStartTime!
        }
        if self.eventLevelShrink != nil {
            map["eventLevel"] = self.eventLevelShrink!
        }
        if self.eventTypeShrink != nil {
            map["eventType"] = self.eventTypeShrink!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.nodeIP != nil {
            map["nodeIP"] = self.nodeIP!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            var tmp : [ListInstanceHistoryEventsShrinkRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = ListInstanceHistoryEventsShrinkRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
        if dict.keys.contains("eventCreateEndTime") {
            self.eventCreateEndTime = dict["eventCreateEndTime"] as! String
        }
        if dict.keys.contains("eventCreateStartTime") {
            self.eventCreateStartTime = dict["eventCreateStartTime"] as! String
        }
        if dict.keys.contains("eventCycleStatus") {
            self.eventCycleStatusShrink = dict["eventCycleStatus"] as! String
        }
        if dict.keys.contains("eventExecuteEndTime") {
            self.eventExecuteEndTime = dict["eventExecuteEndTime"] as! String
        }
        if dict.keys.contains("eventExecuteStartTime") {
            self.eventExecuteStartTime = dict["eventExecuteStartTime"] as! String
        }
        if dict.keys.contains("eventFinashEndTime") {
            self.eventFinashEndTime = dict["eventFinashEndTime"] as! String
        }
        if dict.keys.contains("eventFinashStartTime") {
            self.eventFinashStartTime = dict["eventFinashStartTime"] as! String
        }
        if dict.keys.contains("eventLevel") {
            self.eventLevelShrink = dict["eventLevel"] as! String
        }
        if dict.keys.contains("eventType") {
            self.eventTypeShrink = dict["eventType"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("nodeIP") {
            self.nodeIP = dict["nodeIP"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListInstanceHistoryEventsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public var xTotalFailed: Int64?

        public var xTotalSuccess: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            if self.xTotalFailed != nil {
                map["X-Total-Failed"] = self.xTotalFailed!
            }
            if self.xTotalSuccess != nil {
                map["X-Total-Success"] = self.xTotalSuccess!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int64
            }
            if dict.keys.contains("X-Total-Failed") {
                self.xTotalFailed = dict["X-Total-Failed"] as! Int64
            }
            if dict.keys.contains("X-Total-Success") {
                self.xTotalSuccess = dict["X-Total-Success"] as! Int64
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var ecsId: String?

        public var eventCreateTime: String?

        public var eventCycleStatus: String?

        public var eventExecuteTime: String?

        public var eventFinashTime: String?

        public var eventLevel: String?

        public var eventType: String?

        public var instanceId: String?

        public var nodeIP: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsId != nil {
                map["ecsId"] = self.ecsId!
            }
            if self.eventCreateTime != nil {
                map["eventCreateTime"] = self.eventCreateTime!
            }
            if self.eventCycleStatus != nil {
                map["eventCycleStatus"] = self.eventCycleStatus!
            }
            if self.eventExecuteTime != nil {
                map["eventExecuteTime"] = self.eventExecuteTime!
            }
            if self.eventFinashTime != nil {
                map["eventFinashTime"] = self.eventFinashTime!
            }
            if self.eventLevel != nil {
                map["eventLevel"] = self.eventLevel!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.nodeIP != nil {
                map["nodeIP"] = self.nodeIP!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ecsId") {
                self.ecsId = dict["ecsId"] as! String
            }
            if dict.keys.contains("eventCreateTime") {
                self.eventCreateTime = dict["eventCreateTime"] as! String
            }
            if dict.keys.contains("eventCycleStatus") {
                self.eventCycleStatus = dict["eventCycleStatus"] as! String
            }
            if dict.keys.contains("eventExecuteTime") {
                self.eventExecuteTime = dict["eventExecuteTime"] as! String
            }
            if dict.keys.contains("eventFinashTime") {
                self.eventFinashTime = dict["eventFinashTime"] as! String
            }
            if dict.keys.contains("eventLevel") {
                self.eventLevel = dict["eventLevel"] as! String
            }
            if dict.keys.contains("eventType") {
                self.eventType = dict["eventType"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("nodeIP") {
                self.nodeIP = dict["nodeIP"] as! String
            }
            if dict.keys.contains("regionId") {
                self.regionId = dict["regionId"] as! String
            }
        }
    }
    public var headers: ListInstanceHistoryEventsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListInstanceHistoryEventsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListInstanceHistoryEventsResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListInstanceHistoryEventsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListInstanceHistoryEventsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListInstanceHistoryEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceHistoryEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceHistoryEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListInstanceIndicesRequest : Tea.TeaModel {
    public var all: Bool?

    public var isManaged: Bool?

    public var isOpenstore: Bool?

    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["all"] = self.all!
        }
        if self.isManaged != nil {
            map["isManaged"] = self.isManaged!
        }
        if self.isOpenstore != nil {
            map["isOpenstore"] = self.isOpenstore!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("all") {
            self.all = dict["all"] as! Bool
        }
        if dict.keys.contains("isManaged") {
            self.isManaged = dict["isManaged"] as! Bool
        }
        if dict.keys.contains("isOpenstore") {
            self.isOpenstore = dict["isOpenstore"] as! Bool
        }
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListInstanceIndicesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xManagedCount: Int32?

        public var xManagedStorageSize: Int64?

        public var xOSSCount: Int32?

        public var xOSSStorageSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xManagedCount != nil {
                map["X-Managed-Count"] = self.xManagedCount!
            }
            if self.xManagedStorageSize != nil {
                map["X-Managed-StorageSize"] = self.xManagedStorageSize!
            }
            if self.xOSSCount != nil {
                map["X-OSS-Count"] = self.xOSSCount!
            }
            if self.xOSSStorageSize != nil {
                map["X-OSS-StorageSize"] = self.xOSSStorageSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Managed-Count") {
                self.xManagedCount = dict["X-Managed-Count"] as! Int32
            }
            if dict.keys.contains("X-Managed-StorageSize") {
                self.xManagedStorageSize = dict["X-Managed-StorageSize"] as! Int64
            }
            if dict.keys.contains("X-OSS-Count") {
                self.xOSSCount = dict["X-OSS-Count"] as! Int32
            }
            if dict.keys.contains("X-OSS-StorageSize") {
                self.xOSSStorageSize = dict["X-OSS-StorageSize"] as! Int64
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var createTime: String?

        public var health: String?

        public var ilmExplain: String?

        public var isManaged: String?

        public var managedStatus: String?

        public var name: String?

        public var phase: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.ilmExplain != nil {
                map["ilmExplain"] = self.ilmExplain!
            }
            if self.isManaged != nil {
                map["isManaged"] = self.isManaged!
            }
            if self.managedStatus != nil {
                map["managedStatus"] = self.managedStatus!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.phase != nil {
                map["phase"] = self.phase!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("health") {
                self.health = dict["health"] as! String
            }
            if dict.keys.contains("ilmExplain") {
                self.ilmExplain = dict["ilmExplain"] as! String
            }
            if dict.keys.contains("isManaged") {
                self.isManaged = dict["isManaged"] as! String
            }
            if dict.keys.contains("managedStatus") {
                self.managedStatus = dict["managedStatus"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("phase") {
                self.phase = dict["phase"] as! String
            }
            if dict.keys.contains("size") {
                self.size = dict["size"] as! Int64
            }
        }
    }
    public var headers: ListInstanceIndicesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListInstanceIndicesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListInstanceIndicesResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListInstanceIndicesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListInstanceIndicesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListInstanceIndicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceIndicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListInstanceIndicesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListKibanaPluginsRequest : Tea.TeaModel {
    public var page: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("page") {
            self.page = dict["page"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListKibanaPluginsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var name: String?

        public var source: String?

        public var specificationUrl: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.specificationUrl != nil {
                map["specificationUrl"] = self.specificationUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("specificationUrl") {
                self.specificationUrl = dict["specificationUrl"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var headers: ListKibanaPluginsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListKibanaPluginsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListKibanaPluginsResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListKibanaPluginsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListKibanaPluginsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListKibanaPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListKibanaPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListKibanaPluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class VSwitchIdsZone : Tea.TeaModel {
            public var vswitchId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
                if dict.keys.contains("zoneId") {
                    self.zoneId = dict["zoneId"] as! String
                }
            }
        }
        public var createTime: String?

        public var endpointId: String?

        public var endpointName: String?

        public var endpointStatus: String?

        public var pvlId: String?

        public var securityGroups: [String]?

        public var vSwitchIdsZone: [ListKibanaPvlNetworkResponseBody.Result.VSwitchIdsZone]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.endpointId != nil {
                map["endpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["endpointName"] = self.endpointName!
            }
            if self.endpointStatus != nil {
                map["endpointStatus"] = self.endpointStatus!
            }
            if self.pvlId != nil {
                map["pvlId"] = self.pvlId!
            }
            if self.securityGroups != nil {
                map["securityGroups"] = self.securityGroups!
            }
            if self.vSwitchIdsZone != nil {
                var tmp : [Any] = []
                for k in self.vSwitchIdsZone! {
                    tmp.append(k.toMap())
                }
                map["vSwitchIdsZone"] = tmp
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("endpointId") {
                self.endpointId = dict["endpointId"] as! String
            }
            if dict.keys.contains("endpointName") {
                self.endpointName = dict["endpointName"] as! String
            }
            if dict.keys.contains("endpointStatus") {
                self.endpointStatus = dict["endpointStatus"] as! String
            }
            if dict.keys.contains("pvlId") {
                self.pvlId = dict["pvlId"] as! String
            }
            if dict.keys.contains("securityGroups") {
                self.securityGroups = dict["securityGroups"] as! [String]
            }
            if dict.keys.contains("vSwitchIdsZone") {
                var tmp : [ListKibanaPvlNetworkResponseBody.Result.VSwitchIdsZone] = []
                for v in dict["vSwitchIdsZone"] as! [Any] {
                    var model = ListKibanaPvlNetworkResponseBody.Result.VSwitchIdsZone()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vSwitchIdsZone = tmp
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListKibanaPvlNetworkResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListKibanaPvlNetworkResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListKibanaPvlNetworkResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListKibanaPvlNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogstashRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var page: Int32?

    public var resourceGroupId: String?

    public var size: Int32?

    public var tags: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("instanceId") {
            self.instanceId = dict["instanceId"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("resourceGroupId") {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("tags") {
            self.tags = dict["tags"] as! String
        }
        if dict.keys.contains("version") {
            self.version = dict["version"] as! String
        }
    }
}

public class ListLogstashResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vsArea") {
                    self.vsArea = dict["vsArea"] as! String
                }
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskEncryption") {
                    self.diskEncryption = dict["diskEncryption"] as! Bool
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public var tags: [ListLogstashResponseBody.Result.Tags]?

        public var createdAt: String?

        public var description_: String?

        public var instanceId: String?

        public var networkConfig: ListLogstashResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: ListLogstashResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var resourceGroupId: String?

        public var status: String?

        public var updatedAt: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.resourceGroupId != nil {
                map["resourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tags") {
                var tmp : [ListLogstashResponseBody.Result.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = ListLogstashResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("networkConfig") {
                var model = ListLogstashResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int32
            }
            if dict.keys.contains("nodeSpec") {
                var model = ListLogstashResponseBody.Result.NodeSpec()
                model.fromMap(dict["nodeSpec"] as! [String: Any])
                self.nodeSpec = model
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("resourceGroupId") {
                self.resourceGroupId = dict["resourceGroupId"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
        }
    }
    public var headers: ListLogstashResponseBody.Headers?

    public var requestId: String?

    public var result: [ListLogstashResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListLogstashResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListLogstashResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListLogstashResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLogstashResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogstashLogRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var endTime: Int64?

    public var page: Int32?

    public var query: String?

    public var size: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.query != nil {
            map["query"] = self.query!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("query") {
            self.query = dict["query"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class ListLogstashLogResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var host: String?

        public var instanceId: String?

        public var level: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("level") {
                self.level = dict["level"] as! String
            }
            if dict.keys.contains("timestamp") {
                self.timestamp = dict["timestamp"] as! Int64
            }
        }
    }
    public var requestId: String?

    public var result: [ListLogstashLogResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListLogstashLogResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListLogstashLogResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListLogstashLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogstashLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLogstashLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListLogstashPluginsRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
    }
}

public class ListLogstashPluginsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var name: String?

        public var source: String?

        public var specificationUrl: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.specificationUrl != nil {
                map["specificationUrl"] = self.specificationUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("specificationUrl") {
                self.specificationUrl = dict["specificationUrl"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListLogstashPluginsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListLogstashPluginsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListLogstashPluginsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListLogstashPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogstashPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListLogstashPluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public var ecsInstanceIds: String?

    public var ecsInstanceName: String?

    public var page: Int32?

    public var size: Int32?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecsInstanceIds != nil {
            map["ecsInstanceIds"] = self.ecsInstanceIds!
        }
        if self.ecsInstanceName != nil {
            map["ecsInstanceName"] = self.ecsInstanceName!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ecsInstanceIds") {
            self.ecsInstanceIds = dict["ecsInstanceIds"] as! String
        }
        if dict.keys.contains("ecsInstanceName") {
            self.ecsInstanceName = dict["ecsInstanceName"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("tags") {
            self.tags = dict["tags"] as! String
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class IpAddress : Tea.TeaModel {
            public var host: String?

            public var ipType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.ipType != nil {
                    map["ipType"] = self.ipType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("host") {
                    self.host = dict["host"] as! String
                }
                if dict.keys.contains("ipType") {
                    self.ipType = dict["ipType"] as! String
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("tagKey") {
                    self.tagKey = dict["tagKey"] as! String
                }
                if dict.keys.contains("tagValue") {
                    self.tagValue = dict["tagValue"] as! String
                }
            }
        }
        public var agentStatus: String?

        public var cloudAssistantStatus: String?

        public var ecsInstanceId: String?

        public var ecsInstanceName: String?

        public var ipAddress: [ListNodesResponseBody.Result.IpAddress]?

        public var osType: String?

        public var status: String?

        public var tags: [ListNodesResponseBody.Result.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentStatus != nil {
                map["agentStatus"] = self.agentStatus!
            }
            if self.cloudAssistantStatus != nil {
                map["cloudAssistantStatus"] = self.cloudAssistantStatus!
            }
            if self.ecsInstanceId != nil {
                map["ecsInstanceId"] = self.ecsInstanceId!
            }
            if self.ecsInstanceName != nil {
                map["ecsInstanceName"] = self.ecsInstanceName!
            }
            if self.ipAddress != nil {
                var tmp : [Any] = []
                for k in self.ipAddress! {
                    tmp.append(k.toMap())
                }
                map["ipAddress"] = tmp
            }
            if self.osType != nil {
                map["osType"] = self.osType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("agentStatus") {
                self.agentStatus = dict["agentStatus"] as! String
            }
            if dict.keys.contains("cloudAssistantStatus") {
                self.cloudAssistantStatus = dict["cloudAssistantStatus"] as! String
            }
            if dict.keys.contains("ecsInstanceId") {
                self.ecsInstanceId = dict["ecsInstanceId"] as! String
            }
            if dict.keys.contains("ecsInstanceName") {
                self.ecsInstanceName = dict["ecsInstanceName"] as! String
            }
            if dict.keys.contains("ipAddress") {
                var tmp : [ListNodesResponseBody.Result.IpAddress] = []
                for v in dict["ipAddress"] as! [Any] {
                    var model = ListNodesResponseBody.Result.IpAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipAddress = tmp
            }
            if dict.keys.contains("osType") {
                self.osType = dict["osType"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("tags") {
                var tmp : [ListNodesResponseBody.Result.Tags] = []
                for v in dict["tags"] as! [Any] {
                    var model = ListNodesResponseBody.Result.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var headers: ListNodesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListNodesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListNodesResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListNodesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListNodesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineRequest : Tea.TeaModel {
    public var page: Int32?

    public var pipelineId: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pipelineId != nil {
            map["pipelineId"] = self.pipelineId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("pipelineId") {
            self.pipelineId = dict["pipelineId"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListPipelineResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var pipelineId: String?

        public var pipelineStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineStatus != nil {
                map["pipelineStatus"] = self.pipelineStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("gmtCreatedTime") {
                self.gmtCreatedTime = dict["gmtCreatedTime"] as! String
            }
            if dict.keys.contains("gmtUpdateTime") {
                self.gmtUpdateTime = dict["gmtUpdateTime"] as! String
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! String
            }
            if dict.keys.contains("pipelineStatus") {
                self.pipelineStatus = dict["pipelineStatus"] as! String
            }
        }
    }
    public var headers: ListPipelineResponseBody.Headers?

    public var requestId: String?

    public var result: [ListPipelineResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListPipelineResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListPipelineResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListPipelineResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPipelineIdsRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class ListPipelineIdsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var available: Bool?

        public var code: String?

        public var message: String?

        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.available != nil {
                map["available"] = self.available!
            }
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("available") {
                self.available = dict["available"] as! Bool
            }
            if dict.keys.contains("code") {
                self.code = dict["code"] as! String
            }
            if dict.keys.contains("message") {
                self.message = dict["message"] as! String
            }
            if dict.keys.contains("pipelineId") {
                self.pipelineId = dict["pipelineId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListPipelineIdsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListPipelineIdsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListPipelineIdsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListPipelineIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPipelineIdsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPluginsRequest : Tea.TeaModel {
    public var name: String?

    public var page: String?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("name") {
            self.name = dict["name"] as! String
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("source") {
            self.source = dict["source"] as! String
        }
    }
}

public class ListPluginsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var name: String?

        public var source: String?

        public var specificationUrl: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.specificationUrl != nil {
                map["specificationUrl"] = self.specificationUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("source") {
                self.source = dict["source"] as! String
            }
            if dict.keys.contains("specificationUrl") {
                self.specificationUrl = dict["specificationUrl"] as! String
            }
            if dict.keys.contains("state") {
                self.state = dict["state"] as! String
            }
        }
    }
    public var headers: ListPluginsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListPluginsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListPluginsResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListPluginsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListPluginsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPluginsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSearchLogRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var endTime: Int64?

    public var page: Int32?

    public var query: String?

    public var size: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.query != nil {
            map["query"] = self.query!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("beginTime") {
            self.beginTime = dict["beginTime"] as! Int64
        }
        if dict.keys.contains("endTime") {
            self.endTime = dict["endTime"] as! Int64
        }
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("query") {
            self.query = dict["query"] as! String
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
    }
}

public class ListSearchLogResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var content: String?

        public var contentCollection: [String: Any]?

        public var host: String?

        public var instanceId: String?

        public var level: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.contentCollection != nil {
                map["contentCollection"] = self.contentCollection!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("contentCollection") {
                self.contentCollection = dict["contentCollection"] as! [String: Any]
            }
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("level") {
                self.level = dict["level"] as! String
            }
            if dict.keys.contains("timestamp") {
                self.timestamp = dict["timestamp"] as! Int64
            }
        }
    }
    public var headers: ListSearchLogResponseBody.Headers?

    public var requestId: String?

    public var result: [ListSearchLogResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListSearchLogResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListSearchLogResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListSearchLogResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListSearchLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSearchLogResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListShardRecoveriesRequest : Tea.TeaModel {
    public var activeOnly: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeOnly != nil {
            map["activeOnly"] = self.activeOnly!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("activeOnly") {
            self.activeOnly = dict["activeOnly"] as! Bool
        }
    }
}

public class ListShardRecoveriesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bytesPercent: String?

        public var bytesTotal: Int64?

        public var filesPercent: String?

        public var filesTotal: Int64?

        public var index: String?

        public var sourceHost: String?

        public var sourceNode: String?

        public var stage: String?

        public var targetHost: String?

        public var targetNode: String?

        public var translogOps: Int64?

        public var translogOpsPercent: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bytesPercent != nil {
                map["bytesPercent"] = self.bytesPercent!
            }
            if self.bytesTotal != nil {
                map["bytesTotal"] = self.bytesTotal!
            }
            if self.filesPercent != nil {
                map["filesPercent"] = self.filesPercent!
            }
            if self.filesTotal != nil {
                map["filesTotal"] = self.filesTotal!
            }
            if self.index != nil {
                map["index"] = self.index!
            }
            if self.sourceHost != nil {
                map["sourceHost"] = self.sourceHost!
            }
            if self.sourceNode != nil {
                map["sourceNode"] = self.sourceNode!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.targetHost != nil {
                map["targetHost"] = self.targetHost!
            }
            if self.targetNode != nil {
                map["targetNode"] = self.targetNode!
            }
            if self.translogOps != nil {
                map["translogOps"] = self.translogOps!
            }
            if self.translogOpsPercent != nil {
                map["translogOpsPercent"] = self.translogOpsPercent!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("bytesPercent") {
                self.bytesPercent = dict["bytesPercent"] as! String
            }
            if dict.keys.contains("bytesTotal") {
                self.bytesTotal = dict["bytesTotal"] as! Int64
            }
            if dict.keys.contains("filesPercent") {
                self.filesPercent = dict["filesPercent"] as! String
            }
            if dict.keys.contains("filesTotal") {
                self.filesTotal = dict["filesTotal"] as! Int64
            }
            if dict.keys.contains("index") {
                self.index = dict["index"] as! String
            }
            if dict.keys.contains("sourceHost") {
                self.sourceHost = dict["sourceHost"] as! String
            }
            if dict.keys.contains("sourceNode") {
                self.sourceNode = dict["sourceNode"] as! String
            }
            if dict.keys.contains("stage") {
                self.stage = dict["stage"] as! String
            }
            if dict.keys.contains("targetHost") {
                self.targetHost = dict["targetHost"] as! String
            }
            if dict.keys.contains("targetNode") {
                self.targetNode = dict["targetNode"] as! String
            }
            if dict.keys.contains("translogOps") {
                self.translogOps = dict["translogOps"] as! Int64
            }
            if dict.keys.contains("translogOpsPercent") {
                self.translogOpsPercent = dict["translogOpsPercent"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListShardRecoveriesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListShardRecoveriesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListShardRecoveriesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListShardRecoveriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListShardRecoveriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListShardRecoveriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListSnapshotReposByInstanceIdResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var instanceId: String?

        public var repoPath: String?

        public var snapWarehouse: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.repoPath != nil {
                map["repoPath"] = self.repoPath!
            }
            if self.snapWarehouse != nil {
                map["snapWarehouse"] = self.snapWarehouse!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("repoPath") {
                self.repoPath = dict["repoPath"] as! String
            }
            if dict.keys.contains("snapWarehouse") {
                self.snapWarehouse = dict["snapWarehouse"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListSnapshotReposByInstanceIdResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListSnapshotReposByInstanceIdResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListSnapshotReposByInstanceIdResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListSnapshotReposByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotReposByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListSnapshotReposByInstanceIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public var nextToken: String?

    public var page: Int32?

    public var resourceIds: String?

    public var resourceType: String?

    public var size: Int32?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Page") {
            self.page = dict["Page"] as! Int32
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("Tags") {
            self.tags = dict["Tags"] as! String
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("X-Total-Count") {
                self.xTotalCount = dict["X-Total-Count"] as! Int32
            }
        }
    }
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var headers: ListTagResourcesResponseBody.Headers?

    public var pageSize: Int32?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            var model = ListTagResourcesResponseBody.Headers()
            model.fromMap(dict["Headers"] as! [String: Any])
            self.headers = model
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagsRequest : Tea.TeaModel {
    public var pageSize: Int32?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resourceType != nil {
            map["resourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("pageSize") {
            self.pageSize = dict["pageSize"] as! Int32
        }
        if dict.keys.contains("resourceType") {
            self.resourceType = dict["resourceType"] as! String
        }
    }
}

public class ListTagsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValue") {
                self.tagValue = dict["TagValue"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListTagsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListTagsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListTagsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListVpcEndpointsRequest : Tea.TeaModel {
    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("page") {
            self.page = dict["page"] as! Int32
        }
        if dict.keys.contains("size") {
            self.size = dict["size"] as! Int32
        }
    }
}

public class ListVpcEndpointsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var connectionStatus: String?

        public var createTime: String?

        public var endpointBusinessStatus: String?

        public var endpointDomain: String?

        public var endpointId: String?

        public var endpointName: String?

        public var endpointStatus: String?

        public var serviceId: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionStatus != nil {
                map["connectionStatus"] = self.connectionStatus!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.endpointBusinessStatus != nil {
                map["endpointBusinessStatus"] = self.endpointBusinessStatus!
            }
            if self.endpointDomain != nil {
                map["endpointDomain"] = self.endpointDomain!
            }
            if self.endpointId != nil {
                map["endpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["endpointName"] = self.endpointName!
            }
            if self.endpointStatus != nil {
                map["endpointStatus"] = self.endpointStatus!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("connectionStatus") {
                self.connectionStatus = dict["connectionStatus"] as! String
            }
            if dict.keys.contains("createTime") {
                self.createTime = dict["createTime"] as! String
            }
            if dict.keys.contains("endpointBusinessStatus") {
                self.endpointBusinessStatus = dict["endpointBusinessStatus"] as! String
            }
            if dict.keys.contains("endpointDomain") {
                self.endpointDomain = dict["endpointDomain"] as! String
            }
            if dict.keys.contains("endpointId") {
                self.endpointId = dict["endpointId"] as! String
            }
            if dict.keys.contains("endpointName") {
                self.endpointName = dict["endpointName"] as! String
            }
            if dict.keys.contains("endpointStatus") {
                self.endpointStatus = dict["endpointStatus"] as! String
            }
            if dict.keys.contains("serviceId") {
                self.serviceId = dict["serviceId"] as! String
            }
            if dict.keys.contains("serviceName") {
                self.serviceName = dict["serviceName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [ListVpcEndpointsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [ListVpcEndpointsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = ListVpcEndpointsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class ListVpcEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListVpcEndpointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MigrateToOtherZoneRequest : Tea.TeaModel {
    public var body: String?

    public var dryRun: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("dryRun") {
            self.dryRun = dict["dryRun"] as! Bool
        }
    }
}

public class MigrateToOtherZoneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class MigrateToOtherZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateToOtherZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MigrateToOtherZoneResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDeployMachineRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class ModifyDeployMachineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ModifyDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDeployMachineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyElastictaskRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class ModifyElastictaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ElasticExpansionTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cronExpression") {
                    self.cronExpression = dict["cronExpression"] as! String
                }
                if dict.keys.contains("elasticNodeCount") {
                    self.elasticNodeCount = dict["elasticNodeCount"] as! Int32
                }
                if dict.keys.contains("replicaCount") {
                    self.replicaCount = dict["replicaCount"] as! Int32
                }
                if dict.keys.contains("targetIndices") {
                    self.targetIndices = dict["targetIndices"] as! [String]
                }
                if dict.keys.contains("triggerType") {
                    self.triggerType = dict["triggerType"] as! String
                }
            }
        }
        public class ElasticShrinkTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("cronExpression") {
                    self.cronExpression = dict["cronExpression"] as! String
                }
                if dict.keys.contains("elasticNodeCount") {
                    self.elasticNodeCount = dict["elasticNodeCount"] as! Int32
                }
                if dict.keys.contains("replicaCount") {
                    self.replicaCount = dict["replicaCount"] as! Int32
                }
                if dict.keys.contains("targetIndices") {
                    self.targetIndices = dict["targetIndices"] as! [String]
                }
                if dict.keys.contains("triggerType") {
                    self.triggerType = dict["triggerType"] as! String
                }
            }
        }
        public var elasticExpansionTask: ModifyElastictaskResponseBody.Result.ElasticExpansionTask?

        public var elasticShrinkTask: ModifyElastictaskResponseBody.Result.ElasticShrinkTask?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.elasticExpansionTask?.validate()
            try self.elasticShrinkTask?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticExpansionTask != nil {
                map["elasticExpansionTask"] = self.elasticExpansionTask?.toMap()
            }
            if self.elasticShrinkTask != nil {
                map["elasticShrinkTask"] = self.elasticShrinkTask?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("elasticExpansionTask") {
                var model = ModifyElastictaskResponseBody.Result.ElasticExpansionTask()
                model.fromMap(dict["elasticExpansionTask"] as! [String: Any])
                self.elasticExpansionTask = model
            }
            if dict.keys.contains("elasticShrinkTask") {
                var model = ModifyElastictaskResponseBody.Result.ElasticShrinkTask()
                model.fromMap(dict["elasticShrinkTask"] as! [String: Any])
                self.elasticShrinkTask = model
            }
        }
    }
    public var requestId: String?

    public var result: ModifyElastictaskResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = ModifyElastictaskResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class ModifyElastictaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyElastictaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyElastictaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceMaintainTimeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class ModifyInstanceMaintainTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ModifyInstanceMaintainTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceMaintainTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceMaintainTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyWhiteIpsRequest : Tea.TeaModel {
    public class WhiteIpGroup : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var whiteIpType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.ips != nil {
                map["ips"] = self.ips!
            }
            if self.whiteIpType != nil {
                map["whiteIpType"] = self.whiteIpType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("groupName") {
                self.groupName = dict["groupName"] as! String
            }
            if dict.keys.contains("ips") {
                self.ips = dict["ips"] as! [String]
            }
            if dict.keys.contains("whiteIpType") {
                self.whiteIpType = dict["whiteIpType"] as! String
            }
        }
    }
    public var modifyMode: String?

    public var networkType: String?

    public var nodeType: String?

    public var whiteIpGroup: ModifyWhiteIpsRequest.WhiteIpGroup?

    public var whiteIpList: [String]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.whiteIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        if self.networkType != nil {
            map["networkType"] = self.networkType!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        if self.whiteIpGroup != nil {
            map["whiteIpGroup"] = self.whiteIpGroup?.toMap()
        }
        if self.whiteIpList != nil {
            map["whiteIpList"] = self.whiteIpList!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("modifyMode") {
            self.modifyMode = dict["modifyMode"] as! String
        }
        if dict.keys.contains("networkType") {
            self.networkType = dict["networkType"] as! String
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
        if dict.keys.contains("whiteIpGroup") {
            var model = ModifyWhiteIpsRequest.WhiteIpGroup()
            model.fromMap(dict["whiteIpGroup"] as! [String: Any])
            self.whiteIpGroup = model
        }
        if dict.keys.contains("whiteIpList") {
            self.whiteIpList = dict["whiteIpList"] as! [String]
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ModifyWhiteIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ModifyWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyWhiteIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class MoveResourceGroupRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class MoveResourceGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DictList : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vsArea") {
                    self.vsArea = dict["vsArea"] as! String
                }
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class SynonymsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var createdAt: String?

        public var description_: String?

        public var dictList: [MoveResourceGroupResponseBody.Result.DictList]?

        public var domain: String?

        public var esVersion: String?

        public var instanceId: String?

        public var kibanaConfiguration: MoveResourceGroupResponseBody.Result.KibanaConfiguration?

        public var kibanaDomain: String?

        public var kibanaPort: Int32?

        public var masterConfiguration: MoveResourceGroupResponseBody.Result.MasterConfiguration?

        public var networkConfig: MoveResourceGroupResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: MoveResourceGroupResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var publicDomain: String?

        public var publicPort: Int32?

        public var status: String?

        public var synonymsDicts: [MoveResourceGroupResponseBody.Result.SynonymsDicts]?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.dictList != nil {
                var tmp : [Any] = []
                for k in self.dictList! {
                    tmp.append(k.toMap())
                }
                map["dictList"] = tmp
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaDomain != nil {
                map["kibanaDomain"] = self.kibanaDomain!
            }
            if self.kibanaPort != nil {
                map["kibanaPort"] = self.kibanaPort!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.publicDomain != nil {
                map["publicDomain"] = self.publicDomain!
            }
            if self.publicPort != nil {
                map["publicPort"] = self.publicPort!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.synonymsDicts != nil {
                var tmp : [Any] = []
                for k in self.synonymsDicts! {
                    tmp.append(k.toMap())
                }
                map["synonymsDicts"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("dictList") {
                var tmp : [MoveResourceGroupResponseBody.Result.DictList] = []
                for v in dict["dictList"] as! [Any] {
                    var model = MoveResourceGroupResponseBody.Result.DictList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dictList = tmp
            }
            if dict.keys.contains("domain") {
                self.domain = dict["domain"] as! String
            }
            if dict.keys.contains("esVersion") {
                self.esVersion = dict["esVersion"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("kibanaConfiguration") {
                var model = MoveResourceGroupResponseBody.Result.KibanaConfiguration()
                model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
                self.kibanaConfiguration = model
            }
            if dict.keys.contains("kibanaDomain") {
                self.kibanaDomain = dict["kibanaDomain"] as! String
            }
            if dict.keys.contains("kibanaPort") {
                self.kibanaPort = dict["kibanaPort"] as! Int32
            }
            if dict.keys.contains("masterConfiguration") {
                var model = MoveResourceGroupResponseBody.Result.MasterConfiguration()
                model.fromMap(dict["masterConfiguration"] as! [String: Any])
                self.masterConfiguration = model
            }
            if dict.keys.contains("networkConfig") {
                var model = MoveResourceGroupResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int32
            }
            if dict.keys.contains("nodeSpec") {
                var model = MoveResourceGroupResponseBody.Result.NodeSpec()
                model.fromMap(dict["nodeSpec"] as! [String: Any])
                self.nodeSpec = model
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("publicDomain") {
                self.publicDomain = dict["publicDomain"] as! String
            }
            if dict.keys.contains("publicPort") {
                self.publicPort = dict["publicPort"] as! Int32
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("synonymsDicts") {
                var tmp : [MoveResourceGroupResponseBody.Result.SynonymsDicts] = []
                for v in dict["synonymsDicts"] as! [Any] {
                    var model = MoveResourceGroupResponseBody.Result.SynonymsDicts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.synonymsDicts = tmp
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: MoveResourceGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = MoveResourceGroupResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class MoveResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = MoveResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenDiagnosisRequest : Tea.TeaModel {
    public var clientToken: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class OpenDiagnosisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class OpenDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenDiagnosisResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class OpenHttpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class OpenHttpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class OpenHttpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenHttpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = OpenHttpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PostEmonTryAlarmRuleRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class PostEmonTryAlarmRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Success") {
            self.success = dict["Success"] as! Bool
        }
    }
}

public class PostEmonTryAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PostEmonTryAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PostEmonTryAlarmRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecommendTemplatesRequest : Tea.TeaModel {
    public var usageScenario: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.usageScenario != nil {
            map["usageScenario"] = self.usageScenario!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("usageScenario") {
            self.usageScenario = dict["usageScenario"] as! String
        }
    }
}

public class RecommendTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("content") {
                self.content = dict["content"] as! String
            }
            if dict.keys.contains("templateName") {
                self.templateName = dict["templateName"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [RecommendTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [RecommendTemplatesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = RecommendTemplatesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class RecommendTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecommendTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecommendTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReinstallCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class ReinstallCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ReinstallCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReinstallCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReinstallCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class RemoveApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveApmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewLogstashRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class RenewLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class RenewLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewLogstashResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class RestartCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class RestartCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartInstanceRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("force") {
            self.force = dict["force"] as! Bool
        }
    }
}

public class RestartInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DictList : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vsArea") {
                    self.vsArea = dict["vsArea"] as! String
                }
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class SynonymsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("fileSize") {
                    self.fileSize = dict["fileSize"] as! Int64
                }
                if dict.keys.contains("name") {
                    self.name = dict["name"] as! String
                }
                if dict.keys.contains("sourceType") {
                    self.sourceType = dict["sourceType"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
            }
        }
        public var createdAt: String?

        public var description_: String?

        public var dictList: [RestartInstanceResponseBody.Result.DictList]?

        public var domain: String?

        public var esVersion: String?

        public var instanceId: String?

        public var kibanaConfiguration: RestartInstanceResponseBody.Result.KibanaConfiguration?

        public var kibanaDomain: String?

        public var kibanaPort: Int32?

        public var masterConfiguration: RestartInstanceResponseBody.Result.MasterConfiguration?

        public var networkConfig: RestartInstanceResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: RestartInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var publicDomain: String?

        public var publicPort: Int32?

        public var status: String?

        public var synonymsDicts: [RestartInstanceResponseBody.Result.SynonymsDicts]?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.dictList != nil {
                var tmp : [Any] = []
                for k in self.dictList! {
                    tmp.append(k.toMap())
                }
                map["dictList"] = tmp
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaDomain != nil {
                map["kibanaDomain"] = self.kibanaDomain!
            }
            if self.kibanaPort != nil {
                map["kibanaPort"] = self.kibanaPort!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.publicDomain != nil {
                map["publicDomain"] = self.publicDomain!
            }
            if self.publicPort != nil {
                map["publicPort"] = self.publicPort!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.synonymsDicts != nil {
                var tmp : [Any] = []
                for k in self.synonymsDicts! {
                    tmp.append(k.toMap())
                }
                map["synonymsDicts"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("dictList") {
                var tmp : [RestartInstanceResponseBody.Result.DictList] = []
                for v in dict["dictList"] as! [Any] {
                    var model = RestartInstanceResponseBody.Result.DictList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dictList = tmp
            }
            if dict.keys.contains("domain") {
                self.domain = dict["domain"] as! String
            }
            if dict.keys.contains("esVersion") {
                self.esVersion = dict["esVersion"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("kibanaConfiguration") {
                var model = RestartInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
                self.kibanaConfiguration = model
            }
            if dict.keys.contains("kibanaDomain") {
                self.kibanaDomain = dict["kibanaDomain"] as! String
            }
            if dict.keys.contains("kibanaPort") {
                self.kibanaPort = dict["kibanaPort"] as! Int32
            }
            if dict.keys.contains("masterConfiguration") {
                var model = RestartInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(dict["masterConfiguration"] as! [String: Any])
                self.masterConfiguration = model
            }
            if dict.keys.contains("networkConfig") {
                var model = RestartInstanceResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int32
            }
            if dict.keys.contains("nodeSpec") {
                var model = RestartInstanceResponseBody.Result.NodeSpec()
                model.fromMap(dict["nodeSpec"] as! [String: Any])
                self.nodeSpec = model
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("publicDomain") {
                self.publicDomain = dict["publicDomain"] as! String
            }
            if dict.keys.contains("publicPort") {
                self.publicPort = dict["publicPort"] as! Int32
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("synonymsDicts") {
                var tmp : [RestartInstanceResponseBody.Result.SynonymsDicts] = []
                for v in dict["synonymsDicts"] as! [Any] {
                    var model = RestartInstanceResponseBody.Result.SynonymsDicts()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.synonymsDicts = tmp
            }
            if dict.keys.contains("updatedAt") {
                self.updatedAt = dict["updatedAt"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: RestartInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = RestartInstanceResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class RestartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RestartLogstashRequest : Tea.TeaModel {
    public var batchCount: Double?

    public var blueGreenDep: Bool?

    public var nodeTypes: [String]?

    public var nodes: [String]?

    public var restartType: String?

    public var clientToken: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchCount != nil {
            map["batchCount"] = self.batchCount!
        }
        if self.blueGreenDep != nil {
            map["blueGreenDep"] = self.blueGreenDep!
        }
        if self.nodeTypes != nil {
            map["nodeTypes"] = self.nodeTypes!
        }
        if self.nodes != nil {
            map["nodes"] = self.nodes!
        }
        if self.restartType != nil {
            map["restartType"] = self.restartType!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("batchCount") {
            self.batchCount = dict["batchCount"] as! Double
        }
        if dict.keys.contains("blueGreenDep") {
            self.blueGreenDep = dict["blueGreenDep"] as! Bool
        }
        if dict.keys.contains("nodeTypes") {
            self.nodeTypes = dict["nodeTypes"] as! [String]
        }
        if dict.keys.contains("nodes") {
            self.nodes = dict["nodes"] as! [String]
        }
        if dict.keys.contains("restartType") {
            self.restartType = dict["restartType"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("force") {
            self.force = dict["force"] as! Bool
        }
    }
}

public class RestartLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Logstash?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = Logstash()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class RestartLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RestartLogstashResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeElasticsearchTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ResumeElasticsearchTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ResumeElasticsearchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeElasticsearchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeElasticsearchTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResumeLogstashTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class ResumeLogstashTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ResumeLogstashTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeLogstashTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResumeLogstashTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RolloverDataStreamRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class RolloverDataStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class RolloverDataStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RolloverDataStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RolloverDataStreamResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunPipelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class RunPipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class RunPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ShrinkNodeRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var hostName: String?

        public var nodeType: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.hostName != nil {
                map["hostName"] = self.hostName!
            }
            if self.nodeType != nil {
                map["nodeType"] = self.nodeType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("hostName") {
                self.hostName = dict["hostName"] as! String
            }
            if dict.keys.contains("nodeType") {
                self.nodeType = dict["nodeType"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public var body: [ShrinkNodeRequest.Body]?

    public var clientToken: String?

    public var count: Int32?

    public var ignoreStatus: Bool?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.ignoreStatus != nil {
            map["ignoreStatus"] = self.ignoreStatus!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            var tmp : [ShrinkNodeRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = ShrinkNodeRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("count") {
            self.count = dict["count"] as! Int32
        }
        if dict.keys.contains("ignoreStatus") {
            self.ignoreStatus = dict["ignoreStatus"] as! Bool
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
    }
}

public class ShrinkNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ShrinkNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ShrinkNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ShrinkNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class StartApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartApmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class StartCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class StartCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class StopApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopApmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
    }
}

public class StopCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class StopCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopPipelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class StopPipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class StopPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopPipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("key") {
                self.key = dict["key"] as! String
            }
            if dict.keys.contains("value") {
                self.value = dict["value"] as! String
            }
        }
    }
    public var resourceIds: [String]?

    public var resourceType: String?

    public var tags: [TagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tags") {
            var tmp : [TagResourcesRequest.Tags] = []
            for v in dict["Tags"] as! [Any] {
                var model = TagResourcesRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TransferNodeRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public var body: [TransferNodeRequest.Body]?

    public var clientToken: String?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            var tmp : [TransferNodeRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = TransferNodeRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
    }
}

public class TransferNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class TransferNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TransferNodeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TriggerNetworkRequest : Tea.TeaModel {
    public var actionType: String?

    public var networkType: String?

    public var nodeType: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["actionType"] = self.actionType!
        }
        if self.networkType != nil {
            map["networkType"] = self.networkType!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("actionType") {
            self.actionType = dict["actionType"] as! String
        }
        if dict.keys.contains("networkType") {
            self.networkType = dict["networkType"] as! String
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class TriggerNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class TriggerNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TriggerNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TriggerNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallKibanaPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UninstallKibanaPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class UninstallKibanaPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallKibanaPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UninstallKibanaPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallLogstashPluginRequest : Tea.TeaModel {
    public var body: [String]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! [String]
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UninstallLogstashPluginResponseBody : Tea.TeaModel {
    public var headers: [String: Any]?

    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Headers") {
            self.headers = dict["Headers"] as! [String: Any]
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class UninstallLogstashPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallLogstashPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UninstallLogstashPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UninstallPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("force") {
            self.force = dict["force"] as! Bool
        }
    }
}

public class UninstallPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! [String]
        }
    }
}

public class UninstallPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UninstallPluginResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var resourceIds: String?

    public var resourceType: String?

    public var tagKeys: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKeys") {
            self.tagKeys = dict["TagKeys"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAdminPasswordRequest : Tea.TeaModel {
    public var esAdminPassword: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esAdminPassword != nil {
            map["esAdminPassword"] = self.esAdminPassword!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("esAdminPassword") {
            self.esAdminPassword = dict["esAdminPassword"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateAdminPasswordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateAdminPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAdminPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAdminPasswordResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAdvancedSettingRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateAdvancedSettingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateAdvancedSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAdvancedSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAdvancedSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateAliwsDictRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateAliwsDictResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateAliwsDictResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [UpdateAliwsDictResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = UpdateAliwsDictResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class UpdateAliwsDictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAliwsDictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateAliwsDictResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateApmRequest : Tea.TeaModel {
    public var description_: String?

    public var outputES: String?

    public var outputESPassword: String?

    public var outputESUserName: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.outputES != nil {
            map["outputES"] = self.outputES!
        }
        if self.outputESPassword != nil {
            map["outputESPassword"] = self.outputESPassword!
        }
        if self.outputESUserName != nil {
            map["outputESUserName"] = self.outputESUserName!
        }
        if self.token != nil {
            map["token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("outputES") {
            self.outputES = dict["outputES"] as! String
        }
        if dict.keys.contains("outputESPassword") {
            self.outputESPassword = dict["outputESPassword"] as! String
        }
        if dict.keys.contains("outputESUserName") {
            self.outputESUserName = dict["outputESUserName"] as! String
        }
        if dict.keys.contains("token") {
            self.token = dict["token"] as! String
        }
    }
}

public class UpdateApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateApmResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateBlackIpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateBlackIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var esIPBlacklist: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.esIPBlacklist != nil {
                map["esIPBlacklist"] = self.esIPBlacklist!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("esIPBlacklist") {
                self.esIPBlacklist = dict["esIPBlacklist"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var result: UpdateBlackIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateBlackIpsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateBlackIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBlackIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateBlackIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateCollectorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("agentStatus") {
                        self.agentStatus = dict["agentStatus"] as! String
                    }
                    if dict.keys.contains("instanceId") {
                        self.instanceId = dict["instanceId"] as! String
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [UpdateCollectorResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("configType") {
                    self.configType = dict["configType"] as! String
                }
                if dict.keys.contains("enableMonitoring") {
                    self.enableMonitoring = dict["enableMonitoring"] as! Bool
                }
                if dict.keys.contains("groupId") {
                    self.groupId = dict["groupId"] as! String
                }
                if dict.keys.contains("host") {
                    self.host = dict["host"] as! String
                }
                if dict.keys.contains("hosts") {
                    self.hosts = dict["hosts"] as! [String]
                }
                if dict.keys.contains("instanceId") {
                    self.instanceId = dict["instanceId"] as! String
                }
                if dict.keys.contains("instanceType") {
                    self.instanceType = dict["instanceType"] as! String
                }
                if dict.keys.contains("kibanaHost") {
                    self.kibanaHost = dict["kibanaHost"] as! String
                }
                if dict.keys.contains("machines") {
                    var tmp : [UpdateCollectorResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in dict["machines"] as! [Any] {
                        var model = UpdateCollectorResponseBody.Result.ExtendConfigs.Machines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.machines = tmp
                }
                if dict.keys.contains("protocol") {
                    self.protocol_ = dict["protocol"] as! String
                }
                if dict.keys.contains("successPodsCount") {
                    self.successPodsCount = dict["successPodsCount"] as! String
                }
                if dict.keys.contains("totalPodsCount") {
                    self.totalPodsCount = dict["totalPodsCount"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("userName") {
                    self.userName = dict["userName"] as! String
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [UpdateCollectorResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [UpdateCollectorResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("collectorPaths") {
                self.collectorPaths = dict["collectorPaths"] as! [String]
            }
            if dict.keys.contains("configs") {
                var tmp : [UpdateCollectorResponseBody.Result.Configs] = []
                for v in dict["configs"] as! [Any] {
                    var model = UpdateCollectorResponseBody.Result.Configs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configs = tmp
            }
            if dict.keys.contains("dryRun") {
                self.dryRun = dict["dryRun"] as! Bool
            }
            if dict.keys.contains("extendConfigs") {
                var tmp : [UpdateCollectorResponseBody.Result.ExtendConfigs] = []
                for v in dict["extendConfigs"] as! [Any] {
                    var model = UpdateCollectorResponseBody.Result.ExtendConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.extendConfigs = tmp
            }
            if dict.keys.contains("gmtCreatedTime") {
                self.gmtCreatedTime = dict["gmtCreatedTime"] as! String
            }
            if dict.keys.contains("gmtUpdateTime") {
                self.gmtUpdateTime = dict["gmtUpdateTime"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! String
            }
            if dict.keys.contains("resId") {
                self.resId = dict["resId"] as! String
            }
            if dict.keys.contains("resType") {
                self.resType = dict["resType"] as! String
            }
            if dict.keys.contains("resVersion") {
                self.resVersion = dict["resVersion"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: UpdateCollectorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateCollectorResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCollectorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateCollectorNameRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateCollectorNameResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("content") {
                    self.content = dict["content"] as! String
                }
                if dict.keys.contains("fileName") {
                    self.fileName = dict["fileName"] as! String
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("agentStatus") {
                        self.agentStatus = dict["agentStatus"] as! String
                    }
                    if dict.keys.contains("instanceId") {
                        self.instanceId = dict["instanceId"] as! String
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [UpdateCollectorNameResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("configType") {
                    self.configType = dict["configType"] as! String
                }
                if dict.keys.contains("enableMonitoring") {
                    self.enableMonitoring = dict["enableMonitoring"] as! Bool
                }
                if dict.keys.contains("groupId") {
                    self.groupId = dict["groupId"] as! String
                }
                if dict.keys.contains("host") {
                    self.host = dict["host"] as! String
                }
                if dict.keys.contains("hosts") {
                    self.hosts = dict["hosts"] as! [String]
                }
                if dict.keys.contains("instanceId") {
                    self.instanceId = dict["instanceId"] as! String
                }
                if dict.keys.contains("instanceType") {
                    self.instanceType = dict["instanceType"] as! String
                }
                if dict.keys.contains("kibanaHost") {
                    self.kibanaHost = dict["kibanaHost"] as! String
                }
                if dict.keys.contains("machines") {
                    var tmp : [UpdateCollectorNameResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in dict["machines"] as! [Any] {
                        var model = UpdateCollectorNameResponseBody.Result.ExtendConfigs.Machines()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.machines = tmp
                }
                if dict.keys.contains("protocol") {
                    self.protocol_ = dict["protocol"] as! String
                }
                if dict.keys.contains("successPodsCount") {
                    self.successPodsCount = dict["successPodsCount"] as! String
                }
                if dict.keys.contains("totalPodsCount") {
                    self.totalPodsCount = dict["totalPodsCount"] as! String
                }
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("userName") {
                    self.userName = dict["userName"] as! String
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [UpdateCollectorNameResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [UpdateCollectorNameResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("collectorPaths") {
                self.collectorPaths = dict["collectorPaths"] as! [String]
            }
            if dict.keys.contains("configs") {
                var tmp : [UpdateCollectorNameResponseBody.Result.Configs] = []
                for v in dict["configs"] as! [Any] {
                    var model = UpdateCollectorNameResponseBody.Result.Configs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.configs = tmp
            }
            if dict.keys.contains("dryRun") {
                self.dryRun = dict["dryRun"] as! Bool
            }
            if dict.keys.contains("extendConfigs") {
                var tmp : [UpdateCollectorNameResponseBody.Result.ExtendConfigs] = []
                for v in dict["extendConfigs"] as! [Any] {
                    var model = UpdateCollectorNameResponseBody.Result.ExtendConfigs()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.extendConfigs = tmp
            }
            if dict.keys.contains("gmtCreatedTime") {
                self.gmtCreatedTime = dict["gmtCreatedTime"] as! String
            }
            if dict.keys.contains("gmtUpdateTime") {
                self.gmtUpdateTime = dict["gmtUpdateTime"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("ownerId") {
                self.ownerId = dict["ownerId"] as! String
            }
            if dict.keys.contains("resId") {
                self.resId = dict["resId"] as! String
            }
            if dict.keys.contains("resType") {
                self.resType = dict["resType"] as! String
            }
            if dict.keys.contains("resVersion") {
                self.resVersion = dict["resVersion"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("vpcId") {
                self.vpcId = dict["vpcId"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: UpdateCollectorNameResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateCollectorNameResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateCollectorNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCollectorNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateCollectorNameResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateComponentIndexRequest : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var aliases: [String: Any]?

        public var mappings: [String: Any]?

        public var settings: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliases != nil {
                map["aliases"] = self.aliases!
            }
            if self.mappings != nil {
                map["mappings"] = self.mappings!
            }
            if self.settings != nil {
                map["settings"] = self.settings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("aliases") {
                self.aliases = dict["aliases"] as! [String: Any]
            }
            if dict.keys.contains("mappings") {
                self.mappings = dict["mappings"] as! [String: Any]
            }
            if dict.keys.contains("settings") {
                self.settings = dict["settings"] as! [String: Any]
            }
        }
    }
    public var meta: [String: Any]?

    public var template: UpdateComponentIndexRequest.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.meta != nil {
            map["_meta"] = self.meta!
        }
        if self.template != nil {
            map["template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("_meta") {
            self.meta = dict["_meta"] as! [String: Any]
        }
        if dict.keys.contains("template") {
            var model = UpdateComponentIndexRequest.Template()
            model.fromMap(dict["template"] as! [String: Any])
            self.template = model
        }
    }
}

public class UpdateComponentIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("requestId") {
            self.requestId = dict["requestId"] as! String
        }
    }
}

public class UpdateComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateComponentIndexResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateDescriptionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: UpdateDescriptionResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateDescriptionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDescriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDiagnosisSettingsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("lang") {
            self.lang = dict["lang"] as! String
        }
    }
}

public class UpdateDiagnosisSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateDiagnosisSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDiagnosisSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDiagnosisSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDictRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateDictResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateDictResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [UpdateDictResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = UpdateDictResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class UpdateDictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDictResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateDynamicSettingsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var body: String?

    public var mode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.mode != nil {
            map["mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("mode") {
            self.mode = dict["mode"] as! String
        }
    }
}

public class UpdateDynamicSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateDynamicSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDynamicSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateDynamicSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateExtendConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateExtendConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateExtendConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateExtendConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateExtendConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateExtendfilesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateExtendfilesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateExtendfilesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [UpdateExtendfilesResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = UpdateExtendfilesResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class UpdateExtendfilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateExtendfilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateExtendfilesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateHotIkDictsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateHotIkDictsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateHotIkDictsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [UpdateHotIkDictsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = UpdateHotIkDictsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class UpdateHotIkDictsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHotIkDictsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateHotIkDictsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateILMPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateILMPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateILMPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateIndexTemplateRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateIndexTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! String
        }
    }
}

public class UpdateIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateIndexTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateInstanceRequest : Tea.TeaModel {
    public var clientNodeConfiguration: ClientNodeConfiguration?

    public var elasticDataNodeConfiguration: ElasticDataNodeConfiguration?

    public var instanceCategory: String?

    public var kibanaConfiguration: KibanaNodeConfiguration?

    public var masterConfiguration: MasterNodeConfiguration?

    public var nodeAmount: Int32?

    public var nodeSpec: NodeSpec?

    public var warmNodeConfiguration: WarmNodeConfiguration?

    public var clientToken: String?

    public var force: Bool?

    public var orderActionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clientNodeConfiguration?.validate()
        try self.elasticDataNodeConfiguration?.validate()
        try self.kibanaConfiguration?.validate()
        try self.masterConfiguration?.validate()
        try self.nodeSpec?.validate()
        try self.warmNodeConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientNodeConfiguration != nil {
            map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
        }
        if self.elasticDataNodeConfiguration != nil {
            map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
        }
        if self.instanceCategory != nil {
            map["instanceCategory"] = self.instanceCategory!
        }
        if self.kibanaConfiguration != nil {
            map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
        }
        if self.masterConfiguration != nil {
            map["masterConfiguration"] = self.masterConfiguration?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.warmNodeConfiguration != nil {
            map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        if self.orderActionType != nil {
            map["orderActionType"] = self.orderActionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientNodeConfiguration") {
            var model = ClientNodeConfiguration()
            model.fromMap(dict["clientNodeConfiguration"] as! [String: Any])
            self.clientNodeConfiguration = model
        }
        if dict.keys.contains("elasticDataNodeConfiguration") {
            var model = ElasticDataNodeConfiguration()
            model.fromMap(dict["elasticDataNodeConfiguration"] as! [String: Any])
            self.elasticDataNodeConfiguration = model
        }
        if dict.keys.contains("instanceCategory") {
            self.instanceCategory = dict["instanceCategory"] as! String
        }
        if dict.keys.contains("kibanaConfiguration") {
            var model = KibanaNodeConfiguration()
            model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
            self.kibanaConfiguration = model
        }
        if dict.keys.contains("masterConfiguration") {
            var model = MasterNodeConfiguration()
            model.fromMap(dict["masterConfiguration"] as! [String: Any])
            self.masterConfiguration = model
        }
        if dict.keys.contains("nodeAmount") {
            self.nodeAmount = dict["nodeAmount"] as! Int32
        }
        if dict.keys.contains("nodeSpec") {
            var model = NodeSpec()
            model.fromMap(dict["nodeSpec"] as! [String: Any])
            self.nodeSpec = model
        }
        if dict.keys.contains("warmNodeConfiguration") {
            var model = WarmNodeConfiguration()
            model.fromMap(dict["warmNodeConfiguration"] as! [String: Any])
            self.warmNodeConfiguration = model
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("force") {
            self.force = dict["force"] as! Bool
        }
        if dict.keys.contains("orderActionType") {
            self.orderActionType = dict["orderActionType"] as! String
        }
    }
}

public class UpdateInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("amount") {
                    self.amount = dict["amount"] as! Int32
                }
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("disk") {
                    self.disk = dict["disk"] as! Int32
                }
                if dict.keys.contains("diskType") {
                    self.diskType = dict["diskType"] as! String
                }
                if dict.keys.contains("spec") {
                    self.spec = dict["spec"] as! String
                }
            }
        }
        public var createdAt: String?

        public var description_: String?

        public var domain: String?

        public var esVersion: String?

        public var instanceId: String?

        public var kibanaConfiguration: UpdateInstanceResponseBody.Result.KibanaConfiguration?

        public var masterConfiguration: UpdateInstanceResponseBody.Result.MasterConfiguration?

        public var nodeAmount: Int32?

        public var nodeSpec: UpdateInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("createdAt") {
                self.createdAt = dict["createdAt"] as! String
            }
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
            if dict.keys.contains("domain") {
                self.domain = dict["domain"] as! String
            }
            if dict.keys.contains("esVersion") {
                self.esVersion = dict["esVersion"] as! String
            }
            if dict.keys.contains("instanceId") {
                self.instanceId = dict["instanceId"] as! String
            }
            if dict.keys.contains("kibanaConfiguration") {
                var model = UpdateInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
                self.kibanaConfiguration = model
            }
            if dict.keys.contains("masterConfiguration") {
                var model = UpdateInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(dict["masterConfiguration"] as! [String: Any])
                self.masterConfiguration = model
            }
            if dict.keys.contains("nodeAmount") {
                self.nodeAmount = dict["nodeAmount"] as! Int32
            }
            if dict.keys.contains("nodeSpec") {
                var model = UpdateInstanceResponseBody.Result.NodeSpec()
                model.fromMap(dict["nodeSpec"] as! [String: Any])
                self.nodeSpec = model
            }
            if dict.keys.contains("paymentType") {
                self.paymentType = dict["paymentType"] as! String
            }
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: UpdateInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateInstanceResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateInstanceChargeTypeRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateInstanceChargeTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateInstanceChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateInstanceChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateInstanceSettingsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateInstanceSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateInstanceSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateInstanceSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateKibanaPvlNetworkRequest : Tea.TeaModel {
    public var endpointName: String?

    public var securityGroups: [String]?

    public var pvlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointName != nil {
            map["endpointName"] = self.endpointName!
        }
        if self.securityGroups != nil {
            map["securityGroups"] = self.securityGroups!
        }
        if self.pvlId != nil {
            map["pvlId"] = self.pvlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endpointName") {
            self.endpointName = dict["endpointName"] as! String
        }
        if dict.keys.contains("securityGroups") {
            self.securityGroups = dict["securityGroups"] as! [String]
        }
        if dict.keys.contains("pvlId") {
            self.pvlId = dict["pvlId"] as! String
        }
    }
}

public class UpdateKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateKibanaPvlNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateKibanaSettingsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateKibanaSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateKibanaSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateKibanaSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateKibanaSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateKibanaWhiteIpsRequest : Tea.TeaModel {
    public class WhiteIpGroup : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var whiteIpType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.ips != nil {
                map["ips"] = self.ips!
            }
            if self.whiteIpType != nil {
                map["whiteIpType"] = self.whiteIpType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("groupName") {
                self.groupName = dict["groupName"] as! String
            }
            if dict.keys.contains("ips") {
                self.ips = dict["ips"] as! [String]
            }
            if dict.keys.contains("whiteIpType") {
                self.whiteIpType = dict["whiteIpType"] as! String
            }
        }
    }
    public var kibanaIPWhitelist: [String]?

    public var whiteIpGroup: UpdateKibanaWhiteIpsRequest.WhiteIpGroup?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.whiteIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.kibanaIPWhitelist != nil {
            map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
        }
        if self.whiteIpGroup != nil {
            map["whiteIpGroup"] = self.whiteIpGroup?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("kibanaIPWhitelist") {
            self.kibanaIPWhitelist = dict["kibanaIPWhitelist"] as! [String]
        }
        if dict.keys.contains("whiteIpGroup") {
            var model = UpdateKibanaWhiteIpsRequest.WhiteIpGroup()
            model.fromMap(dict["whiteIpGroup"] as! [String: Any])
            self.whiteIpGroup = model
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("modifyMode") {
            self.modifyMode = dict["modifyMode"] as! String
        }
    }
}

public class UpdateKibanaWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("groupName") {
                        self.groupName = dict["groupName"] as! String
                    }
                    if dict.keys.contains("ips") {
                        self.ips = dict["ips"] as! [String]
                    }
                    if dict.keys.contains("whiteIpType") {
                        self.whiteIpType = dict["whiteIpType"] as! String
                    }
                }
            }
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public var whiteIpGroupList: [UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("type") {
                    self.type = dict["type"] as! String
                }
                if dict.keys.contains("vpcId") {
                    self.vpcId = dict["vpcId"] as! String
                }
                if dict.keys.contains("vsArea") {
                    self.vsArea = dict["vsArea"] as! String
                }
                if dict.keys.contains("vswitchId") {
                    self.vswitchId = dict["vswitchId"] as! String
                }
                if dict.keys.contains("whiteIpGroupList") {
                    var tmp : [UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in dict["whiteIpGroupList"] as! [Any] {
                        var model = UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public var kibanaIPWhitelist: [String]?

        public var kibanaPrivateIPWhitelist: [String]?

        public var networkConfig: UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.kibanaIPWhitelist != nil {
                map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
            }
            if self.kibanaPrivateIPWhitelist != nil {
                map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("kibanaIPWhitelist") {
                self.kibanaIPWhitelist = dict["kibanaIPWhitelist"] as! [String]
            }
            if dict.keys.contains("kibanaPrivateIPWhitelist") {
                self.kibanaPrivateIPWhitelist = dict["kibanaPrivateIPWhitelist"] as! [String]
            }
            if dict.keys.contains("networkConfig") {
                var model = UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
        }
    }
    public var requestId: String?

    public var result: UpdateKibanaWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateKibanaWhiteIpsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateKibanaWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateKibanaWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateKibanaWhiteIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLogstashRequest : Tea.TeaModel {
    public class NodeSpec : Tea.TeaModel {
        public var disk: Int32?

        public var diskType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                map["disk"] = self.disk!
            }
            if self.diskType != nil {
                map["diskType"] = self.diskType!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("disk") {
                self.disk = dict["disk"] as! Int32
            }
            if dict.keys.contains("diskType") {
                self.diskType = dict["diskType"] as! String
            }
            if dict.keys.contains("spec") {
                self.spec = dict["spec"] as! String
            }
        }
    }
    public var nodeAmount: Int32?

    public var nodeSpec: UpdateLogstashRequest.NodeSpec?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSpec?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("nodeAmount") {
            self.nodeAmount = dict["nodeAmount"] as! Int32
        }
        if dict.keys.contains("nodeSpec") {
            var model = UpdateLogstashRequest.NodeSpec()
            model.fromMap(dict["nodeSpec"] as! [String: Any])
            self.nodeSpec = model
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLogstashResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLogstashChargeTypeRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateLogstashChargeTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateLogstashChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLogstashChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLogstashDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateLogstashDescriptionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("description") {
                self.description_ = dict["description"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: UpdateLogstashDescriptionResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateLogstashDescriptionResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateLogstashDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLogstashDescriptionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateLogstashSettingsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateLogstashSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UpdateLogstashSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateLogstashSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelineManagementConfigRequest : Tea.TeaModel {
    public var endpoints: [String]?

    public var esInstanceId: String?

    public var password: String?

    public var pipelineIds: [String]?

    public var pipelineManagementType: String?

    public var userName: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoints != nil {
            map["endpoints"] = self.endpoints!
        }
        if self.esInstanceId != nil {
            map["esInstanceId"] = self.esInstanceId!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.pipelineIds != nil {
            map["pipelineIds"] = self.pipelineIds!
        }
        if self.pipelineManagementType != nil {
            map["pipelineManagementType"] = self.pipelineManagementType!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("endpoints") {
            self.endpoints = dict["endpoints"] as! [String]
        }
        if dict.keys.contains("esInstanceId") {
            self.esInstanceId = dict["esInstanceId"] as! String
        }
        if dict.keys.contains("password") {
            self.password = dict["password"] as! String
        }
        if dict.keys.contains("pipelineIds") {
            self.pipelineIds = dict["pipelineIds"] as! [String]
        }
        if dict.keys.contains("pipelineManagementType") {
            self.pipelineManagementType = dict["pipelineManagementType"] as! String
        }
        if dict.keys.contains("userName") {
            self.userName = dict["userName"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdatePipelineManagementConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdatePipelineManagementConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineManagementConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelineManagementConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePipelinesRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var trigger: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("trigger") {
            self.trigger = dict["trigger"] as! Bool
        }
    }
}

public class UpdatePipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdatePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePrivateNetworkWhiteIpsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("modifyMode") {
            self.modifyMode = dict["modifyMode"] as! String
        }
    }
}

public class UpdatePrivateNetworkWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var privateNetworkIpWhiteList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateNetworkIpWhiteList != nil {
                map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("privateNetworkIpWhiteList") {
                self.privateNetworkIpWhiteList = dict["privateNetworkIpWhiteList"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var result: UpdatePrivateNetworkWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdatePrivateNetworkWhiteIpsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdatePrivateNetworkWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrivateNetworkWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePrivateNetworkWhiteIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePublicNetworkRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdatePublicNetworkResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enablePublic: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enablePublic != nil {
                map["enablePublic"] = self.enablePublic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enablePublic") {
                self.enablePublic = dict["enablePublic"] as! Bool
            }
        }
    }
    public var requestId: String?

    public var result: UpdatePublicNetworkResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdatePublicNetworkResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdatePublicNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePublicNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePublicNetworkResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdatePublicWhiteIpsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("modifyMode") {
            self.modifyMode = dict["modifyMode"] as! String
        }
    }
}

public class UpdatePublicWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var publicIpWhitelist: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.publicIpWhitelist != nil {
                map["publicIpWhitelist"] = self.publicIpWhitelist!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("publicIpWhitelist") {
                self.publicIpWhitelist = dict["publicIpWhitelist"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var result: UpdatePublicWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdatePublicWhiteIpsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdatePublicWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePublicWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdatePublicWhiteIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateReadWritePolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateReadWritePolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateReadWritePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateReadWritePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateReadWritePolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSnapshotSettingRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateSnapshotSettingResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var quartzRegex: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.quartzRegex != nil {
                map["quartzRegex"] = self.quartzRegex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enable") {
                self.enable = dict["enable"] as! Bool
            }
            if dict.keys.contains("quartzRegex") {
                self.quartzRegex = dict["quartzRegex"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: UpdateSnapshotSettingResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateSnapshotSettingResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateSnapshotSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSnapshotSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSnapshotSettingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateSynonymsDictsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class UpdateSynonymsDictsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("fileSize") {
                self.fileSize = dict["fileSize"] as! Int64
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("sourceType") {
                self.sourceType = dict["sourceType"] as! String
            }
            if dict.keys.contains("type") {
                self.type = dict["type"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateSynonymsDictsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [UpdateSynonymsDictsResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = UpdateSynonymsDictsResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class UpdateSynonymsDictsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSynonymsDictsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateSynonymsDictsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateWhiteIpsRequest : Tea.TeaModel {
    public class WhiteIpGroup : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var whiteIpType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.ips != nil {
                map["ips"] = self.ips!
            }
            if self.whiteIpType != nil {
                map["whiteIpType"] = self.whiteIpType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("groupName") {
                self.groupName = dict["groupName"] as! String
            }
            if dict.keys.contains("ips") {
                self.ips = dict["ips"] as! [String]
            }
            if dict.keys.contains("whiteIpType") {
                self.whiteIpType = dict["whiteIpType"] as! String
            }
        }
    }
    public var esIPWhitelist: [String]?

    public var whiteIpGroup: UpdateWhiteIpsRequest.WhiteIpGroup?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.whiteIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esIPWhitelist != nil {
            map["esIPWhitelist"] = self.esIPWhitelist!
        }
        if self.whiteIpGroup != nil {
            map["whiteIpGroup"] = self.whiteIpGroup?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("esIPWhitelist") {
            self.esIPWhitelist = dict["esIPWhitelist"] as! [String]
        }
        if dict.keys.contains("whiteIpGroup") {
            var model = UpdateWhiteIpsRequest.WhiteIpGroup()
            model.fromMap(dict["whiteIpGroup"] as! [String: Any])
            self.whiteIpGroup = model
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("modifyMode") {
            self.modifyMode = dict["modifyMode"] as! String
        }
    }
}

public class UpdateWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("groupName") {
                        self.groupName = dict["groupName"] as! String
                    }
                    if dict.keys.contains("ips") {
                        self.ips = dict["ips"] as! [String]
                    }
                    if dict.keys.contains("whiteIpType") {
                        self.whiteIpType = dict["whiteIpType"] as! String
                    }
                }
            }
            public var whiteIpGroupList: [UpdateWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("whiteIpGroupList") {
                    var tmp : [UpdateWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in dict["whiteIpGroupList"] as! [Any] {
                        var model = UpdateWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public var esIPWhitelist: [String]?

        public var networkConfig: UpdateWhiteIpsResponseBody.Result.NetworkConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.esIPWhitelist != nil {
                map["esIPWhitelist"] = self.esIPWhitelist!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("esIPWhitelist") {
                self.esIPWhitelist = dict["esIPWhitelist"] as! [String]
            }
            if dict.keys.contains("networkConfig") {
                var model = UpdateWhiteIpsResponseBody.Result.NetworkConfig()
                model.fromMap(dict["networkConfig"] as! [String: Any])
                self.networkConfig = model
            }
        }
    }
    public var requestId: String?

    public var result: UpdateWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var model = UpdateWhiteIpsResponseBody.Result()
            model.fromMap(dict["Result"] as! [String: Any])
            self.result = model
        }
    }
}

public class UpdateWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateWhiteIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpdateXpackMonitorConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var enable: Bool?

    public var endpoints: [String]?

    public var password: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enable != nil {
            map["enable"] = self.enable!
        }
        if self.endpoints != nil {
            map["endpoints"] = self.endpoints!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("enable") {
            self.enable = dict["enable"] as! Bool
        }
        if dict.keys.contains("endpoints") {
            self.endpoints = dict["endpoints"] as! [String]
        }
        if dict.keys.contains("password") {
            self.password = dict["password"] as! String
        }
        if dict.keys.contains("userName") {
            self.userName = dict["userName"] as! String
        }
    }
}

public class UpdateXpackMonitorConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class UpdateXpackMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateXpackMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpdateXpackMonitorConfigResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UpgradeEngineVersionRequest : Tea.TeaModel {
    public class Plugins : Tea.TeaModel {
        public var enable: String?

        public var fileVersion: String?

        public var name: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.fileVersion != nil {
                map["fileVersion"] = self.fileVersion!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("enable") {
                self.enable = dict["enable"] as! String
            }
            if dict.keys.contains("fileVersion") {
                self.fileVersion = dict["fileVersion"] as! String
            }
            if dict.keys.contains("name") {
                self.name = dict["name"] as! String
            }
            if dict.keys.contains("version") {
                self.version = dict["version"] as! String
            }
        }
    }
    public var plugins: [UpgradeEngineVersionRequest.Plugins]?

    public var type: String?

    public var version: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.plugins != nil {
            var tmp : [Any] = []
            for k in self.plugins! {
                tmp.append(k.toMap())
            }
            map["plugins"] = tmp
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("plugins") {
            var tmp : [UpgradeEngineVersionRequest.Plugins] = []
            for v in dict["plugins"] as! [Any] {
                var model = UpgradeEngineVersionRequest.Plugins()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.plugins = tmp
        }
        if dict.keys.contains("type") {
            self.type = dict["type"] as! String
        }
        if dict.keys.contains("version") {
            self.version = dict["version"] as! String
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
        if dict.keys.contains("dryRun") {
            self.dryRun = dict["dryRun"] as! Bool
        }
    }
}

public class UpgradeEngineVersionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ValidateResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMsg: String?

            public var errorType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["errorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["errorMsg"] = self.errorMsg!
                }
                if self.errorType != nil {
                    map["errorType"] = self.errorType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("errorCode") {
                    self.errorCode = dict["errorCode"] as! String
                }
                if dict.keys.contains("errorMsg") {
                    self.errorMsg = dict["errorMsg"] as! String
                }
                if dict.keys.contains("errorType") {
                    self.errorType = dict["errorType"] as! String
                }
            }
        }
        public var status: String?

        public var validateResult: [UpgradeEngineVersionResponseBody.Result.ValidateResult]?

        public var validateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.validateResult != nil {
                var tmp : [Any] = []
                for k in self.validateResult! {
                    tmp.append(k.toMap())
                }
                map["validateResult"] = tmp
            }
            if self.validateType != nil {
                map["validateType"] = self.validateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("status") {
                self.status = dict["status"] as! String
            }
            if dict.keys.contains("validateResult") {
                var tmp : [UpgradeEngineVersionResponseBody.Result.ValidateResult] = []
                for v in dict["validateResult"] as! [Any] {
                    var model = UpgradeEngineVersionResponseBody.Result.ValidateResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.validateResult = tmp
            }
            if dict.keys.contains("validateType") {
                self.validateType = dict["validateType"] as! String
            }
        }
    }
    public var requestId: String?

    public var result: [UpgradeEngineVersionResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            var tmp : [UpgradeEngineVersionResponseBody.Result] = []
            for v in dict["Result"] as! [Any] {
                var model = UpgradeEngineVersionResponseBody.Result()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.result = tmp
        }
    }
}

public class UpgradeEngineVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeEngineVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UpgradeEngineVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("body") {
            self.body = dict["body"] as! String
        }
    }
}

public class ValidateConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ValidateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidateConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateShrinkNodesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var hostName: String?

        public var nodeType: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.hostName != nil {
                map["hostName"] = self.hostName!
            }
            if self.nodeType != nil {
                map["nodeType"] = self.nodeType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("hostName") {
                self.hostName = dict["hostName"] as! String
            }
            if dict.keys.contains("nodeType") {
                self.nodeType = dict["nodeType"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public var body: [ValidateShrinkNodesRequest.Body]?

    public var count: Int32?

    public var ignoreStatus: Bool?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.ignoreStatus != nil {
            map["ignoreStatus"] = self.ignoreStatus!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            var tmp : [ValidateShrinkNodesRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = ValidateShrinkNodesRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
        if dict.keys.contains("count") {
            self.count = dict["count"] as! Int32
        }
        if dict.keys.contains("ignoreStatus") {
            self.ignoreStatus = dict["ignoreStatus"] as! Bool
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
    }
}

public class ValidateShrinkNodesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ValidateShrinkNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateShrinkNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidateShrinkNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateSlrPermissionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var rolename: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.rolename != nil {
            map["rolename"] = self.rolename!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("rolename") {
            self.rolename = dict["rolename"] as! String
        }
    }
}

public class ValidateSlrPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ValidateSlrPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateSlrPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidateSlrPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ValidateTransferableNodesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("host") {
                self.host = dict["host"] as! String
            }
            if dict.keys.contains("port") {
                self.port = dict["port"] as! Int32
            }
            if dict.keys.contains("zoneId") {
                self.zoneId = dict["zoneId"] as! String
            }
        }
    }
    public var body: [ValidateTransferableNodesRequest.Body]?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("body") {
            var tmp : [ValidateTransferableNodesRequest.Body] = []
            for v in dict["body"] as! [Any] {
                var model = ValidateTransferableNodesRequest.Body()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.body = tmp
        }
        if dict.keys.contains("nodeType") {
            self.nodeType = dict["nodeType"] as! String
        }
    }
}

public class ValidateTransferableNodesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Result") {
            self.result = dict["Result"] as! Bool
        }
    }
}

public class ValidateTransferableNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateTransferableNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ValidateTransferableNodesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["tagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["tagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("tagKey") {
                self.tagKey = dict["tagKey"] as! String
            }
            if dict.keys.contains("tagValue") {
                self.tagValue = dict["tagValue"] as! String
            }
        }
    }
    public var clientNodeConfiguration: ClientNodeConfiguration?

    public var description_: String?

    public var elasticDataNodeConfiguration: ElasticDataNodeConfiguration?

    public var esAdminPassword: String?

    public var esVersion: String?

    public var instanceCategory: String?

    public var kibanaConfiguration: KibanaNodeConfiguration?

    public var masterConfiguration: MasterNodeConfiguration?

    public var networkConfig: NetworkConfig?

    public var nodeAmount: Int32?

    public var nodeSpec: NodeSpec?

    public var paymentInfo: PaymentInfo?

    public var paymentType: String?

    public var resourceGroupId: String?

    public var tags: [CreateInstanceRequest.Tags]?

    public var warmNodeConfiguration: WarmNodeConfiguration?

    public var zoneCount: Int32?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clientNodeConfiguration?.validate()
        try self.elasticDataNodeConfiguration?.validate()
        try self.kibanaConfiguration?.validate()
        try self.masterConfiguration?.validate()
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
        try self.paymentInfo?.validate()
        try self.warmNodeConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientNodeConfiguration != nil {
            map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.elasticDataNodeConfiguration != nil {
            map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
        }
        if self.esAdminPassword != nil {
            map["esAdminPassword"] = self.esAdminPassword!
        }
        if self.esVersion != nil {
            map["esVersion"] = self.esVersion!
        }
        if self.instanceCategory != nil {
            map["instanceCategory"] = self.instanceCategory!
        }
        if self.kibanaConfiguration != nil {
            map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
        }
        if self.masterConfiguration != nil {
            map["masterConfiguration"] = self.masterConfiguration?.toMap()
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentInfo != nil {
            map["paymentInfo"] = self.paymentInfo?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.warmNodeConfiguration != nil {
            map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
        }
        if self.zoneCount != nil {
            map["zoneCount"] = self.zoneCount!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("clientNodeConfiguration") {
            var model = ClientNodeConfiguration()
            model.fromMap(dict["clientNodeConfiguration"] as! [String: Any])
            self.clientNodeConfiguration = model
        }
        if dict.keys.contains("description") {
            self.description_ = dict["description"] as! String
        }
        if dict.keys.contains("elasticDataNodeConfiguration") {
            var model = ElasticDataNodeConfiguration()
            model.fromMap(dict["elasticDataNodeConfiguration"] as! [String: Any])
            self.elasticDataNodeConfiguration = model
        }
        if dict.keys.contains("esAdminPassword") {
            self.esAdminPassword = dict["esAdminPassword"] as! String
        }
        if dict.keys.contains("esVersion") {
            self.esVersion = dict["esVersion"] as! String
        }
        if dict.keys.contains("instanceCategory") {
            self.instanceCategory = dict["instanceCategory"] as! String
        }
        if dict.keys.contains("kibanaConfiguration") {
            var model = KibanaNodeConfiguration()
            model.fromMap(dict["kibanaConfiguration"] as! [String: Any])
            self.kibanaConfiguration = model
        }
        if dict.keys.contains("masterConfiguration") {
            var model = MasterNodeConfiguration()
            model.fromMap(dict["masterConfiguration"] as! [String: Any])
            self.masterConfiguration = model
        }
        if dict.keys.contains("networkConfig") {
            var model = NetworkConfig()
            model.fromMap(dict["networkConfig"] as! [String: Any])
            self.networkConfig = model
        }
        if dict.keys.contains("nodeAmount") {
            self.nodeAmount = dict["nodeAmount"] as! Int32
        }
        if dict.keys.contains("nodeSpec") {
            var model = NodeSpec()
            model.fromMap(dict["nodeSpec"] as! [String: Any])
            self.nodeSpec = model
        }
        if dict.keys.contains("paymentInfo") {
            var model = PaymentInfo()
            model.fromMap(dict["paymentInfo"] as! [String: Any])
            self.paymentInfo = model
        }
        if dict.keys.contains("paymentType") {
            self.paymentType = dict["paymentType"] as! String
        }
        if dict.keys.contains("resourceGroupId") {
            self.resourceGroupId = dict["resourceGroupId"] as! String
        }
        if dict.keys.contains("tags") {
            var tmp : [CreateInstanceRequest.Tags] = []
            for v in dict["tags"] as! [Any] {
                var model = CreateInstanceRequest.Tags()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tags = tmp
        }
        if dict.keys.contains("warmNodeConfiguration") {
            var model = WarmNodeConfiguration()
            model.fromMap(dict["warmNodeConfiguration"] as! [String: Any])
            self.warmNodeConfiguration = model
        }
        if dict.keys.contains("zoneCount") {
            self.zoneCount = dict["zoneCount"] as! Int32
        }
        if dict.keys.contains("clientToken") {
            self.clientToken = dict["clientToken"] as! String
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
    }
}
