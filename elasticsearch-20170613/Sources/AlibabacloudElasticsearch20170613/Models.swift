import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class ClientNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskType: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["amount"] as? Int64 {
            self.amount = value
        }
        if let value = dict["disk"] as? Int64 {
            self.disk = value
        }
        if let value = dict["diskType"] as? String {
            self.diskType = value
        }
        if let value = dict["spec"] as? String {
            self.spec = value
        }
    }
}

public class CollectorDeployMachine : Tea.TeaModel {
    public class Machines : Tea.TeaModel {
        public var agentStatus: String?

        public var instanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentStatus != nil {
                map["agentStatus"] = self.agentStatus!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["agentStatus"] as? String {
                self.agentStatus = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
        }
    }
    public var configType: String?

    public var groupId: String?

    public var instanceId: String?

    public var machines: [CollectorDeployMachine.Machines]?

    public var successPodsCount: String?

    public var totalPodsCount: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configType != nil {
            map["configType"] = self.configType!
        }
        if self.groupId != nil {
            map["groupId"] = self.groupId!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.machines != nil {
            var tmp : [Any] = []
            for k in self.machines! {
                tmp.append(k.toMap())
            }
            map["machines"] = tmp
        }
        if self.successPodsCount != nil {
            map["successPodsCount"] = self.successPodsCount!
        }
        if self.totalPodsCount != nil {
            map["totalPodsCount"] = self.totalPodsCount!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["configType"] as? String {
            self.configType = value
        }
        if let value = dict["groupId"] as? String {
            self.groupId = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["machines"] as? [Any?] {
            var tmp : [CollectorDeployMachine.Machines] = []
            for v in value {
                if v != nil {
                    var model = CollectorDeployMachine.Machines()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.machines = tmp
        }
        if let value = dict["successPodsCount"] as? String {
            self.successPodsCount = value
        }
        if let value = dict["totalPodsCount"] as? String {
            self.totalPodsCount = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class CollectorKibanaInstance : Tea.TeaModel {
    public var configType: String?

    public var host: String?

    public var instanceId: String?

    public var kibanaHost: String?

    public var password: String?

    public var protocol_: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configType != nil {
            map["configType"] = self.configType!
        }
        if self.host != nil {
            map["host"] = self.host!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.kibanaHost != nil {
            map["kibanaHost"] = self.kibanaHost!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["configType"] as? String {
            self.configType = value
        }
        if let value = dict["host"] as? String {
            self.host = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["kibanaHost"] as? String {
            self.kibanaHost = value
        }
        if let value = dict["password"] as? String {
            self.password = value
        }
        if let value = dict["protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["userName"] as? String {
            self.userName = value
        }
    }
}

public class CollectorTargetInstance : Tea.TeaModel {
    public var configType: String?

    public var enableMonitoring: Bool?

    public var hosts: [String]?

    public var instanceId: String?

    public var instanceType: String?

    public var password: String?

    public var protocol_: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configType != nil {
            map["configType"] = self.configType!
        }
        if self.enableMonitoring != nil {
            map["enableMonitoring"] = self.enableMonitoring!
        }
        if self.hosts != nil {
            map["hosts"] = self.hosts!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["instanceType"] = self.instanceType!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["configType"] as? String {
            self.configType = value
        }
        if let value = dict["enableMonitoring"] as? Bool {
            self.enableMonitoring = value
        }
        if let value = dict["hosts"] as? [String] {
            self.hosts = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["instanceType"] as? String {
            self.instanceType = value
        }
        if let value = dict["password"] as? String {
            self.password = value
        }
        if let value = dict["protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["userName"] as? String {
            self.userName = value
        }
    }
}

public class DictInfo : Tea.TeaModel {
    public var fileSize: Int64?

    public var name: String?

    public var sourceType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.fileSize != nil {
            map["fileSize"] = self.fileSize!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["fileSize"] as? Int64 {
            self.fileSize = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["sourceType"] as? String {
            self.sourceType = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class ElasticDataNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskEncryption: Bool?

    public var diskType: String?

    public var performanceLevel: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskEncryption != nil {
            map["diskEncryption"] = self.diskEncryption!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.performanceLevel != nil {
            map["performanceLevel"] = self.performanceLevel!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["amount"] as? Int64 {
            self.amount = value
        }
        if let value = dict["disk"] as? Int64 {
            self.disk = value
        }
        if let value = dict["diskEncryption"] as? Bool {
            self.diskEncryption = value
        }
        if let value = dict["diskType"] as? String {
            self.diskType = value
        }
        if let value = dict["performanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["spec"] as? String {
            self.spec = value
        }
    }
}

public class Elasticsearch : Tea.TeaModel {
    public class AdvancedSetting : Tea.TeaModel {
        public var gcName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gcName != nil {
                map["gcName"] = self.gcName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gcName"] as? String {
                self.gcName = value
            }
        }
    }
    public var advancedDedicateMaster: Bool?

    public var advancedSetting: Elasticsearch.AdvancedSetting?

    public var aliwsDicts: [DictInfo]?

    public var clientNodeConfiguration: ClientNodeConfiguration?

    public var createdAt: String?

    public var dataNode: Bool?

    public var dedicateMaster: Bool?

    public var description_: String?

    public var dictList: [DictInfo]?

    public var domain: String?

    public var elasticDataNodeConfiguration: ElasticDataNodeConfiguration?

    public var enableKibanaPrivateNetwork: Bool?

    public var enableKibanaPublicNetwork: Bool?

    public var enablePublic: Bool?

    public var endTime: Int64?

    public var esConfig: [String: String]?

    public var esIPWhitelist: [String]?

    public var esVersion: String?

    public var extendConfigs: [[String: Any]]?

    public var haveClientNode: Bool?

    public var haveElasticDataNode: Bool?

    public var haveKibana: Bool?

    public var ikHotDicts: [DictInfo]?

    public var instanceId: String?

    public var kibanaConfiguration: KibanaNodeConfiguration?

    public var kibanaDomain: String?

    public var kibanaIPWhitelist: [String]?

    public var kibanaPort: Int64?

    public var kibanaPrivateDomain: String?

    public var kibanaPrivateIPWhitelist: [String]?

    public var kibanaPrivatePort: Int64?

    public var kibanaProtocol: String?

    public var masterConfiguration: MasterNodeConfiguration?

    public var networkConfig: NetworkConfig?

    public var nodeAmount: Int64?

    public var nodeSpec: NodeSpec?

    public var paymentType: String?

    public var port: Int64?

    public var privateNetworkIpWhiteList: [String]?

    public var productType: String?

    public var protocol_: String?

    public var publicDomain: String?

    public var publicIpWhitelist: [String]?

    public var publicPort: Int64?

    public var readWritePolicy: ReadWritePolicy?

    public var resourceGroupId: String?

    public var serviceVpc: Bool?

    public var status: String?

    public var synonymsDicts: [DictInfo]?

    public var tags: [Tag]?

    public var updatedAt: String?

    public var warmNode: Bool?

    public var warmNodeConfiguration: WarmNodeConfiguration?

    public var zoneCount: Int64?

    public var zoneInfos: [ZoneInfo]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.advancedSetting?.validate()
        try self.clientNodeConfiguration?.validate()
        try self.elasticDataNodeConfiguration?.validate()
        try self.kibanaConfiguration?.validate()
        try self.masterConfiguration?.validate()
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
        try self.readWritePolicy?.validate()
        try self.warmNodeConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedDedicateMaster != nil {
            map["advancedDedicateMaster"] = self.advancedDedicateMaster!
        }
        if self.advancedSetting != nil {
            map["advancedSetting"] = self.advancedSetting?.toMap()
        }
        if self.aliwsDicts != nil {
            var tmp : [Any] = []
            for k in self.aliwsDicts! {
                tmp.append(k.toMap())
            }
            map["aliwsDicts"] = tmp
        }
        if self.clientNodeConfiguration != nil {
            map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
        }
        if self.createdAt != nil {
            map["createdAt"] = self.createdAt!
        }
        if self.dataNode != nil {
            map["dataNode"] = self.dataNode!
        }
        if self.dedicateMaster != nil {
            map["dedicateMaster"] = self.dedicateMaster!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.dictList != nil {
            var tmp : [Any] = []
            for k in self.dictList! {
                tmp.append(k.toMap())
            }
            map["dictList"] = tmp
        }
        if self.domain != nil {
            map["domain"] = self.domain!
        }
        if self.elasticDataNodeConfiguration != nil {
            map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
        }
        if self.enableKibanaPrivateNetwork != nil {
            map["enableKibanaPrivateNetwork"] = self.enableKibanaPrivateNetwork!
        }
        if self.enableKibanaPublicNetwork != nil {
            map["enableKibanaPublicNetwork"] = self.enableKibanaPublicNetwork!
        }
        if self.enablePublic != nil {
            map["enablePublic"] = self.enablePublic!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.esConfig != nil {
            map["esConfig"] = self.esConfig!
        }
        if self.esIPWhitelist != nil {
            map["esIPWhitelist"] = self.esIPWhitelist!
        }
        if self.esVersion != nil {
            map["esVersion"] = self.esVersion!
        }
        if self.extendConfigs != nil {
            map["extendConfigs"] = self.extendConfigs!
        }
        if self.haveClientNode != nil {
            map["haveClientNode"] = self.haveClientNode!
        }
        if self.haveElasticDataNode != nil {
            map["haveElasticDataNode"] = self.haveElasticDataNode!
        }
        if self.haveKibana != nil {
            map["haveKibana"] = self.haveKibana!
        }
        if self.ikHotDicts != nil {
            var tmp : [Any] = []
            for k in self.ikHotDicts! {
                tmp.append(k.toMap())
            }
            map["ikHotDicts"] = tmp
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.kibanaConfiguration != nil {
            map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
        }
        if self.kibanaDomain != nil {
            map["kibanaDomain"] = self.kibanaDomain!
        }
        if self.kibanaIPWhitelist != nil {
            map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
        }
        if self.kibanaPort != nil {
            map["kibanaPort"] = self.kibanaPort!
        }
        if self.kibanaPrivateDomain != nil {
            map["kibanaPrivateDomain"] = self.kibanaPrivateDomain!
        }
        if self.kibanaPrivateIPWhitelist != nil {
            map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
        }
        if self.kibanaPrivatePort != nil {
            map["kibanaPrivatePort"] = self.kibanaPrivatePort!
        }
        if self.kibanaProtocol != nil {
            map["kibanaProtocol"] = self.kibanaProtocol!
        }
        if self.masterConfiguration != nil {
            map["masterConfiguration"] = self.masterConfiguration?.toMap()
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.port != nil {
            map["port"] = self.port!
        }
        if self.privateNetworkIpWhiteList != nil {
            map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
        }
        if self.productType != nil {
            map["productType"] = self.productType!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.publicDomain != nil {
            map["publicDomain"] = self.publicDomain!
        }
        if self.publicIpWhitelist != nil {
            map["publicIpWhitelist"] = self.publicIpWhitelist!
        }
        if self.publicPort != nil {
            map["publicPort"] = self.publicPort!
        }
        if self.readWritePolicy != nil {
            map["readWritePolicy"] = self.readWritePolicy?.toMap()
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.serviceVpc != nil {
            map["serviceVpc"] = self.serviceVpc!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.synonymsDicts != nil {
            var tmp : [Any] = []
            for k in self.synonymsDicts! {
                tmp.append(k.toMap())
            }
            map["synonymsDicts"] = tmp
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.updatedAt != nil {
            map["updatedAt"] = self.updatedAt!
        }
        if self.warmNode != nil {
            map["warmNode"] = self.warmNode!
        }
        if self.warmNodeConfiguration != nil {
            map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
        }
        if self.zoneCount != nil {
            map["zoneCount"] = self.zoneCount!
        }
        if self.zoneInfos != nil {
            var tmp : [Any] = []
            for k in self.zoneInfos! {
                tmp.append(k.toMap())
            }
            map["zoneInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["advancedDedicateMaster"] as? Bool {
            self.advancedDedicateMaster = value
        }
        if let value = dict["advancedSetting"] as? [String: Any?] {
            var model = Elasticsearch.AdvancedSetting()
            model.fromMap(value)
            self.advancedSetting = model
        }
        if let value = dict["aliwsDicts"] as? [Any?] {
            var tmp : [DictInfo] = []
            for v in value {
                if v != nil {
                    var model = DictInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.aliwsDicts = tmp
        }
        if let value = dict["clientNodeConfiguration"] as? [String: Any?] {
            var model = ClientNodeConfiguration()
            model.fromMap(value)
            self.clientNodeConfiguration = model
        }
        if let value = dict["createdAt"] as? String {
            self.createdAt = value
        }
        if let value = dict["dataNode"] as? Bool {
            self.dataNode = value
        }
        if let value = dict["dedicateMaster"] as? Bool {
            self.dedicateMaster = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["dictList"] as? [Any?] {
            var tmp : [DictInfo] = []
            for v in value {
                if v != nil {
                    var model = DictInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dictList = tmp
        }
        if let value = dict["domain"] as? String {
            self.domain = value
        }
        if let value = dict["elasticDataNodeConfiguration"] as? [String: Any?] {
            var model = ElasticDataNodeConfiguration()
            model.fromMap(value)
            self.elasticDataNodeConfiguration = model
        }
        if let value = dict["enableKibanaPrivateNetwork"] as? Bool {
            self.enableKibanaPrivateNetwork = value
        }
        if let value = dict["enableKibanaPublicNetwork"] as? Bool {
            self.enableKibanaPublicNetwork = value
        }
        if let value = dict["enablePublic"] as? Bool {
            self.enablePublic = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["esConfig"] as? [String: String] {
            self.esConfig = value
        }
        if let value = dict["esIPWhitelist"] as? [String] {
            self.esIPWhitelist = value
        }
        if let value = dict["esVersion"] as? String {
            self.esVersion = value
        }
        if let value = dict["extendConfigs"] as? [[String: Any]] {
            self.extendConfigs = value
        }
        if let value = dict["haveClientNode"] as? Bool {
            self.haveClientNode = value
        }
        if let value = dict["haveElasticDataNode"] as? Bool {
            self.haveElasticDataNode = value
        }
        if let value = dict["haveKibana"] as? Bool {
            self.haveKibana = value
        }
        if let value = dict["ikHotDicts"] as? [Any?] {
            var tmp : [DictInfo] = []
            for v in value {
                if v != nil {
                    var model = DictInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.ikHotDicts = tmp
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["kibanaConfiguration"] as? [String: Any?] {
            var model = KibanaNodeConfiguration()
            model.fromMap(value)
            self.kibanaConfiguration = model
        }
        if let value = dict["kibanaDomain"] as? String {
            self.kibanaDomain = value
        }
        if let value = dict["kibanaIPWhitelist"] as? [String] {
            self.kibanaIPWhitelist = value
        }
        if let value = dict["kibanaPort"] as? Int64 {
            self.kibanaPort = value
        }
        if let value = dict["kibanaPrivateDomain"] as? String {
            self.kibanaPrivateDomain = value
        }
        if let value = dict["kibanaPrivateIPWhitelist"] as? [String] {
            self.kibanaPrivateIPWhitelist = value
        }
        if let value = dict["kibanaPrivatePort"] as? Int64 {
            self.kibanaPrivatePort = value
        }
        if let value = dict["kibanaProtocol"] as? String {
            self.kibanaProtocol = value
        }
        if let value = dict["masterConfiguration"] as? [String: Any?] {
            var model = MasterNodeConfiguration()
            model.fromMap(value)
            self.masterConfiguration = model
        }
        if let value = dict["networkConfig"] as? [String: Any?] {
            var model = NetworkConfig()
            model.fromMap(value)
            self.networkConfig = model
        }
        if let value = dict["nodeAmount"] as? Int64 {
            self.nodeAmount = value
        }
        if let value = dict["nodeSpec"] as? [String: Any?] {
            var model = NodeSpec()
            model.fromMap(value)
            self.nodeSpec = model
        }
        if let value = dict["paymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["port"] as? Int64 {
            self.port = value
        }
        if let value = dict["privateNetworkIpWhiteList"] as? [String] {
            self.privateNetworkIpWhiteList = value
        }
        if let value = dict["productType"] as? String {
            self.productType = value
        }
        if let value = dict["protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["publicDomain"] as? String {
            self.publicDomain = value
        }
        if let value = dict["publicIpWhitelist"] as? [String] {
            self.publicIpWhitelist = value
        }
        if let value = dict["publicPort"] as? Int64 {
            self.publicPort = value
        }
        if let value = dict["readWritePolicy"] as? [String: Any?] {
            var model = ReadWritePolicy()
            model.fromMap(value)
            self.readWritePolicy = model
        }
        if let value = dict["resourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["serviceVpc"] as? Bool {
            self.serviceVpc = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["synonymsDicts"] as? [Any?] {
            var tmp : [DictInfo] = []
            for v in value {
                if v != nil {
                    var model = DictInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.synonymsDicts = tmp
        }
        if let value = dict["tags"] as? [Any?] {
            var tmp : [Tag] = []
            for v in value {
                if v != nil {
                    var model = Tag()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["updatedAt"] as? String {
            self.updatedAt = value
        }
        if let value = dict["warmNode"] as? Bool {
            self.warmNode = value
        }
        if let value = dict["warmNodeConfiguration"] as? [String: Any?] {
            var model = WarmNodeConfiguration()
            model.fromMap(value)
            self.warmNodeConfiguration = model
        }
        if let value = dict["zoneCount"] as? Int64 {
            self.zoneCount = value
        }
        if let value = dict["zoneInfos"] as? [Any?] {
            var tmp : [ZoneInfo] = []
            for v in value {
                if v != nil {
                    var model = ZoneInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.zoneInfos = tmp
        }
    }
}

public class KibanaNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["amount"] as? Int64 {
            self.amount = value
        }
        if let value = dict["disk"] as? Int64 {
            self.disk = value
        }
        if let value = dict["spec"] as? String {
            self.spec = value
        }
    }
}

public class Logstash : Tea.TeaModel {
    public class EndpointList : Tea.TeaModel {
        public var host: String?

        public var port: Int64?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["port"] as? Int64 {
                self.port = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public class NetworkConfig : Tea.TeaModel {
        public var type: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["vsArea"] as? String {
                self.vsArea = value
            }
            if let value = dict["vswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public class NodeSpec : Tea.TeaModel {
        public var disk: Int64?

        public var diskType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                map["disk"] = self.disk!
            }
            if self.diskType != nil {
                map["diskType"] = self.diskType!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["disk"] as? Int64 {
                self.disk = value
            }
            if let value = dict["diskType"] as? String {
                self.diskType = value
            }
            if let value = dict["spec"] as? String {
                self.spec = value
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["tagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["tagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["tagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["tagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public class ZoneInfos : Tea.TeaModel {
        public var status: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var config: [String: String]?

    public var createdAt: String?

    public var dataNode: Bool?

    public var description_: String?

    public var endTime: Int64?

    public var endpointList: [Logstash.EndpointList]?

    public var instanceId: String?

    public var networkConfig: Logstash.NetworkConfig?

    public var nodeAmount: Int64?

    public var nodeSpec: Logstash.NodeSpec?

    public var paymentType: String?

    public var protocol_: String?

    public var resourceGroupId: String?

    public var status: String?

    public var tags: [Logstash.Tags]?

    public var updatedAt: String?

    public var version: String?

    public var zoneCount: Int64?

    public var zoneInfos: [Logstash.ZoneInfos]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.config != nil {
            map["config"] = self.config!
        }
        if self.createdAt != nil {
            map["createdAt"] = self.createdAt!
        }
        if self.dataNode != nil {
            map["dataNode"] = self.dataNode!
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.endpointList != nil {
            var tmp : [Any] = []
            for k in self.endpointList! {
                tmp.append(k.toMap())
            }
            map["endpointList"] = tmp
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.protocol_ != nil {
            map["protocol"] = self.protocol_!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.updatedAt != nil {
            map["updatedAt"] = self.updatedAt!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        if self.zoneCount != nil {
            map["zoneCount"] = self.zoneCount!
        }
        if self.zoneInfos != nil {
            var tmp : [Any] = []
            for k in self.zoneInfos! {
                tmp.append(k.toMap())
            }
            map["zoneInfos"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["config"] as? [String: String] {
            self.config = value
        }
        if let value = dict["createdAt"] as? String {
            self.createdAt = value
        }
        if let value = dict["dataNode"] as? Bool {
            self.dataNode = value
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["endpointList"] as? [Any?] {
            var tmp : [Logstash.EndpointList] = []
            for v in value {
                if v != nil {
                    var model = Logstash.EndpointList()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.endpointList = tmp
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["networkConfig"] as? [String: Any?] {
            var model = Logstash.NetworkConfig()
            model.fromMap(value)
            self.networkConfig = model
        }
        if let value = dict["nodeAmount"] as? Int64 {
            self.nodeAmount = value
        }
        if let value = dict["nodeSpec"] as? [String: Any?] {
            var model = Logstash.NodeSpec()
            model.fromMap(value)
            self.nodeSpec = model
        }
        if let value = dict["paymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["protocol"] as? String {
            self.protocol_ = value
        }
        if let value = dict["resourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["tags"] as? [Any?] {
            var tmp : [Logstash.Tags] = []
            for v in value {
                if v != nil {
                    var model = Logstash.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["updatedAt"] as? String {
            self.updatedAt = value
        }
        if let value = dict["version"] as? String {
            self.version = value
        }
        if let value = dict["zoneCount"] as? Int64 {
            self.zoneCount = value
        }
        if let value = dict["zoneInfos"] as? [Any?] {
            var tmp : [Logstash.ZoneInfos] = []
            for v in value {
                if v != nil {
                    var model = Logstash.ZoneInfos()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.zoneInfos = tmp
        }
    }
}

public class MasterNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskType: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["amount"] as? Int64 {
            self.amount = value
        }
        if let value = dict["disk"] as? Int64 {
            self.disk = value
        }
        if let value = dict["diskType"] as? String {
            self.diskType = value
        }
        if let value = dict["spec"] as? String {
            self.spec = value
        }
    }
}

public class MigrationJob : Tea.TeaModel {
    public class SourceCluster : Tea.TeaModel {
        public var instanceId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public class StatusResult : Tea.TeaModel {
        public var code: String?

        public var success: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.success != nil {
                map["success"] = self.success!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["code"] as? String {
                self.code = value
            }
            if let value = dict["success"] as? Bool {
                self.success = value
            }
        }
    }
    public class TargetCluster : Tea.TeaModel {
        public var instanceId: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var currentState: String?

    public var disableSourceClusterAuth: Bool?

    public var disableTargetClusterAuth: Bool?

    public var endTime: Int64?

    public var migrationJobId: String?

    public var phase: String?

    public var sourceCluster: MigrationJob.SourceCluster?

    public var startTime: Int64?

    public var statusResult: [MigrationJob.StatusResult]?

    public var targetCluster: MigrationJob.TargetCluster?

    public var updateTime: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sourceCluster?.validate()
        try self.targetCluster?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currentState != nil {
            map["currentState"] = self.currentState!
        }
        if self.disableSourceClusterAuth != nil {
            map["disableSourceClusterAuth"] = self.disableSourceClusterAuth!
        }
        if self.disableTargetClusterAuth != nil {
            map["disableTargetClusterAuth"] = self.disableTargetClusterAuth!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.migrationJobId != nil {
            map["migrationJobId"] = self.migrationJobId!
        }
        if self.phase != nil {
            map["phase"] = self.phase!
        }
        if self.sourceCluster != nil {
            map["sourceCluster"] = self.sourceCluster?.toMap()
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.statusResult != nil {
            var tmp : [Any] = []
            for k in self.statusResult! {
                tmp.append(k.toMap())
            }
            map["statusResult"] = tmp
        }
        if self.targetCluster != nil {
            map["targetCluster"] = self.targetCluster?.toMap()
        }
        if self.updateTime != nil {
            map["updateTime"] = self.updateTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["currentState"] as? String {
            self.currentState = value
        }
        if let value = dict["disableSourceClusterAuth"] as? Bool {
            self.disableSourceClusterAuth = value
        }
        if let value = dict["disableTargetClusterAuth"] as? Bool {
            self.disableTargetClusterAuth = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["migrationJobId"] as? String {
            self.migrationJobId = value
        }
        if let value = dict["phase"] as? String {
            self.phase = value
        }
        if let value = dict["sourceCluster"] as? [String: Any?] {
            var model = MigrationJob.SourceCluster()
            model.fromMap(value)
            self.sourceCluster = model
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["statusResult"] as? [Any?] {
            var tmp : [MigrationJob.StatusResult] = []
            for v in value {
                if v != nil {
                    var model = MigrationJob.StatusResult()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.statusResult = tmp
        }
        if let value = dict["targetCluster"] as? [String: Any?] {
            var model = MigrationJob.TargetCluster()
            model.fromMap(value)
            self.targetCluster = model
        }
        if let value = dict["updateTime"] as? Int64 {
            self.updateTime = value
        }
    }
}

public class NetworkConfig : Tea.TeaModel {
    public var type: String?

    public var vpcId: String?

    public var vsArea: String?

    public var vswitchId: String?

    public var whiteIpGroupList: [WhiteIpGroup]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        if self.vsArea != nil {
            map["vsArea"] = self.vsArea!
        }
        if self.vswitchId != nil {
            map["vswitchId"] = self.vswitchId!
        }
        if self.whiteIpGroupList != nil {
            var tmp : [Any] = []
            for k in self.whiteIpGroupList! {
                tmp.append(k.toMap())
            }
            map["whiteIpGroupList"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["type"] as? String {
            self.type = value
        }
        if let value = dict["vpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["vsArea"] as? String {
            self.vsArea = value
        }
        if let value = dict["vswitchId"] as? String {
            self.vswitchId = value
        }
        if let value = dict["whiteIpGroupList"] as? [Any?] {
            var tmp : [WhiteIpGroup] = []
            for v in value {
                if v != nil {
                    var model = WhiteIpGroup()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.whiteIpGroupList = tmp
        }
    }
}

public class NodeInfo : Tea.TeaModel {
    public var host: String?

    public var hostName: String?

    public var port: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.host != nil {
            map["host"] = self.host!
        }
        if self.hostName != nil {
            map["hostName"] = self.hostName!
        }
        if self.port != nil {
            map["port"] = self.port!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["host"] as? String {
            self.host = value
        }
        if let value = dict["hostName"] as? String {
            self.hostName = value
        }
        if let value = dict["port"] as? Int64 {
            self.port = value
        }
        if let value = dict["zoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class NodeSpec : Tea.TeaModel {
    public var disk: Int32?

    public var diskEncryption: Bool?

    public var diskPreference: String?

    public var diskType: String?

    public var performanceLevel: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskEncryption != nil {
            map["diskEncryption"] = self.diskEncryption!
        }
        if self.diskPreference != nil {
            map["diskPreference"] = self.diskPreference!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.performanceLevel != nil {
            map["performanceLevel"] = self.performanceLevel!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["disk"] as? Int32 {
            self.disk = value
        }
        if let value = dict["diskEncryption"] as? Bool {
            self.diskEncryption = value
        }
        if let value = dict["diskPreference"] as? String {
            self.diskPreference = value
        }
        if let value = dict["diskType"] as? String {
            self.diskType = value
        }
        if let value = dict["performanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["spec"] as? String {
            self.spec = value
        }
    }
}

public class PaymentInfo : Tea.TeaModel {
    public var autoRenewDuration: Int64?

    public var duration: Int64?

    public var isAutoRenew: Bool?

    public var pricingCycle: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenewDuration != nil {
            map["autoRenewDuration"] = self.autoRenewDuration!
        }
        if self.duration != nil {
            map["duration"] = self.duration!
        }
        if self.isAutoRenew != nil {
            map["isAutoRenew"] = self.isAutoRenew!
        }
        if self.pricingCycle != nil {
            map["pricingCycle"] = self.pricingCycle!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["autoRenewDuration"] as? Int64 {
            self.autoRenewDuration = value
        }
        if let value = dict["duration"] as? Int64 {
            self.duration = value
        }
        if let value = dict["isAutoRenew"] as? Bool {
            self.isAutoRenew = value
        }
        if let value = dict["pricingCycle"] as? String {
            self.pricingCycle = value
        }
    }
}

public class ReadWritePolicy : Tea.TeaModel {
    public var autoGeneratePk: Bool?

    public var writeHa: Bool?

    public var writePolicy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoGeneratePk != nil {
            map["autoGeneratePk"] = self.autoGeneratePk!
        }
        if self.writeHa != nil {
            map["writeHa"] = self.writeHa!
        }
        if self.writePolicy != nil {
            map["writePolicy"] = self.writePolicy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["autoGeneratePk"] as? Bool {
            self.autoGeneratePk = value
        }
        if let value = dict["writeHa"] as? Bool {
            self.writeHa = value
        }
        if let value = dict["writePolicy"] as? String {
            self.writePolicy = value
        }
    }
}

public class Tag : Tea.TeaModel {
    public var tagKey: String?

    public var tagValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.tagKey != nil {
            map["tagKey"] = self.tagKey!
        }
        if self.tagValue != nil {
            map["tagValue"] = self.tagValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["tagKey"] as? String {
            self.tagKey = value
        }
        if let value = dict["tagValue"] as? String {
            self.tagValue = value
        }
    }
}

public class WarmNodeConfiguration : Tea.TeaModel {
    public var amount: Int64?

    public var disk: Int64?

    public var diskEncryption: Bool?

    public var diskType: String?

    public var performanceLevel: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["amount"] = self.amount!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskEncryption != nil {
            map["diskEncryption"] = self.diskEncryption!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        if self.performanceLevel != nil {
            map["performanceLevel"] = self.performanceLevel!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["amount"] as? Int64 {
            self.amount = value
        }
        if let value = dict["disk"] as? Int64 {
            self.disk = value
        }
        if let value = dict["diskEncryption"] as? Bool {
            self.diskEncryption = value
        }
        if let value = dict["diskType"] as? String {
            self.diskType = value
        }
        if let value = dict["performanceLevel"] as? String {
            self.performanceLevel = value
        }
        if let value = dict["spec"] as? String {
            self.spec = value
        }
    }
}

public class WhiteIpGroup : Tea.TeaModel {
    public var whiteIpType: String?

    public var groupName: String?

    public var ips: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.whiteIpType != nil {
            map["WhiteIpType"] = self.whiteIpType!
        }
        if self.groupName != nil {
            map["groupName"] = self.groupName!
        }
        if self.ips != nil {
            map["ips"] = self.ips!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["WhiteIpType"] as? String {
            self.whiteIpType = value
        }
        if let value = dict["groupName"] as? String {
            self.groupName = value
        }
        if let value = dict["ips"] as? [String] {
            self.ips = value
        }
    }
}

public class ZoneInfo : Tea.TeaModel {
    public var status: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["zoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class ResultSpecInfoMapValue : Tea.TeaModel {
    public var cpuCount: String?

    public var memorySize: String?

    public var enable: String?

    public var spec: String?

    public var specGroupType: String?

    public var disk: String?

    public var diskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuCount != nil {
            map["cpuCount"] = self.cpuCount!
        }
        if self.memorySize != nil {
            map["memorySize"] = self.memorySize!
        }
        if self.enable != nil {
            map["enable"] = self.enable!
        }
        if self.spec != nil {
            map["spec"] = self.spec!
        }
        if self.specGroupType != nil {
            map["specGroupType"] = self.specGroupType!
        }
        if self.disk != nil {
            map["disk"] = self.disk!
        }
        if self.diskType != nil {
            map["diskType"] = self.diskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["cpuCount"] as? String {
            self.cpuCount = value
        }
        if let value = dict["memorySize"] as? String {
            self.memorySize = value
        }
        if let value = dict["enable"] as? String {
            self.enable = value
        }
        if let value = dict["spec"] as? String {
            self.spec = value
        }
        if let value = dict["specGroupType"] as? String {
            self.specGroupType = value
        }
        if let value = dict["disk"] as? String {
            self.disk = value
        }
        if let value = dict["diskType"] as? String {
            self.diskType = value
        }
    }
}

public class ActivateZonesRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class ActivateZonesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ActivateZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ActivateZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddConnectableClusterRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class AddConnectableClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class AddConnectableClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddConnectableClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddConnectableClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class AddSnapshotRepoRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class AddSnapshotRepoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class AddSnapshotRepoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddSnapshotRepoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = AddSnapshotRepoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelDeletionRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class CancelDeletionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CancelDeletionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelDeletionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelDeletionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelLogstashDeletionRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class CancelLogstashDeletionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CancelLogstashDeletionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelLogstashDeletionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelLogstashDeletionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CancelTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var taskType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.taskType != nil {
            map["taskType"] = self.taskType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["taskType"] as? String {
            self.taskType = value
        }
    }
}

public class CancelTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CancelTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CancelTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CapacityPlanRequest : Tea.TeaModel {
    public class DataInfo : Tea.TeaModel {
        public var code: String?

        public var size: Int64?

        public var totalCount: Int32?

        public var type: String?

        public var unit: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            if self.totalCount != nil {
                map["totalCount"] = self.totalCount!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.unit != nil {
                map["unit"] = self.unit!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["code"] as? String {
                self.code = value
            }
            if let value = dict["size"] as? Int64 {
                self.size = value
            }
            if let value = dict["totalCount"] as? Int32 {
                self.totalCount = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["unit"] as? String {
                self.unit = value
            }
        }
    }
    public class Metric : Tea.TeaModel {
        public var averageQps: Int32?

        public var code: String?

        public var concurrent: Int64?

        public var peakQps: Int32?

        public var responseTime: Int32?

        public var throughput: Int64?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.averageQps != nil {
                map["averageQps"] = self.averageQps!
            }
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.concurrent != nil {
                map["concurrent"] = self.concurrent!
            }
            if self.peakQps != nil {
                map["peakQps"] = self.peakQps!
            }
            if self.responseTime != nil {
                map["responseTime"] = self.responseTime!
            }
            if self.throughput != nil {
                map["throughput"] = self.throughput!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["averageQps"] as? Int32 {
                self.averageQps = value
            }
            if let value = dict["code"] as? String {
                self.code = value
            }
            if let value = dict["concurrent"] as? Int64 {
                self.concurrent = value
            }
            if let value = dict["peakQps"] as? Int32 {
                self.peakQps = value
            }
            if let value = dict["responseTime"] as? Int32 {
                self.responseTime = value
            }
            if let value = dict["throughput"] as? Int64 {
                self.throughput = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var complexQueryAvailable: Bool?

    public var dataInfo: [CapacityPlanRequest.DataInfo]?

    public var metric: [CapacityPlanRequest.Metric]?

    public var usageScenario: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.complexQueryAvailable != nil {
            map["complexQueryAvailable"] = self.complexQueryAvailable!
        }
        if self.dataInfo != nil {
            var tmp : [Any] = []
            for k in self.dataInfo! {
                tmp.append(k.toMap())
            }
            map["dataInfo"] = tmp
        }
        if self.metric != nil {
            var tmp : [Any] = []
            for k in self.metric! {
                tmp.append(k.toMap())
            }
            map["metric"] = tmp
        }
        if self.usageScenario != nil {
            map["usageScenario"] = self.usageScenario!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["complexQueryAvailable"] as? Bool {
            self.complexQueryAvailable = value
        }
        if let value = dict["dataInfo"] as? [Any?] {
            var tmp : [CapacityPlanRequest.DataInfo] = []
            for v in value {
                if v != nil {
                    var model = CapacityPlanRequest.DataInfo()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.dataInfo = tmp
        }
        if let value = dict["metric"] as? [Any?] {
            var tmp : [CapacityPlanRequest.Metric] = []
            for v in value {
                if v != nil {
                    var model = CapacityPlanRequest.Metric()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.metric = tmp
        }
        if let value = dict["usageScenario"] as? String {
            self.usageScenario = value
        }
    }
}

public class CapacityPlanResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ExtendConfigs : Tea.TeaModel {
            public var configType: String?

            public var disk: Int64?

            public var diskType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["ConfigType"] = self.configType!
                }
                if self.disk != nil {
                    map["Disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ConfigType"] as? String {
                    self.configType = value
                }
                if let value = dict["Disk"] as? Int64 {
                    self.disk = value
                }
                if let value = dict["DiskType"] as? String {
                    self.diskType = value
                }
            }
        }
        public class NodeConfigurations : Tea.TeaModel {
            public var amount: Int64?

            public var cpu: Int64?

            public var disk: Int64?

            public var diskType: String?

            public var memory: Int64?

            public var nodeType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.disk != nil {
                    map["Disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["DiskType"] = self.diskType!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.nodeType != nil {
                    map["NodeType"] = self.nodeType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["Amount"] as? Int64 {
                    self.amount = value
                }
                if let value = dict["Cpu"] as? Int64 {
                    self.cpu = value
                }
                if let value = dict["Disk"] as? Int64 {
                    self.disk = value
                }
                if let value = dict["DiskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["Memory"] as? Int64 {
                    self.memory = value
                }
                if let value = dict["NodeType"] as? String {
                    self.nodeType = value
                }
            }
        }
        public var extendConfigs: [CapacityPlanResponseBody.Result.ExtendConfigs]?

        public var instanceCategory: String?

        public var nodeConfigurations: [CapacityPlanResponseBody.Result.NodeConfigurations]?

        public var oversizedCluster: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["ExtendConfigs"] = tmp
            }
            if self.instanceCategory != nil {
                map["InstanceCategory"] = self.instanceCategory!
            }
            if self.nodeConfigurations != nil {
                var tmp : [Any] = []
                for k in self.nodeConfigurations! {
                    tmp.append(k.toMap())
                }
                map["NodeConfigurations"] = tmp
            }
            if self.oversizedCluster != nil {
                map["OversizedCluster"] = self.oversizedCluster!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExtendConfigs"] as? [Any?] {
                var tmp : [CapacityPlanResponseBody.Result.ExtendConfigs] = []
                for v in value {
                    if v != nil {
                        var model = CapacityPlanResponseBody.Result.ExtendConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.extendConfigs = tmp
            }
            if let value = dict["InstanceCategory"] as? String {
                self.instanceCategory = value
            }
            if let value = dict["NodeConfigurations"] as? [Any?] {
                var tmp : [CapacityPlanResponseBody.Result.NodeConfigurations] = []
                for v in value {
                    if v != nil {
                        var model = CapacityPlanResponseBody.Result.NodeConfigurations()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodeConfigurations = tmp
            }
            if let value = dict["OversizedCluster"] as? Bool {
                self.oversizedCluster = value
            }
        }
    }
    public var requestId: String?

    public var result: CapacityPlanResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CapacityPlanResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CapacityPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CapacityPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CapacityPlanResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloseDiagnosisRequest : Tea.TeaModel {
    public var clientToken: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class CloseDiagnosisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CloseDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloseDiagnosisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloseHttpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class CloseHttpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CloseHttpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseHttpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloseHttpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CloseManagedIndexRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class CloseManagedIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CloseManagedIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CloseManagedIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CloseManagedIndexResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateCollectorRequest : Tea.TeaModel {
    public class Configs : Tea.TeaModel {
        public var content: String?

        public var fileName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.fileName != nil {
                map["fileName"] = self.fileName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["fileName"] as? String {
                self.fileName = value
            }
        }
    }
    public var collectorPaths: [String]?

    public var configs: [CreateCollectorRequest.Configs]?

    public var dryRun: Bool?

    public var extendConfigs: [[String: Any]]?

    public var name: String?

    public var resType: String?

    public var resVersion: String?

    public var vpcId: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.collectorPaths != nil {
            map["collectorPaths"] = self.collectorPaths!
        }
        if self.configs != nil {
            var tmp : [Any] = []
            for k in self.configs! {
                tmp.append(k.toMap())
            }
            map["configs"] = tmp
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        if self.extendConfigs != nil {
            map["extendConfigs"] = self.extendConfigs!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.resType != nil {
            map["resType"] = self.resType!
        }
        if self.resVersion != nil {
            map["resVersion"] = self.resVersion!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["collectorPaths"] as? [String] {
            self.collectorPaths = value
        }
        if let value = dict["configs"] as? [Any?] {
            var tmp : [CreateCollectorRequest.Configs] = []
            for v in value {
                if v != nil {
                    var model = CreateCollectorRequest.Configs()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.configs = tmp
        }
        if let value = dict["dryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["extendConfigs"] as? [[String: Any]] {
            self.extendConfigs = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["resType"] as? String {
            self.resType = value
        }
        if let value = dict["resVersion"] as? String {
            self.resVersion = value
        }
        if let value = dict["vpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class CreateCollectorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var resId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["resId"] as? String {
                self.resId = value
            }
        }
    }
    public var requestId: String?

    public var result: CreateCollectorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CreateCollectorResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateComponentIndexRequest : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var aliases: [String: Any]?

        public var mappings: [String: Any]?

        public var settings: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliases != nil {
                map["aliases"] = self.aliases!
            }
            if self.mappings != nil {
                map["mappings"] = self.mappings!
            }
            if self.settings != nil {
                map["settings"] = self.settings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aliases"] as? [String: Any] {
                self.aliases = value
            }
            if let value = dict["mappings"] as? [String: Any] {
                self.mappings = value
            }
            if let value = dict["settings"] as? [String: Any] {
                self.settings = value
            }
        }
    }
    public var meta: [String: Any]?

    public var template: CreateComponentIndexRequest.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.meta != nil {
            map["_meta"] = self.meta!
        }
        if self.template != nil {
            map["template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["_meta"] as? [String: Any] {
            self.meta = value
        }
        if let value = dict["template"] as? [String: Any?] {
            var model = CreateComponentIndexRequest.Template()
            model.fromMap(value)
            self.template = model
        }
    }
}

public class CreateComponentIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CreateComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateComponentIndexResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateDataStreamRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class CreateDataStreamResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var requestId: String?

    public var result: CreateDataStreamResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CreateDataStreamResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateDataStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDataStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateDataStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateILMPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class CreateILMPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
    }
}

public class CreateILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateILMPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateIndexTemplateRequest : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var aliases: String?

        public var mappings: String?

        public var settings: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliases != nil {
                map["aliases"] = self.aliases!
            }
            if self.mappings != nil {
                map["mappings"] = self.mappings!
            }
            if self.settings != nil {
                map["settings"] = self.settings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aliases"] as? String {
                self.aliases = value
            }
            if let value = dict["mappings"] as? String {
                self.mappings = value
            }
            if let value = dict["settings"] as? String {
                self.settings = value
            }
        }
    }
    public var clientToken: String?

    public var dataStream: Bool?

    public var ilmPolicy: String?

    public var indexPatterns: [String]?

    public var indexTemplate: String?

    public var priority: Int32?

    public var template: CreateIndexTemplateRequest.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataStream != nil {
            map["dataStream"] = self.dataStream!
        }
        if self.ilmPolicy != nil {
            map["ilmPolicy"] = self.ilmPolicy!
        }
        if self.indexPatterns != nil {
            map["indexPatterns"] = self.indexPatterns!
        }
        if self.indexTemplate != nil {
            map["indexTemplate"] = self.indexTemplate!
        }
        if self.priority != nil {
            map["priority"] = self.priority!
        }
        if self.template != nil {
            map["template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["dataStream"] as? Bool {
            self.dataStream = value
        }
        if let value = dict["ilmPolicy"] as? String {
            self.ilmPolicy = value
        }
        if let value = dict["indexPatterns"] as? [String] {
            self.indexPatterns = value
        }
        if let value = dict["indexTemplate"] as? String {
            self.indexTemplate = value
        }
        if let value = dict["priority"] as? Int32 {
            self.priority = value
        }
        if let value = dict["template"] as? [String: Any?] {
            var model = CreateIndexTemplateRequest.Template()
            model.fromMap(value)
            self.template = model
        }
    }
}

public class CreateIndexTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
    }
}

public class CreateIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateIndexTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateLogstashRequest : Tea.TeaModel {
    public class NetworkConfig : Tea.TeaModel {
        public var type: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.type != nil {
                map["type"] = self.type!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["type"] as? String {
                self.type = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["vsArea"] as? String {
                self.vsArea = value
            }
            if let value = dict["vswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public class NodeSpec : Tea.TeaModel {
        public var disk: Int64?

        public var diskType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                map["disk"] = self.disk!
            }
            if self.diskType != nil {
                map["diskType"] = self.diskType!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["disk"] as? Int64 {
                self.disk = value
            }
            if let value = dict["diskType"] as? String {
                self.diskType = value
            }
            if let value = dict["spec"] as? String {
                self.spec = value
            }
        }
    }
    public class PaymentInfo : Tea.TeaModel {
        public var autoRenewDuration: Int64?

        public var duration: Int64?

        public var isAutoRenew: Bool?

        public var pricingCycle: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoRenewDuration != nil {
                map["autoRenewDuration"] = self.autoRenewDuration!
            }
            if self.duration != nil {
                map["duration"] = self.duration!
            }
            if self.isAutoRenew != nil {
                map["isAutoRenew"] = self.isAutoRenew!
            }
            if self.pricingCycle != nil {
                map["pricingCycle"] = self.pricingCycle!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["autoRenewDuration"] as? Int64 {
                self.autoRenewDuration = value
            }
            if let value = dict["duration"] as? Int64 {
                self.duration = value
            }
            if let value = dict["isAutoRenew"] as? Bool {
                self.isAutoRenew = value
            }
            if let value = dict["pricingCycle"] as? String {
                self.pricingCycle = value
            }
        }
    }
    public var description_: String?

    public var networkConfig: CreateLogstashRequest.NetworkConfig?

    public var nodeAmount: Int32?

    public var nodeSpec: CreateLogstashRequest.NodeSpec?

    public var paymentInfo: CreateLogstashRequest.PaymentInfo?

    public var paymentType: String?

    public var resourceGroupId: String?

    public var version: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
        try self.paymentInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentInfo != nil {
            map["paymentInfo"] = self.paymentInfo?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["networkConfig"] as? [String: Any?] {
            var model = CreateLogstashRequest.NetworkConfig()
            model.fromMap(value)
            self.networkConfig = model
        }
        if let value = dict["nodeAmount"] as? Int32 {
            self.nodeAmount = value
        }
        if let value = dict["nodeSpec"] as? [String: Any?] {
            var model = CreateLogstashRequest.NodeSpec()
            model.fromMap(value)
            self.nodeSpec = model
        }
        if let value = dict["paymentInfo"] as? [String: Any?] {
            var model = CreateLogstashRequest.PaymentInfo()
            model.fromMap(value)
            self.paymentInfo = model
        }
        if let value = dict["paymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["resourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["version"] as? String {
            self.version = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class CreateLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Logstash?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = Logstash()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateLogstashResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreatePipelinesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var batchDelay: Int32?

        public var batchSize: Int32?

        public var config: String?

        public var description_: String?

        public var pipelineId: String?

        public var queueCheckPointWrites: Int32?

        public var queueMaxBytes: Int32?

        public var queueType: String?

        public var workers: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchDelay != nil {
                map["batchDelay"] = self.batchDelay!
            }
            if self.batchSize != nil {
                map["batchSize"] = self.batchSize!
            }
            if self.config != nil {
                map["config"] = self.config!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.queueCheckPointWrites != nil {
                map["queueCheckPointWrites"] = self.queueCheckPointWrites!
            }
            if self.queueMaxBytes != nil {
                map["queueMaxBytes"] = self.queueMaxBytes!
            }
            if self.queueType != nil {
                map["queueType"] = self.queueType!
            }
            if self.workers != nil {
                map["workers"] = self.workers!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["batchDelay"] as? Int32 {
                self.batchDelay = value
            }
            if let value = dict["batchSize"] as? Int32 {
                self.batchSize = value
            }
            if let value = dict["config"] as? String {
                self.config = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["pipelineId"] as? String {
                self.pipelineId = value
            }
            if let value = dict["queueCheckPointWrites"] as? Int32 {
                self.queueCheckPointWrites = value
            }
            if let value = dict["queueMaxBytes"] as? Int32 {
                self.queueMaxBytes = value
            }
            if let value = dict["queueType"] as? String {
                self.queueType = value
            }
            if let value = dict["workers"] as? Int32 {
                self.workers = value
            }
        }
    }
    public var clientToken: String?

    public var body: [CreatePipelinesRequest.Body]?

    public var trigger: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? [Any?] {
            var tmp : [CreatePipelinesRequest.Body] = []
            for v in value {
                if v != nil {
                    var model = CreatePipelinesRequest.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
        if let value = dict["trigger"] as? Bool {
            self.trigger = value
        }
    }
}

public class CreatePipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CreatePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreatePipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateSnapshotRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class CreateSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class CreateSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateSnapshotResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateVpcEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public var serviceId: String?

    public var zoneId: String?

    public var dryRun: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.serviceId != nil {
            map["serviceId"] = self.serviceId!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["serviceId"] as? String {
            self.serviceId = value
        }
        if let value = dict["zoneId"] as? String {
            self.zoneId = value
        }
        if let value = dict["dryRun"] as? Bool {
            self.dryRun = value
        }
    }
}

public class CreateVpcEndpointResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var endpointDomain: String?

        public var endpointId: String?

        public var endpointName: String?

        public var serviceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpointDomain != nil {
                map["endpointDomain"] = self.endpointDomain!
            }
            if self.endpointId != nil {
                map["endpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["endpointName"] = self.endpointName!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["endpointDomain"] as? String {
                self.endpointDomain = value
            }
            if let value = dict["endpointId"] as? String {
                self.endpointId = value
            }
            if let value = dict["endpointName"] as? String {
                self.endpointName = value
            }
            if let value = dict["serviceId"] as? String {
                self.serviceId = value
            }
        }
    }
    public var requestId: String?

    public var result: CreateVpcEndpointResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = CreateVpcEndpointResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class CreateVpcEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = CreateVpcEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeactivateZonesRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DeactivateZonesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeactivateZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeactivateZonesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DeleteCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteComponentIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteComponentIndexResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteConnectedClusterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var connectedInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.connectedInstanceId != nil {
            map["connectedInstanceId"] = self.connectedInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["connectedInstanceId"] as? String {
            self.connectedInstanceId = value
        }
    }
}

public class DeleteConnectedClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteConnectedClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteConnectedClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteConnectedClusterResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataStreamRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DeleteDataStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteDataStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDataTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.taskId != nil {
            map["taskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["taskId"] as? String {
            self.taskId = value
        }
    }
}

public class DeleteDataTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteDataTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDataTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDataTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteDeprecatedTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteDeprecatedTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeprecatedTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteDeprecatedTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteILMPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteILMPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteIndexTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteIndexTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var deleteType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.deleteType != nil {
            map["deleteType"] = self.deleteType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["deleteType"] as? String {
            self.deleteType = value
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteLogstashRequest : Tea.TeaModel {
    public var clientToken: String?

    public var deleteType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.deleteType != nil {
            map["deleteType"] = self.deleteType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["deleteType"] as? String {
            self.deleteType = value
        }
    }
}

public class DeleteLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class DeleteLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteLogstashResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeletePipelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var pipelineIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.pipelineIds != nil {
            map["pipelineIds"] = self.pipelineIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["pipelineIds"] as? String {
            self.pipelineIds = value
        }
    }
}

public class DeletePipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeletePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeletePipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteSnapshotRepoRequest : Tea.TeaModel {
    public var clientToken: String?

    public var repoPath: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.repoPath != nil {
            map["repoPath"] = self.repoPath!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["repoPath"] as? String {
            self.repoPath = value
        }
    }
}

public class DeleteSnapshotRepoResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteSnapshotRepoResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotRepoResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteSnapshotRepoResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DeleteVpcEndpointRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DeleteVpcEndpointResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DeleteVpcEndpointResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcEndpointResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DeleteVpcEndpointResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeAckOperatorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var status: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeAckOperatorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeAckOperatorResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeAckOperatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAckOperatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeAckOperatorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeApmResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var apmServerDomain: String?

        public var createdAt: String?

        public var deployedReplica: Int64?

        public var description_: String?

        public var endTime: Int64?

        public var instanceId: String?

        public var nodeAmount: Int64?

        public var outputES: String?

        public var outputESUserName: String?

        public var ownerId: String?

        public var paymentType: String?

        public var region: String?

        public var replica: Int32?

        public var resourceSpec: String?

        public var status: String?

        public var version: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.apmServerDomain != nil {
                map["apmServerDomain"] = self.apmServerDomain!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.deployedReplica != nil {
                map["deployedReplica"] = self.deployedReplica!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.outputES != nil {
                map["outputES"] = self.outputES!
            }
            if self.outputESUserName != nil {
                map["outputESUserName"] = self.outputESUserName!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.region != nil {
                map["region"] = self.region!
            }
            if self.replica != nil {
                map["replica"] = self.replica!
            }
            if self.resourceSpec != nil {
                map["resourceSpec"] = self.resourceSpec!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["apmServerDomain"] as? String {
                self.apmServerDomain = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["deployedReplica"] as? Int64 {
                self.deployedReplica = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["endTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["nodeAmount"] as? Int64 {
                self.nodeAmount = value
            }
            if let value = dict["outputES"] as? String {
                self.outputES = value
            }
            if let value = dict["outputESUserName"] as? String {
                self.outputESUserName = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["region"] as? String {
                self.region = value
            }
            if let value = dict["replica"] as? Int32 {
                self.replica = value
            }
            if let value = dict["resourceSpec"] as? String {
                self.resourceSpec = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["vsArea"] as? String {
                self.vsArea = value
            }
            if let value = dict["vswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeApmResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeApmResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeApmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeCollectorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["content"] as? String {
                    self.content = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["agentStatus"] as? String {
                        self.agentStatus = value
                    }
                    if let value = dict["instanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [DescribeCollectorResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["configType"] as? String {
                    self.configType = value
                }
                if let value = dict["enableMonitoring"] as? Bool {
                    self.enableMonitoring = value
                }
                if let value = dict["groupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["host"] as? String {
                    self.host = value
                }
                if let value = dict["hosts"] as? [String] {
                    self.hosts = value
                }
                if let value = dict["instanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["instanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["kibanaHost"] as? String {
                    self.kibanaHost = value
                }
                if let value = dict["machines"] as? [Any?] {
                    var tmp : [DescribeCollectorResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeCollectorResponseBody.Result.ExtendConfigs.Machines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.machines = tmp
                }
                if let value = dict["protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["successPodsCount"] as? String {
                    self.successPodsCount = value
                }
                if let value = dict["totalPodsCount"] as? String {
                    self.totalPodsCount = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["userName"] as? String {
                    self.userName = value
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [DescribeCollectorResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [DescribeCollectorResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["collectorPaths"] as? [String] {
                self.collectorPaths = value
            }
            if let value = dict["configs"] as? [Any?] {
                var tmp : [DescribeCollectorResponseBody.Result.Configs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCollectorResponseBody.Result.Configs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configs = tmp
            }
            if let value = dict["dryRun"] as? Bool {
                self.dryRun = value
            }
            if let value = dict["extendConfigs"] as? [Any?] {
                var tmp : [DescribeCollectorResponseBody.Result.ExtendConfigs] = []
                for v in value {
                    if v != nil {
                        var model = DescribeCollectorResponseBody.Result.ExtendConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.extendConfigs = tmp
            }
            if let value = dict["gmtCreatedTime"] as? String {
                self.gmtCreatedTime = value
            }
            if let value = dict["gmtUpdateTime"] as? String {
                self.gmtUpdateTime = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["resId"] as? String {
                self.resId = value
            }
            if let value = dict["resType"] as? String {
                self.resType = value
            }
            if let value = dict["resVersion"] as? String {
                self.resVersion = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeCollectorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeCollectorResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeComponentIndexResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: [String: Any]?

            public var mappings: [String: Any]?

            public var settings: [String: Any]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliases"] as? [String: Any] {
                    self.aliases = value
                }
                if let value = dict["mappings"] as? [String: Any] {
                    self.mappings = value
                }
                if let value = dict["settings"] as? [String: Any] {
                    self.settings = value
                }
            }
        }
        public var meta: [String: Any]?

        public var template: DescribeComponentIndexResponseBody.Result.Template?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.meta != nil {
                map["_meta"] = self.meta!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["_meta"] as? [String: Any] {
                self.meta = value
            }
            if let value = dict["template"] as? [String: Any?] {
                var model = DescribeComponentIndexResponseBody.Result.Template()
                model.fromMap(value)
                self.template = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeComponentIndexResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeComponentIndexResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeComponentIndexResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeConnectableClustersRequest : Tea.TeaModel {
    public var alreadySetItems: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alreadySetItems != nil {
            map["alreadySetItems"] = self.alreadySetItems!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["alreadySetItems"] as? Bool {
            self.alreadySetItems = value
        }
    }
}

public class DescribeConnectableClustersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var instances: String?

        public var networkType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instances != nil {
                map["instances"] = self.instances!
            }
            if self.networkType != nil {
                map["networkType"] = self.networkType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["instances"] as? String {
                self.instances = value
            }
            if let value = dict["networkType"] as? String {
                self.networkType = value
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeConnectableClustersResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [DescribeConnectableClustersResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = DescribeConnectableClustersResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class DescribeConnectableClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeConnectableClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeConnectableClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDeprecatedTemplateResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliases"] as? String {
                    self.aliases = value
                }
                if let value = dict["mappings"] as? String {
                    self.mappings = value
                }
                if let value = dict["settings"] as? String {
                    self.settings = value
                }
            }
        }
        public var dataStream: Bool?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var order: Int64?

        public var template: DescribeDeprecatedTemplateResponseBody.Result.Template?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["dataStream"] as? Bool {
                self.dataStream = value
            }
            if let value = dict["indexPatterns"] as? [String] {
                self.indexPatterns = value
            }
            if let value = dict["indexTemplate"] as? String {
                self.indexTemplate = value
            }
            if let value = dict["order"] as? Int64 {
                self.order = value
            }
            if let value = dict["template"] as? [String: Any?] {
                var model = DescribeDeprecatedTemplateResponseBody.Result.Template()
                model.fromMap(value)
                self.template = model
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDeprecatedTemplateResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeDeprecatedTemplateResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeDeprecatedTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeprecatedTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDeprecatedTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnoseReportRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDiagnoseReportResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DiagnoseItems : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var desc: String?

                public var name: String?

                public var result: String?

                public var suggest: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desc != nil {
                        map["desc"] = self.desc!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.result != nil {
                        map["result"] = self.result!
                    }
                    if self.suggest != nil {
                        map["suggest"] = self.suggest!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["desc"] as? String {
                        self.desc = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["result"] as? String {
                        self.result = value
                    }
                    if let value = dict["suggest"] as? String {
                        self.suggest = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                }
            }
            public var detail: DescribeDiagnoseReportResponseBody.Result.DiagnoseItems.Detail?

            public var health: String?

            public var item: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail?.toMap()
                }
                if self.health != nil {
                    map["health"] = self.health!
                }
                if self.item != nil {
                    map["item"] = self.item!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["detail"] as? [String: Any?] {
                    var model = DescribeDiagnoseReportResponseBody.Result.DiagnoseItems.Detail()
                    model.fromMap(value)
                    self.detail = model
                }
                if let value = dict["health"] as? String {
                    self.health = value
                }
                if let value = dict["item"] as? String {
                    self.item = value
                }
            }
        }
        public var createTime: Int64?

        public var diagnoseItems: [DescribeDiagnoseReportResponseBody.Result.DiagnoseItems]?

        public var health: String?

        public var instanceId: String?

        public var reportId: String?

        public var state: String?

        public var trigger: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.diagnoseItems != nil {
                var tmp : [Any] = []
                for k in self.diagnoseItems! {
                    tmp.append(k.toMap())
                }
                map["diagnoseItems"] = tmp
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.reportId != nil {
                map["reportId"] = self.reportId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.trigger != nil {
                map["trigger"] = self.trigger!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["diagnoseItems"] as? [Any?] {
                var tmp : [DescribeDiagnoseReportResponseBody.Result.DiagnoseItems] = []
                for v in value {
                    if v != nil {
                        var model = DescribeDiagnoseReportResponseBody.Result.DiagnoseItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.diagnoseItems = tmp
            }
            if let value = dict["health"] as? String {
                self.health = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["reportId"] as? String {
                self.reportId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["trigger"] as? String {
                self.trigger = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDiagnoseReportResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeDiagnoseReportResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeDiagnoseReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnoseReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnoseReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDiagnosisSettingsRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class DescribeDiagnosisSettingsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var scene: String?

        public var updateTime: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.scene != nil {
                map["scene"] = self.scene!
            }
            if self.updateTime != nil {
                map["updateTime"] = self.updateTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["scene"] as? String {
                self.scene = value
            }
            if let value = dict["updateTime"] as? Int64 {
                self.updateTime = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeDiagnosisSettingsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeDiagnosisSettingsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeDiagnosisSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosisSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDiagnosisSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeDynamicSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
    }
}

public class DescribeDynamicSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDynamicSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeDynamicSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeElasticsearchHealthResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
    }
}

public class DescribeElasticsearchHealthResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticsearchHealthResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeElasticsearchHealthResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeILMPolicyResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var name: String?

        public var phases: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.phases != nil {
                map["phases"] = self.phases!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["phases"] as? [String: Any] {
                self.phases = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeILMPolicyResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeILMPolicyResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeILMPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeIndexTemplateResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliases"] as? String {
                    self.aliases = value
                }
                if let value = dict["mappings"] as? String {
                    self.mappings = value
                }
                if let value = dict["settings"] as? String {
                    self.settings = value
                }
            }
        }
        public var dataStream: Bool?

        public var ilmPolicy: String?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var priority: Int32?

        public var template: DescribeIndexTemplateResponseBody.Result.Template?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.ilmPolicy != nil {
                map["ilmPolicy"] = self.ilmPolicy!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["dataStream"] as? Bool {
                self.dataStream = value
            }
            if let value = dict["ilmPolicy"] as? String {
                self.ilmPolicy = value
            }
            if let value = dict["indexPatterns"] as? [String] {
                self.indexPatterns = value
            }
            if let value = dict["indexTemplate"] as? String {
                self.indexTemplate = value
            }
            if let value = dict["priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["template"] as? [String: Any?] {
                var model = DescribeIndexTemplateResponseBody.Result.Template()
                model.fromMap(value)
                self.template = model
            }
        }
    }
    public var requestId: String?

    public var result: DescribeIndexTemplateResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeIndexTemplateResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeIndexTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class AdvancedSetting : Tea.TeaModel {
            public var gcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.gcName != nil {
                    map["gcName"] = self.gcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["gcName"] as? String {
                    self.gcName = value
                }
            }
        }
        public class AliwsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class ClientNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class DictList : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class ElasticDataNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class IkHotDicts : Tea.TeaModel {
            public var fileSize: Int32?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int32 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["groupName"] as? String {
                        self.groupName = value
                    }
                    if let value = dict["ips"] as? [String] {
                        self.ips = value
                    }
                    if let value = dict["whiteIpType"] as? String {
                        self.whiteIpType = value
                    }
                }
            }
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public var whiteIpGroupList: [DescribeInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vsArea"] as? String {
                    self.vsArea = value
                }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
                if let value = dict["whiteIpGroupList"] as? [Any?] {
                    var tmp : [DescribeInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in value {
                        if v != nil {
                            var model = DescribeInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var performanceLevel: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.performanceLevel != nil {
                    map["performanceLevel"] = self.performanceLevel!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["performanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class SynonymsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["tagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["tagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class WarmNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class ZoneInfos : Tea.TeaModel {
            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["status"] as? String {
                    self.status = value
                }
                if let value = dict["zoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var advancedDedicateMaster: Bool?

        public var advancedSetting: DescribeInstanceResponseBody.Result.AdvancedSetting?

        public var aliwsDicts: [DescribeInstanceResponseBody.Result.AliwsDicts]?

        public var archType: String?

        public var clientNodeConfiguration: DescribeInstanceResponseBody.Result.ClientNodeConfiguration?

        public var createdAt: String?

        public var dedicateMaster: Bool?

        public var description_: String?

        public var dictList: [DescribeInstanceResponseBody.Result.DictList]?

        public var domain: String?

        public var elasticDataNodeConfiguration: DescribeInstanceResponseBody.Result.ElasticDataNodeConfiguration?

        public var enableKibanaPrivateNetwork: Bool?

        public var enableKibanaPublicNetwork: Bool?

        public var enablePublic: Bool?

        public var endTime: Int64?

        public var esConfig: [String: Any]?

        public var esIPBlacklist: [String]?

        public var esIPWhitelist: [String]?

        public var esVersion: String?

        public var extendConfigs: [[String: Any]]?

        public var haveClientNode: Bool?

        public var haveKibana: Bool?

        public var ikHotDicts: [DescribeInstanceResponseBody.Result.IkHotDicts]?

        public var instanceCategory: String?

        public var instanceId: String?

        public var isNewDeployment: Bool?

        public var kibanaConfiguration: DescribeInstanceResponseBody.Result.KibanaConfiguration?

        public var kibanaDomain: String?

        public var kibanaIPWhitelist: [String]?

        public var kibanaPort: Int32?

        public var kibanaPrivateDomain: String?

        public var kibanaPrivateIPWhitelist: [String]?

        public var kibanaPrivatePort: String?

        public var masterConfiguration: DescribeInstanceResponseBody.Result.MasterConfiguration?

        public var networkConfig: DescribeInstanceResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: DescribeInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var port: Int32?

        public var postpaidServiceStatus: String?

        public var privateNetworkIpWhiteList: [String]?

        public var protocol_: String?

        public var publicDomain: String?

        public var publicIpWhitelist: [String]?

        public var publicPort: Int32?

        public var resourceGroupId: String?

        public var serviceVpc: Bool?

        public var status: String?

        public var synonymsDicts: [DescribeInstanceResponseBody.Result.SynonymsDicts]?

        public var tags: [DescribeInstanceResponseBody.Result.Tags]?

        public var updatedAt: String?

        public var vpcInstanceId: String?

        public var warmNode: Bool?

        public var warmNodeConfiguration: DescribeInstanceResponseBody.Result.WarmNodeConfiguration?

        public var zoneCount: Int32?

        public var zoneInfos: [DescribeInstanceResponseBody.Result.ZoneInfos]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.advancedSetting?.validate()
            try self.clientNodeConfiguration?.validate()
            try self.elasticDataNodeConfiguration?.validate()
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
            try self.warmNodeConfiguration?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advancedDedicateMaster != nil {
                map["advancedDedicateMaster"] = self.advancedDedicateMaster!
            }
            if self.advancedSetting != nil {
                map["advancedSetting"] = self.advancedSetting?.toMap()
            }
            if self.aliwsDicts != nil {
                var tmp : [Any] = []
                for k in self.aliwsDicts! {
                    tmp.append(k.toMap())
                }
                map["aliwsDicts"] = tmp
            }
            if self.archType != nil {
                map["archType"] = self.archType!
            }
            if self.clientNodeConfiguration != nil {
                map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.dedicateMaster != nil {
                map["dedicateMaster"] = self.dedicateMaster!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.dictList != nil {
                var tmp : [Any] = []
                for k in self.dictList! {
                    tmp.append(k.toMap())
                }
                map["dictList"] = tmp
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.elasticDataNodeConfiguration != nil {
                map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
            }
            if self.enableKibanaPrivateNetwork != nil {
                map["enableKibanaPrivateNetwork"] = self.enableKibanaPrivateNetwork!
            }
            if self.enableKibanaPublicNetwork != nil {
                map["enableKibanaPublicNetwork"] = self.enableKibanaPublicNetwork!
            }
            if self.enablePublic != nil {
                map["enablePublic"] = self.enablePublic!
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.esConfig != nil {
                map["esConfig"] = self.esConfig!
            }
            if self.esIPBlacklist != nil {
                map["esIPBlacklist"] = self.esIPBlacklist!
            }
            if self.esIPWhitelist != nil {
                map["esIPWhitelist"] = self.esIPWhitelist!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.extendConfigs != nil {
                map["extendConfigs"] = self.extendConfigs!
            }
            if self.haveClientNode != nil {
                map["haveClientNode"] = self.haveClientNode!
            }
            if self.haveKibana != nil {
                map["haveKibana"] = self.haveKibana!
            }
            if self.ikHotDicts != nil {
                var tmp : [Any] = []
                for k in self.ikHotDicts! {
                    tmp.append(k.toMap())
                }
                map["ikHotDicts"] = tmp
            }
            if self.instanceCategory != nil {
                map["instanceCategory"] = self.instanceCategory!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.isNewDeployment != nil {
                map["isNewDeployment"] = self.isNewDeployment!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaDomain != nil {
                map["kibanaDomain"] = self.kibanaDomain!
            }
            if self.kibanaIPWhitelist != nil {
                map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
            }
            if self.kibanaPort != nil {
                map["kibanaPort"] = self.kibanaPort!
            }
            if self.kibanaPrivateDomain != nil {
                map["kibanaPrivateDomain"] = self.kibanaPrivateDomain!
            }
            if self.kibanaPrivateIPWhitelist != nil {
                map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
            }
            if self.kibanaPrivatePort != nil {
                map["kibanaPrivatePort"] = self.kibanaPrivatePort!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.postpaidServiceStatus != nil {
                map["postpaidServiceStatus"] = self.postpaidServiceStatus!
            }
            if self.privateNetworkIpWhiteList != nil {
                map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
            }
            if self.protocol_ != nil {
                map["protocol"] = self.protocol_!
            }
            if self.publicDomain != nil {
                map["publicDomain"] = self.publicDomain!
            }
            if self.publicIpWhitelist != nil {
                map["publicIpWhitelist"] = self.publicIpWhitelist!
            }
            if self.publicPort != nil {
                map["publicPort"] = self.publicPort!
            }
            if self.resourceGroupId != nil {
                map["resourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceVpc != nil {
                map["serviceVpc"] = self.serviceVpc!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.synonymsDicts != nil {
                var tmp : [Any] = []
                for k in self.synonymsDicts! {
                    tmp.append(k.toMap())
                }
                map["synonymsDicts"] = tmp
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.vpcInstanceId != nil {
                map["vpcInstanceId"] = self.vpcInstanceId!
            }
            if self.warmNode != nil {
                map["warmNode"] = self.warmNode!
            }
            if self.warmNodeConfiguration != nil {
                map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
            }
            if self.zoneCount != nil {
                map["zoneCount"] = self.zoneCount!
            }
            if self.zoneInfos != nil {
                var tmp : [Any] = []
                for k in self.zoneInfos! {
                    tmp.append(k.toMap())
                }
                map["zoneInfos"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["advancedDedicateMaster"] as? Bool {
                self.advancedDedicateMaster = value
            }
            if let value = dict["advancedSetting"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.AdvancedSetting()
                model.fromMap(value)
                self.advancedSetting = model
            }
            if let value = dict["aliwsDicts"] as? [Any?] {
                var tmp : [DescribeInstanceResponseBody.Result.AliwsDicts] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceResponseBody.Result.AliwsDicts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.aliwsDicts = tmp
            }
            if let value = dict["archType"] as? String {
                self.archType = value
            }
            if let value = dict["clientNodeConfiguration"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.ClientNodeConfiguration()
                model.fromMap(value)
                self.clientNodeConfiguration = model
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["dedicateMaster"] as? Bool {
                self.dedicateMaster = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["dictList"] as? [Any?] {
                var tmp : [DescribeInstanceResponseBody.Result.DictList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceResponseBody.Result.DictList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dictList = tmp
            }
            if let value = dict["domain"] as? String {
                self.domain = value
            }
            if let value = dict["elasticDataNodeConfiguration"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.ElasticDataNodeConfiguration()
                model.fromMap(value)
                self.elasticDataNodeConfiguration = model
            }
            if let value = dict["enableKibanaPrivateNetwork"] as? Bool {
                self.enableKibanaPrivateNetwork = value
            }
            if let value = dict["enableKibanaPublicNetwork"] as? Bool {
                self.enableKibanaPublicNetwork = value
            }
            if let value = dict["enablePublic"] as? Bool {
                self.enablePublic = value
            }
            if let value = dict["endTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["esConfig"] as? [String: Any] {
                self.esConfig = value
            }
            if let value = dict["esIPBlacklist"] as? [String] {
                self.esIPBlacklist = value
            }
            if let value = dict["esIPWhitelist"] as? [String] {
                self.esIPWhitelist = value
            }
            if let value = dict["esVersion"] as? String {
                self.esVersion = value
            }
            if let value = dict["extendConfigs"] as? [[String: Any]] {
                self.extendConfigs = value
            }
            if let value = dict["haveClientNode"] as? Bool {
                self.haveClientNode = value
            }
            if let value = dict["haveKibana"] as? Bool {
                self.haveKibana = value
            }
            if let value = dict["ikHotDicts"] as? [Any?] {
                var tmp : [DescribeInstanceResponseBody.Result.IkHotDicts] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceResponseBody.Result.IkHotDicts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ikHotDicts = tmp
            }
            if let value = dict["instanceCategory"] as? String {
                self.instanceCategory = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["isNewDeployment"] as? Bool {
                self.isNewDeployment = value
            }
            if let value = dict["kibanaConfiguration"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(value)
                self.kibanaConfiguration = model
            }
            if let value = dict["kibanaDomain"] as? String {
                self.kibanaDomain = value
            }
            if let value = dict["kibanaIPWhitelist"] as? [String] {
                self.kibanaIPWhitelist = value
            }
            if let value = dict["kibanaPort"] as? Int32 {
                self.kibanaPort = value
            }
            if let value = dict["kibanaPrivateDomain"] as? String {
                self.kibanaPrivateDomain = value
            }
            if let value = dict["kibanaPrivateIPWhitelist"] as? [String] {
                self.kibanaPrivateIPWhitelist = value
            }
            if let value = dict["kibanaPrivatePort"] as? String {
                self.kibanaPrivatePort = value
            }
            if let value = dict["masterConfiguration"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(value)
                self.masterConfiguration = model
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
            if let value = dict["nodeAmount"] as? Int32 {
                self.nodeAmount = value
            }
            if let value = dict["nodeSpec"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.NodeSpec()
                model.fromMap(value)
                self.nodeSpec = model
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
            if let value = dict["postpaidServiceStatus"] as? String {
                self.postpaidServiceStatus = value
            }
            if let value = dict["privateNetworkIpWhiteList"] as? [String] {
                self.privateNetworkIpWhiteList = value
            }
            if let value = dict["protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["publicDomain"] as? String {
                self.publicDomain = value
            }
            if let value = dict["publicIpWhitelist"] as? [String] {
                self.publicIpWhitelist = value
            }
            if let value = dict["publicPort"] as? Int32 {
                self.publicPort = value
            }
            if let value = dict["resourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["serviceVpc"] as? Bool {
                self.serviceVpc = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["synonymsDicts"] as? [Any?] {
                var tmp : [DescribeInstanceResponseBody.Result.SynonymsDicts] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceResponseBody.Result.SynonymsDicts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.synonymsDicts = tmp
            }
            if let value = dict["tags"] as? [Any?] {
                var tmp : [DescribeInstanceResponseBody.Result.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceResponseBody.Result.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["vpcInstanceId"] as? String {
                self.vpcInstanceId = value
            }
            if let value = dict["warmNode"] as? Bool {
                self.warmNode = value
            }
            if let value = dict["warmNodeConfiguration"] as? [String: Any?] {
                var model = DescribeInstanceResponseBody.Result.WarmNodeConfiguration()
                model.fromMap(value)
                self.warmNodeConfiguration = model
            }
            if let value = dict["zoneCount"] as? Int32 {
                self.zoneCount = value
            }
            if let value = dict["zoneInfos"] as? [Any?] {
                var tmp : [DescribeInstanceResponseBody.Result.ZoneInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeInstanceResponseBody.Result.ZoneInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.zoneInfos = tmp
            }
        }
    }
    public var requestId: String?

    public var result: DescribeInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeInstanceResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeKibanaSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String: Any]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any] {
            self.result = value
        }
    }
}

public class DescribeKibanaSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKibanaSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeKibanaSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeLogstashResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["tagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["tagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class ZoneInfos : Tea.TeaModel {
            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["status"] as? String {
                    self.status = value
                }
                if let value = dict["zoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public class EndpointList : Tea.TeaModel {
            public var host: String?

            public var port: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.port != nil {
                    map["port"] = self.port!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["host"] as? String {
                    self.host = value
                }
                if let value = dict["port"] as? String {
                    self.port = value
                }
                if let value = dict["zoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vsArea"] as? String {
                    self.vsArea = value
                }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public var extendConfigs: [[String: Any]]?

        public var resourceGroupId: String?

        public var tags: [DescribeLogstashResponseBody.Result.Tags]?

        public var zoneInfos: [DescribeLogstashResponseBody.Result.ZoneInfos]?

        public var config: [String: Any]?

        public var createdAt: String?

        public var description_: String?

        public var endpointList: [DescribeLogstashResponseBody.Result.EndpointList]?

        public var instanceId: String?

        public var networkConfig: DescribeLogstashResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: DescribeLogstashResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var status: String?

        public var updatedAt: String?

        public var version: String?

        public var vpcInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.extendConfigs != nil {
                map["ExtendConfigs"] = self.extendConfigs!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.zoneInfos != nil {
                var tmp : [Any] = []
                for k in self.zoneInfos! {
                    tmp.append(k.toMap())
                }
                map["ZoneInfos"] = tmp
            }
            if self.config != nil {
                map["config"] = self.config!
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endpointList != nil {
                var tmp : [Any] = []
                for k in self.endpointList! {
                    tmp.append(k.toMap())
                }
                map["endpointList"] = tmp
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            if self.vpcInstanceId != nil {
                map["vpcInstanceId"] = self.vpcInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ExtendConfigs"] as? [[String: Any]] {
                self.extendConfigs = value
            }
            if let value = dict["ResourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [DescribeLogstashResponseBody.Result.Tags] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLogstashResponseBody.Result.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["ZoneInfos"] as? [Any?] {
                var tmp : [DescribeLogstashResponseBody.Result.ZoneInfos] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLogstashResponseBody.Result.ZoneInfos()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.zoneInfos = tmp
            }
            if let value = dict["config"] as? [String: Any] {
                self.config = value
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["endpointList"] as? [Any?] {
                var tmp : [DescribeLogstashResponseBody.Result.EndpointList] = []
                for v in value {
                    if v != nil {
                        var model = DescribeLogstashResponseBody.Result.EndpointList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.endpointList = tmp
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = DescribeLogstashResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
            if let value = dict["nodeAmount"] as? Int32 {
                self.nodeAmount = value
            }
            if let value = dict["nodeSpec"] as? [String: Any?] {
                var model = DescribeLogstashResponseBody.Result.NodeSpec()
                model.fromMap(value)
                self.nodeSpec = model
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
            if let value = dict["vpcInstanceId"] as? String {
                self.vpcInstanceId = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeLogstashResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeLogstashResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeLogstashResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePipelineResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var batchDelay: Int32?

        public var batchSize: Int32?

        public var config: String?

        public var description_: String?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var pipelineId: String?

        public var pipelineStatus: String?

        public var queueCheckPointWrites: Int32?

        public var queueMaxBytes: Int32?

        public var queueType: String?

        public var workers: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.batchDelay != nil {
                map["batchDelay"] = self.batchDelay!
            }
            if self.batchSize != nil {
                map["batchSize"] = self.batchSize!
            }
            if self.config != nil {
                map["config"] = self.config!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineStatus != nil {
                map["pipelineStatus"] = self.pipelineStatus!
            }
            if self.queueCheckPointWrites != nil {
                map["queueCheckPointWrites"] = self.queueCheckPointWrites!
            }
            if self.queueMaxBytes != nil {
                map["queueMaxBytes"] = self.queueMaxBytes!
            }
            if self.queueType != nil {
                map["queueType"] = self.queueType!
            }
            if self.workers != nil {
                map["workers"] = self.workers!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["batchDelay"] as? Int32 {
                self.batchDelay = value
            }
            if let value = dict["batchSize"] as? Int32 {
                self.batchSize = value
            }
            if let value = dict["config"] as? String {
                self.config = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["gmtCreatedTime"] as? String {
                self.gmtCreatedTime = value
            }
            if let value = dict["gmtUpdateTime"] as? String {
                self.gmtUpdateTime = value
            }
            if let value = dict["pipelineId"] as? String {
                self.pipelineId = value
            }
            if let value = dict["pipelineStatus"] as? String {
                self.pipelineStatus = value
            }
            if let value = dict["queueCheckPointWrites"] as? Int32 {
                self.queueCheckPointWrites = value
            }
            if let value = dict["queueMaxBytes"] as? Int32 {
                self.queueMaxBytes = value
            }
            if let value = dict["queueType"] as? String {
                self.queueType = value
            }
            if let value = dict["workers"] as? Int32 {
                self.workers = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribePipelineResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribePipelineResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribePipelineManagementConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class DescribePipelineManagementConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var endpoints: String?

        public var esInstanceId: String?

        public var pipelineIds: [String]?

        public var pipelineManagementType: String?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endpoints != nil {
                map["endpoints"] = self.endpoints!
            }
            if self.esInstanceId != nil {
                map["esInstanceId"] = self.esInstanceId!
            }
            if self.pipelineIds != nil {
                map["pipelineIds"] = self.pipelineIds!
            }
            if self.pipelineManagementType != nil {
                map["pipelineManagementType"] = self.pipelineManagementType!
            }
            if self.userName != nil {
                map["userName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["endpoints"] as? String {
                self.endpoints = value
            }
            if let value = dict["esInstanceId"] as? String {
                self.esInstanceId = value
            }
            if let value = dict["pipelineIds"] as? [String] {
                self.pipelineIds = value
            }
            if let value = dict["pipelineManagementType"] as? String {
                self.pipelineManagementType = value
            }
            if let value = dict["userName"] as? String {
                self.userName = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribePipelineManagementConfigResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribePipelineManagementConfigResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribePipelineManagementConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePipelineManagementConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribePipelineManagementConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var consoleEndpoint: String?

        public var localName: String?

        public var regionEndpoint: String?

        public var regionId: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.consoleEndpoint != nil {
                map["consoleEndpoint"] = self.consoleEndpoint!
            }
            if self.localName != nil {
                map["localName"] = self.localName!
            }
            if self.regionEndpoint != nil {
                map["regionEndpoint"] = self.regionEndpoint!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["consoleEndpoint"] as? String {
                self.consoleEndpoint = value
            }
            if let value = dict["localName"] as? String {
                self.localName = value
            }
            if let value = dict["regionEndpoint"] as? String {
                self.regionEndpoint = value
            }
            if let value = dict["regionId"] as? String {
                self.regionId = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeRegionsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [DescribeRegionsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = DescribeRegionsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeRegionsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeSnapshotSettingResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var quartzRegex: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["Enable"] = self.enable!
            }
            if self.quartzRegex != nil {
                map["QuartzRegex"] = self.quartzRegex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["QuartzRegex"] as? String {
                self.quartzRegex = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeSnapshotSettingResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeSnapshotSettingResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeSnapshotSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeSnapshotSettingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["templateName"] as? String {
                self.templateName = value
            }
        }
    }
    public var requestId: String?

    public var result: [DescribeTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [DescribeTemplatesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = DescribeTemplatesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class DescribeTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DescribeXpackMonitorConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var endpoints: [String]?

        public var esInstanceId: String?

        public var pipelineIds: [String]?

        public var userName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.endpoints != nil {
                map["endpoints"] = self.endpoints!
            }
            if self.esInstanceId != nil {
                map["esInstanceId"] = self.esInstanceId!
            }
            if self.pipelineIds != nil {
                map["pipelineIds"] = self.pipelineIds!
            }
            if self.userName != nil {
                map["userName"] = self.userName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["endpoints"] as? [String] {
                self.endpoints = value
            }
            if let value = dict["esInstanceId"] as? String {
                self.esInstanceId = value
            }
            if let value = dict["pipelineIds"] as? [String] {
                self.pipelineIds = value
            }
            if let value = dict["userName"] as? String {
                self.userName = value
            }
        }
    }
    public var requestId: String?

    public var result: DescribeXpackMonitorConfigResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DescribeXpackMonitorConfigResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DescribeXpackMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeXpackMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DescribeXpackMonitorConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DiagnoseInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diagnoseItems: [String]?

    public var indices: [String]?

    public var type: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diagnoseItems != nil {
            map["diagnoseItems"] = self.diagnoseItems!
        }
        if self.indices != nil {
            map["indices"] = self.indices!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["diagnoseItems"] as? [String] {
            self.diagnoseItems = value
        }
        if let value = dict["indices"] as? [String] {
            self.indices = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class DiagnoseInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var createTime: Int64?

        public var instanceId: String?

        public var reportId: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.reportId != nil {
                map["reportId"] = self.reportId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["reportId"] as? String {
                self.reportId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var requestId: String?

    public var result: DiagnoseInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = DiagnoseInstanceResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class DiagnoseInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DiagnoseInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DiagnoseInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class DisableKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class DisableKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = DisableKibanaPvlNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EnableKibanaPvlNetworkRequest : Tea.TeaModel {
    public class VSwitchIdsZone : Tea.TeaModel {
        public var vswitchId: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["vswitchId"] as? String {
                self.vswitchId = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var endpointName: String?

    public var securityGroups: [String]?

    public var vSwitchIdsZone: [EnableKibanaPvlNetworkRequest.VSwitchIdsZone]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointName != nil {
            map["endpointName"] = self.endpointName!
        }
        if self.securityGroups != nil {
            map["securityGroups"] = self.securityGroups!
        }
        if self.vSwitchIdsZone != nil {
            var tmp : [Any] = []
            for k in self.vSwitchIdsZone! {
                tmp.append(k.toMap())
            }
            map["vSwitchIdsZone"] = tmp
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endpointName"] as? String {
            self.endpointName = value
        }
        if let value = dict["securityGroups"] as? [String] {
            self.securityGroups = value
        }
        if let value = dict["vSwitchIdsZone"] as? [Any?] {
            var tmp : [EnableKibanaPvlNetworkRequest.VSwitchIdsZone] = []
            for v in value {
                if v != nil {
                    var model = EnableKibanaPvlNetworkRequest.VSwitchIdsZone()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.vSwitchIdsZone = tmp
        }
        if let value = dict["vpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class EnableKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class EnableKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EnableKibanaPvlNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EstimatedLogstashRestartTimeRequest : Tea.TeaModel {
    public var body: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
    }
}

public class EstimatedLogstashRestartTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var unit: String?

        public var value: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.unit != nil {
                map["unit"] = self.unit!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["unit"] as? String {
                self.unit = value
            }
            if let value = dict["value"] as? Int64 {
                self.value = value
            }
        }
    }
    public var requestId: String?

    public var result: EstimatedLogstashRestartTimeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = EstimatedLogstashRestartTimeResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class EstimatedLogstashRestartTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EstimatedLogstashRestartTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EstimatedLogstashRestartTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class EstimatedRestartTimeRequest : Tea.TeaModel {
    public var body: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
    }
}

public class EstimatedRestartTimeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var unit: String?

        public var value: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.unit != nil {
                map["unit"] = self.unit!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["unit"] as? String {
                self.unit = value
            }
            if let value = dict["value"] as? Int64 {
                self.value = value
            }
        }
    }
    public var requestId: String?

    public var result: EstimatedRestartTimeResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = EstimatedRestartTimeResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class EstimatedRestartTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EstimatedRestartTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = EstimatedRestartTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetClusterDataInformationRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class GetClusterDataInformationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class MetaInfo : Tea.TeaModel {
            public var fields: [String]?

            public var indices: [String]?

            public var mapping: String?

            public var settings: String?

            public var typeName: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fields != nil {
                    map["fields"] = self.fields!
                }
                if self.indices != nil {
                    map["indices"] = self.indices!
                }
                if self.mapping != nil {
                    map["mapping"] = self.mapping!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                if self.typeName != nil {
                    map["typeName"] = self.typeName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fields"] as? [String] {
                    self.fields = value
                }
                if let value = dict["indices"] as? [String] {
                    self.indices = value
                }
                if let value = dict["mapping"] as? String {
                    self.mapping = value
                }
                if let value = dict["settings"] as? String {
                    self.settings = value
                }
                if let value = dict["typeName"] as? [String] {
                    self.typeName = value
                }
            }
        }
        public var connectable: Bool?

        public var metaInfo: GetClusterDataInformationResponseBody.Result.MetaInfo?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.metaInfo?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectable != nil {
                map["connectable"] = self.connectable!
            }
            if self.metaInfo != nil {
                map["metaInfo"] = self.metaInfo?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["connectable"] as? Bool {
                self.connectable = value
            }
            if let value = dict["metaInfo"] as? [String: Any?] {
                var model = GetClusterDataInformationResponseBody.Result.MetaInfo()
                model.fromMap(value)
                self.metaInfo = model
            }
        }
    }
    public var requestId: String?

    public var result: GetClusterDataInformationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetClusterDataInformationResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetClusterDataInformationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetClusterDataInformationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetClusterDataInformationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetElastictaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ElasticExpansionTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cronExpression"] as? String {
                    self.cronExpression = value
                }
                if let value = dict["elasticNodeCount"] as? Int32 {
                    self.elasticNodeCount = value
                }
                if let value = dict["replicaCount"] as? Int32 {
                    self.replicaCount = value
                }
                if let value = dict["targetIndices"] as? [String] {
                    self.targetIndices = value
                }
                if let value = dict["triggerType"] as? String {
                    self.triggerType = value
                }
            }
        }
        public class ElasticShrinkTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cronExpression"] as? String {
                    self.cronExpression = value
                }
                if let value = dict["elasticNodeCount"] as? Int32 {
                    self.elasticNodeCount = value
                }
                if let value = dict["replicaCount"] as? Int32 {
                    self.replicaCount = value
                }
                if let value = dict["targetIndices"] as? [String] {
                    self.targetIndices = value
                }
                if let value = dict["triggerType"] as? String {
                    self.triggerType = value
                }
            }
        }
        public var elasticExpansionTask: GetElastictaskResponseBody.Result.ElasticExpansionTask?

        public var elasticShrinkTask: GetElastictaskResponseBody.Result.ElasticShrinkTask?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.elasticExpansionTask?.validate()
            try self.elasticShrinkTask?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticExpansionTask != nil {
                map["elasticExpansionTask"] = self.elasticExpansionTask?.toMap()
            }
            if self.elasticShrinkTask != nil {
                map["elasticShrinkTask"] = self.elasticShrinkTask?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["elasticExpansionTask"] as? [String: Any?] {
                var model = GetElastictaskResponseBody.Result.ElasticExpansionTask()
                model.fromMap(value)
                self.elasticExpansionTask = model
            }
            if let value = dict["elasticShrinkTask"] as? [String: Any?] {
                var model = GetElastictaskResponseBody.Result.ElasticShrinkTask()
                model.fromMap(value)
                self.elasticShrinkTask = model
            }
        }
    }
    public var requestId: String?

    public var result: GetElastictaskResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetElastictaskResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetElastictaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetElastictaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetElastictaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEmonGrafanaAlertsRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class GetEmonGrafanaAlertsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetEmonGrafanaAlertsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEmonGrafanaAlertsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEmonGrafanaAlertsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEmonGrafanaDashboardsRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class GetEmonGrafanaDashboardsResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetEmonGrafanaDashboardsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEmonGrafanaDashboardsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEmonGrafanaDashboardsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetEmonMonitorDataRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class GetEmonMonitorDataResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var dps: [String: Any]?

        public var integrity: Double?

        public var messageWatermark: Int64?

        public var metric: String?

        public var summary: Double?

        public var tags: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dps != nil {
                map["dps"] = self.dps!
            }
            if self.integrity != nil {
                map["integrity"] = self.integrity!
            }
            if self.messageWatermark != nil {
                map["messageWatermark"] = self.messageWatermark!
            }
            if self.metric != nil {
                map["metric"] = self.metric!
            }
            if self.summary != nil {
                map["summary"] = self.summary!
            }
            if self.tags != nil {
                map["tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["dps"] as? [String: Any] {
                self.dps = value
            }
            if let value = dict["integrity"] as? Double {
                self.integrity = value
            }
            if let value = dict["messageWatermark"] as? Int64 {
                self.messageWatermark = value
            }
            if let value = dict["metric"] as? String {
                self.metric = value
            }
            if let value = dict["summary"] as? Double {
                self.summary = value
            }
            if let value = dict["tags"] as? [String: Any] {
                self.tags = value
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: [GetEmonMonitorDataResponseBody.Result]?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [GetEmonMonitorDataResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = GetEmonMonitorDataResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class GetEmonMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetEmonMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetEmonMonitorDataResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetOpenStoreUsageResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var currentUsage: Int64?

        public var lastDayUsage: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.currentUsage != nil {
                map["currentUsage"] = self.currentUsage!
            }
            if self.lastDayUsage != nil {
                map["lastDayUsage"] = self.lastDayUsage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["currentUsage"] as? Int64 {
                self.currentUsage = value
            }
            if let value = dict["lastDayUsage"] as? Int64 {
                self.lastDayUsage = value
            }
        }
    }
    public var requestId: String?

    public var result: GetOpenStoreUsageResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetOpenStoreUsageResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetOpenStoreUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetOpenStoreUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetOpenStoreUsageResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRegionConfigurationRequest : Tea.TeaModel {
    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["zoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class GetRegionConfigurationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ClientNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["maxAmount"] as? Int32 {
                    self.maxAmount = value
                }
                if let value = dict["minAmount"] as? Int32 {
                    self.minAmount = value
                }
            }
        }
        public class ClientNodeDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["maxSize"] as? Int32 {
                    self.maxSize = value
                }
                if let value = dict["minSize"] as? Int32 {
                    self.minSize = value
                }
                if let value = dict["scaleLimit"] as? Int32 {
                    self.scaleLimit = value
                }
            }
        }
        public class DataDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var valueLimitSet: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.valueLimitSet != nil {
                    map["valueLimitSet"] = self.valueLimitSet!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["maxSize"] as? Int32 {
                    self.maxSize = value
                }
                if let value = dict["minSize"] as? Int32 {
                    self.minSize = value
                }
                if let value = dict["scaleLimit"] as? Int32 {
                    self.scaleLimit = value
                }
                if let value = dict["valueLimitSet"] as? [String] {
                    self.valueLimitSet = value
                }
            }
        }
        public class ElasticNodeProperties : Tea.TeaModel {
            public class AmountRange : Tea.TeaModel {
                public var maxAmount: Int32?

                public var minAmount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxAmount != nil {
                        map["maxAmount"] = self.maxAmount!
                    }
                    if self.minAmount != nil {
                        map["minAmount"] = self.minAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["maxAmount"] as? Int32 {
                        self.maxAmount = value
                    }
                    if let value = dict["minAmount"] as? Int32 {
                        self.minAmount = value
                    }
                }
            }
            public class DiskList : Tea.TeaModel {
                public var diskEncryption: Bool?

                public var diskType: String?

                public var maxSize: Int32?

                public var minSize: Int32?

                public var scaleLimit: Int32?

                public var valueLimitSet: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskEncryption != nil {
                        map["diskEncryption"] = self.diskEncryption!
                    }
                    if self.diskType != nil {
                        map["diskType"] = self.diskType!
                    }
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.scaleLimit != nil {
                        map["scaleLimit"] = self.scaleLimit!
                    }
                    if self.valueLimitSet != nil {
                        map["valueLimitSet"] = self.valueLimitSet!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["diskEncryption"] as? Bool {
                        self.diskEncryption = value
                    }
                    if let value = dict["diskType"] as? String {
                        self.diskType = value
                    }
                    if let value = dict["maxSize"] as? Int32 {
                        self.maxSize = value
                    }
                    if let value = dict["minSize"] as? Int32 {
                        self.minSize = value
                    }
                    if let value = dict["scaleLimit"] as? Int32 {
                        self.scaleLimit = value
                    }
                    if let value = dict["valueLimitSet"] as? [String] {
                        self.valueLimitSet = value
                    }
                }
            }
            public var amountRange: GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.AmountRange?

            public var diskList: [GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.DiskList]?

            public var spec: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.amountRange?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amountRange != nil {
                    map["amountRange"] = self.amountRange?.toMap()
                }
                if self.diskList != nil {
                    var tmp : [Any] = []
                    for k in self.diskList! {
                        tmp.append(k.toMap())
                    }
                    map["diskList"] = tmp
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amountRange"] as? [String: Any?] {
                    var model = GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.AmountRange()
                    model.fromMap(value)
                    self.amountRange = model
                }
                if let value = dict["diskList"] as? [Any?] {
                    var tmp : [GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.DiskList] = []
                    for v in value {
                        if v != nil {
                            var model = GetRegionConfigurationResponseBody.Result.ElasticNodeProperties.DiskList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.diskList = tmp
                }
                if let value = dict["spec"] as? [String] {
                    self.spec = value
                }
            }
        }
        public class EsVersionsLatestList : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["key"] = self.key!
                }
                if self.value != nil {
                    map["value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["key"] as? String {
                    self.key = value
                }
                if let value = dict["value"] as? String {
                    self.value = value
                }
            }
        }
        public class JvmConfine : Tea.TeaModel {
            public var memory: Int32?

            public var supportEsVersions: [String]?

            public var supportGcs: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memory != nil {
                    map["memory"] = self.memory!
                }
                if self.supportEsVersions != nil {
                    map["supportEsVersions"] = self.supportEsVersions!
                }
                if self.supportGcs != nil {
                    map["supportGcs"] = self.supportGcs!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["memory"] as? Int32 {
                    self.memory = value
                }
                if let value = dict["supportEsVersions"] as? [String] {
                    self.supportEsVersions = value
                }
                if let value = dict["supportGcs"] as? [String] {
                    self.supportGcs = value
                }
            }
        }
        public class KibanaNodeProperties : Tea.TeaModel {
            public class AmountRange : Tea.TeaModel {
                public var maxAmount: Int32?

                public var minAmount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxAmount != nil {
                        map["maxAmount"] = self.maxAmount!
                    }
                    if self.minAmount != nil {
                        map["minAmount"] = self.minAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["maxAmount"] as? Int32 {
                        self.maxAmount = value
                    }
                    if let value = dict["minAmount"] as? Int32 {
                        self.minAmount = value
                    }
                }
            }
            public var amountRange: GetRegionConfigurationResponseBody.Result.KibanaNodeProperties.AmountRange?

            public var spec: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.amountRange?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amountRange != nil {
                    map["amountRange"] = self.amountRange?.toMap()
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amountRange"] as? [String: Any?] {
                    var model = GetRegionConfigurationResponseBody.Result.KibanaNodeProperties.AmountRange()
                    model.fromMap(value)
                    self.amountRange = model
                }
                if let value = dict["spec"] as? [String] {
                    self.spec = value
                }
            }
        }
        public class MasterDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["maxSize"] as? Int32 {
                    self.maxSize = value
                }
                if let value = dict["minSize"] as? Int32 {
                    self.minSize = value
                }
                if let value = dict["scaleLimit"] as? Int32 {
                    self.scaleLimit = value
                }
            }
        }
        public class Node : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["maxAmount"] as? Int32 {
                    self.maxAmount = value
                }
                if let value = dict["minAmount"] as? Int32 {
                    self.minAmount = value
                }
            }
        }
        public class NodeSpecList : Tea.TeaModel {
            public var cpuCount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var enable: Bool?

            public var memorySize: Int32?

            public var spec: String?

            public var specGroupType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCount != nil {
                    map["cpuCount"] = self.cpuCount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.enable != nil {
                    map["enable"] = self.enable!
                }
                if self.memorySize != nil {
                    map["memorySize"] = self.memorySize!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specGroupType != nil {
                    map["specGroupType"] = self.specGroupType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cpuCount"] as? Int32 {
                    self.cpuCount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["enable"] as? Bool {
                    self.enable = value
                }
                if let value = dict["memorySize"] as? Int32 {
                    self.memorySize = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specGroupType"] as? String {
                    self.specGroupType = value
                }
            }
        }
        public class SupportVersions : Tea.TeaModel {
            public class SupportVersionList : Tea.TeaModel {
                public var key: String?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.key != nil {
                        map["key"] = self.key!
                    }
                    if self.value != nil {
                        map["value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["key"] as? String {
                        self.key = value
                    }
                    if let value = dict["value"] as? String {
                        self.value = value
                    }
                }
            }
            public var instanceCategory: String?

            public var supportVersionList: [GetRegionConfigurationResponseBody.Result.SupportVersions.SupportVersionList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceCategory != nil {
                    map["instanceCategory"] = self.instanceCategory!
                }
                if self.supportVersionList != nil {
                    var tmp : [Any] = []
                    for k in self.supportVersionList! {
                        tmp.append(k.toMap())
                    }
                    map["supportVersionList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["instanceCategory"] as? String {
                    self.instanceCategory = value
                }
                if let value = dict["supportVersionList"] as? [Any?] {
                    var tmp : [GetRegionConfigurationResponseBody.Result.SupportVersions.SupportVersionList] = []
                    for v in value {
                        if v != nil {
                            var model = GetRegionConfigurationResponseBody.Result.SupportVersions.SupportVersionList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.supportVersionList = tmp
                }
            }
        }
        public class WarmNodeProperties : Tea.TeaModel {
            public class AmountRange : Tea.TeaModel {
                public var maxAmount: Int32?

                public var minAmount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxAmount != nil {
                        map["maxAmount"] = self.maxAmount!
                    }
                    if self.minAmount != nil {
                        map["minAmount"] = self.minAmount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["maxAmount"] as? Int32 {
                        self.maxAmount = value
                    }
                    if let value = dict["minAmount"] as? Int32 {
                        self.minAmount = value
                    }
                }
            }
            public class DiskList : Tea.TeaModel {
                public var diskEncryption: Bool?

                public var diskType: String?

                public var maxSize: Int32?

                public var minSize: Int32?

                public var scaleLimit: Int32?

                public var valueLimitSet: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskEncryption != nil {
                        map["diskEncryption"] = self.diskEncryption!
                    }
                    if self.diskType != nil {
                        map["diskType"] = self.diskType!
                    }
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.scaleLimit != nil {
                        map["scaleLimit"] = self.scaleLimit!
                    }
                    if self.valueLimitSet != nil {
                        map["valueLimitSet"] = self.valueLimitSet!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["diskEncryption"] as? Bool {
                        self.diskEncryption = value
                    }
                    if let value = dict["diskType"] as? String {
                        self.diskType = value
                    }
                    if let value = dict["maxSize"] as? Int32 {
                        self.maxSize = value
                    }
                    if let value = dict["minSize"] as? Int32 {
                        self.minSize = value
                    }
                    if let value = dict["scaleLimit"] as? Int32 {
                        self.scaleLimit = value
                    }
                    if let value = dict["valueLimitSet"] as? [String] {
                        self.valueLimitSet = value
                    }
                }
            }
            public var amountRange: GetRegionConfigurationResponseBody.Result.WarmNodeProperties.AmountRange?

            public var diskList: [GetRegionConfigurationResponseBody.Result.WarmNodeProperties.DiskList]?

            public var spec: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.amountRange?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amountRange != nil {
                    map["amountRange"] = self.amountRange?.toMap()
                }
                if self.diskList != nil {
                    var tmp : [Any] = []
                    for k in self.diskList! {
                        tmp.append(k.toMap())
                    }
                    map["diskList"] = tmp
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amountRange"] as? [String: Any?] {
                    var model = GetRegionConfigurationResponseBody.Result.WarmNodeProperties.AmountRange()
                    model.fromMap(value)
                    self.amountRange = model
                }
                if let value = dict["diskList"] as? [Any?] {
                    var tmp : [GetRegionConfigurationResponseBody.Result.WarmNodeProperties.DiskList] = []
                    for v in value {
                        if v != nil {
                            var model = GetRegionConfigurationResponseBody.Result.WarmNodeProperties.DiskList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.diskList = tmp
                }
                if let value = dict["spec"] as? [String] {
                    self.spec = value
                }
            }
        }
        public var clientNodeAmountRange: GetRegionConfigurationResponseBody.Result.ClientNodeAmountRange?

        public var clientNodeDiskList: [GetRegionConfigurationResponseBody.Result.ClientNodeDiskList]?

        public var clientNodeSpec: [String]?

        public var createUrl: String?

        public var dataDiskList: [GetRegionConfigurationResponseBody.Result.DataDiskList]?

        public var elasticNodeProperties: GetRegionConfigurationResponseBody.Result.ElasticNodeProperties?

        public var env: String?

        public var esVersions: [String]?

        public var esVersionsLatestList: [GetRegionConfigurationResponseBody.Result.EsVersionsLatestList]?

        public var instanceSupportNodes: [String]?

        public var jvmConfine: GetRegionConfigurationResponseBody.Result.JvmConfine?

        public var kibanaNodeProperties: GetRegionConfigurationResponseBody.Result.KibanaNodeProperties?

        public var logstashZones: [String]?

        public var masterDiskList: [GetRegionConfigurationResponseBody.Result.MasterDiskList]?

        public var masterSpec: [String]?

        public var node: GetRegionConfigurationResponseBody.Result.Node?

        public var nodeSpecList: [GetRegionConfigurationResponseBody.Result.NodeSpecList]?

        public var regionId: String?

        public var supportVersions: [GetRegionConfigurationResponseBody.Result.SupportVersions]?

        public var warmNodeProperties: GetRegionConfigurationResponseBody.Result.WarmNodeProperties?

        public var zones: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clientNodeAmountRange?.validate()
            try self.elasticNodeProperties?.validate()
            try self.jvmConfine?.validate()
            try self.kibanaNodeProperties?.validate()
            try self.node?.validate()
            try self.warmNodeProperties?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientNodeAmountRange != nil {
                map["clientNodeAmountRange"] = self.clientNodeAmountRange?.toMap()
            }
            if self.clientNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.clientNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["clientNodeDiskList"] = tmp
            }
            if self.clientNodeSpec != nil {
                map["clientNodeSpec"] = self.clientNodeSpec!
            }
            if self.createUrl != nil {
                map["createUrl"] = self.createUrl!
            }
            if self.dataDiskList != nil {
                var tmp : [Any] = []
                for k in self.dataDiskList! {
                    tmp.append(k.toMap())
                }
                map["dataDiskList"] = tmp
            }
            if self.elasticNodeProperties != nil {
                map["elasticNodeProperties"] = self.elasticNodeProperties?.toMap()
            }
            if self.env != nil {
                map["env"] = self.env!
            }
            if self.esVersions != nil {
                map["esVersions"] = self.esVersions!
            }
            if self.esVersionsLatestList != nil {
                var tmp : [Any] = []
                for k in self.esVersionsLatestList! {
                    tmp.append(k.toMap())
                }
                map["esVersionsLatestList"] = tmp
            }
            if self.instanceSupportNodes != nil {
                map["instanceSupportNodes"] = self.instanceSupportNodes!
            }
            if self.jvmConfine != nil {
                map["jvmConfine"] = self.jvmConfine?.toMap()
            }
            if self.kibanaNodeProperties != nil {
                map["kibanaNodeProperties"] = self.kibanaNodeProperties?.toMap()
            }
            if self.logstashZones != nil {
                map["logstashZones"] = self.logstashZones!
            }
            if self.masterDiskList != nil {
                var tmp : [Any] = []
                for k in self.masterDiskList! {
                    tmp.append(k.toMap())
                }
                map["masterDiskList"] = tmp
            }
            if self.masterSpec != nil {
                map["masterSpec"] = self.masterSpec!
            }
            if self.node != nil {
                map["node"] = self.node?.toMap()
            }
            if self.nodeSpecList != nil {
                var tmp : [Any] = []
                for k in self.nodeSpecList! {
                    tmp.append(k.toMap())
                }
                map["nodeSpecList"] = tmp
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            if self.supportVersions != nil {
                var tmp : [Any] = []
                for k in self.supportVersions! {
                    tmp.append(k.toMap())
                }
                map["supportVersions"] = tmp
            }
            if self.warmNodeProperties != nil {
                map["warmNodeProperties"] = self.warmNodeProperties?.toMap()
            }
            if self.zones != nil {
                map["zones"] = self.zones!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["clientNodeAmountRange"] as? [String: Any?] {
                var model = GetRegionConfigurationResponseBody.Result.ClientNodeAmountRange()
                model.fromMap(value)
                self.clientNodeAmountRange = model
            }
            if let value = dict["clientNodeDiskList"] as? [Any?] {
                var tmp : [GetRegionConfigurationResponseBody.Result.ClientNodeDiskList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionConfigurationResponseBody.Result.ClientNodeDiskList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.clientNodeDiskList = tmp
            }
            if let value = dict["clientNodeSpec"] as? [String] {
                self.clientNodeSpec = value
            }
            if let value = dict["createUrl"] as? String {
                self.createUrl = value
            }
            if let value = dict["dataDiskList"] as? [Any?] {
                var tmp : [GetRegionConfigurationResponseBody.Result.DataDiskList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionConfigurationResponseBody.Result.DataDiskList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataDiskList = tmp
            }
            if let value = dict["elasticNodeProperties"] as? [String: Any?] {
                var model = GetRegionConfigurationResponseBody.Result.ElasticNodeProperties()
                model.fromMap(value)
                self.elasticNodeProperties = model
            }
            if let value = dict["env"] as? String {
                self.env = value
            }
            if let value = dict["esVersions"] as? [String] {
                self.esVersions = value
            }
            if let value = dict["esVersionsLatestList"] as? [Any?] {
                var tmp : [GetRegionConfigurationResponseBody.Result.EsVersionsLatestList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionConfigurationResponseBody.Result.EsVersionsLatestList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.esVersionsLatestList = tmp
            }
            if let value = dict["instanceSupportNodes"] as? [String] {
                self.instanceSupportNodes = value
            }
            if let value = dict["jvmConfine"] as? [String: Any?] {
                var model = GetRegionConfigurationResponseBody.Result.JvmConfine()
                model.fromMap(value)
                self.jvmConfine = model
            }
            if let value = dict["kibanaNodeProperties"] as? [String: Any?] {
                var model = GetRegionConfigurationResponseBody.Result.KibanaNodeProperties()
                model.fromMap(value)
                self.kibanaNodeProperties = model
            }
            if let value = dict["logstashZones"] as? [String] {
                self.logstashZones = value
            }
            if let value = dict["masterDiskList"] as? [Any?] {
                var tmp : [GetRegionConfigurationResponseBody.Result.MasterDiskList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionConfigurationResponseBody.Result.MasterDiskList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.masterDiskList = tmp
            }
            if let value = dict["masterSpec"] as? [String] {
                self.masterSpec = value
            }
            if let value = dict["node"] as? [String: Any?] {
                var model = GetRegionConfigurationResponseBody.Result.Node()
                model.fromMap(value)
                self.node = model
            }
            if let value = dict["nodeSpecList"] as? [Any?] {
                var tmp : [GetRegionConfigurationResponseBody.Result.NodeSpecList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionConfigurationResponseBody.Result.NodeSpecList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.nodeSpecList = tmp
            }
            if let value = dict["regionId"] as? String {
                self.regionId = value
            }
            if let value = dict["supportVersions"] as? [Any?] {
                var tmp : [GetRegionConfigurationResponseBody.Result.SupportVersions] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionConfigurationResponseBody.Result.SupportVersions()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.supportVersions = tmp
            }
            if let value = dict["warmNodeProperties"] as? [String: Any?] {
                var model = GetRegionConfigurationResponseBody.Result.WarmNodeProperties()
                model.fromMap(value)
                self.warmNodeProperties = model
            }
            if let value = dict["zones"] as? [String] {
                self.zones = value
            }
        }
    }
    public var requestId: String?

    public var result: GetRegionConfigurationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetRegionConfigurationResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetRegionConfigurationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRegionConfigurationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRegionConfigurationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetRegionalInstanceConfigResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ClientNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["maxAmount"] as? Int32 {
                    self.maxAmount = value
                }
                if let value = dict["minAmount"] as? Int32 {
                    self.minAmount = value
                }
            }
        }
        public class ClientNodeDiskList : Tea.TeaModel {
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["maxSize"] as? Int32 {
                    self.maxSize = value
                }
                if let value = dict["minSize"] as? Int32 {
                    self.minSize = value
                }
                if let value = dict["scaleLimit"] as? Int32 {
                    self.scaleLimit = value
                }
            }
        }
        public class DataNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["maxAmount"] as? Int32 {
                    self.maxAmount = value
                }
                if let value = dict["minAmount"] as? Int32 {
                    self.minAmount = value
                }
            }
        }
        public class DataNodeDiskList : Tea.TeaModel {
            public class SubClassificationConfines : Tea.TeaModel {
                public var maxSize: Int32?

                public var minSize: Int32?

                public var performanceLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.performanceLevel != nil {
                        map["performanceLevel"] = self.performanceLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["maxSize"] as? Int32 {
                        self.maxSize = value
                    }
                    if let value = dict["minSize"] as? Int32 {
                        self.minSize = value
                    }
                    if let value = dict["performanceLevel"] as? String {
                        self.performanceLevel = value
                    }
                }
            }
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var subClassificationConfines: [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList.SubClassificationConfines]?

            public var valueLimitSet: [Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.subClassificationConfines != nil {
                    var tmp : [Any] = []
                    for k in self.subClassificationConfines! {
                        tmp.append(k.toMap())
                    }
                    map["subClassificationConfines"] = tmp
                }
                if self.valueLimitSet != nil {
                    map["valueLimitSet"] = self.valueLimitSet!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["maxSize"] as? Int32 {
                    self.maxSize = value
                }
                if let value = dict["minSize"] as? Int32 {
                    self.minSize = value
                }
                if let value = dict["scaleLimit"] as? Int32 {
                    self.scaleLimit = value
                }
                if let value = dict["subClassificationConfines"] as? [Any?] {
                    var tmp : [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList.SubClassificationConfines] = []
                    for v in value {
                        if v != nil {
                            var model = GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList.SubClassificationConfines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.subClassificationConfines = tmp
                }
                if let value = dict["valueLimitSet"] as? [Int32] {
                    self.valueLimitSet = value
                }
            }
        }
        public class MasterDiskList : Tea.TeaModel {
            public class SubClassificationConfines : Tea.TeaModel {
                public var maxSize: Int32?

                public var minSize: Int32?

                public var performanceLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.performanceLevel != nil {
                        map["performanceLevel"] = self.performanceLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["maxSize"] as? Int32 {
                        self.maxSize = value
                    }
                    if let value = dict["minSize"] as? Int32 {
                        self.minSize = value
                    }
                    if let value = dict["performanceLevel"] as? String {
                        self.performanceLevel = value
                    }
                }
            }
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var subClassificationConfines: [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList.SubClassificationConfines]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.subClassificationConfines != nil {
                    var tmp : [Any] = []
                    for k in self.subClassificationConfines! {
                        tmp.append(k.toMap())
                    }
                    map["subClassificationConfines"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["maxSize"] as? Int32 {
                    self.maxSize = value
                }
                if let value = dict["minSize"] as? Int32 {
                    self.minSize = value
                }
                if let value = dict["scaleLimit"] as? Int32 {
                    self.scaleLimit = value
                }
                if let value = dict["subClassificationConfines"] as? [Any?] {
                    var tmp : [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList.SubClassificationConfines] = []
                    for v in value {
                        if v != nil {
                            var model = GetRegionalInstanceConfigResponseBody.Result.MasterDiskList.SubClassificationConfines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.subClassificationConfines = tmp
                }
            }
        }
        public class WarmNodeAmountRange : Tea.TeaModel {
            public var maxAmount: Int32?

            public var minAmount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.maxAmount != nil {
                    map["maxAmount"] = self.maxAmount!
                }
                if self.minAmount != nil {
                    map["minAmount"] = self.minAmount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["maxAmount"] as? Int32 {
                    self.maxAmount = value
                }
                if let value = dict["minAmount"] as? Int32 {
                    self.minAmount = value
                }
            }
        }
        public class WarmNodeDiskList : Tea.TeaModel {
            public class SubClassificationConfines : Tea.TeaModel {
                public var maxSize: Int32?

                public var minSize: Int32?

                public var performanceLevel: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maxSize != nil {
                        map["maxSize"] = self.maxSize!
                    }
                    if self.minSize != nil {
                        map["minSize"] = self.minSize!
                    }
                    if self.performanceLevel != nil {
                        map["performanceLevel"] = self.performanceLevel!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["maxSize"] as? Int32 {
                        self.maxSize = value
                    }
                    if let value = dict["minSize"] as? Int32 {
                        self.minSize = value
                    }
                    if let value = dict["performanceLevel"] as? String {
                        self.performanceLevel = value
                    }
                }
            }
            public var diskType: String?

            public var maxSize: Int32?

            public var minSize: Int32?

            public var scaleLimit: Int32?

            public var subClassificationConfines: [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList.SubClassificationConfines]?

            public var valueLimitSet: [Int32]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.maxSize != nil {
                    map["maxSize"] = self.maxSize!
                }
                if self.minSize != nil {
                    map["minSize"] = self.minSize!
                }
                if self.scaleLimit != nil {
                    map["scaleLimit"] = self.scaleLimit!
                }
                if self.subClassificationConfines != nil {
                    var tmp : [Any] = []
                    for k in self.subClassificationConfines! {
                        tmp.append(k.toMap())
                    }
                    map["subClassificationConfines"] = tmp
                }
                if self.valueLimitSet != nil {
                    map["valueLimitSet"] = self.valueLimitSet!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["maxSize"] as? Int32 {
                    self.maxSize = value
                }
                if let value = dict["minSize"] as? Int32 {
                    self.minSize = value
                }
                if let value = dict["scaleLimit"] as? Int32 {
                    self.scaleLimit = value
                }
                if let value = dict["subClassificationConfines"] as? [Any?] {
                    var tmp : [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList.SubClassificationConfines] = []
                    for v in value {
                        if v != nil {
                            var model = GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList.SubClassificationConfines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.subClassificationConfines = tmp
                }
                if let value = dict["valueLimitSet"] as? [Int32] {
                    self.valueLimitSet = value
                }
            }
        }
        public var clientNodeAmountRange: GetRegionalInstanceConfigResponseBody.Result.ClientNodeAmountRange?

        public var clientNodeDiskList: [GetRegionalInstanceConfigResponseBody.Result.ClientNodeDiskList]?

        public var clientSpecs: [String]?

        public var dataNodeAmountRange: GetRegionalInstanceConfigResponseBody.Result.DataNodeAmountRange?

        public var dataNodeDiskList: [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList]?

        public var dataNodeSpecs: [String]?

        public var kibanaSpecs: [String]?

        public var masterAmountRange: [String]?

        public var masterDiskList: [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList]?

        public var masterSpecs: [String]?

        public var specInfoMap: [String: ResultSpecInfoMapValue]?

        public var versions: [String]?

        public var warmNodeAmountRange: GetRegionalInstanceConfigResponseBody.Result.WarmNodeAmountRange?

        public var warmNodeDiskList: [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList]?

        public var warmNodeSpecs: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clientNodeAmountRange?.validate()
            try self.dataNodeAmountRange?.validate()
            try self.warmNodeAmountRange?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clientNodeAmountRange != nil {
                map["clientNodeAmountRange"] = self.clientNodeAmountRange?.toMap()
            }
            if self.clientNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.clientNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["clientNodeDiskList"] = tmp
            }
            if self.clientSpecs != nil {
                map["clientSpecs"] = self.clientSpecs!
            }
            if self.dataNodeAmountRange != nil {
                map["dataNodeAmountRange"] = self.dataNodeAmountRange?.toMap()
            }
            if self.dataNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.dataNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["dataNodeDiskList"] = tmp
            }
            if self.dataNodeSpecs != nil {
                map["dataNodeSpecs"] = self.dataNodeSpecs!
            }
            if self.kibanaSpecs != nil {
                map["kibanaSpecs"] = self.kibanaSpecs!
            }
            if self.masterAmountRange != nil {
                map["masterAmountRange"] = self.masterAmountRange!
            }
            if self.masterDiskList != nil {
                var tmp : [Any] = []
                for k in self.masterDiskList! {
                    tmp.append(k.toMap())
                }
                map["masterDiskList"] = tmp
            }
            if self.masterSpecs != nil {
                map["masterSpecs"] = self.masterSpecs!
            }
            if self.specInfoMap != nil {
                var tmp : [String: Any] = [:]
                for (k, v) in self.specInfoMap! {
                    tmp[k] = v.toMap()
                }
                map["specInfoMap"] = tmp
            }
            if self.versions != nil {
                map["versions"] = self.versions!
            }
            if self.warmNodeAmountRange != nil {
                map["warmNodeAmountRange"] = self.warmNodeAmountRange?.toMap()
            }
            if self.warmNodeDiskList != nil {
                var tmp : [Any] = []
                for k in self.warmNodeDiskList! {
                    tmp.append(k.toMap())
                }
                map["warmNodeDiskList"] = tmp
            }
            if self.warmNodeSpecs != nil {
                map["warmNodeSpecs"] = self.warmNodeSpecs!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["clientNodeAmountRange"] as? [String: Any?] {
                var model = GetRegionalInstanceConfigResponseBody.Result.ClientNodeAmountRange()
                model.fromMap(value)
                self.clientNodeAmountRange = model
            }
            if let value = dict["clientNodeDiskList"] as? [Any?] {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.ClientNodeDiskList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionalInstanceConfigResponseBody.Result.ClientNodeDiskList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.clientNodeDiskList = tmp
            }
            if let value = dict["clientSpecs"] as? [String] {
                self.clientSpecs = value
            }
            if let value = dict["dataNodeAmountRange"] as? [String: Any?] {
                var model = GetRegionalInstanceConfigResponseBody.Result.DataNodeAmountRange()
                model.fromMap(value)
                self.dataNodeAmountRange = model
            }
            if let value = dict["dataNodeDiskList"] as? [Any?] {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionalInstanceConfigResponseBody.Result.DataNodeDiskList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dataNodeDiskList = tmp
            }
            if let value = dict["dataNodeSpecs"] as? [String] {
                self.dataNodeSpecs = value
            }
            if let value = dict["kibanaSpecs"] as? [String] {
                self.kibanaSpecs = value
            }
            if let value = dict["masterAmountRange"] as? [String] {
                self.masterAmountRange = value
            }
            if let value = dict["masterDiskList"] as? [Any?] {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.MasterDiskList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionalInstanceConfigResponseBody.Result.MasterDiskList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.masterDiskList = tmp
            }
            if let value = dict["masterSpecs"] as? [String] {
                self.masterSpecs = value
            }
            if let value = dict["specInfoMap"] as? [String: Any?] {
                var tmp : [String: ResultSpecInfoMapValue] = [:]
                for (k, v) in value {
                    if v != nil {
                        var model = ResultSpecInfoMapValue()
                        model.fromMap(v as? [String: Any?])
                        tmp[k] = model
                    }
                }
                self.specInfoMap = tmp
            }
            if let value = dict["versions"] as? [String] {
                self.versions = value
            }
            if let value = dict["warmNodeAmountRange"] as? [String: Any?] {
                var model = GetRegionalInstanceConfigResponseBody.Result.WarmNodeAmountRange()
                model.fromMap(value)
                self.warmNodeAmountRange = model
            }
            if let value = dict["warmNodeDiskList"] as? [Any?] {
                var tmp : [GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList] = []
                for v in value {
                    if v != nil {
                        var model = GetRegionalInstanceConfigResponseBody.Result.WarmNodeDiskList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.warmNodeDiskList = tmp
            }
            if let value = dict["warmNodeSpecs"] as? [String] {
                self.warmNodeSpecs = value
            }
        }
    }
    public var requestId: String?

    public var result: GetRegionalInstanceConfigResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = GetRegionalInstanceConfigResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class GetRegionalInstanceConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetRegionalInstanceConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetRegionalInstanceConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetSuggestShrinkableNodesRequest : Tea.TeaModel {
    public var count: Int32?

    public var ignoreStatus: Bool?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.ignoreStatus != nil {
            map["ignoreStatus"] = self.ignoreStatus!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["count"] as? Int32 {
            self.count = value
        }
        if let value = dict["ignoreStatus"] as? Bool {
            self.ignoreStatus = value
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
    }
}

public class GetSuggestShrinkableNodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
        }
    }
    public var requestId: String?

    public var result: [GetSuggestShrinkableNodesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [GetSuggestShrinkableNodesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = GetSuggestShrinkableNodesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class GetSuggestShrinkableNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetSuggestShrinkableNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetSuggestShrinkableNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class GetTransferableNodesRequest : Tea.TeaModel {
    public var count: Int32?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["count"] as? Int32 {
            self.count = value
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
    }
}

public class GetTransferableNodesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
        }
    }
    public var requestId: String?

    public var result: [GetTransferableNodesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [GetTransferableNodesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = GetTransferableNodesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class GetTransferableNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetTransferableNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = GetTransferableNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InitializeOperationRoleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class InitializeOperationRoleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class InitializeOperationRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InitializeOperationRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InitializeOperationRoleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InstallAckOperatorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class InstallAckOperatorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class InstallAckOperatorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallAckOperatorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InstallAckOperatorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InstallKibanaSystemPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class InstallKibanaSystemPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class InstallKibanaSystemPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallKibanaSystemPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InstallKibanaSystemPluginResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InstallLogstashSystemPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class InstallLogstashSystemPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class InstallLogstashSystemPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallLogstashSystemPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InstallLogstashSystemPluginResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InstallSystemPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class InstallSystemPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class InstallSystemPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallSystemPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InstallSystemPluginResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InstallUserPluginsRequest : Tea.TeaModel {
    public var body: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
    }
}

public class InstallUserPluginsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class InstallUserPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallUserPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InstallUserPluginsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InterruptElasticsearchTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class InterruptElasticsearchTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class InterruptElasticsearchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InterruptElasticsearchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InterruptElasticsearchTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class InterruptLogstashTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class InterruptLogstashTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class InterruptLogstashTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InterruptLogstashTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = InterruptLogstashTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAckClustersRequest : Tea.TeaModel {
    public var page: Int32?

    public var size: Int32?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["vpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListAckClustersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var clusterId: String?

        public var clusterType: String?

        public var name: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.clusterId != nil {
                map["clusterId"] = self.clusterId!
            }
            if self.clusterType != nil {
                map["clusterType"] = self.clusterType!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["clusterId"] as? String {
                self.clusterId = value
            }
            if let value = dict["clusterType"] as? String {
                self.clusterType = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListAckClustersResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListAckClustersResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListAckClustersResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListAckClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAckClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAckClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAckNamespacesRequest : Tea.TeaModel {
    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListAckNamespacesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var namespace: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.namespace != nil {
                map["namespace"] = self.namespace!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["namespace"] as? String {
                self.namespace = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListAckNamespacesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListAckNamespacesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListAckNamespacesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListAckNamespacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAckNamespacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAckNamespacesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListActionRecordsRequest : Tea.TeaModel {
    public var actionNames: String?

    public var endTime: Int64?

    public var filter: String?

    public var page: Int32?

    public var requestId: String?

    public var size: Int32?

    public var startTime: Int64?

    public var userId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionNames != nil {
            map["actionNames"] = self.actionNames!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.filter != nil {
            map["filter"] = self.filter!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.userId != nil {
            map["userId"] = self.userId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["actionNames"] as? String {
            self.actionNames = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["filter"] as? String {
            self.filter = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["userId"] as? String {
            self.userId = value
        }
    }
}

public class ListActionRecordsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class StatusInfo : Tea.TeaModel {
            public class SubStatusInfo : Tea.TeaModel {
                public var completeNodeCount: Int32?

                public var endTime: Int64?

                public var exception: String?

                public var latencyMills: Int64?

                public var nodeCount: Int32?

                public var process: String?

                public var startTime: Int64?

                public var stateType: String?

                public var subState: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.completeNodeCount != nil {
                        map["completeNodeCount"] = self.completeNodeCount!
                    }
                    if self.endTime != nil {
                        map["endTime"] = self.endTime!
                    }
                    if self.exception != nil {
                        map["exception"] = self.exception!
                    }
                    if self.latencyMills != nil {
                        map["latencyMills"] = self.latencyMills!
                    }
                    if self.nodeCount != nil {
                        map["nodeCount"] = self.nodeCount!
                    }
                    if self.process != nil {
                        map["process"] = self.process!
                    }
                    if self.startTime != nil {
                        map["startTime"] = self.startTime!
                    }
                    if self.stateType != nil {
                        map["stateType"] = self.stateType!
                    }
                    if self.subState != nil {
                        map["subState"] = self.subState!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["completeNodeCount"] as? Int32 {
                        self.completeNodeCount = value
                    }
                    if let value = dict["endTime"] as? Int64 {
                        self.endTime = value
                    }
                    if let value = dict["exception"] as? String {
                        self.exception = value
                    }
                    if let value = dict["latencyMills"] as? Int64 {
                        self.latencyMills = value
                    }
                    if let value = dict["nodeCount"] as? Int32 {
                        self.nodeCount = value
                    }
                    if let value = dict["process"] as? String {
                        self.process = value
                    }
                    if let value = dict["startTime"] as? Int64 {
                        self.startTime = value
                    }
                    if let value = dict["stateType"] as? String {
                        self.stateType = value
                    }
                    if let value = dict["subState"] as? String {
                        self.subState = value
                    }
                }
            }
            public var completeNodeCount: Int32?

            public var endTime: Int64?

            public var exception: String?

            public var latencyMills: Int64?

            public var nodeCount: Int32?

            public var process: String?

            public var startTime: Int64?

            public var stateType: String?

            public var subState: String?

            public var subStatusInfo: [ListActionRecordsResponseBody.Result.StatusInfo.SubStatusInfo]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.completeNodeCount != nil {
                    map["completeNodeCount"] = self.completeNodeCount!
                }
                if self.endTime != nil {
                    map["endTime"] = self.endTime!
                }
                if self.exception != nil {
                    map["exception"] = self.exception!
                }
                if self.latencyMills != nil {
                    map["latencyMills"] = self.latencyMills!
                }
                if self.nodeCount != nil {
                    map["nodeCount"] = self.nodeCount!
                }
                if self.process != nil {
                    map["process"] = self.process!
                }
                if self.startTime != nil {
                    map["startTime"] = self.startTime!
                }
                if self.stateType != nil {
                    map["stateType"] = self.stateType!
                }
                if self.subState != nil {
                    map["subState"] = self.subState!
                }
                if self.subStatusInfo != nil {
                    var tmp : [Any] = []
                    for k in self.subStatusInfo! {
                        tmp.append(k.toMap())
                    }
                    map["subStatusInfo"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["completeNodeCount"] as? Int32 {
                    self.completeNodeCount = value
                }
                if let value = dict["endTime"] as? Int64 {
                    self.endTime = value
                }
                if let value = dict["exception"] as? String {
                    self.exception = value
                }
                if let value = dict["latencyMills"] as? Int64 {
                    self.latencyMills = value
                }
                if let value = dict["nodeCount"] as? Int32 {
                    self.nodeCount = value
                }
                if let value = dict["process"] as? String {
                    self.process = value
                }
                if let value = dict["startTime"] as? Int64 {
                    self.startTime = value
                }
                if let value = dict["stateType"] as? String {
                    self.stateType = value
                }
                if let value = dict["subState"] as? String {
                    self.subState = value
                }
                if let value = dict["subStatusInfo"] as? [Any?] {
                    var tmp : [ListActionRecordsResponseBody.Result.StatusInfo.SubStatusInfo] = []
                    for v in value {
                        if v != nil {
                            var model = ListActionRecordsResponseBody.Result.StatusInfo.SubStatusInfo()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.subStatusInfo = tmp
                }
            }
        }
        public var actionName: String?

        public var actionParams: [String: Any]?

        public var actionResultAccessList: [String]?

        public var endTime: Int64?

        public var instanceId: String?

        public var metaNow: String?

        public var metaOld: String?

        public var ownerId: String?

        public var process: String?

        public var recordDiff: [String: Any]?

        public var recordIds: [String]?

        public var requestId: String?

        public var startTime: Int64?

        public var stateType: String?

        public var statusInfo: [ListActionRecordsResponseBody.Result.StatusInfo]?

        public var userId: String?

        public var userInfo: String?

        public var userType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.actionName != nil {
                map["actionName"] = self.actionName!
            }
            if self.actionParams != nil {
                map["actionParams"] = self.actionParams!
            }
            if self.actionResultAccessList != nil {
                map["actionResultAccessList"] = self.actionResultAccessList!
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.metaNow != nil {
                map["metaNow"] = self.metaNow!
            }
            if self.metaOld != nil {
                map["metaOld"] = self.metaOld!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.process != nil {
                map["process"] = self.process!
            }
            if self.recordDiff != nil {
                map["recordDiff"] = self.recordDiff!
            }
            if self.recordIds != nil {
                map["recordIds"] = self.recordIds!
            }
            if self.requestId != nil {
                map["requestId"] = self.requestId!
            }
            if self.startTime != nil {
                map["startTime"] = self.startTime!
            }
            if self.stateType != nil {
                map["stateType"] = self.stateType!
            }
            if self.statusInfo != nil {
                var tmp : [Any] = []
                for k in self.statusInfo! {
                    tmp.append(k.toMap())
                }
                map["statusInfo"] = tmp
            }
            if self.userId != nil {
                map["userId"] = self.userId!
            }
            if self.userInfo != nil {
                map["userInfo"] = self.userInfo!
            }
            if self.userType != nil {
                map["userType"] = self.userType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["actionName"] as? String {
                self.actionName = value
            }
            if let value = dict["actionParams"] as? [String: Any] {
                self.actionParams = value
            }
            if let value = dict["actionResultAccessList"] as? [String] {
                self.actionResultAccessList = value
            }
            if let value = dict["endTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["metaNow"] as? String {
                self.metaNow = value
            }
            if let value = dict["metaOld"] as? String {
                self.metaOld = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["process"] as? String {
                self.process = value
            }
            if let value = dict["recordDiff"] as? [String: Any] {
                self.recordDiff = value
            }
            if let value = dict["recordIds"] as? [String] {
                self.recordIds = value
            }
            if let value = dict["requestId"] as? String {
                self.requestId = value
            }
            if let value = dict["startTime"] as? Int64 {
                self.startTime = value
            }
            if let value = dict["stateType"] as? String {
                self.stateType = value
            }
            if let value = dict["statusInfo"] as? [Any?] {
                var tmp : [ListActionRecordsResponseBody.Result.StatusInfo] = []
                for v in value {
                    if v != nil {
                        var model = ListActionRecordsResponseBody.Result.StatusInfo()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.statusInfo = tmp
            }
            if let value = dict["userId"] as? String {
                self.userId = value
            }
            if let value = dict["userInfo"] as? String {
                self.userInfo = value
            }
            if let value = dict["userType"] as? String {
                self.userType = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListActionRecordsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListActionRecordsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListActionRecordsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListActionRecordsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListActionRecordsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListActionRecordsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAllNodeRequest : Tea.TeaModel {
    public var extended: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.extended != nil {
            map["extended"] = self.extended!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["extended"] as? Bool {
            self.extended = value
        }
    }
}

public class ListAllNodeResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var cpuPercent: String?

        public var diskUsedPercent: String?

        public var health: String?

        public var heapPercent: String?

        public var host: String?

        public var loadOneM: String?

        public var nodeType: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cpuPercent != nil {
                map["cpuPercent"] = self.cpuPercent!
            }
            if self.diskUsedPercent != nil {
                map["diskUsedPercent"] = self.diskUsedPercent!
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.heapPercent != nil {
                map["heapPercent"] = self.heapPercent!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.loadOneM != nil {
                map["loadOneM"] = self.loadOneM!
            }
            if self.nodeType != nil {
                map["nodeType"] = self.nodeType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["cpuPercent"] as? String {
                self.cpuPercent = value
            }
            if let value = dict["diskUsedPercent"] as? String {
                self.diskUsedPercent = value
            }
            if let value = dict["health"] as? String {
                self.health = value
            }
            if let value = dict["heapPercent"] as? String {
                self.heapPercent = value
            }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["loadOneM"] as? String {
                self.loadOneM = value
            }
            if let value = dict["nodeType"] as? String {
                self.nodeType = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListAllNodeResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListAllNodeResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListAllNodeResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListAllNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAllNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAllNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAlternativeSnapshotReposRequest : Tea.TeaModel {
    public var alreadySetItems: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.alreadySetItems != nil {
            map["alreadySetItems"] = self.alreadySetItems!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["alreadySetItems"] as? Bool {
            self.alreadySetItems = value
        }
    }
}

public class ListAlternativeSnapshotReposResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var instanceId: String?

        public var repoPath: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.repoPath != nil {
                map["repoPath"] = self.repoPath!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["repoPath"] as? String {
                self.repoPath = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListAlternativeSnapshotReposResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListAlternativeSnapshotReposResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListAlternativeSnapshotReposResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListAlternativeSnapshotReposResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAlternativeSnapshotReposResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAlternativeSnapshotReposResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListApmRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var output: String?

    public var page: Int64?

    public var size: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.output != nil {
            map["output"] = self.output!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["output"] as? String {
            self.output = value
        }
        if let value = dict["page"] as? Int64 {
            self.page = value
        }
        if let value = dict["size"] as? Int64 {
            self.size = value
        }
    }
}

public class ListApmResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int64 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var createdAt: String?

        public var deployedReplica: Int64?

        public var description_: String?

        public var instanceId: String?

        public var nodeAmount: Int64?

        public var outputES: String?

        public var outputESUserName: String?

        public var ownerId: String?

        public var paymentType: String?

        public var region: String?

        public var replica: Int64?

        public var resourceSpec: String?

        public var status: String?

        public var version: String?

        public var vpcId: String?

        public var vsArea: String?

        public var vswitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.deployedReplica != nil {
                map["deployedReplica"] = self.deployedReplica!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.outputES != nil {
                map["outputES"] = self.outputES!
            }
            if self.outputESUserName != nil {
                map["outputESUserName"] = self.outputESUserName!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.region != nil {
                map["region"] = self.region!
            }
            if self.replica != nil {
                map["replica"] = self.replica!
            }
            if self.resourceSpec != nil {
                map["resourceSpec"] = self.resourceSpec!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            if self.vsArea != nil {
                map["vsArea"] = self.vsArea!
            }
            if self.vswitchId != nil {
                map["vswitchId"] = self.vswitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["deployedReplica"] as? Int64 {
                self.deployedReplica = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["nodeAmount"] as? Int64 {
                self.nodeAmount = value
            }
            if let value = dict["outputES"] as? String {
                self.outputES = value
            }
            if let value = dict["outputESUserName"] as? String {
                self.outputESUserName = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["region"] as? String {
                self.region = value
            }
            if let value = dict["replica"] as? Int64 {
                self.replica = value
            }
            if let value = dict["resourceSpec"] as? String {
                self.resourceSpec = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
            if let value = dict["vsArea"] as? String {
                self.vsArea = value
            }
            if let value = dict["vswitchId"] as? String {
                self.vswitchId = value
            }
        }
    }
    public var headers: ListApmResponseBody.Headers?

    public var requestId: String?

    public var result: [ListApmResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListApmResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListApmResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListApmResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListApmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListAvailableEsInstanceIdsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var endpoint: String?

        public var esInstanceId: String?

        public var kibanaEndpoint: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.endpoint != nil {
                map["endpoint"] = self.endpoint!
            }
            if self.esInstanceId != nil {
                map["esInstanceId"] = self.esInstanceId!
            }
            if self.kibanaEndpoint != nil {
                map["kibanaEndpoint"] = self.kibanaEndpoint!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["endpoint"] as? String {
                self.endpoint = value
            }
            if let value = dict["esInstanceId"] as? String {
                self.esInstanceId = value
            }
            if let value = dict["kibanaEndpoint"] as? String {
                self.kibanaEndpoint = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListAvailableEsInstanceIdsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListAvailableEsInstanceIdsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListAvailableEsInstanceIdsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListAvailableEsInstanceIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListAvailableEsInstanceIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListAvailableEsInstanceIdsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListCollectorsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var name: String?

    public var page: Int32?

    public var resId: String?

    public var size: Int32?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.resId != nil {
            map["resId"] = self.resId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["resId"] as? String {
            self.resId = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["sourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class ListCollectorsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["content"] as? String {
                    self.content = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["agentStatus"] as? String {
                        self.agentStatus = value
                    }
                    if let value = dict["instanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [ListCollectorsResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["configType"] as? String {
                    self.configType = value
                }
                if let value = dict["enableMonitoring"] as? Bool {
                    self.enableMonitoring = value
                }
                if let value = dict["groupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["host"] as? String {
                    self.host = value
                }
                if let value = dict["hosts"] as? [String] {
                    self.hosts = value
                }
                if let value = dict["instanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["instanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["kibanaHost"] as? String {
                    self.kibanaHost = value
                }
                if let value = dict["machines"] as? [Any?] {
                    var tmp : [ListCollectorsResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in value {
                        if v != nil {
                            var model = ListCollectorsResponseBody.Result.ExtendConfigs.Machines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.machines = tmp
                }
                if let value = dict["protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["successPodsCount"] as? String {
                    self.successPodsCount = value
                }
                if let value = dict["totalPodsCount"] as? String {
                    self.totalPodsCount = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["userName"] as? String {
                    self.userName = value
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [ListCollectorsResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [ListCollectorsResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["collectorPaths"] as? [String] {
                self.collectorPaths = value
            }
            if let value = dict["configs"] as? [Any?] {
                var tmp : [ListCollectorsResponseBody.Result.Configs] = []
                for v in value {
                    if v != nil {
                        var model = ListCollectorsResponseBody.Result.Configs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configs = tmp
            }
            if let value = dict["dryRun"] as? Bool {
                self.dryRun = value
            }
            if let value = dict["extendConfigs"] as? [Any?] {
                var tmp : [ListCollectorsResponseBody.Result.ExtendConfigs] = []
                for v in value {
                    if v != nil {
                        var model = ListCollectorsResponseBody.Result.ExtendConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.extendConfigs = tmp
            }
            if let value = dict["gmtCreatedTime"] as? String {
                self.gmtCreatedTime = value
            }
            if let value = dict["gmtUpdateTime"] as? String {
                self.gmtUpdateTime = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["resId"] as? String {
                self.resId = value
            }
            if let value = dict["resType"] as? String {
                self.resType = value
            }
            if let value = dict["resVersion"] as? String {
                self.resVersion = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var headers: ListCollectorsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListCollectorsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListCollectorsResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListCollectorsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListCollectorsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListCollectorsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListCollectorsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListCollectorsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListComponentIndicesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListComponentIndicesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int64 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Content : Tea.TeaModel {
            public class Template : Tea.TeaModel {
                public class Settings : Tea.TeaModel {
                    public class Index : Tea.TeaModel {
                        public class Lifecycle : Tea.TeaModel {
                            public var name: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.name != nil {
                                    map["name"] = self.name!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                                guard let dict else { return }
                                if let value = dict["name"] as? String {
                                    self.name = value
                                }
                            }
                        }
                        public var codec: String?

                        public var lifecycle: ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index.Lifecycle?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.lifecycle?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.codec != nil {
                                map["codec"] = self.codec!
                            }
                            if self.lifecycle != nil {
                                map["lifecycle"] = self.lifecycle?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any?]?) -> Void {
                            guard let dict else { return }
                            if let value = dict["codec"] as? String {
                                self.codec = value
                            }
                            if let value = dict["lifecycle"] as? [String: Any?] {
                                var model = ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index.Lifecycle()
                                model.fromMap(value)
                                self.lifecycle = model
                            }
                        }
                    }
                    public var index: ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.index?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.index != nil {
                            map["index"] = self.index?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["index"] as? [String: Any?] {
                            var model = ListComponentIndicesResponseBody.Result.Content.Template.Settings.Index()
                            model.fromMap(value)
                            self.index = model
                        }
                    }
                }
                public var settings: ListComponentIndicesResponseBody.Result.Content.Template.Settings?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.settings?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.settings != nil {
                        map["settings"] = self.settings?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["settings"] as? [String: Any?] {
                        var model = ListComponentIndicesResponseBody.Result.Content.Template.Settings()
                        model.fromMap(value)
                        self.settings = model
                    }
                }
            }
            public var meta: [String: Any]?

            public var template: ListComponentIndicesResponseBody.Result.Content.Template?

            public var version: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.template?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.meta != nil {
                    map["_meta"] = self.meta!
                }
                if self.template != nil {
                    map["template"] = self.template?.toMap()
                }
                if self.version != nil {
                    map["version"] = self.version!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["_meta"] as? [String: Any] {
                    self.meta = value
                }
                if let value = dict["template"] as? [String: Any?] {
                    var model = ListComponentIndicesResponseBody.Result.Content.Template()
                    model.fromMap(value)
                    self.template = model
                }
                if let value = dict["version"] as? Int64 {
                    self.version = value
                }
            }
        }
        public var composed: [String]?

        public var content: ListComponentIndicesResponseBody.Result.Content?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.content?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.composed != nil {
                map["composed"] = self.composed!
            }
            if self.content != nil {
                map["content"] = self.content?.toMap()
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["composed"] as? [String] {
                self.composed = value
            }
            if let value = dict["content"] as? [String: Any?] {
                var model = ListComponentIndicesResponseBody.Result.Content()
                model.fromMap(value)
                self.content = model
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var headers: ListComponentIndicesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListComponentIndicesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListComponentIndicesResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListComponentIndicesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListComponentIndicesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListComponentIndicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListComponentIndicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListComponentIndicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListConnectedClustersResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var instances: String?

            public var networkType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instances != nil {
                    map["instances"] = self.instances!
                }
                if self.networkType != nil {
                    map["networkType"] = self.networkType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["instances"] as? String {
                    self.instances = value
                }
                if let value = dict["networkType"] as? String {
                    self.networkType = value
                }
            }
        }
        public var result: [ListConnectedClustersResponseBody.Result.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Result"] as? [Any?] {
                var tmp : [ListConnectedClustersResponseBody.Result.Result] = []
                for v in value {
                    if v != nil {
                        var model = ListConnectedClustersResponseBody.Result.Result()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.result = tmp
            }
        }
    }
    public var requestId: String?

    public var result: ListConnectedClustersResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListConnectedClustersResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListConnectedClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListConnectedClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListConnectedClustersResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataStreamsRequest : Tea.TeaModel {
    public var isManaged: Bool?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isManaged != nil {
            map["isManaged"] = self.isManaged!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["isManaged"] as? Bool {
            self.isManaged = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class ListDataStreamsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xManagedCount: Int32?

        public var xManagedStorageSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xManagedCount != nil {
                map["X-Managed-Count"] = self.xManagedCount!
            }
            if self.xManagedStorageSize != nil {
                map["X-Managed-StorageSize"] = self.xManagedStorageSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Managed-Count"] as? Int32 {
                self.xManagedCount = value
            }
            if let value = dict["X-Managed-StorageSize"] as? Int64 {
                self.xManagedStorageSize = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Indices : Tea.TeaModel {
            public var createTime: String?

            public var health: String?

            public var isManaged: Bool?

            public var managedStatus: String?

            public var name: String?

            public var size: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["createTime"] = self.createTime!
                }
                if self.health != nil {
                    map["health"] = self.health!
                }
                if self.isManaged != nil {
                    map["isManaged"] = self.isManaged!
                }
                if self.managedStatus != nil {
                    map["managedStatus"] = self.managedStatus!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.size != nil {
                    map["size"] = self.size!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["createTime"] as? String {
                    self.createTime = value
                }
                if let value = dict["health"] as? String {
                    self.health = value
                }
                if let value = dict["isManaged"] as? Bool {
                    self.isManaged = value
                }
                if let value = dict["managedStatus"] as? String {
                    self.managedStatus = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["size"] as? Int64 {
                    self.size = value
                }
            }
        }
        public var health: String?

        public var ilmPolicyName: String?

        public var indexTemplateName: String?

        public var indices: [ListDataStreamsResponseBody.Result.Indices]?

        public var managedStorageSize: Int64?

        public var name: String?

        public var totalStorageSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.ilmPolicyName != nil {
                map["ilmPolicyName"] = self.ilmPolicyName!
            }
            if self.indexTemplateName != nil {
                map["indexTemplateName"] = self.indexTemplateName!
            }
            if self.indices != nil {
                var tmp : [Any] = []
                for k in self.indices! {
                    tmp.append(k.toMap())
                }
                map["indices"] = tmp
            }
            if self.managedStorageSize != nil {
                map["managedStorageSize"] = self.managedStorageSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.totalStorageSize != nil {
                map["totalStorageSize"] = self.totalStorageSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["health"] as? String {
                self.health = value
            }
            if let value = dict["ilmPolicyName"] as? String {
                self.ilmPolicyName = value
            }
            if let value = dict["indexTemplateName"] as? String {
                self.indexTemplateName = value
            }
            if let value = dict["indices"] as? [Any?] {
                var tmp : [ListDataStreamsResponseBody.Result.Indices] = []
                for v in value {
                    if v != nil {
                        var model = ListDataStreamsResponseBody.Result.Indices()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.indices = tmp
            }
            if let value = dict["managedStorageSize"] as? Int64 {
                self.managedStorageSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["totalStorageSize"] as? Int64 {
                self.totalStorageSize = value
            }
        }
    }
    public var headers: ListDataStreamsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDataStreamsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListDataStreamsResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListDataStreamsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListDataStreamsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListDataStreamsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataStreamsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataStreamsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDataTasksResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class SinkCluster : Tea.TeaModel {
            public var dataSourceType: String?

            public var endpoint: String?

            public var index: String?

            public var type: String?

            public var vpcId: String?

            public var vpcInstanceId: String?

            public var vpcInstancePort: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceType != nil {
                    map["dataSourceType"] = self.dataSourceType!
                }
                if self.endpoint != nil {
                    map["endpoint"] = self.endpoint!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vpcInstanceId != nil {
                    map["vpcInstanceId"] = self.vpcInstanceId!
                }
                if self.vpcInstancePort != nil {
                    map["vpcInstancePort"] = self.vpcInstancePort!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["dataSourceType"] as? String {
                    self.dataSourceType = value
                }
                if let value = dict["endpoint"] as? String {
                    self.endpoint = value
                }
                if let value = dict["index"] as? String {
                    self.index = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vpcInstanceId"] as? String {
                    self.vpcInstanceId = value
                }
                if let value = dict["vpcInstancePort"] as? String {
                    self.vpcInstancePort = value
                }
            }
        }
        public class SourceCluster : Tea.TeaModel {
            public var dataSourceType: String?

            public var index: String?

            public var mapping: String?

            public var routing: String?

            public var settings: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dataSourceType != nil {
                    map["dataSourceType"] = self.dataSourceType!
                }
                if self.index != nil {
                    map["index"] = self.index!
                }
                if self.mapping != nil {
                    map["mapping"] = self.mapping!
                }
                if self.routing != nil {
                    map["routing"] = self.routing!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["dataSourceType"] as? String {
                    self.dataSourceType = value
                }
                if let value = dict["index"] as? String {
                    self.index = value
                }
                if let value = dict["mapping"] as? String {
                    self.mapping = value
                }
                if let value = dict["routing"] as? String {
                    self.routing = value
                }
                if let value = dict["settings"] as? String {
                    self.settings = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var createTime: String?

        public var sinkCluster: ListDataTasksResponseBody.Result.SinkCluster?

        public var sourceCluster: ListDataTasksResponseBody.Result.SourceCluster?

        public var status: String?

        public var taskId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.sinkCluster?.validate()
            try self.sourceCluster?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.sinkCluster != nil {
                map["sinkCluster"] = self.sinkCluster?.toMap()
            }
            if self.sourceCluster != nil {
                map["sourceCluster"] = self.sourceCluster?.toMap()
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.taskId != nil {
                map["taskId"] = self.taskId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? String {
                self.createTime = value
            }
            if let value = dict["sinkCluster"] as? [String: Any?] {
                var model = ListDataTasksResponseBody.Result.SinkCluster()
                model.fromMap(value)
                self.sinkCluster = model
            }
            if let value = dict["sourceCluster"] as? [String: Any?] {
                var model = ListDataTasksResponseBody.Result.SourceCluster()
                model.fromMap(value)
                self.sourceCluster = model
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["taskId"] as? String {
                self.taskId = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListDataTasksResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListDataTasksResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListDataTasksResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListDataTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDataTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDataTasksResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDefaultCollectorConfigurationsRequest : Tea.TeaModel {
    public var resType: String?

    public var resVersion: String?

    public var sourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resType != nil {
            map["resType"] = self.resType!
        }
        if self.resVersion != nil {
            map["resVersion"] = self.resVersion!
        }
        if self.sourceType != nil {
            map["sourceType"] = self.sourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["resType"] as? String {
            self.resType = value
        }
        if let value = dict["resVersion"] as? String {
            self.resVersion = value
        }
        if let value = dict["sourceType"] as? String {
            self.sourceType = value
        }
    }
}

public class ListDefaultCollectorConfigurationsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var fileName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.fileName != nil {
                map["fileName"] = self.fileName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["fileName"] as? String {
                self.fileName = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListDefaultCollectorConfigurationsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListDefaultCollectorConfigurationsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListDefaultCollectorConfigurationsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListDefaultCollectorConfigurationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDefaultCollectorConfigurationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDefaultCollectorConfigurationsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDeprecatedTemplatesRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListDeprecatedTemplatesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int64 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliases"] as? String {
                    self.aliases = value
                }
                if let value = dict["mappings"] as? String {
                    self.mappings = value
                }
                if let value = dict["settings"] as? String {
                    self.settings = value
                }
            }
        }
        public var dataStream: Bool?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var order: Int64?

        public var template: ListDeprecatedTemplatesResponseBody.Result.Template?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.order != nil {
                map["order"] = self.order!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["dataStream"] as? Bool {
                self.dataStream = value
            }
            if let value = dict["indexPatterns"] as? [String] {
                self.indexPatterns = value
            }
            if let value = dict["indexTemplate"] as? String {
                self.indexTemplate = value
            }
            if let value = dict["order"] as? Int64 {
                self.order = value
            }
            if let value = dict["template"] as? [String: Any?] {
                var model = ListDeprecatedTemplatesResponseBody.Result.Template()
                model.fromMap(value)
                self.template = model
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
        }
    }
    public var headers: ListDeprecatedTemplatesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDeprecatedTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListDeprecatedTemplatesResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListDeprecatedTemplatesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListDeprecatedTemplatesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListDeprecatedTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDeprecatedTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDeprecatedTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDiagnoseIndicesRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class ListDiagnoseIndicesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class ListDiagnoseIndicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnoseIndicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDiagnoseIndicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDiagnoseReportRequest : Tea.TeaModel {
    public var detail: Bool?

    public var endTime: Int64?

    public var lang: String?

    public var page: Int32?

    public var size: Int32?

    public var startTime: Int64?

    public var trigger: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detail != nil {
            map["detail"] = self.detail!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["detail"] as? Bool {
            self.detail = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["trigger"] as? String {
            self.trigger = value
        }
    }
}

public class ListDiagnoseReportResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class DiagnoseItems : Tea.TeaModel {
            public class Detail : Tea.TeaModel {
                public var desc: String?

                public var name: String?

                public var result: String?

                public var suggest: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.desc != nil {
                        map["desc"] = self.desc!
                    }
                    if self.name != nil {
                        map["name"] = self.name!
                    }
                    if self.result != nil {
                        map["result"] = self.result!
                    }
                    if self.suggest != nil {
                        map["suggest"] = self.suggest!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["desc"] as? String {
                        self.desc = value
                    }
                    if let value = dict["name"] as? String {
                        self.name = value
                    }
                    if let value = dict["result"] as? String {
                        self.result = value
                    }
                    if let value = dict["suggest"] as? String {
                        self.suggest = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                }
            }
            public var detail: ListDiagnoseReportResponseBody.Result.DiagnoseItems.Detail?

            public var health: String?

            public var item: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detail?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.detail != nil {
                    map["detail"] = self.detail?.toMap()
                }
                if self.health != nil {
                    map["health"] = self.health!
                }
                if self.item != nil {
                    map["item"] = self.item!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["detail"] as? [String: Any?] {
                    var model = ListDiagnoseReportResponseBody.Result.DiagnoseItems.Detail()
                    model.fromMap(value)
                    self.detail = model
                }
                if let value = dict["health"] as? String {
                    self.health = value
                }
                if let value = dict["item"] as? String {
                    self.item = value
                }
            }
        }
        public var createTime: Int64?

        public var diagnoseItems: [ListDiagnoseReportResponseBody.Result.DiagnoseItems]?

        public var health: String?

        public var instanceId: String?

        public var reportId: String?

        public var state: String?

        public var trigger: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.diagnoseItems != nil {
                var tmp : [Any] = []
                for k in self.diagnoseItems! {
                    tmp.append(k.toMap())
                }
                map["diagnoseItems"] = tmp
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.reportId != nil {
                map["reportId"] = self.reportId!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            if self.trigger != nil {
                map["trigger"] = self.trigger!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? Int64 {
                self.createTime = value
            }
            if let value = dict["diagnoseItems"] as? [Any?] {
                var tmp : [ListDiagnoseReportResponseBody.Result.DiagnoseItems] = []
                for v in value {
                    if v != nil {
                        var model = ListDiagnoseReportResponseBody.Result.DiagnoseItems()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.diagnoseItems = tmp
            }
            if let value = dict["health"] as? String {
                self.health = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["reportId"] as? String {
                self.reportId = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
            if let value = dict["trigger"] as? String {
                self.trigger = value
            }
        }
    }
    public var headers: ListDiagnoseReportResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDiagnoseReportResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListDiagnoseReportResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListDiagnoseReportResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListDiagnoseReportResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListDiagnoseReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnoseReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDiagnoseReportResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDiagnoseReportIdsRequest : Tea.TeaModel {
    public var endTime: Int64?

    public var lang: String?

    public var page: Int32?

    public var size: Int32?

    public var startTime: Int64?

    public var trigger: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.startTime != nil {
            map["startTime"] = self.startTime!
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["startTime"] as? Int64 {
            self.startTime = value
        }
        if let value = dict["trigger"] as? String {
            self.trigger = value
        }
    }
}

public class ListDiagnoseReportIdsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public var headers: ListDiagnoseReportIdsResponseBody.Headers?

    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListDiagnoseReportIdsResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class ListDiagnoseReportIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnoseReportIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDiagnoseReportIdsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDiagnosisItemsRequest : Tea.TeaModel {
    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class ListDiagnosisItemsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var key: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["key"] as? String {
                self.key = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListDiagnosisItemsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListDiagnosisItemsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListDiagnosisItemsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListDiagnosisItemsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDiagnosisItemsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDiagnosisItemsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDictInformationRequest : Tea.TeaModel {
    public var analyzerType: String?

    public var bucketName: String?

    public var key: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analyzerType != nil {
            map["analyzerType"] = self.analyzerType!
        }
        if self.bucketName != nil {
            map["bucketName"] = self.bucketName!
        }
        if self.key != nil {
            map["key"] = self.key!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["analyzerType"] as? String {
            self.analyzerType = value
        }
        if let value = dict["bucketName"] as? String {
            self.bucketName = value
        }
        if let value = dict["key"] as? String {
            self.key = value
        }
    }
}

public class ListDictInformationResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class OssObject : Tea.TeaModel {
            public var bucketName: String?

            public var etag: String?

            public var key: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["bucketName"] = self.bucketName!
                }
                if self.etag != nil {
                    map["etag"] = self.etag!
                }
                if self.key != nil {
                    map["key"] = self.key!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["bucketName"] as? String {
                    self.bucketName = value
                }
                if let value = dict["etag"] as? String {
                    self.etag = value
                }
                if let value = dict["key"] as? String {
                    self.key = value
                }
            }
        }
        public var fileSize: Int64?

        public var ossObject: ListDictInformationResponseBody.Result.OssObject?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ossObject?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.ossObject != nil {
                map["ossObject"] = self.ossObject?.toMap()
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["ossObject"] as? [String: Any?] {
                var model = ListDictInformationResponseBody.Result.OssObject()
                model.fromMap(value)
                self.ossObject = model
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var requestId: String?

    public var result: ListDictInformationResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ListDictInformationResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ListDictInformationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDictInformationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDictInformationResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListDictsRequest : Tea.TeaModel {
    public var analyzerType: String?

    public var name: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.analyzerType != nil {
            map["analyzerType"] = self.analyzerType!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["analyzerType"] as? String {
            self.analyzerType = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
    }
}

public class ListDictsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var downloadUrl: String?

        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.downloadUrl != nil {
                map["downloadUrl"] = self.downloadUrl!
            }
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["downloadUrl"] as? String {
                self.downloadUrl = value
            }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var headers: ListDictsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListDictsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListDictsResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListDictsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListDictsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListDictsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListDictsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListDictsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListEcsInstancesRequest : Tea.TeaModel {
    public var ecsInstanceIds: String?

    public var ecsInstanceName: String?

    public var page: Int32?

    public var size: Int32?

    public var tags: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecsInstanceIds != nil {
            map["ecsInstanceIds"] = self.ecsInstanceIds!
        }
        if self.ecsInstanceName != nil {
            map["ecsInstanceName"] = self.ecsInstanceName!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ecsInstanceIds"] as? String {
            self.ecsInstanceIds = value
        }
        if let value = dict["ecsInstanceName"] as? String {
            self.ecsInstanceName = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["tags"] as? String {
            self.tags = value
        }
        if let value = dict["vpcId"] as? String {
            self.vpcId = value
        }
    }
}

public class ListEcsInstancesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Collectors : Tea.TeaModel {
            public class Configs : Tea.TeaModel {
                public var content: String?

                public var fileName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.content != nil {
                        map["content"] = self.content!
                    }
                    if self.fileName != nil {
                        map["fileName"] = self.fileName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["content"] as? String {
                        self.content = value
                    }
                    if let value = dict["fileName"] as? String {
                        self.fileName = value
                    }
                }
            }
            public class ExtendConfigs : Tea.TeaModel {
                public class Machines : Tea.TeaModel {
                    public var agentStatus: String?

                    public var instanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.agentStatus != nil {
                            map["agentStatus"] = self.agentStatus!
                        }
                        if self.instanceId != nil {
                            map["instanceId"] = self.instanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any?]?) -> Void {
                        guard let dict else { return }
                        if let value = dict["agentStatus"] as? String {
                            self.agentStatus = value
                        }
                        if let value = dict["instanceId"] as? String {
                            self.instanceId = value
                        }
                    }
                }
                public var configType: String?

                public var enableMonitoring: Bool?

                public var groupId: String?

                public var hosts: [String]?

                public var instanceId: String?

                public var instanceType: String?

                public var machines: [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs.Machines]?

                public var protocol_: String?

                public var type: String?

                public var userName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configType != nil {
                        map["configType"] = self.configType!
                    }
                    if self.enableMonitoring != nil {
                        map["enableMonitoring"] = self.enableMonitoring!
                    }
                    if self.groupId != nil {
                        map["groupId"] = self.groupId!
                    }
                    if self.hosts != nil {
                        map["hosts"] = self.hosts!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    if self.instanceType != nil {
                        map["instanceType"] = self.instanceType!
                    }
                    if self.machines != nil {
                        var tmp : [Any] = []
                        for k in self.machines! {
                            tmp.append(k.toMap())
                        }
                        map["machines"] = tmp
                    }
                    if self.protocol_ != nil {
                        map["protocol"] = self.protocol_!
                    }
                    if self.type != nil {
                        map["type"] = self.type!
                    }
                    if self.userName != nil {
                        map["userName"] = self.userName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["configType"] as? String {
                        self.configType = value
                    }
                    if let value = dict["enableMonitoring"] as? Bool {
                        self.enableMonitoring = value
                    }
                    if let value = dict["groupId"] as? String {
                        self.groupId = value
                    }
                    if let value = dict["hosts"] as? [String] {
                        self.hosts = value
                    }
                    if let value = dict["instanceId"] as? String {
                        self.instanceId = value
                    }
                    if let value = dict["instanceType"] as? String {
                        self.instanceType = value
                    }
                    if let value = dict["machines"] as? [Any?] {
                        var tmp : [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs.Machines] = []
                        for v in value {
                            if v != nil {
                                var model = ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs.Machines()
                                if v != nil {
                                    model.fromMap(v as? [String: Any?])
                                }
                                tmp.append(model)
                            }
                        }
                        self.machines = tmp
                    }
                    if let value = dict["protocol"] as? String {
                        self.protocol_ = value
                    }
                    if let value = dict["type"] as? String {
                        self.type = value
                    }
                    if let value = dict["userName"] as? String {
                        self.userName = value
                    }
                }
            }
            public var collectorPaths: [String]?

            public var configs: [ListEcsInstancesResponseBody.Result.Collectors.Configs]?

            public var dryRun: Bool?

            public var extendConfigs: [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs]?

            public var gmtCreatedTime: String?

            public var gmtUpdateTime: String?

            public var name: String?

            public var ownerId: String?

            public var resId: String?

            public var resType: String?

            public var resVersion: String?

            public var status: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.collectorPaths != nil {
                    map["collectorPaths"] = self.collectorPaths!
                }
                if self.configs != nil {
                    var tmp : [Any] = []
                    for k in self.configs! {
                        tmp.append(k.toMap())
                    }
                    map["configs"] = tmp
                }
                if self.dryRun != nil {
                    map["dryRun"] = self.dryRun!
                }
                if self.extendConfigs != nil {
                    var tmp : [Any] = []
                    for k in self.extendConfigs! {
                        tmp.append(k.toMap())
                    }
                    map["extendConfigs"] = tmp
                }
                if self.gmtCreatedTime != nil {
                    map["gmtCreatedTime"] = self.gmtCreatedTime!
                }
                if self.gmtUpdateTime != nil {
                    map["gmtUpdateTime"] = self.gmtUpdateTime!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.ownerId != nil {
                    map["ownerId"] = self.ownerId!
                }
                if self.resId != nil {
                    map["resId"] = self.resId!
                }
                if self.resType != nil {
                    map["resType"] = self.resType!
                }
                if self.resVersion != nil {
                    map["resVersion"] = self.resVersion!
                }
                if self.status != nil {
                    map["status"] = self.status!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["collectorPaths"] as? [String] {
                    self.collectorPaths = value
                }
                if let value = dict["configs"] as? [Any?] {
                    var tmp : [ListEcsInstancesResponseBody.Result.Collectors.Configs] = []
                    for v in value {
                        if v != nil {
                            var model = ListEcsInstancesResponseBody.Result.Collectors.Configs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.configs = tmp
                }
                if let value = dict["dryRun"] as? Bool {
                    self.dryRun = value
                }
                if let value = dict["extendConfigs"] as? [Any?] {
                    var tmp : [ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs] = []
                    for v in value {
                        if v != nil {
                            var model = ListEcsInstancesResponseBody.Result.Collectors.ExtendConfigs()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.extendConfigs = tmp
                }
                if let value = dict["gmtCreatedTime"] as? String {
                    self.gmtCreatedTime = value
                }
                if let value = dict["gmtUpdateTime"] as? String {
                    self.gmtUpdateTime = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["ownerId"] as? String {
                    self.ownerId = value
                }
                if let value = dict["resId"] as? String {
                    self.resId = value
                }
                if let value = dict["resType"] as? String {
                    self.resType = value
                }
                if let value = dict["resVersion"] as? String {
                    self.resVersion = value
                }
                if let value = dict["status"] as? String {
                    self.status = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
            }
        }
        public class IpAddress : Tea.TeaModel {
            public var host: String?

            public var ipType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.ipType != nil {
                    map["ipType"] = self.ipType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["host"] as? String {
                    self.host = value
                }
                if let value = dict["ipType"] as? String {
                    self.ipType = value
                }
            }
        }
        public var cloudAssistantStatus: String?

        public var collectors: [ListEcsInstancesResponseBody.Result.Collectors]?

        public var ecsInstanceId: String?

        public var ecsInstanceName: String?

        public var ipAddress: [ListEcsInstancesResponseBody.Result.IpAddress]?

        public var osType: String?

        public var status: String?

        public var tags: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cloudAssistantStatus != nil {
                map["cloudAssistantStatus"] = self.cloudAssistantStatus!
            }
            if self.collectors != nil {
                var tmp : [Any] = []
                for k in self.collectors! {
                    tmp.append(k.toMap())
                }
                map["collectors"] = tmp
            }
            if self.ecsInstanceId != nil {
                map["ecsInstanceId"] = self.ecsInstanceId!
            }
            if self.ecsInstanceName != nil {
                map["ecsInstanceName"] = self.ecsInstanceName!
            }
            if self.ipAddress != nil {
                var tmp : [Any] = []
                for k in self.ipAddress! {
                    tmp.append(k.toMap())
                }
                map["ipAddress"] = tmp
            }
            if self.osType != nil {
                map["osType"] = self.osType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tags != nil {
                map["tags"] = self.tags!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["cloudAssistantStatus"] as? String {
                self.cloudAssistantStatus = value
            }
            if let value = dict["collectors"] as? [Any?] {
                var tmp : [ListEcsInstancesResponseBody.Result.Collectors] = []
                for v in value {
                    if v != nil {
                        var model = ListEcsInstancesResponseBody.Result.Collectors()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.collectors = tmp
            }
            if let value = dict["ecsInstanceId"] as? String {
                self.ecsInstanceId = value
            }
            if let value = dict["ecsInstanceName"] as? String {
                self.ecsInstanceName = value
            }
            if let value = dict["ipAddress"] as? [Any?] {
                var tmp : [ListEcsInstancesResponseBody.Result.IpAddress] = []
                for v in value {
                    if v != nil {
                        var model = ListEcsInstancesResponseBody.Result.IpAddress()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipAddress = tmp
            }
            if let value = dict["osType"] as? String {
                self.osType = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["tags"] as? String {
                self.tags = value
            }
        }
    }
    public var headers: ListEcsInstancesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListEcsInstancesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListEcsInstancesResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListEcsInstancesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListEcsInstancesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListEcsInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListEcsInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListEcsInstancesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListExtendfilesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var filePath: String?

        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.filePath != nil {
                map["filePath"] = self.filePath!
            }
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["filePath"] as? String {
                self.filePath = value
            }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListExtendfilesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListExtendfilesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListExtendfilesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListExtendfilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListExtendfilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListExtendfilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListILMPoliciesRequest : Tea.TeaModel {
    public var policyName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.policyName != nil {
            map["policyName"] = self.policyName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["policyName"] as? String {
            self.policyName = value
        }
    }
}

public class ListILMPoliciesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var name: String?

        public var phases: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.phases != nil {
                map["phases"] = self.phases!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["phases"] as? [String: Any] {
                self.phases = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListILMPoliciesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListILMPoliciesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListILMPoliciesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListILMPoliciesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListILMPoliciesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListILMPoliciesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListIndexTemplatesRequest : Tea.TeaModel {
    public var indexTemplate: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.indexTemplate != nil {
            map["indexTemplate"] = self.indexTemplate!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["indexTemplate"] as? String {
            self.indexTemplate = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListIndexTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Template : Tea.TeaModel {
            public var aliases: String?

            public var mappings: String?

            public var settings: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliases != nil {
                    map["aliases"] = self.aliases!
                }
                if self.mappings != nil {
                    map["mappings"] = self.mappings!
                }
                if self.settings != nil {
                    map["settings"] = self.settings!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["aliases"] as? String {
                    self.aliases = value
                }
                if let value = dict["mappings"] as? String {
                    self.mappings = value
                }
                if let value = dict["settings"] as? String {
                    self.settings = value
                }
            }
        }
        public var dataStream: Bool?

        public var ilmPolicy: String?

        public var indexPatterns: [String]?

        public var indexTemplate: String?

        public var priority: Int32?

        public var template: ListIndexTemplatesResponseBody.Result.Template?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.template?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataStream != nil {
                map["dataStream"] = self.dataStream!
            }
            if self.ilmPolicy != nil {
                map["ilmPolicy"] = self.ilmPolicy!
            }
            if self.indexPatterns != nil {
                map["indexPatterns"] = self.indexPatterns!
            }
            if self.indexTemplate != nil {
                map["indexTemplate"] = self.indexTemplate!
            }
            if self.priority != nil {
                map["priority"] = self.priority!
            }
            if self.template != nil {
                map["template"] = self.template?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["dataStream"] as? Bool {
                self.dataStream = value
            }
            if let value = dict["ilmPolicy"] as? String {
                self.ilmPolicy = value
            }
            if let value = dict["indexPatterns"] as? [String] {
                self.indexPatterns = value
            }
            if let value = dict["indexTemplate"] as? String {
                self.indexTemplate = value
            }
            if let value = dict["priority"] as? Int32 {
                self.priority = value
            }
            if let value = dict["template"] as? [String: Any?] {
                var model = ListIndexTemplatesResponseBody.Result.Template()
                model.fromMap(value)
                self.template = model
            }
        }
    }
    public var requestId: String?

    public var result: [ListIndexTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListIndexTemplatesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListIndexTemplatesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListIndexTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListIndexTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListIndexTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInstanceRequest : Tea.TeaModel {
    public var description_: String?

    public var esVersion: String?

    public var instanceCategory: String?

    public var instanceId: String?

    public var page: Int32?

    public var paymentType: String?

    public var resourceGroupId: String?

    public var size: Int32?

    public var status: String?

    public var tags: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.esVersion != nil {
            map["esVersion"] = self.esVersion!
        }
        if self.instanceCategory != nil {
            map["instanceCategory"] = self.instanceCategory!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.status != nil {
            map["status"] = self.status!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.vpcId != nil {
            map["vpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["zoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["esVersion"] as? String {
            self.esVersion = value
        }
        if let value = dict["instanceCategory"] as? String {
            self.instanceCategory = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["paymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["resourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["status"] as? String {
            self.status = value
        }
        if let value = dict["tags"] as? String {
            self.tags = value
        }
        if let value = dict["vpcId"] as? String {
            self.vpcId = value
        }
        if let value = dict["zoneId"] as? String {
            self.zoneId = value
        }
    }
}

public class ListInstanceResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class ClientNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class ElasticDataNodeConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["groupName"] as? String {
                        self.groupName = value
                    }
                    if let value = dict["ips"] as? [String] {
                        self.ips = value
                    }
                    if let value = dict["whiteIpType"] as? String {
                        self.whiteIpType = value
                    }
                }
            }
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public var whiteIpGroupList: [ListInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vsArea"] as? String {
                    self.vsArea = value
                }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
                if let value = dict["whiteIpGroupList"] as? [Any?] {
                    var tmp : [ListInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in value {
                        if v != nil {
                            var model = ListInstanceResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var performanceLevel: String?

            public var spec: String?

            public var specInfo: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.performanceLevel != nil {
                    map["performanceLevel"] = self.performanceLevel!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                if self.specInfo != nil {
                    map["specInfo"] = self.specInfo!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["performanceLevel"] as? String {
                    self.performanceLevel = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
                if let value = dict["specInfo"] as? String {
                    self.specInfo = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["tagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["tagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var advancedDedicateMaster: Bool?

        public var archType: String?

        public var clientNodeConfiguration: ListInstanceResponseBody.Result.ClientNodeConfiguration?

        public var createdAt: String?

        public var dedicateMaster: Bool?

        public var description_: String?

        public var domain: String?

        public var elasticDataNodeConfiguration: ListInstanceResponseBody.Result.ElasticDataNodeConfiguration?

        public var endTime: Int64?

        public var esVersion: String?

        public var extendConfigs: [[String: Any]]?

        public var instanceId: String?

        public var isNewDeployment: String?

        public var kibanaConfiguration: ListInstanceResponseBody.Result.KibanaConfiguration?

        public var kibanaIPWhitelist: [String]?

        public var kibanaPrivateIPWhitelist: [String]?

        public var masterConfiguration: ListInstanceResponseBody.Result.MasterConfiguration?

        public var networkConfig: ListInstanceResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: ListInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var port: String?

        public var postpaidServiceStatus: String?

        public var privateNetworkIpWhiteList: [String]?

        public var protocol_: String?

        public var publicIpWhitelist: [String]?

        public var resourceGroupId: String?

        public var serviceVpc: Bool?

        public var status: String?

        public var tags: [ListInstanceResponseBody.Result.Tags]?

        public var updatedAt: String?

        public var vpcInstanceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.clientNodeConfiguration?.validate()
            try self.elasticDataNodeConfiguration?.validate()
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.advancedDedicateMaster != nil {
                map["advancedDedicateMaster"] = self.advancedDedicateMaster!
            }
            if self.archType != nil {
                map["archType"] = self.archType!
            }
            if self.clientNodeConfiguration != nil {
                map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.dedicateMaster != nil {
                map["dedicateMaster"] = self.dedicateMaster!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.elasticDataNodeConfiguration != nil {
                map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
            }
            if self.endTime != nil {
                map["endTime"] = self.endTime!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.extendConfigs != nil {
                map["extendConfigs"] = self.extendConfigs!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.isNewDeployment != nil {
                map["isNewDeployment"] = self.isNewDeployment!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaIPWhitelist != nil {
                map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
            }
            if self.kibanaPrivateIPWhitelist != nil {
                map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.postpaidServiceStatus != nil {
                map["postpaidServiceStatus"] = self.postpaidServiceStatus!
            }
            if self.privateNetworkIpWhiteList != nil {
                map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
            }
            if self.protocol_ != nil {
                map["protocol"] = self.protocol_!
            }
            if self.publicIpWhitelist != nil {
                map["publicIpWhitelist"] = self.publicIpWhitelist!
            }
            if self.resourceGroupId != nil {
                map["resourceGroupId"] = self.resourceGroupId!
            }
            if self.serviceVpc != nil {
                map["serviceVpc"] = self.serviceVpc!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.vpcInstanceId != nil {
                map["vpcInstanceId"] = self.vpcInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["advancedDedicateMaster"] as? Bool {
                self.advancedDedicateMaster = value
            }
            if let value = dict["archType"] as? String {
                self.archType = value
            }
            if let value = dict["clientNodeConfiguration"] as? [String: Any?] {
                var model = ListInstanceResponseBody.Result.ClientNodeConfiguration()
                model.fromMap(value)
                self.clientNodeConfiguration = model
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["dedicateMaster"] as? Bool {
                self.dedicateMaster = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["domain"] as? String {
                self.domain = value
            }
            if let value = dict["elasticDataNodeConfiguration"] as? [String: Any?] {
                var model = ListInstanceResponseBody.Result.ElasticDataNodeConfiguration()
                model.fromMap(value)
                self.elasticDataNodeConfiguration = model
            }
            if let value = dict["endTime"] as? Int64 {
                self.endTime = value
            }
            if let value = dict["esVersion"] as? String {
                self.esVersion = value
            }
            if let value = dict["extendConfigs"] as? [[String: Any]] {
                self.extendConfigs = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["isNewDeployment"] as? String {
                self.isNewDeployment = value
            }
            if let value = dict["kibanaConfiguration"] as? [String: Any?] {
                var model = ListInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(value)
                self.kibanaConfiguration = model
            }
            if let value = dict["kibanaIPWhitelist"] as? [String] {
                self.kibanaIPWhitelist = value
            }
            if let value = dict["kibanaPrivateIPWhitelist"] as? [String] {
                self.kibanaPrivateIPWhitelist = value
            }
            if let value = dict["masterConfiguration"] as? [String: Any?] {
                var model = ListInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(value)
                self.masterConfiguration = model
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = ListInstanceResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
            if let value = dict["nodeAmount"] as? Int32 {
                self.nodeAmount = value
            }
            if let value = dict["nodeSpec"] as? [String: Any?] {
                var model = ListInstanceResponseBody.Result.NodeSpec()
                model.fromMap(value)
                self.nodeSpec = model
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["port"] as? String {
                self.port = value
            }
            if let value = dict["postpaidServiceStatus"] as? String {
                self.postpaidServiceStatus = value
            }
            if let value = dict["privateNetworkIpWhiteList"] as? [String] {
                self.privateNetworkIpWhiteList = value
            }
            if let value = dict["protocol"] as? String {
                self.protocol_ = value
            }
            if let value = dict["publicIpWhitelist"] as? [String] {
                self.publicIpWhitelist = value
            }
            if let value = dict["resourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["serviceVpc"] as? Bool {
                self.serviceVpc = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["tags"] as? [Any?] {
                var tmp : [ListInstanceResponseBody.Result.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListInstanceResponseBody.Result.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["vpcInstanceId"] as? String {
                self.vpcInstanceId = value
            }
        }
    }
    public var headers: ListInstanceResponseBody.Headers?

    public var requestId: String?

    public var result: [ListInstanceResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListInstanceResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListInstanceResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListInstanceResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInstanceHistoryEventsRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var desc: Bool?

        public var sortField: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["desc"] = self.desc!
            }
            if self.sortField != nil {
                map["sortField"] = self.sortField!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["desc"] as? Bool {
                self.desc = value
            }
            if let value = dict["sortField"] as? String {
                self.sortField = value
            }
        }
    }
    public var body: [ListInstanceHistoryEventsRequest.Body]?

    public var eventCreateEndTime: String?

    public var eventCreateStartTime: String?

    public var eventCycleStatus: [String]?

    public var eventExecuteEndTime: String?

    public var eventExecuteStartTime: String?

    public var eventFinashEndTime: String?

    public var eventFinashStartTime: String?

    public var eventLevel: [String]?

    public var eventType: [String]?

    public var instanceId: String?

    public var nodeIP: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.eventCreateEndTime != nil {
            map["eventCreateEndTime"] = self.eventCreateEndTime!
        }
        if self.eventCreateStartTime != nil {
            map["eventCreateStartTime"] = self.eventCreateStartTime!
        }
        if self.eventCycleStatus != nil {
            map["eventCycleStatus"] = self.eventCycleStatus!
        }
        if self.eventExecuteEndTime != nil {
            map["eventExecuteEndTime"] = self.eventExecuteEndTime!
        }
        if self.eventExecuteStartTime != nil {
            map["eventExecuteStartTime"] = self.eventExecuteStartTime!
        }
        if self.eventFinashEndTime != nil {
            map["eventFinashEndTime"] = self.eventFinashEndTime!
        }
        if self.eventFinashStartTime != nil {
            map["eventFinashStartTime"] = self.eventFinashStartTime!
        }
        if self.eventLevel != nil {
            map["eventLevel"] = self.eventLevel!
        }
        if self.eventType != nil {
            map["eventType"] = self.eventType!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.nodeIP != nil {
            map["nodeIP"] = self.nodeIP!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? [Any?] {
            var tmp : [ListInstanceHistoryEventsRequest.Body] = []
            for v in value {
                if v != nil {
                    var model = ListInstanceHistoryEventsRequest.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
        if let value = dict["eventCreateEndTime"] as? String {
            self.eventCreateEndTime = value
        }
        if let value = dict["eventCreateStartTime"] as? String {
            self.eventCreateStartTime = value
        }
        if let value = dict["eventCycleStatus"] as? [String] {
            self.eventCycleStatus = value
        }
        if let value = dict["eventExecuteEndTime"] as? String {
            self.eventExecuteEndTime = value
        }
        if let value = dict["eventExecuteStartTime"] as? String {
            self.eventExecuteStartTime = value
        }
        if let value = dict["eventFinashEndTime"] as? String {
            self.eventFinashEndTime = value
        }
        if let value = dict["eventFinashStartTime"] as? String {
            self.eventFinashStartTime = value
        }
        if let value = dict["eventLevel"] as? [String] {
            self.eventLevel = value
        }
        if let value = dict["eventType"] as? [String] {
            self.eventType = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["nodeIP"] as? String {
            self.nodeIP = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListInstanceHistoryEventsShrinkRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var desc: Bool?

        public var sortField: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.desc != nil {
                map["desc"] = self.desc!
            }
            if self.sortField != nil {
                map["sortField"] = self.sortField!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["desc"] as? Bool {
                self.desc = value
            }
            if let value = dict["sortField"] as? String {
                self.sortField = value
            }
        }
    }
    public var body: [ListInstanceHistoryEventsShrinkRequest.Body]?

    public var eventCreateEndTime: String?

    public var eventCreateStartTime: String?

    public var eventCycleStatusShrink: String?

    public var eventExecuteEndTime: String?

    public var eventExecuteStartTime: String?

    public var eventFinashEndTime: String?

    public var eventFinashStartTime: String?

    public var eventLevelShrink: String?

    public var eventTypeShrink: String?

    public var instanceId: String?

    public var nodeIP: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.eventCreateEndTime != nil {
            map["eventCreateEndTime"] = self.eventCreateEndTime!
        }
        if self.eventCreateStartTime != nil {
            map["eventCreateStartTime"] = self.eventCreateStartTime!
        }
        if self.eventCycleStatusShrink != nil {
            map["eventCycleStatus"] = self.eventCycleStatusShrink!
        }
        if self.eventExecuteEndTime != nil {
            map["eventExecuteEndTime"] = self.eventExecuteEndTime!
        }
        if self.eventExecuteStartTime != nil {
            map["eventExecuteStartTime"] = self.eventExecuteStartTime!
        }
        if self.eventFinashEndTime != nil {
            map["eventFinashEndTime"] = self.eventFinashEndTime!
        }
        if self.eventFinashStartTime != nil {
            map["eventFinashStartTime"] = self.eventFinashStartTime!
        }
        if self.eventLevelShrink != nil {
            map["eventLevel"] = self.eventLevelShrink!
        }
        if self.eventTypeShrink != nil {
            map["eventType"] = self.eventTypeShrink!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.nodeIP != nil {
            map["nodeIP"] = self.nodeIP!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? [Any?] {
            var tmp : [ListInstanceHistoryEventsShrinkRequest.Body] = []
            for v in value {
                if v != nil {
                    var model = ListInstanceHistoryEventsShrinkRequest.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
        if let value = dict["eventCreateEndTime"] as? String {
            self.eventCreateEndTime = value
        }
        if let value = dict["eventCreateStartTime"] as? String {
            self.eventCreateStartTime = value
        }
        if let value = dict["eventCycleStatus"] as? String {
            self.eventCycleStatusShrink = value
        }
        if let value = dict["eventExecuteEndTime"] as? String {
            self.eventExecuteEndTime = value
        }
        if let value = dict["eventExecuteStartTime"] as? String {
            self.eventExecuteStartTime = value
        }
        if let value = dict["eventFinashEndTime"] as? String {
            self.eventFinashEndTime = value
        }
        if let value = dict["eventFinashStartTime"] as? String {
            self.eventFinashStartTime = value
        }
        if let value = dict["eventLevel"] as? String {
            self.eventLevelShrink = value
        }
        if let value = dict["eventType"] as? String {
            self.eventTypeShrink = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["nodeIP"] as? String {
            self.nodeIP = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListInstanceHistoryEventsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int64?

        public var xTotalFailed: Int64?

        public var xTotalSuccess: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            if self.xTotalFailed != nil {
                map["X-Total-Failed"] = self.xTotalFailed!
            }
            if self.xTotalSuccess != nil {
                map["X-Total-Success"] = self.xTotalSuccess!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int64 {
                self.xTotalCount = value
            }
            if let value = dict["X-Total-Failed"] as? Int64 {
                self.xTotalFailed = value
            }
            if let value = dict["X-Total-Success"] as? Int64 {
                self.xTotalSuccess = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var ecsId: String?

        public var eventCreateTime: String?

        public var eventCycleStatus: String?

        public var eventExecuteTime: String?

        public var eventFinashTime: String?

        public var eventLevel: String?

        public var eventType: String?

        public var instanceId: String?

        public var nodeIP: String?

        public var regionId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ecsId != nil {
                map["ecsId"] = self.ecsId!
            }
            if self.eventCreateTime != nil {
                map["eventCreateTime"] = self.eventCreateTime!
            }
            if self.eventCycleStatus != nil {
                map["eventCycleStatus"] = self.eventCycleStatus!
            }
            if self.eventExecuteTime != nil {
                map["eventExecuteTime"] = self.eventExecuteTime!
            }
            if self.eventFinashTime != nil {
                map["eventFinashTime"] = self.eventFinashTime!
            }
            if self.eventLevel != nil {
                map["eventLevel"] = self.eventLevel!
            }
            if self.eventType != nil {
                map["eventType"] = self.eventType!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.nodeIP != nil {
                map["nodeIP"] = self.nodeIP!
            }
            if self.regionId != nil {
                map["regionId"] = self.regionId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["ecsId"] as? String {
                self.ecsId = value
            }
            if let value = dict["eventCreateTime"] as? String {
                self.eventCreateTime = value
            }
            if let value = dict["eventCycleStatus"] as? String {
                self.eventCycleStatus = value
            }
            if let value = dict["eventExecuteTime"] as? String {
                self.eventExecuteTime = value
            }
            if let value = dict["eventFinashTime"] as? String {
                self.eventFinashTime = value
            }
            if let value = dict["eventLevel"] as? String {
                self.eventLevel = value
            }
            if let value = dict["eventType"] as? String {
                self.eventType = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["nodeIP"] as? String {
                self.nodeIP = value
            }
            if let value = dict["regionId"] as? String {
                self.regionId = value
            }
        }
    }
    public var headers: ListInstanceHistoryEventsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListInstanceHistoryEventsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListInstanceHistoryEventsResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListInstanceHistoryEventsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListInstanceHistoryEventsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListInstanceHistoryEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceHistoryEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInstanceHistoryEventsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListInstanceIndicesRequest : Tea.TeaModel {
    public var all: Bool?

    public var isManaged: Bool?

    public var isOpenstore: Bool?

    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["all"] = self.all!
        }
        if self.isManaged != nil {
            map["isManaged"] = self.isManaged!
        }
        if self.isOpenstore != nil {
            map["isOpenstore"] = self.isOpenstore!
        }
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["all"] as? Bool {
            self.all = value
        }
        if let value = dict["isManaged"] as? Bool {
            self.isManaged = value
        }
        if let value = dict["isOpenstore"] as? Bool {
            self.isOpenstore = value
        }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListInstanceIndicesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xManagedCount: Int32?

        public var xManagedStorageSize: Int64?

        public var xOSSCount: Int32?

        public var xOSSStorageSize: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xManagedCount != nil {
                map["X-Managed-Count"] = self.xManagedCount!
            }
            if self.xManagedStorageSize != nil {
                map["X-Managed-StorageSize"] = self.xManagedStorageSize!
            }
            if self.xOSSCount != nil {
                map["X-OSS-Count"] = self.xOSSCount!
            }
            if self.xOSSStorageSize != nil {
                map["X-OSS-StorageSize"] = self.xOSSStorageSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Managed-Count"] as? Int32 {
                self.xManagedCount = value
            }
            if let value = dict["X-Managed-StorageSize"] as? Int64 {
                self.xManagedStorageSize = value
            }
            if let value = dict["X-OSS-Count"] as? Int32 {
                self.xOSSCount = value
            }
            if let value = dict["X-OSS-StorageSize"] as? Int64 {
                self.xOSSStorageSize = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var createTime: String?

        public var health: String?

        public var ilmExplain: String?

        public var isManaged: String?

        public var managedStatus: String?

        public var name: String?

        public var phase: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.health != nil {
                map["health"] = self.health!
            }
            if self.ilmExplain != nil {
                map["ilmExplain"] = self.ilmExplain!
            }
            if self.isManaged != nil {
                map["isManaged"] = self.isManaged!
            }
            if self.managedStatus != nil {
                map["managedStatus"] = self.managedStatus!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.phase != nil {
                map["phase"] = self.phase!
            }
            if self.size != nil {
                map["size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? String {
                self.createTime = value
            }
            if let value = dict["health"] as? String {
                self.health = value
            }
            if let value = dict["ilmExplain"] as? String {
                self.ilmExplain = value
            }
            if let value = dict["isManaged"] as? String {
                self.isManaged = value
            }
            if let value = dict["managedStatus"] as? String {
                self.managedStatus = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["phase"] as? String {
                self.phase = value
            }
            if let value = dict["size"] as? Int64 {
                self.size = value
            }
        }
    }
    public var headers: ListInstanceIndicesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListInstanceIndicesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListInstanceIndicesResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListInstanceIndicesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListInstanceIndicesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListInstanceIndicesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListInstanceIndicesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListInstanceIndicesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListKibanaPluginsRequest : Tea.TeaModel {
    public var page: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["page"] as? String {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListKibanaPluginsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var name: String?

        public var source: String?

        public var specificationUrl: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.specificationUrl != nil {
                map["specificationUrl"] = self.specificationUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["specificationUrl"] as? String {
                self.specificationUrl = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var headers: ListKibanaPluginsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListKibanaPluginsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListKibanaPluginsResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListKibanaPluginsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListKibanaPluginsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListKibanaPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListKibanaPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListKibanaPluginsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class VSwitchIdsZone : Tea.TeaModel {
            public var vswitchId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.zoneId != nil {
                    map["zoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
                if let value = dict["zoneId"] as? String {
                    self.zoneId = value
                }
            }
        }
        public var createTime: String?

        public var endpointId: String?

        public var endpointName: String?

        public var endpointStatus: String?

        public var pvlId: String?

        public var securityGroups: [String]?

        public var vSwitchIdsZone: [ListKibanaPvlNetworkResponseBody.Result.VSwitchIdsZone]?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.endpointId != nil {
                map["endpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["endpointName"] = self.endpointName!
            }
            if self.endpointStatus != nil {
                map["endpointStatus"] = self.endpointStatus!
            }
            if self.pvlId != nil {
                map["pvlId"] = self.pvlId!
            }
            if self.securityGroups != nil {
                map["securityGroups"] = self.securityGroups!
            }
            if self.vSwitchIdsZone != nil {
                var tmp : [Any] = []
                for k in self.vSwitchIdsZone! {
                    tmp.append(k.toMap())
                }
                map["vSwitchIdsZone"] = tmp
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createTime"] as? String {
                self.createTime = value
            }
            if let value = dict["endpointId"] as? String {
                self.endpointId = value
            }
            if let value = dict["endpointName"] as? String {
                self.endpointName = value
            }
            if let value = dict["endpointStatus"] as? String {
                self.endpointStatus = value
            }
            if let value = dict["pvlId"] as? String {
                self.pvlId = value
            }
            if let value = dict["securityGroups"] as? [String] {
                self.securityGroups = value
            }
            if let value = dict["vSwitchIdsZone"] as? [Any?] {
                var tmp : [ListKibanaPvlNetworkResponseBody.Result.VSwitchIdsZone] = []
                for v in value {
                    if v != nil {
                        var model = ListKibanaPvlNetworkResponseBody.Result.VSwitchIdsZone()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.vSwitchIdsZone = tmp
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListKibanaPvlNetworkResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListKibanaPvlNetworkResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListKibanaPvlNetworkResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListKibanaPvlNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLogstashRequest : Tea.TeaModel {
    public var description_: String?

    public var instanceId: String?

    public var page: Int32?

    public var resourceGroupId: String?

    public var size: Int32?

    public var tags: String?

    public var version: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.instanceId != nil {
            map["instanceId"] = self.instanceId!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["instanceId"] as? String {
            self.instanceId = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["resourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["tags"] as? String {
            self.tags = value
        }
        if let value = dict["version"] as? String {
            self.version = value
        }
    }
}

public class ListLogstashResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vsArea"] as? String {
                    self.vsArea = value
                }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskEncryption: Bool?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskEncryption != nil {
                    map["diskEncryption"] = self.diskEncryption!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskEncryption"] as? Bool {
                    self.diskEncryption = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public var tags: [ListLogstashResponseBody.Result.Tags]?

        public var createdAt: String?

        public var description_: String?

        public var instanceId: String?

        public var networkConfig: ListLogstashResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: ListLogstashResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var resourceGroupId: String?

        public var status: String?

        public var updatedAt: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.resourceGroupId != nil {
                map["resourceGroupId"] = self.resourceGroupId!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["Tags"] as? [Any?] {
                var tmp : [ListLogstashResponseBody.Result.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListLogstashResponseBody.Result.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = ListLogstashResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
            if let value = dict["nodeAmount"] as? Int32 {
                self.nodeAmount = value
            }
            if let value = dict["nodeSpec"] as? [String: Any?] {
                var model = ListLogstashResponseBody.Result.NodeSpec()
                model.fromMap(value)
                self.nodeSpec = model
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["resourceGroupId"] as? String {
                self.resourceGroupId = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
        }
    }
    public var headers: ListLogstashResponseBody.Headers?

    public var requestId: String?

    public var result: [ListLogstashResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListLogstashResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListLogstashResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListLogstashResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLogstashResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLogstashLogRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var endTime: Int64?

    public var page: Int32?

    public var query: String?

    public var size: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.query != nil {
            map["query"] = self.query!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["beginTime"] as? Int64 {
            self.beginTime = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["query"] as? String {
            self.query = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class ListLogstashLogResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var host: String?

        public var instanceId: String?

        public var level: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["level"] as? String {
                self.level = value
            }
            if let value = dict["timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListLogstashLogResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListLogstashLogResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListLogstashLogResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListLogstashLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogstashLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLogstashLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListLogstashPluginsRequest : Tea.TeaModel {
    public var name: String?

    public var page: Int32?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["source"] as? String {
            self.source = value
        }
    }
}

public class ListLogstashPluginsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var name: String?

        public var source: String?

        public var specificationUrl: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.specificationUrl != nil {
                map["specificationUrl"] = self.specificationUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["specificationUrl"] as? String {
                self.specificationUrl = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListLogstashPluginsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListLogstashPluginsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListLogstashPluginsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListLogstashPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListLogstashPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListLogstashPluginsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListNodesRequest : Tea.TeaModel {
    public var ecsInstanceIds: String?

    public var ecsInstanceName: String?

    public var page: Int32?

    public var size: Int32?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ecsInstanceIds != nil {
            map["ecsInstanceIds"] = self.ecsInstanceIds!
        }
        if self.ecsInstanceName != nil {
            map["ecsInstanceName"] = self.ecsInstanceName!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.tags != nil {
            map["tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ecsInstanceIds"] as? String {
            self.ecsInstanceIds = value
        }
        if let value = dict["ecsInstanceName"] as? String {
            self.ecsInstanceName = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["tags"] as? String {
            self.tags = value
        }
    }
}

public class ListNodesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public class IpAddress : Tea.TeaModel {
            public var host: String?

            public var ipType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.ipType != nil {
                    map["ipType"] = self.ipType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["host"] as? String {
                    self.host = value
                }
                if let value = dict["ipType"] as? String {
                    self.ipType = value
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["tagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["tagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["tagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["tagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var agentStatus: String?

        public var cloudAssistantStatus: String?

        public var ecsInstanceId: String?

        public var ecsInstanceName: String?

        public var ipAddress: [ListNodesResponseBody.Result.IpAddress]?

        public var osType: String?

        public var status: String?

        public var tags: [ListNodesResponseBody.Result.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.agentStatus != nil {
                map["agentStatus"] = self.agentStatus!
            }
            if self.cloudAssistantStatus != nil {
                map["cloudAssistantStatus"] = self.cloudAssistantStatus!
            }
            if self.ecsInstanceId != nil {
                map["ecsInstanceId"] = self.ecsInstanceId!
            }
            if self.ecsInstanceName != nil {
                map["ecsInstanceName"] = self.ecsInstanceName!
            }
            if self.ipAddress != nil {
                var tmp : [Any] = []
                for k in self.ipAddress! {
                    tmp.append(k.toMap())
                }
                map["ipAddress"] = tmp
            }
            if self.osType != nil {
                map["osType"] = self.osType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["agentStatus"] as? String {
                self.agentStatus = value
            }
            if let value = dict["cloudAssistantStatus"] as? String {
                self.cloudAssistantStatus = value
            }
            if let value = dict["ecsInstanceId"] as? String {
                self.ecsInstanceId = value
            }
            if let value = dict["ecsInstanceName"] as? String {
                self.ecsInstanceName = value
            }
            if let value = dict["ipAddress"] as? [Any?] {
                var tmp : [ListNodesResponseBody.Result.IpAddress] = []
                for v in value {
                    if v != nil {
                        var model = ListNodesResponseBody.Result.IpAddress()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.ipAddress = tmp
            }
            if let value = dict["osType"] as? String {
                self.osType = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["tags"] as? [Any?] {
                var tmp : [ListNodesResponseBody.Result.Tags] = []
                for v in value {
                    if v != nil {
                        var model = ListNodesResponseBody.Result.Tags()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tags = tmp
            }
        }
    }
    public var headers: ListNodesResponseBody.Headers?

    public var requestId: String?

    public var result: [ListNodesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListNodesResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListNodesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListNodesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineRequest : Tea.TeaModel {
    public var page: Int32?

    public var pipelineId: String?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.pipelineId != nil {
            map["pipelineId"] = self.pipelineId!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["pipelineId"] as? String {
            self.pipelineId = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListPipelineResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var pipelineId: String?

        public var pipelineStatus: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            if self.pipelineStatus != nil {
                map["pipelineStatus"] = self.pipelineStatus!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["gmtCreatedTime"] as? String {
                self.gmtCreatedTime = value
            }
            if let value = dict["gmtUpdateTime"] as? String {
                self.gmtUpdateTime = value
            }
            if let value = dict["pipelineId"] as? String {
                self.pipelineId = value
            }
            if let value = dict["pipelineStatus"] as? String {
                self.pipelineStatus = value
            }
        }
    }
    public var headers: ListPipelineResponseBody.Headers?

    public var requestId: String?

    public var result: [ListPipelineResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListPipelineResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListPipelineResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListPipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPipelineIdsRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class ListPipelineIdsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var available: Bool?

        public var code: String?

        public var message: String?

        public var pipelineId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.available != nil {
                map["available"] = self.available!
            }
            if self.code != nil {
                map["code"] = self.code!
            }
            if self.message != nil {
                map["message"] = self.message!
            }
            if self.pipelineId != nil {
                map["pipelineId"] = self.pipelineId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["available"] as? Bool {
                self.available = value
            }
            if let value = dict["code"] as? String {
                self.code = value
            }
            if let value = dict["message"] as? String {
                self.message = value
            }
            if let value = dict["pipelineId"] as? String {
                self.pipelineId = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListPipelineIdsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListPipelineIdsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListPipelineIdsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListPipelineIdsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPipelineIdsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPipelineIdsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListPluginsRequest : Tea.TeaModel {
    public var name: String?

    public var page: String?

    public var size: Int32?

    public var source: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.name != nil {
            map["name"] = self.name!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.source != nil {
            map["source"] = self.source!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["name"] as? String {
            self.name = value
        }
        if let value = dict["page"] as? String {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["source"] as? String {
            self.source = value
        }
    }
}

public class ListPluginsResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var description_: String?

        public var name: String?

        public var source: String?

        public var specificationUrl: String?

        public var state: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.source != nil {
                map["source"] = self.source!
            }
            if self.specificationUrl != nil {
                map["specificationUrl"] = self.specificationUrl!
            }
            if self.state != nil {
                map["state"] = self.state!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["source"] as? String {
                self.source = value
            }
            if let value = dict["specificationUrl"] as? String {
                self.specificationUrl = value
            }
            if let value = dict["state"] as? String {
                self.state = value
            }
        }
    }
    public var headers: ListPluginsResponseBody.Headers?

    public var requestId: String?

    public var result: [ListPluginsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListPluginsResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListPluginsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListPluginsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListPluginsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPluginsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListPluginsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSearchLogRequest : Tea.TeaModel {
    public var beginTime: Int64?

    public var endTime: Int64?

    public var page: Int32?

    public var query: String?

    public var size: Int32?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.beginTime != nil {
            map["beginTime"] = self.beginTime!
        }
        if self.endTime != nil {
            map["endTime"] = self.endTime!
        }
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.query != nil {
            map["query"] = self.query!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["beginTime"] as? Int64 {
            self.beginTime = value
        }
        if let value = dict["endTime"] as? Int64 {
            self.endTime = value
        }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["query"] as? String {
            self.query = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
    }
}

public class ListSearchLogResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class Result : Tea.TeaModel {
        public var content: String?

        public var contentCollection: [String: Any]?

        public var host: String?

        public var instanceId: String?

        public var level: String?

        public var timestamp: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.contentCollection != nil {
                map["contentCollection"] = self.contentCollection!
            }
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.level != nil {
                map["level"] = self.level!
            }
            if self.timestamp != nil {
                map["timestamp"] = self.timestamp!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["contentCollection"] as? [String: Any] {
                self.contentCollection = value
            }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["level"] as? String {
                self.level = value
            }
            if let value = dict["timestamp"] as? Int64 {
                self.timestamp = value
            }
        }
    }
    public var headers: ListSearchLogResponseBody.Headers?

    public var requestId: String?

    public var result: [ListSearchLogResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListSearchLogResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListSearchLogResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListSearchLogResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListSearchLogResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSearchLogResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSearchLogResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListShardRecoveriesRequest : Tea.TeaModel {
    public var activeOnly: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activeOnly != nil {
            map["activeOnly"] = self.activeOnly!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["activeOnly"] as? Bool {
            self.activeOnly = value
        }
    }
}

public class ListShardRecoveriesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var bytesPercent: String?

        public var bytesTotal: Int64?

        public var filesPercent: String?

        public var filesTotal: Int64?

        public var index: String?

        public var sourceHost: String?

        public var sourceNode: String?

        public var stage: String?

        public var targetHost: String?

        public var targetNode: String?

        public var translogOps: Int64?

        public var translogOpsPercent: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bytesPercent != nil {
                map["bytesPercent"] = self.bytesPercent!
            }
            if self.bytesTotal != nil {
                map["bytesTotal"] = self.bytesTotal!
            }
            if self.filesPercent != nil {
                map["filesPercent"] = self.filesPercent!
            }
            if self.filesTotal != nil {
                map["filesTotal"] = self.filesTotal!
            }
            if self.index != nil {
                map["index"] = self.index!
            }
            if self.sourceHost != nil {
                map["sourceHost"] = self.sourceHost!
            }
            if self.sourceNode != nil {
                map["sourceNode"] = self.sourceNode!
            }
            if self.stage != nil {
                map["stage"] = self.stage!
            }
            if self.targetHost != nil {
                map["targetHost"] = self.targetHost!
            }
            if self.targetNode != nil {
                map["targetNode"] = self.targetNode!
            }
            if self.translogOps != nil {
                map["translogOps"] = self.translogOps!
            }
            if self.translogOpsPercent != nil {
                map["translogOpsPercent"] = self.translogOpsPercent!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["bytesPercent"] as? String {
                self.bytesPercent = value
            }
            if let value = dict["bytesTotal"] as? Int64 {
                self.bytesTotal = value
            }
            if let value = dict["filesPercent"] as? String {
                self.filesPercent = value
            }
            if let value = dict["filesTotal"] as? Int64 {
                self.filesTotal = value
            }
            if let value = dict["index"] as? String {
                self.index = value
            }
            if let value = dict["sourceHost"] as? String {
                self.sourceHost = value
            }
            if let value = dict["sourceNode"] as? String {
                self.sourceNode = value
            }
            if let value = dict["stage"] as? String {
                self.stage = value
            }
            if let value = dict["targetHost"] as? String {
                self.targetHost = value
            }
            if let value = dict["targetNode"] as? String {
                self.targetNode = value
            }
            if let value = dict["translogOps"] as? Int64 {
                self.translogOps = value
            }
            if let value = dict["translogOpsPercent"] as? String {
                self.translogOpsPercent = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListShardRecoveriesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListShardRecoveriesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListShardRecoveriesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListShardRecoveriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListShardRecoveriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListShardRecoveriesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListSnapshotReposByInstanceIdResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var instanceId: String?

        public var repoPath: String?

        public var snapWarehouse: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.repoPath != nil {
                map["repoPath"] = self.repoPath!
            }
            if self.snapWarehouse != nil {
                map["snapWarehouse"] = self.snapWarehouse!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["repoPath"] as? String {
                self.repoPath = value
            }
            if let value = dict["snapWarehouse"] as? String {
                self.snapWarehouse = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListSnapshotReposByInstanceIdResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListSnapshotReposByInstanceIdResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListSnapshotReposByInstanceIdResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListSnapshotReposByInstanceIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListSnapshotReposByInstanceIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListSnapshotReposByInstanceIdResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public var nextToken: String?

    public var page: Int32?

    public var resourceIds: String?

    public var resourceType: String?

    public var size: Int32?

    public var tags: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.page != nil {
            map["Page"] = self.page!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.tags != nil {
            map["Tags"] = self.tags!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["NextToken"] as? String {
            self.nextToken = value
        }
        if let value = dict["Page"] as? Int32 {
            self.page = value
        }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Size"] as? Int32 {
            self.size = value
        }
        if let value = dict["Tags"] as? String {
            self.tags = value
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class Headers : Tea.TeaModel {
        public var xTotalCount: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.xTotalCount != nil {
                map["X-Total-Count"] = self.xTotalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["X-Total-Count"] as? Int32 {
                self.xTotalCount = value
            }
        }
    }
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["ResourceId"] as? String {
                    self.resourceId = value
                }
                if let value = dict["ResourceType"] as? String {
                    self.resourceType = value
                }
                if let value = dict["TagKey"] as? String {
                    self.tagKey = value
                }
                if let value = dict["TagValue"] as? String {
                    self.tagValue = value
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagResource"] as? [Any?] {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in value {
                    if v != nil {
                        var model = ListTagResourcesResponseBody.TagResources.TagResource()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.tagResource = tmp
            }
        }
    }
    public var headers: ListTagResourcesResponseBody.Headers?

    public var pageSize: Int32?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.headers?.validate()
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers?.toMap()
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.Headers()
            model.fromMap(value)
            self.headers = model
        }
        if let value = dict["PageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["TagResources"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(value)
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListTagsRequest : Tea.TeaModel {
    public var pageSize: Int32?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageSize != nil {
            map["pageSize"] = self.pageSize!
        }
        if self.resourceType != nil {
            map["resourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["pageSize"] as? Int32 {
            self.pageSize = value
        }
        if let value = dict["resourceType"] as? String {
            self.resourceType = value
        }
    }
}

public class ListTagsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["TagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["TagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["TagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListTagsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListTagsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListTagsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListTagsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ListVpcEndpointsRequest : Tea.TeaModel {
    public var page: Int32?

    public var size: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.page != nil {
            map["page"] = self.page!
        }
        if self.size != nil {
            map["size"] = self.size!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["page"] as? Int32 {
            self.page = value
        }
        if let value = dict["size"] as? Int32 {
            self.size = value
        }
    }
}

public class ListVpcEndpointsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var connectionStatus: String?

        public var createTime: String?

        public var endpointBusinessStatus: String?

        public var endpointDomain: String?

        public var endpointId: String?

        public var endpointName: String?

        public var endpointStatus: String?

        public var serviceId: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.connectionStatus != nil {
                map["connectionStatus"] = self.connectionStatus!
            }
            if self.createTime != nil {
                map["createTime"] = self.createTime!
            }
            if self.endpointBusinessStatus != nil {
                map["endpointBusinessStatus"] = self.endpointBusinessStatus!
            }
            if self.endpointDomain != nil {
                map["endpointDomain"] = self.endpointDomain!
            }
            if self.endpointId != nil {
                map["endpointId"] = self.endpointId!
            }
            if self.endpointName != nil {
                map["endpointName"] = self.endpointName!
            }
            if self.endpointStatus != nil {
                map["endpointStatus"] = self.endpointStatus!
            }
            if self.serviceId != nil {
                map["serviceId"] = self.serviceId!
            }
            if self.serviceName != nil {
                map["serviceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["connectionStatus"] as? String {
                self.connectionStatus = value
            }
            if let value = dict["createTime"] as? String {
                self.createTime = value
            }
            if let value = dict["endpointBusinessStatus"] as? String {
                self.endpointBusinessStatus = value
            }
            if let value = dict["endpointDomain"] as? String {
                self.endpointDomain = value
            }
            if let value = dict["endpointId"] as? String {
                self.endpointId = value
            }
            if let value = dict["endpointName"] as? String {
                self.endpointName = value
            }
            if let value = dict["endpointStatus"] as? String {
                self.endpointStatus = value
            }
            if let value = dict["serviceId"] as? String {
                self.serviceId = value
            }
            if let value = dict["serviceName"] as? String {
                self.serviceName = value
            }
        }
    }
    public var requestId: String?

    public var result: [ListVpcEndpointsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [ListVpcEndpointsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = ListVpcEndpointsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class ListVpcEndpointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListVpcEndpointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ListVpcEndpointsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MigrateToOtherZoneRequest : Tea.TeaModel {
    public var body: String?

    public var dryRun: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["dryRun"] as? Bool {
            self.dryRun = value
        }
    }
}

public class MigrateToOtherZoneResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class MigrateToOtherZoneResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MigrateToOtherZoneResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MigrateToOtherZoneResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyDeployMachineRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class ModifyDeployMachineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ModifyDeployMachineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDeployMachineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyDeployMachineResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyElastictaskRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class ModifyElastictaskResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ElasticExpansionTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cronExpression"] as? String {
                    self.cronExpression = value
                }
                if let value = dict["elasticNodeCount"] as? Int32 {
                    self.elasticNodeCount = value
                }
                if let value = dict["replicaCount"] as? Int32 {
                    self.replicaCount = value
                }
                if let value = dict["targetIndices"] as? [String] {
                    self.targetIndices = value
                }
                if let value = dict["triggerType"] as? String {
                    self.triggerType = value
                }
            }
        }
        public class ElasticShrinkTask : Tea.TeaModel {
            public var cronExpression: String?

            public var elasticNodeCount: Int32?

            public var replicaCount: Int32?

            public var targetIndices: [String]?

            public var triggerType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cronExpression != nil {
                    map["cronExpression"] = self.cronExpression!
                }
                if self.elasticNodeCount != nil {
                    map["elasticNodeCount"] = self.elasticNodeCount!
                }
                if self.replicaCount != nil {
                    map["replicaCount"] = self.replicaCount!
                }
                if self.targetIndices != nil {
                    map["targetIndices"] = self.targetIndices!
                }
                if self.triggerType != nil {
                    map["triggerType"] = self.triggerType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["cronExpression"] as? String {
                    self.cronExpression = value
                }
                if let value = dict["elasticNodeCount"] as? Int32 {
                    self.elasticNodeCount = value
                }
                if let value = dict["replicaCount"] as? Int32 {
                    self.replicaCount = value
                }
                if let value = dict["targetIndices"] as? [String] {
                    self.targetIndices = value
                }
                if let value = dict["triggerType"] as? String {
                    self.triggerType = value
                }
            }
        }
        public var elasticExpansionTask: ModifyElastictaskResponseBody.Result.ElasticExpansionTask?

        public var elasticShrinkTask: ModifyElastictaskResponseBody.Result.ElasticShrinkTask?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.elasticExpansionTask?.validate()
            try self.elasticShrinkTask?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticExpansionTask != nil {
                map["elasticExpansionTask"] = self.elasticExpansionTask?.toMap()
            }
            if self.elasticShrinkTask != nil {
                map["elasticShrinkTask"] = self.elasticShrinkTask?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["elasticExpansionTask"] as? [String: Any?] {
                var model = ModifyElastictaskResponseBody.Result.ElasticExpansionTask()
                model.fromMap(value)
                self.elasticExpansionTask = model
            }
            if let value = dict["elasticShrinkTask"] as? [String: Any?] {
                var model = ModifyElastictaskResponseBody.Result.ElasticShrinkTask()
                model.fromMap(value)
                self.elasticShrinkTask = model
            }
        }
    }
    public var requestId: String?

    public var result: ModifyElastictaskResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = ModifyElastictaskResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class ModifyElastictaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyElastictaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyElastictaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyInstanceMaintainTimeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class ModifyInstanceMaintainTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ModifyInstanceMaintainTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceMaintainTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyInstanceMaintainTimeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ModifyWhiteIpsRequest : Tea.TeaModel {
    public class WhiteIpGroup : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var whiteIpType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.ips != nil {
                map["ips"] = self.ips!
            }
            if self.whiteIpType != nil {
                map["whiteIpType"] = self.whiteIpType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["groupName"] as? String {
                self.groupName = value
            }
            if let value = dict["ips"] as? [String] {
                self.ips = value
            }
            if let value = dict["whiteIpType"] as? String {
                self.whiteIpType = value
            }
        }
    }
    public var modifyMode: String?

    public var networkType: String?

    public var nodeType: String?

    public var whiteIpGroup: ModifyWhiteIpsRequest.WhiteIpGroup?

    public var whiteIpList: [String]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.whiteIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        if self.networkType != nil {
            map["networkType"] = self.networkType!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        if self.whiteIpGroup != nil {
            map["whiteIpGroup"] = self.whiteIpGroup?.toMap()
        }
        if self.whiteIpList != nil {
            map["whiteIpList"] = self.whiteIpList!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["modifyMode"] as? String {
            self.modifyMode = value
        }
        if let value = dict["networkType"] as? String {
            self.networkType = value
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["whiteIpGroup"] as? [String: Any?] {
            var model = ModifyWhiteIpsRequest.WhiteIpGroup()
            model.fromMap(value)
            self.whiteIpGroup = model
        }
        if let value = dict["whiteIpList"] as? [String] {
            self.whiteIpList = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class ModifyWhiteIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ModifyWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ModifyWhiteIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class MoveResourceGroupRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class MoveResourceGroupResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DictList : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vsArea"] as? String {
                    self.vsArea = value
                }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class SynonymsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var createdAt: String?

        public var description_: String?

        public var dictList: [MoveResourceGroupResponseBody.Result.DictList]?

        public var domain: String?

        public var esVersion: String?

        public var instanceId: String?

        public var kibanaConfiguration: MoveResourceGroupResponseBody.Result.KibanaConfiguration?

        public var kibanaDomain: String?

        public var kibanaPort: Int32?

        public var masterConfiguration: MoveResourceGroupResponseBody.Result.MasterConfiguration?

        public var networkConfig: MoveResourceGroupResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: MoveResourceGroupResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var publicDomain: String?

        public var publicPort: Int32?

        public var status: String?

        public var synonymsDicts: [MoveResourceGroupResponseBody.Result.SynonymsDicts]?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.dictList != nil {
                var tmp : [Any] = []
                for k in self.dictList! {
                    tmp.append(k.toMap())
                }
                map["dictList"] = tmp
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaDomain != nil {
                map["kibanaDomain"] = self.kibanaDomain!
            }
            if self.kibanaPort != nil {
                map["kibanaPort"] = self.kibanaPort!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.publicDomain != nil {
                map["publicDomain"] = self.publicDomain!
            }
            if self.publicPort != nil {
                map["publicPort"] = self.publicPort!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.synonymsDicts != nil {
                var tmp : [Any] = []
                for k in self.synonymsDicts! {
                    tmp.append(k.toMap())
                }
                map["synonymsDicts"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["dictList"] as? [Any?] {
                var tmp : [MoveResourceGroupResponseBody.Result.DictList] = []
                for v in value {
                    if v != nil {
                        var model = MoveResourceGroupResponseBody.Result.DictList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dictList = tmp
            }
            if let value = dict["domain"] as? String {
                self.domain = value
            }
            if let value = dict["esVersion"] as? String {
                self.esVersion = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["kibanaConfiguration"] as? [String: Any?] {
                var model = MoveResourceGroupResponseBody.Result.KibanaConfiguration()
                model.fromMap(value)
                self.kibanaConfiguration = model
            }
            if let value = dict["kibanaDomain"] as? String {
                self.kibanaDomain = value
            }
            if let value = dict["kibanaPort"] as? Int32 {
                self.kibanaPort = value
            }
            if let value = dict["masterConfiguration"] as? [String: Any?] {
                var model = MoveResourceGroupResponseBody.Result.MasterConfiguration()
                model.fromMap(value)
                self.masterConfiguration = model
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = MoveResourceGroupResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
            if let value = dict["nodeAmount"] as? Int32 {
                self.nodeAmount = value
            }
            if let value = dict["nodeSpec"] as? [String: Any?] {
                var model = MoveResourceGroupResponseBody.Result.NodeSpec()
                model.fromMap(value)
                self.nodeSpec = model
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["publicDomain"] as? String {
                self.publicDomain = value
            }
            if let value = dict["publicPort"] as? Int32 {
                self.publicPort = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["synonymsDicts"] as? [Any?] {
                var tmp : [MoveResourceGroupResponseBody.Result.SynonymsDicts] = []
                for v in value {
                    if v != nil {
                        var model = MoveResourceGroupResponseBody.Result.SynonymsDicts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.synonymsDicts = tmp
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
        }
    }
    public var requestId: String?

    public var result: MoveResourceGroupResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = MoveResourceGroupResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class MoveResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: MoveResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = MoveResourceGroupResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenDiagnosisRequest : Tea.TeaModel {
    public var clientToken: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class OpenDiagnosisResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class OpenDiagnosisResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenDiagnosisResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenDiagnosisResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class OpenHttpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class OpenHttpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class OpenHttpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: OpenHttpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = OpenHttpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class PostEmonTryAlarmRuleRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class PostEmonTryAlarmRuleResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var success: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.success != nil {
            map["Success"] = self.success!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Success"] as? Bool {
            self.success = value
        }
    }
}

public class PostEmonTryAlarmRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PostEmonTryAlarmRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = PostEmonTryAlarmRuleResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RecommendTemplatesRequest : Tea.TeaModel {
    public var usageScenario: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.usageScenario != nil {
            map["usageScenario"] = self.usageScenario!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["usageScenario"] as? String {
            self.usageScenario = value
        }
    }
}

public class RecommendTemplatesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var content: String?

        public var templateName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.content != nil {
                map["content"] = self.content!
            }
            if self.templateName != nil {
                map["templateName"] = self.templateName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["content"] as? String {
                self.content = value
            }
            if let value = dict["templateName"] as? String {
                self.templateName = value
            }
        }
    }
    public var requestId: String?

    public var result: [RecommendTemplatesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [RecommendTemplatesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = RecommendTemplatesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class RecommendTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecommendTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RecommendTemplatesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ReinstallCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class ReinstallCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ReinstallCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReinstallCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ReinstallCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RemoveApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class RemoveApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RemoveApmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RenewLogstashRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class RenewLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class RenewLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RenewLogstashResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class RestartCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class RestartCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartInstanceRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
    }
}

public class RestartInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class DictList : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class NetworkConfig : Tea.TeaModel {
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vsArea"] as? String {
                    self.vsArea = value
                }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class SynonymsDicts : Tea.TeaModel {
            public var fileSize: Int64?

            public var name: String?

            public var sourceType: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.fileSize != nil {
                    map["fileSize"] = self.fileSize!
                }
                if self.name != nil {
                    map["name"] = self.name!
                }
                if self.sourceType != nil {
                    map["sourceType"] = self.sourceType!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["fileSize"] as? Int64 {
                    self.fileSize = value
                }
                if let value = dict["name"] as? String {
                    self.name = value
                }
                if let value = dict["sourceType"] as? String {
                    self.sourceType = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
            }
        }
        public var createdAt: String?

        public var description_: String?

        public var dictList: [RestartInstanceResponseBody.Result.DictList]?

        public var domain: String?

        public var esVersion: String?

        public var instanceId: String?

        public var kibanaConfiguration: RestartInstanceResponseBody.Result.KibanaConfiguration?

        public var kibanaDomain: String?

        public var kibanaPort: Int32?

        public var masterConfiguration: RestartInstanceResponseBody.Result.MasterConfiguration?

        public var networkConfig: RestartInstanceResponseBody.Result.NetworkConfig?

        public var nodeAmount: Int32?

        public var nodeSpec: RestartInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var publicDomain: String?

        public var publicPort: Int32?

        public var status: String?

        public var synonymsDicts: [RestartInstanceResponseBody.Result.SynonymsDicts]?

        public var updatedAt: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.networkConfig?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.dictList != nil {
                var tmp : [Any] = []
                for k in self.dictList! {
                    tmp.append(k.toMap())
                }
                map["dictList"] = tmp
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.kibanaDomain != nil {
                map["kibanaDomain"] = self.kibanaDomain!
            }
            if self.kibanaPort != nil {
                map["kibanaPort"] = self.kibanaPort!
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.publicDomain != nil {
                map["publicDomain"] = self.publicDomain!
            }
            if self.publicPort != nil {
                map["publicPort"] = self.publicPort!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.synonymsDicts != nil {
                var tmp : [Any] = []
                for k in self.synonymsDicts! {
                    tmp.append(k.toMap())
                }
                map["synonymsDicts"] = tmp
            }
            if self.updatedAt != nil {
                map["updatedAt"] = self.updatedAt!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["dictList"] as? [Any?] {
                var tmp : [RestartInstanceResponseBody.Result.DictList] = []
                for v in value {
                    if v != nil {
                        var model = RestartInstanceResponseBody.Result.DictList()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.dictList = tmp
            }
            if let value = dict["domain"] as? String {
                self.domain = value
            }
            if let value = dict["esVersion"] as? String {
                self.esVersion = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["kibanaConfiguration"] as? [String: Any?] {
                var model = RestartInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(value)
                self.kibanaConfiguration = model
            }
            if let value = dict["kibanaDomain"] as? String {
                self.kibanaDomain = value
            }
            if let value = dict["kibanaPort"] as? Int32 {
                self.kibanaPort = value
            }
            if let value = dict["masterConfiguration"] as? [String: Any?] {
                var model = RestartInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(value)
                self.masterConfiguration = model
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = RestartInstanceResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
            if let value = dict["nodeAmount"] as? Int32 {
                self.nodeAmount = value
            }
            if let value = dict["nodeSpec"] as? [String: Any?] {
                var model = RestartInstanceResponseBody.Result.NodeSpec()
                model.fromMap(value)
                self.nodeSpec = model
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["publicDomain"] as? String {
                self.publicDomain = value
            }
            if let value = dict["publicPort"] as? Int32 {
                self.publicPort = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["synonymsDicts"] as? [Any?] {
                var tmp : [RestartInstanceResponseBody.Result.SynonymsDicts] = []
                for v in value {
                    if v != nil {
                        var model = RestartInstanceResponseBody.Result.SynonymsDicts()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.synonymsDicts = tmp
            }
            if let value = dict["updatedAt"] as? String {
                self.updatedAt = value
            }
        }
    }
    public var requestId: String?

    public var result: RestartInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = RestartInstanceResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class RestartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RestartLogstashRequest : Tea.TeaModel {
    public var batchCount: Double?

    public var blueGreenDep: Bool?

    public var nodeTypes: [String]?

    public var nodes: [String]?

    public var restartType: String?

    public var clientToken: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchCount != nil {
            map["batchCount"] = self.batchCount!
        }
        if self.blueGreenDep != nil {
            map["blueGreenDep"] = self.blueGreenDep!
        }
        if self.nodeTypes != nil {
            map["nodeTypes"] = self.nodeTypes!
        }
        if self.nodes != nil {
            map["nodes"] = self.nodes!
        }
        if self.restartType != nil {
            map["restartType"] = self.restartType!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["batchCount"] as? Double {
            self.batchCount = value
        }
        if let value = dict["blueGreenDep"] as? Bool {
            self.blueGreenDep = value
        }
        if let value = dict["nodeTypes"] as? [String] {
            self.nodeTypes = value
        }
        if let value = dict["nodes"] as? [String] {
            self.nodes = value
        }
        if let value = dict["restartType"] as? String {
            self.restartType = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
    }
}

public class RestartLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Logstash?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = Logstash()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class RestartLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RestartLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RestartLogstashResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeElasticsearchTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class ResumeElasticsearchTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ResumeElasticsearchTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeElasticsearchTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeElasticsearchTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ResumeLogstashTaskRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class ResumeLogstashTaskResponseBody : Tea.TeaModel {
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ResumeLogstashTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResumeLogstashTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ResumeLogstashTaskResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RolloverDataStreamRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class RolloverDataStreamResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class RolloverDataStreamResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RolloverDataStreamResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RolloverDataStreamResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class RunPipelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class RunPipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class RunPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = RunPipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ShrinkNodeRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var hostName: String?

        public var nodeType: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.hostName != nil {
                map["hostName"] = self.hostName!
            }
            if self.nodeType != nil {
                map["nodeType"] = self.nodeType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["hostName"] as? String {
                self.hostName = value
            }
            if let value = dict["nodeType"] as? String {
                self.nodeType = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var body: [ShrinkNodeRequest.Body]?

    public var clientToken: String?

    public var count: Int32?

    public var ignoreStatus: Bool?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.ignoreStatus != nil {
            map["ignoreStatus"] = self.ignoreStatus!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? [Any?] {
            var tmp : [ShrinkNodeRequest.Body] = []
            for v in value {
                if v != nil {
                    var model = ShrinkNodeRequest.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["count"] as? Int32 {
            self.count = value
        }
        if let value = dict["ignoreStatus"] as? Bool {
            self.ignoreStatus = value
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
    }
}

public class ShrinkNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ShrinkNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ShrinkNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ShrinkNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class StartApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartApmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StartCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class StartCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class StartCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StartCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class StopApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopApmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class StopCollectorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class StopCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class StopPipelinesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class StopPipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class StopPipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopPipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = StopPipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["key"] = self.key!
            }
            if self.value != nil {
                map["value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["key"] as? String {
                self.key = value
            }
            if let value = dict["value"] as? String {
                self.value = value
            }
        }
    }
    public var resourceIds: [String]?

    public var resourceType: String?

    public var tags: [TagResourcesRequest.Tags]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["Tags"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ResourceIds"] as? [String] {
            self.resourceIds = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["Tags"] as? [Any?] {
            var tmp : [TagResourcesRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = TagResourcesRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TransferNodeRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var body: [TransferNodeRequest.Body]?

    public var clientToken: String?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? [Any?] {
            var tmp : [TransferNodeRequest.Body] = []
            for v in value {
                if v != nil {
                    var model = TransferNodeRequest.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
    }
}

public class TransferNodeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class TransferNodeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TransferNodeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TransferNodeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class TriggerNetworkRequest : Tea.TeaModel {
    public var actionType: String?

    public var networkType: String?

    public var nodeType: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["actionType"] = self.actionType!
        }
        if self.networkType != nil {
            map["networkType"] = self.networkType!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["actionType"] as? String {
            self.actionType = value
        }
        if let value = dict["networkType"] as? String {
            self.networkType = value
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class TriggerNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class TriggerNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TriggerNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = TriggerNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UninstallKibanaPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UninstallKibanaPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class UninstallKibanaPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallKibanaPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UninstallKibanaPluginResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UninstallLogstashPluginRequest : Tea.TeaModel {
    public var body: [String]?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? [String] {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UninstallLogstashPluginResponseBody : Tea.TeaModel {
    public var headers: [String: Any]?

    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["Headers"] = self.headers!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Headers"] as? [String: Any] {
            self.headers = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class UninstallLogstashPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallLogstashPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UninstallLogstashPluginResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UninstallPluginRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var force: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
    }
}

public class UninstallPluginResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String] {
            self.result = value
        }
    }
}

public class UninstallPluginResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UninstallPluginResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UninstallPluginResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var resourceIds: String?

    public var resourceType: String?

    public var tagKeys: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKeys != nil {
            map["TagKeys"] = self.tagKeys!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["All"] as? Bool {
            self.all = value
        }
        if let value = dict["ResourceIds"] as? String {
            self.resourceIds = value
        }
        if let value = dict["ResourceType"] as? String {
            self.resourceType = value
        }
        if let value = dict["TagKeys"] as? String {
            self.tagKeys = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UntagResourcesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAdminPasswordRequest : Tea.TeaModel {
    public var esAdminPassword: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esAdminPassword != nil {
            map["esAdminPassword"] = self.esAdminPassword!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["esAdminPassword"] as? String {
            self.esAdminPassword = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateAdminPasswordResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateAdminPasswordResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAdminPasswordResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAdminPasswordResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAdvancedSettingRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateAdvancedSettingResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateAdvancedSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAdvancedSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAdvancedSettingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateAliwsDictRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateAliwsDictResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateAliwsDictResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [UpdateAliwsDictResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = UpdateAliwsDictResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class UpdateAliwsDictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateAliwsDictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateAliwsDictResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateApmRequest : Tea.TeaModel {
    public var description_: String?

    public var outputES: String?

    public var outputESPassword: String?

    public var outputESUserName: String?

    public var token: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.outputES != nil {
            map["outputES"] = self.outputES!
        }
        if self.outputESPassword != nil {
            map["outputESPassword"] = self.outputESPassword!
        }
        if self.outputESUserName != nil {
            map["outputESUserName"] = self.outputESUserName!
        }
        if self.token != nil {
            map["token"] = self.token!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["outputES"] as? String {
            self.outputES = value
        }
        if let value = dict["outputESPassword"] as? String {
            self.outputESPassword = value
        }
        if let value = dict["outputESUserName"] as? String {
            self.outputESUserName = value
        }
        if let value = dict["token"] as? String {
            self.token = value
        }
    }
}

public class UpdateApmResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateApmResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateApmResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateApmResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateBlackIpsRequest : Tea.TeaModel {
    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateBlackIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var esIPBlacklist: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.esIPBlacklist != nil {
                map["esIPBlacklist"] = self.esIPBlacklist!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["esIPBlacklist"] as? [String] {
                self.esIPBlacklist = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateBlackIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateBlackIpsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateBlackIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateBlackIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateBlackIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCollectorRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateCollectorResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["content"] as? String {
                    self.content = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["agentStatus"] as? String {
                        self.agentStatus = value
                    }
                    if let value = dict["instanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [UpdateCollectorResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["configType"] as? String {
                    self.configType = value
                }
                if let value = dict["enableMonitoring"] as? Bool {
                    self.enableMonitoring = value
                }
                if let value = dict["groupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["host"] as? String {
                    self.host = value
                }
                if let value = dict["hosts"] as? [String] {
                    self.hosts = value
                }
                if let value = dict["instanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["instanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["kibanaHost"] as? String {
                    self.kibanaHost = value
                }
                if let value = dict["machines"] as? [Any?] {
                    var tmp : [UpdateCollectorResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateCollectorResponseBody.Result.ExtendConfigs.Machines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.machines = tmp
                }
                if let value = dict["protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["successPodsCount"] as? String {
                    self.successPodsCount = value
                }
                if let value = dict["totalPodsCount"] as? String {
                    self.totalPodsCount = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["userName"] as? String {
                    self.userName = value
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [UpdateCollectorResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [UpdateCollectorResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["collectorPaths"] as? [String] {
                self.collectorPaths = value
            }
            if let value = dict["configs"] as? [Any?] {
                var tmp : [UpdateCollectorResponseBody.Result.Configs] = []
                for v in value {
                    if v != nil {
                        var model = UpdateCollectorResponseBody.Result.Configs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configs = tmp
            }
            if let value = dict["dryRun"] as? Bool {
                self.dryRun = value
            }
            if let value = dict["extendConfigs"] as? [Any?] {
                var tmp : [UpdateCollectorResponseBody.Result.ExtendConfigs] = []
                for v in value {
                    if v != nil {
                        var model = UpdateCollectorResponseBody.Result.ExtendConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.extendConfigs = tmp
            }
            if let value = dict["gmtCreatedTime"] as? String {
                self.gmtCreatedTime = value
            }
            if let value = dict["gmtUpdateTime"] as? String {
                self.gmtUpdateTime = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["resId"] as? String {
                self.resId = value
            }
            if let value = dict["resType"] as? String {
                self.resType = value
            }
            if let value = dict["resVersion"] as? String {
                self.resVersion = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateCollectorResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateCollectorResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateCollectorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCollectorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCollectorResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateCollectorNameRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateCollectorNameResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class Configs : Tea.TeaModel {
            public var content: String?

            public var fileName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["content"] = self.content!
                }
                if self.fileName != nil {
                    map["fileName"] = self.fileName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["content"] as? String {
                    self.content = value
                }
                if let value = dict["fileName"] as? String {
                    self.fileName = value
                }
            }
        }
        public class ExtendConfigs : Tea.TeaModel {
            public class Machines : Tea.TeaModel {
                public var agentStatus: String?

                public var instanceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.agentStatus != nil {
                        map["agentStatus"] = self.agentStatus!
                    }
                    if self.instanceId != nil {
                        map["instanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["agentStatus"] as? String {
                        self.agentStatus = value
                    }
                    if let value = dict["instanceId"] as? String {
                        self.instanceId = value
                    }
                }
            }
            public var configType: String?

            public var enableMonitoring: Bool?

            public var groupId: String?

            public var host: String?

            public var hosts: [String]?

            public var instanceId: String?

            public var instanceType: String?

            public var kibanaHost: String?

            public var machines: [UpdateCollectorNameResponseBody.Result.ExtendConfigs.Machines]?

            public var protocol_: String?

            public var successPodsCount: String?

            public var totalPodsCount: String?

            public var type: String?

            public var userName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.configType != nil {
                    map["configType"] = self.configType!
                }
                if self.enableMonitoring != nil {
                    map["enableMonitoring"] = self.enableMonitoring!
                }
                if self.groupId != nil {
                    map["groupId"] = self.groupId!
                }
                if self.host != nil {
                    map["host"] = self.host!
                }
                if self.hosts != nil {
                    map["hosts"] = self.hosts!
                }
                if self.instanceId != nil {
                    map["instanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["instanceType"] = self.instanceType!
                }
                if self.kibanaHost != nil {
                    map["kibanaHost"] = self.kibanaHost!
                }
                if self.machines != nil {
                    var tmp : [Any] = []
                    for k in self.machines! {
                        tmp.append(k.toMap())
                    }
                    map["machines"] = tmp
                }
                if self.protocol_ != nil {
                    map["protocol"] = self.protocol_!
                }
                if self.successPodsCount != nil {
                    map["successPodsCount"] = self.successPodsCount!
                }
                if self.totalPodsCount != nil {
                    map["totalPodsCount"] = self.totalPodsCount!
                }
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.userName != nil {
                    map["userName"] = self.userName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["configType"] as? String {
                    self.configType = value
                }
                if let value = dict["enableMonitoring"] as? Bool {
                    self.enableMonitoring = value
                }
                if let value = dict["groupId"] as? String {
                    self.groupId = value
                }
                if let value = dict["host"] as? String {
                    self.host = value
                }
                if let value = dict["hosts"] as? [String] {
                    self.hosts = value
                }
                if let value = dict["instanceId"] as? String {
                    self.instanceId = value
                }
                if let value = dict["instanceType"] as? String {
                    self.instanceType = value
                }
                if let value = dict["kibanaHost"] as? String {
                    self.kibanaHost = value
                }
                if let value = dict["machines"] as? [Any?] {
                    var tmp : [UpdateCollectorNameResponseBody.Result.ExtendConfigs.Machines] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateCollectorNameResponseBody.Result.ExtendConfigs.Machines()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.machines = tmp
                }
                if let value = dict["protocol"] as? String {
                    self.protocol_ = value
                }
                if let value = dict["successPodsCount"] as? String {
                    self.successPodsCount = value
                }
                if let value = dict["totalPodsCount"] as? String {
                    self.totalPodsCount = value
                }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["userName"] as? String {
                    self.userName = value
                }
            }
        }
        public var collectorPaths: [String]?

        public var configs: [UpdateCollectorNameResponseBody.Result.Configs]?

        public var dryRun: Bool?

        public var extendConfigs: [UpdateCollectorNameResponseBody.Result.ExtendConfigs]?

        public var gmtCreatedTime: String?

        public var gmtUpdateTime: String?

        public var name: String?

        public var ownerId: String?

        public var resId: String?

        public var resType: String?

        public var resVersion: String?

        public var status: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.collectorPaths != nil {
                map["collectorPaths"] = self.collectorPaths!
            }
            if self.configs != nil {
                var tmp : [Any] = []
                for k in self.configs! {
                    tmp.append(k.toMap())
                }
                map["configs"] = tmp
            }
            if self.dryRun != nil {
                map["dryRun"] = self.dryRun!
            }
            if self.extendConfigs != nil {
                var tmp : [Any] = []
                for k in self.extendConfigs! {
                    tmp.append(k.toMap())
                }
                map["extendConfigs"] = tmp
            }
            if self.gmtCreatedTime != nil {
                map["gmtCreatedTime"] = self.gmtCreatedTime!
            }
            if self.gmtUpdateTime != nil {
                map["gmtUpdateTime"] = self.gmtUpdateTime!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.ownerId != nil {
                map["ownerId"] = self.ownerId!
            }
            if self.resId != nil {
                map["resId"] = self.resId!
            }
            if self.resType != nil {
                map["resType"] = self.resType!
            }
            if self.resVersion != nil {
                map["resVersion"] = self.resVersion!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.vpcId != nil {
                map["vpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["collectorPaths"] as? [String] {
                self.collectorPaths = value
            }
            if let value = dict["configs"] as? [Any?] {
                var tmp : [UpdateCollectorNameResponseBody.Result.Configs] = []
                for v in value {
                    if v != nil {
                        var model = UpdateCollectorNameResponseBody.Result.Configs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.configs = tmp
            }
            if let value = dict["dryRun"] as? Bool {
                self.dryRun = value
            }
            if let value = dict["extendConfigs"] as? [Any?] {
                var tmp : [UpdateCollectorNameResponseBody.Result.ExtendConfigs] = []
                for v in value {
                    if v != nil {
                        var model = UpdateCollectorNameResponseBody.Result.ExtendConfigs()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.extendConfigs = tmp
            }
            if let value = dict["gmtCreatedTime"] as? String {
                self.gmtCreatedTime = value
            }
            if let value = dict["gmtUpdateTime"] as? String {
                self.gmtUpdateTime = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["ownerId"] as? String {
                self.ownerId = value
            }
            if let value = dict["resId"] as? String {
                self.resId = value
            }
            if let value = dict["resType"] as? String {
                self.resType = value
            }
            if let value = dict["resVersion"] as? String {
                self.resVersion = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["vpcId"] as? String {
                self.vpcId = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateCollectorNameResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateCollectorNameResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateCollectorNameResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateCollectorNameResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateCollectorNameResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateComponentIndexRequest : Tea.TeaModel {
    public class Template : Tea.TeaModel {
        public var aliases: [String: Any]?

        public var mappings: [String: Any]?

        public var settings: [String: Any]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.aliases != nil {
                map["aliases"] = self.aliases!
            }
            if self.mappings != nil {
                map["mappings"] = self.mappings!
            }
            if self.settings != nil {
                map["settings"] = self.settings!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["aliases"] as? [String: Any] {
                self.aliases = value
            }
            if let value = dict["mappings"] as? [String: Any] {
                self.mappings = value
            }
            if let value = dict["settings"] as? [String: Any] {
                self.settings = value
            }
        }
    }
    public var meta: [String: Any]?

    public var template: UpdateComponentIndexRequest.Template?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.template?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.meta != nil {
            map["_meta"] = self.meta!
        }
        if self.template != nil {
            map["template"] = self.template?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["_meta"] as? [String: Any] {
            self.meta = value
        }
        if let value = dict["template"] as? [String: Any?] {
            var model = UpdateComponentIndexRequest.Template()
            model.fromMap(value)
            self.template = model
        }
    }
}

public class UpdateComponentIndexResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["requestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["requestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateComponentIndexResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateComponentIndexResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateComponentIndexResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateDescriptionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateDescriptionResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateDescriptionResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDiagnosisSettingsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public var lang: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.lang != nil {
            map["lang"] = self.lang!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["lang"] as? String {
            self.lang = value
        }
    }
}

public class UpdateDiagnosisSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateDiagnosisSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDiagnosisSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDiagnosisSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDictRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateDictResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateDictResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [UpdateDictResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = UpdateDictResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class UpdateDictResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDictResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDictResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateDynamicSettingsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var regionId: String?

    public var body: String?

    public var mode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.mode != nil {
            map["mode"] = self.mode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["RegionId"] as? String {
            self.regionId = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["mode"] as? String {
            self.mode = value
        }
    }
}

public class UpdateDynamicSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateDynamicSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateDynamicSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateDynamicSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateExtendConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateExtendConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateExtendConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateExtendConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateExtendConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateExtendfilesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateExtendfilesResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateExtendfilesResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [UpdateExtendfilesResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = UpdateExtendfilesResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class UpdateExtendfilesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateExtendfilesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateExtendfilesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateHotIkDictsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateHotIkDictsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateHotIkDictsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [UpdateHotIkDictsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = UpdateHotIkDictsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class UpdateHotIkDictsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateHotIkDictsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateHotIkDictsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateILMPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateILMPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
    }
}

public class UpdateILMPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateILMPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateILMPolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateIndexTemplateRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateIndexTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? String {
            self.result = value
        }
    }
}

public class UpdateIndexTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateIndexTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateIndexTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateInstanceRequest : Tea.TeaModel {
    public var clientNodeConfiguration: ClientNodeConfiguration?

    public var elasticDataNodeConfiguration: ElasticDataNodeConfiguration?

    public var instanceCategory: String?

    public var kibanaConfiguration: KibanaNodeConfiguration?

    public var masterConfiguration: MasterNodeConfiguration?

    public var nodeAmount: Int32?

    public var nodeSpec: NodeSpec?

    public var warmNodeConfiguration: WarmNodeConfiguration?

    public var clientToken: String?

    public var force: Bool?

    public var orderActionType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clientNodeConfiguration?.validate()
        try self.elasticDataNodeConfiguration?.validate()
        try self.kibanaConfiguration?.validate()
        try self.masterConfiguration?.validate()
        try self.nodeSpec?.validate()
        try self.warmNodeConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientNodeConfiguration != nil {
            map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
        }
        if self.elasticDataNodeConfiguration != nil {
            map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
        }
        if self.instanceCategory != nil {
            map["instanceCategory"] = self.instanceCategory!
        }
        if self.kibanaConfiguration != nil {
            map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
        }
        if self.masterConfiguration != nil {
            map["masterConfiguration"] = self.masterConfiguration?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.warmNodeConfiguration != nil {
            map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        if self.orderActionType != nil {
            map["orderActionType"] = self.orderActionType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientNodeConfiguration"] as? [String: Any?] {
            var model = ClientNodeConfiguration()
            model.fromMap(value)
            self.clientNodeConfiguration = model
        }
        if let value = dict["elasticDataNodeConfiguration"] as? [String: Any?] {
            var model = ElasticDataNodeConfiguration()
            model.fromMap(value)
            self.elasticDataNodeConfiguration = model
        }
        if let value = dict["instanceCategory"] as? String {
            self.instanceCategory = value
        }
        if let value = dict["kibanaConfiguration"] as? [String: Any?] {
            var model = KibanaNodeConfiguration()
            model.fromMap(value)
            self.kibanaConfiguration = model
        }
        if let value = dict["masterConfiguration"] as? [String: Any?] {
            var model = MasterNodeConfiguration()
            model.fromMap(value)
            self.masterConfiguration = model
        }
        if let value = dict["nodeAmount"] as? Int32 {
            self.nodeAmount = value
        }
        if let value = dict["nodeSpec"] as? [String: Any?] {
            var model = NodeSpec()
            model.fromMap(value)
            self.nodeSpec = model
        }
        if let value = dict["warmNodeConfiguration"] as? [String: Any?] {
            var model = WarmNodeConfiguration()
            model.fromMap(value)
            self.warmNodeConfiguration = model
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
        if let value = dict["orderActionType"] as? String {
            self.orderActionType = value
        }
    }
}

public class UpdateInstanceResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class KibanaConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class MasterConfiguration : Tea.TeaModel {
            public var amount: Int32?

            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["amount"] = self.amount!
                }
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["amount"] as? Int32 {
                    self.amount = value
                }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public class NodeSpec : Tea.TeaModel {
            public var disk: Int32?

            public var diskType: String?

            public var spec: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.disk != nil {
                    map["disk"] = self.disk!
                }
                if self.diskType != nil {
                    map["diskType"] = self.diskType!
                }
                if self.spec != nil {
                    map["spec"] = self.spec!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["disk"] as? Int32 {
                    self.disk = value
                }
                if let value = dict["diskType"] as? String {
                    self.diskType = value
                }
                if let value = dict["spec"] as? String {
                    self.spec = value
                }
            }
        }
        public var createdAt: String?

        public var description_: String?

        public var domain: String?

        public var esVersion: String?

        public var instanceId: String?

        public var kibanaConfiguration: UpdateInstanceResponseBody.Result.KibanaConfiguration?

        public var masterConfiguration: UpdateInstanceResponseBody.Result.MasterConfiguration?

        public var nodeAmount: Int32?

        public var nodeSpec: UpdateInstanceResponseBody.Result.NodeSpec?

        public var paymentType: String?

        public var status: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.kibanaConfiguration?.validate()
            try self.masterConfiguration?.validate()
            try self.nodeSpec?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.createdAt != nil {
                map["createdAt"] = self.createdAt!
            }
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            if self.domain != nil {
                map["domain"] = self.domain!
            }
            if self.esVersion != nil {
                map["esVersion"] = self.esVersion!
            }
            if self.instanceId != nil {
                map["instanceId"] = self.instanceId!
            }
            if self.kibanaConfiguration != nil {
                map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
            }
            if self.masterConfiguration != nil {
                map["masterConfiguration"] = self.masterConfiguration?.toMap()
            }
            if self.nodeAmount != nil {
                map["nodeAmount"] = self.nodeAmount!
            }
            if self.nodeSpec != nil {
                map["nodeSpec"] = self.nodeSpec?.toMap()
            }
            if self.paymentType != nil {
                map["paymentType"] = self.paymentType!
            }
            if self.status != nil {
                map["status"] = self.status!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["createdAt"] as? String {
                self.createdAt = value
            }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
            if let value = dict["domain"] as? String {
                self.domain = value
            }
            if let value = dict["esVersion"] as? String {
                self.esVersion = value
            }
            if let value = dict["instanceId"] as? String {
                self.instanceId = value
            }
            if let value = dict["kibanaConfiguration"] as? [String: Any?] {
                var model = UpdateInstanceResponseBody.Result.KibanaConfiguration()
                model.fromMap(value)
                self.kibanaConfiguration = model
            }
            if let value = dict["masterConfiguration"] as? [String: Any?] {
                var model = UpdateInstanceResponseBody.Result.MasterConfiguration()
                model.fromMap(value)
                self.masterConfiguration = model
            }
            if let value = dict["nodeAmount"] as? Int32 {
                self.nodeAmount = value
            }
            if let value = dict["nodeSpec"] as? [String: Any?] {
                var model = UpdateInstanceResponseBody.Result.NodeSpec()
                model.fromMap(value)
                self.nodeSpec = model
            }
            if let value = dict["paymentType"] as? String {
                self.paymentType = value
            }
            if let value = dict["status"] as? String {
                self.status = value
            }
        }
    }
    public var code: String?

    public var message: String?

    public var requestId: String?

    public var result: UpdateInstanceResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["Code"] as? String {
            self.code = value
        }
        if let value = dict["Message"] as? String {
            self.message = value
        }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateInstanceResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateInstanceResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateInstanceChargeTypeRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateInstanceChargeTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateInstanceChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateInstanceChargeTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateInstanceSettingsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var force: Bool?

    public var updateStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["force"] = self.force!
        }
        if self.updateStrategy != nil {
            map["updateStrategy"] = self.updateStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["force"] as? Bool {
            self.force = value
        }
        if let value = dict["updateStrategy"] as? String {
            self.updateStrategy = value
        }
    }
}

public class UpdateInstanceSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateInstanceSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateInstanceSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateInstanceSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateKibanaPvlNetworkRequest : Tea.TeaModel {
    public var endpointName: String?

    public var securityGroups: [String]?

    public var pvlId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpointName != nil {
            map["endpointName"] = self.endpointName!
        }
        if self.securityGroups != nil {
            map["securityGroups"] = self.securityGroups!
        }
        if self.pvlId != nil {
            map["pvlId"] = self.pvlId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endpointName"] as? String {
            self.endpointName = value
        }
        if let value = dict["securityGroups"] as? [String] {
            self.securityGroups = value
        }
        if let value = dict["pvlId"] as? String {
            self.pvlId = value
        }
    }
}

public class UpdateKibanaPvlNetworkResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateKibanaPvlNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateKibanaPvlNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateKibanaPvlNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateKibanaSettingsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateKibanaSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateKibanaSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateKibanaSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateKibanaSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateKibanaWhiteIpsRequest : Tea.TeaModel {
    public class WhiteIpGroup : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var whiteIpType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.ips != nil {
                map["ips"] = self.ips!
            }
            if self.whiteIpType != nil {
                map["whiteIpType"] = self.whiteIpType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["groupName"] as? String {
                self.groupName = value
            }
            if let value = dict["ips"] as? [String] {
                self.ips = value
            }
            if let value = dict["whiteIpType"] as? String {
                self.whiteIpType = value
            }
        }
    }
    public var kibanaIPWhitelist: [String]?

    public var whiteIpGroup: UpdateKibanaWhiteIpsRequest.WhiteIpGroup?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.whiteIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.kibanaIPWhitelist != nil {
            map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
        }
        if self.whiteIpGroup != nil {
            map["whiteIpGroup"] = self.whiteIpGroup?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["kibanaIPWhitelist"] as? [String] {
            self.kibanaIPWhitelist = value
        }
        if let value = dict["whiteIpGroup"] as? [String: Any?] {
            var model = UpdateKibanaWhiteIpsRequest.WhiteIpGroup()
            model.fromMap(value)
            self.whiteIpGroup = model
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["modifyMode"] as? String {
            self.modifyMode = value
        }
    }
}

public class UpdateKibanaWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["groupName"] as? String {
                        self.groupName = value
                    }
                    if let value = dict["ips"] as? [String] {
                        self.ips = value
                    }
                    if let value = dict["whiteIpType"] as? String {
                        self.whiteIpType = value
                    }
                }
            }
            public var type: String?

            public var vpcId: String?

            public var vsArea: String?

            public var vswitchId: String?

            public var whiteIpGroupList: [UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.type != nil {
                    map["type"] = self.type!
                }
                if self.vpcId != nil {
                    map["vpcId"] = self.vpcId!
                }
                if self.vsArea != nil {
                    map["vsArea"] = self.vsArea!
                }
                if self.vswitchId != nil {
                    map["vswitchId"] = self.vswitchId!
                }
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["type"] as? String {
                    self.type = value
                }
                if let value = dict["vpcId"] as? String {
                    self.vpcId = value
                }
                if let value = dict["vsArea"] as? String {
                    self.vsArea = value
                }
                if let value = dict["vswitchId"] as? String {
                    self.vswitchId = value
                }
                if let value = dict["whiteIpGroupList"] as? [Any?] {
                    var tmp : [UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public var kibanaIPWhitelist: [String]?

        public var kibanaPrivateIPWhitelist: [String]?

        public var networkConfig: UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.kibanaIPWhitelist != nil {
                map["kibanaIPWhitelist"] = self.kibanaIPWhitelist!
            }
            if self.kibanaPrivateIPWhitelist != nil {
                map["kibanaPrivateIPWhitelist"] = self.kibanaPrivateIPWhitelist!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["kibanaIPWhitelist"] as? [String] {
                self.kibanaIPWhitelist = value
            }
            if let value = dict["kibanaPrivateIPWhitelist"] as? [String] {
                self.kibanaPrivateIPWhitelist = value
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = UpdateKibanaWhiteIpsResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
        }
    }
    public var requestId: String?

    public var result: UpdateKibanaWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateKibanaWhiteIpsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateKibanaWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateKibanaWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateKibanaWhiteIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLogstashRequest : Tea.TeaModel {
    public class NodeSpec : Tea.TeaModel {
        public var disk: Int32?

        public var diskType: String?

        public var spec: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                map["disk"] = self.disk!
            }
            if self.diskType != nil {
                map["diskType"] = self.diskType!
            }
            if self.spec != nil {
                map["spec"] = self.spec!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["disk"] as? Int32 {
                self.disk = value
            }
            if let value = dict["diskType"] as? String {
                self.diskType = value
            }
            if let value = dict["spec"] as? String {
                self.spec = value
            }
        }
    }
    public var nodeAmount: Int32?

    public var nodeSpec: UpdateLogstashRequest.NodeSpec?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.nodeSpec?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["nodeAmount"] as? Int32 {
            self.nodeAmount = value
        }
        if let value = dict["nodeSpec"] as? [String: Any?] {
            var model = UpdateLogstashRequest.NodeSpec()
            model.fromMap(value)
            self.nodeSpec = model
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateLogstashResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateLogstashResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLogstashResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLogstashChargeTypeRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateLogstashChargeTypeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateLogstashChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLogstashChargeTypeResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLogstashDescriptionRequest : Tea.TeaModel {
    public var description_: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateLogstashDescriptionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["description"] as? String {
                self.description_ = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateLogstashDescriptionResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateLogstashDescriptionResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateLogstashDescriptionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashDescriptionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLogstashDescriptionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateLogstashSettingsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateLogstashSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
    }
}

public class UpdateLogstashSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateLogstashSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateLogstashSettingsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePipelineManagementConfigRequest : Tea.TeaModel {
    public var endpoints: [String]?

    public var esInstanceId: String?

    public var password: String?

    public var pipelineIds: [String]?

    public var pipelineManagementType: String?

    public var userName: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endpoints != nil {
            map["endpoints"] = self.endpoints!
        }
        if self.esInstanceId != nil {
            map["esInstanceId"] = self.esInstanceId!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.pipelineIds != nil {
            map["pipelineIds"] = self.pipelineIds!
        }
        if self.pipelineManagementType != nil {
            map["pipelineManagementType"] = self.pipelineManagementType!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["endpoints"] as? [String] {
            self.endpoints = value
        }
        if let value = dict["esInstanceId"] as? String {
            self.esInstanceId = value
        }
        if let value = dict["password"] as? String {
            self.password = value
        }
        if let value = dict["pipelineIds"] as? [String] {
            self.pipelineIds = value
        }
        if let value = dict["pipelineManagementType"] as? String {
            self.pipelineManagementType = value
        }
        if let value = dict["userName"] as? String {
            self.userName = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdatePipelineManagementConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdatePipelineManagementConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelineManagementConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePipelineManagementConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePipelinesRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var trigger: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.trigger != nil {
            map["trigger"] = self.trigger!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["trigger"] as? Bool {
            self.trigger = value
        }
    }
}

public class UpdatePipelinesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdatePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePipelinesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePrivateNetworkWhiteIpsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["modifyMode"] as? String {
            self.modifyMode = value
        }
    }
}

public class UpdatePrivateNetworkWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var privateNetworkIpWhiteList: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateNetworkIpWhiteList != nil {
                map["privateNetworkIpWhiteList"] = self.privateNetworkIpWhiteList!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["privateNetworkIpWhiteList"] as? [String] {
                self.privateNetworkIpWhiteList = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdatePrivateNetworkWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdatePrivateNetworkWhiteIpsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdatePrivateNetworkWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePrivateNetworkWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePrivateNetworkWhiteIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePublicNetworkRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdatePublicNetworkResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enablePublic: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enablePublic != nil {
                map["enablePublic"] = self.enablePublic!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["enablePublic"] as? Bool {
                self.enablePublic = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdatePublicNetworkResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdatePublicNetworkResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdatePublicNetworkResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePublicNetworkResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePublicNetworkResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdatePublicWhiteIpsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["modifyMode"] as? String {
            self.modifyMode = value
        }
    }
}

public class UpdatePublicWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var publicIpWhitelist: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.publicIpWhitelist != nil {
                map["publicIpWhitelist"] = self.publicIpWhitelist!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["publicIpWhitelist"] as? [String] {
                self.publicIpWhitelist = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdatePublicWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdatePublicWhiteIpsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdatePublicWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdatePublicWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdatePublicWhiteIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateReadWritePolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateReadWritePolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateReadWritePolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateReadWritePolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateReadWritePolicyResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSnapshotSettingRequest : Tea.TeaModel {
    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateSnapshotSettingResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var enable: Bool?

        public var quartzRegex: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.quartzRegex != nil {
                map["quartzRegex"] = self.quartzRegex!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["enable"] as? Bool {
                self.enable = value
            }
            if let value = dict["quartzRegex"] as? String {
                self.quartzRegex = value
            }
        }
    }
    public var requestId: String?

    public var result: UpdateSnapshotSettingResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateSnapshotSettingResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateSnapshotSettingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSnapshotSettingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSnapshotSettingResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateSynonymsDictsRequest : Tea.TeaModel {
    public var body: String?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            map["body"] = self.body!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? String {
            self.body = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class UpdateSynonymsDictsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public var fileSize: Int64?

        public var name: String?

        public var sourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.fileSize != nil {
                map["fileSize"] = self.fileSize!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.sourceType != nil {
                map["sourceType"] = self.sourceType!
            }
            if self.type != nil {
                map["type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["fileSize"] as? Int64 {
                self.fileSize = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["sourceType"] as? String {
                self.sourceType = value
            }
            if let value = dict["type"] as? String {
                self.type = value
            }
        }
    }
    public var requestId: String?

    public var result: [UpdateSynonymsDictsResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [UpdateSynonymsDictsResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = UpdateSynonymsDictsResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class UpdateSynonymsDictsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateSynonymsDictsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateSynonymsDictsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateTemplateRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class UpdateTemplateResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateTemplateResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateWhiteIpsRequest : Tea.TeaModel {
    public class WhiteIpGroup : Tea.TeaModel {
        public var groupName: String?

        public var ips: [String]?

        public var whiteIpType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.groupName != nil {
                map["groupName"] = self.groupName!
            }
            if self.ips != nil {
                map["ips"] = self.ips!
            }
            if self.whiteIpType != nil {
                map["whiteIpType"] = self.whiteIpType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["groupName"] as? String {
                self.groupName = value
            }
            if let value = dict["ips"] as? [String] {
                self.ips = value
            }
            if let value = dict["whiteIpType"] as? String {
                self.whiteIpType = value
            }
        }
    }
    public var esIPWhitelist: [String]?

    public var whiteIpGroup: UpdateWhiteIpsRequest.WhiteIpGroup?

    public var clientToken: String?

    public var modifyMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.whiteIpGroup?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.esIPWhitelist != nil {
            map["esIPWhitelist"] = self.esIPWhitelist!
        }
        if self.whiteIpGroup != nil {
            map["whiteIpGroup"] = self.whiteIpGroup?.toMap()
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.modifyMode != nil {
            map["modifyMode"] = self.modifyMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["esIPWhitelist"] as? [String] {
            self.esIPWhitelist = value
        }
        if let value = dict["whiteIpGroup"] as? [String: Any?] {
            var model = UpdateWhiteIpsRequest.WhiteIpGroup()
            model.fromMap(value)
            self.whiteIpGroup = model
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["modifyMode"] as? String {
            self.modifyMode = value
        }
    }
}

public class UpdateWhiteIpsResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class NetworkConfig : Tea.TeaModel {
            public class WhiteIpGroupList : Tea.TeaModel {
                public var groupName: String?

                public var ips: [String]?

                public var whiteIpType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.groupName != nil {
                        map["groupName"] = self.groupName!
                    }
                    if self.ips != nil {
                        map["ips"] = self.ips!
                    }
                    if self.whiteIpType != nil {
                        map["whiteIpType"] = self.whiteIpType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any?]?) -> Void {
                    guard let dict else { return }
                    if let value = dict["groupName"] as? String {
                        self.groupName = value
                    }
                    if let value = dict["ips"] as? [String] {
                        self.ips = value
                    }
                    if let value = dict["whiteIpType"] as? String {
                        self.whiteIpType = value
                    }
                }
            }
            public var whiteIpGroupList: [UpdateWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.whiteIpGroupList != nil {
                    var tmp : [Any] = []
                    for k in self.whiteIpGroupList! {
                        tmp.append(k.toMap())
                    }
                    map["whiteIpGroupList"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["whiteIpGroupList"] as? [Any?] {
                    var tmp : [UpdateWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList] = []
                    for v in value {
                        if v != nil {
                            var model = UpdateWhiteIpsResponseBody.Result.NetworkConfig.WhiteIpGroupList()
                            if v != nil {
                                model.fromMap(v as? [String: Any?])
                            }
                            tmp.append(model)
                        }
                    }
                    self.whiteIpGroupList = tmp
                }
            }
        }
        public var esIPWhitelist: [String]?

        public var networkConfig: UpdateWhiteIpsResponseBody.Result.NetworkConfig?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.networkConfig?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.esIPWhitelist != nil {
                map["esIPWhitelist"] = self.esIPWhitelist!
            }
            if self.networkConfig != nil {
                map["networkConfig"] = self.networkConfig?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["esIPWhitelist"] as? [String] {
                self.esIPWhitelist = value
            }
            if let value = dict["networkConfig"] as? [String: Any?] {
                var model = UpdateWhiteIpsResponseBody.Result.NetworkConfig()
                model.fromMap(value)
                self.networkConfig = model
            }
        }
    }
    public var requestId: String?

    public var result: UpdateWhiteIpsResponseBody.Result?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.result?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [String: Any?] {
            var model = UpdateWhiteIpsResponseBody.Result()
            model.fromMap(value)
            self.result = model
        }
    }
}

public class UpdateWhiteIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateWhiteIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateWhiteIpsResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpdateXpackMonitorConfigRequest : Tea.TeaModel {
    public var clientToken: String?

    public var enable: Bool?

    public var endpoints: [String]?

    public var password: String?

    public var userName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.enable != nil {
            map["enable"] = self.enable!
        }
        if self.endpoints != nil {
            map["endpoints"] = self.endpoints!
        }
        if self.password != nil {
            map["password"] = self.password!
        }
        if self.userName != nil {
            map["userName"] = self.userName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["enable"] as? Bool {
            self.enable = value
        }
        if let value = dict["endpoints"] as? [String] {
            self.endpoints = value
        }
        if let value = dict["password"] as? String {
            self.password = value
        }
        if let value = dict["userName"] as? String {
            self.userName = value
        }
    }
}

public class UpdateXpackMonitorConfigResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class UpdateXpackMonitorConfigResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpdateXpackMonitorConfigResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpdateXpackMonitorConfigResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class UpgradeEngineVersionRequest : Tea.TeaModel {
    public class Plugins : Tea.TeaModel {
        public var enable: String?

        public var fileVersion: String?

        public var name: String?

        public var version: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enable != nil {
                map["enable"] = self.enable!
            }
            if self.fileVersion != nil {
                map["fileVersion"] = self.fileVersion!
            }
            if self.name != nil {
                map["name"] = self.name!
            }
            if self.version != nil {
                map["version"] = self.version!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["enable"] as? String {
                self.enable = value
            }
            if let value = dict["fileVersion"] as? String {
                self.fileVersion = value
            }
            if let value = dict["name"] as? String {
                self.name = value
            }
            if let value = dict["version"] as? String {
                self.version = value
            }
        }
    }
    public var plugins: [UpgradeEngineVersionRequest.Plugins]?

    public var type: String?

    public var version: String?

    public var clientToken: String?

    public var dryRun: Bool?

    public var updateStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.plugins != nil {
            var tmp : [Any] = []
            for k in self.plugins! {
                tmp.append(k.toMap())
            }
            map["plugins"] = tmp
        }
        if self.type != nil {
            map["type"] = self.type!
        }
        if self.version != nil {
            map["version"] = self.version!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["dryRun"] = self.dryRun!
        }
        if self.updateStrategy != nil {
            map["updateStrategy"] = self.updateStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["plugins"] as? [Any?] {
            var tmp : [UpgradeEngineVersionRequest.Plugins] = []
            for v in value {
                if v != nil {
                    var model = UpgradeEngineVersionRequest.Plugins()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.plugins = tmp
        }
        if let value = dict["type"] as? String {
            self.type = value
        }
        if let value = dict["version"] as? String {
            self.version = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["dryRun"] as? Bool {
            self.dryRun = value
        }
        if let value = dict["updateStrategy"] as? String {
            self.updateStrategy = value
        }
    }
}

public class UpgradeEngineVersionResponseBody : Tea.TeaModel {
    public class Result : Tea.TeaModel {
        public class ValidateResult : Tea.TeaModel {
            public var errorCode: String?

            public var errorMsg: String?

            public var errorType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["errorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["errorMsg"] = self.errorMsg!
                }
                if self.errorType != nil {
                    map["errorType"] = self.errorType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any?]?) -> Void {
                guard let dict else { return }
                if let value = dict["errorCode"] as? String {
                    self.errorCode = value
                }
                if let value = dict["errorMsg"] as? String {
                    self.errorMsg = value
                }
                if let value = dict["errorType"] as? String {
                    self.errorType = value
                }
            }
        }
        public var status: String?

        public var validateResult: [UpgradeEngineVersionResponseBody.Result.ValidateResult]?

        public var validateType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.status != nil {
                map["status"] = self.status!
            }
            if self.validateResult != nil {
                var tmp : [Any] = []
                for k in self.validateResult! {
                    tmp.append(k.toMap())
                }
                map["validateResult"] = tmp
            }
            if self.validateType != nil {
                map["validateType"] = self.validateType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["status"] as? String {
                self.status = value
            }
            if let value = dict["validateResult"] as? [Any?] {
                var tmp : [UpgradeEngineVersionResponseBody.Result.ValidateResult] = []
                for v in value {
                    if v != nil {
                        var model = UpgradeEngineVersionResponseBody.Result.ValidateResult()
                        if v != nil {
                            model.fromMap(v as? [String: Any?])
                        }
                        tmp.append(model)
                    }
                }
                self.validateResult = tmp
            }
            if let value = dict["validateType"] as? String {
                self.validateType = value
            }
        }
    }
    public var requestId: String?

    public var result: [UpgradeEngineVersionResponseBody.Result]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            var tmp : [Any] = []
            for k in self.result! {
                tmp.append(k.toMap())
            }
            map["Result"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? [Any?] {
            var tmp : [UpgradeEngineVersionResponseBody.Result] = []
            for v in value {
                if v != nil {
                    var model = UpgradeEngineVersionResponseBody.Result()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.result = tmp
        }
    }
}

public class UpgradeEngineVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UpgradeEngineVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = UpgradeEngineVersionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ValidateConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var body: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.body != nil {
            map["body"] = self.body!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["body"] as? String {
            self.body = value
        }
    }
}

public class ValidateConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ValidateConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ValidateConnectionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ValidateShrinkNodesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var hostName: String?

        public var nodeType: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.hostName != nil {
                map["hostName"] = self.hostName!
            }
            if self.nodeType != nil {
                map["nodeType"] = self.nodeType!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["hostName"] as? String {
                self.hostName = value
            }
            if let value = dict["nodeType"] as? String {
                self.nodeType = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var body: [ValidateShrinkNodesRequest.Body]?

    public var count: Int32?

    public var ignoreStatus: Bool?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.count != nil {
            map["count"] = self.count!
        }
        if self.ignoreStatus != nil {
            map["ignoreStatus"] = self.ignoreStatus!
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? [Any?] {
            var tmp : [ValidateShrinkNodesRequest.Body] = []
            for v in value {
                if v != nil {
                    var model = ValidateShrinkNodesRequest.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
        if let value = dict["count"] as? Int32 {
            self.count = value
        }
        if let value = dict["ignoreStatus"] as? Bool {
            self.ignoreStatus = value
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
    }
}

public class ValidateShrinkNodesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ValidateShrinkNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateShrinkNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ValidateShrinkNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ValidateSlrPermissionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var rolename: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.rolename != nil {
            map["rolename"] = self.rolename!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["ClientToken"] as? String {
            self.clientToken = value
        }
        if let value = dict["rolename"] as? String {
            self.rolename = value
        }
    }
}

public class ValidateSlrPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ValidateSlrPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateSlrPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ValidateSlrPermissionResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class ValidateTransferableNodesRequest : Tea.TeaModel {
    public class Body : Tea.TeaModel {
        public var host: String?

        public var port: Int32?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.host != nil {
                map["host"] = self.host!
            }
            if self.port != nil {
                map["port"] = self.port!
            }
            if self.zoneId != nil {
                map["zoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["host"] as? String {
                self.host = value
            }
            if let value = dict["port"] as? Int32 {
                self.port = value
            }
            if let value = dict["zoneId"] as? String {
                self.zoneId = value
            }
        }
    }
    public var body: [ValidateTransferableNodesRequest.Body]?

    public var nodeType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.body != nil {
            var tmp : [Any] = []
            for k in self.body! {
                tmp.append(k.toMap())
            }
            map["body"] = tmp
        }
        if self.nodeType != nil {
            map["nodeType"] = self.nodeType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["body"] as? [Any?] {
            var tmp : [ValidateTransferableNodesRequest.Body] = []
            for v in value {
                if v != nil {
                    var model = ValidateTransferableNodesRequest.Body()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.body = tmp
        }
        if let value = dict["nodeType"] as? String {
            self.nodeType = value
        }
    }
}

public class ValidateTransferableNodesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var result: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.result != nil {
            map["Result"] = self.result!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["RequestId"] as? String {
            self.requestId = value
        }
        if let value = dict["Result"] as? Bool {
            self.result = value
        }
    }
}

public class ValidateTransferableNodesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ValidateTransferableNodesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
        if let value = dict["body"] as? [String: Any?] {
            var model = ValidateTransferableNodesResponseBody()
            model.fromMap(value)
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public var tagKey: String?

        public var tagValue: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["tagKey"] = self.tagKey!
            }
            if self.tagValue != nil {
                map["tagValue"] = self.tagValue!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any?]?) -> Void {
            guard let dict else { return }
            if let value = dict["tagKey"] as? String {
                self.tagKey = value
            }
            if let value = dict["tagValue"] as? String {
                self.tagValue = value
            }
        }
    }
    public var clientNodeConfiguration: ClientNodeConfiguration?

    public var description_: String?

    public var elasticDataNodeConfiguration: ElasticDataNodeConfiguration?

    public var esAdminPassword: String?

    public var esVersion: String?

    public var instanceCategory: String?

    public var kibanaConfiguration: KibanaNodeConfiguration?

    public var masterConfiguration: MasterNodeConfiguration?

    public var networkConfig: NetworkConfig?

    public var nodeAmount: Int32?

    public var nodeSpec: NodeSpec?

    public var paymentInfo: PaymentInfo?

    public var paymentType: String?

    public var resourceGroupId: String?

    public var tags: [CreateInstanceRequest.Tags]?

    public var warmNodeConfiguration: WarmNodeConfiguration?

    public var zoneCount: Int32?

    public var clientToken: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clientNodeConfiguration?.validate()
        try self.elasticDataNodeConfiguration?.validate()
        try self.kibanaConfiguration?.validate()
        try self.masterConfiguration?.validate()
        try self.networkConfig?.validate()
        try self.nodeSpec?.validate()
        try self.paymentInfo?.validate()
        try self.warmNodeConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientNodeConfiguration != nil {
            map["clientNodeConfiguration"] = self.clientNodeConfiguration?.toMap()
        }
        if self.description_ != nil {
            map["description"] = self.description_!
        }
        if self.elasticDataNodeConfiguration != nil {
            map["elasticDataNodeConfiguration"] = self.elasticDataNodeConfiguration?.toMap()
        }
        if self.esAdminPassword != nil {
            map["esAdminPassword"] = self.esAdminPassword!
        }
        if self.esVersion != nil {
            map["esVersion"] = self.esVersion!
        }
        if self.instanceCategory != nil {
            map["instanceCategory"] = self.instanceCategory!
        }
        if self.kibanaConfiguration != nil {
            map["kibanaConfiguration"] = self.kibanaConfiguration?.toMap()
        }
        if self.masterConfiguration != nil {
            map["masterConfiguration"] = self.masterConfiguration?.toMap()
        }
        if self.networkConfig != nil {
            map["networkConfig"] = self.networkConfig?.toMap()
        }
        if self.nodeAmount != nil {
            map["nodeAmount"] = self.nodeAmount!
        }
        if self.nodeSpec != nil {
            map["nodeSpec"] = self.nodeSpec?.toMap()
        }
        if self.paymentInfo != nil {
            map["paymentInfo"] = self.paymentInfo?.toMap()
        }
        if self.paymentType != nil {
            map["paymentType"] = self.paymentType!
        }
        if self.resourceGroupId != nil {
            map["resourceGroupId"] = self.resourceGroupId!
        }
        if self.tags != nil {
            var tmp : [Any] = []
            for k in self.tags! {
                tmp.append(k.toMap())
            }
            map["tags"] = tmp
        }
        if self.warmNodeConfiguration != nil {
            map["warmNodeConfiguration"] = self.warmNodeConfiguration?.toMap()
        }
        if self.zoneCount != nil {
            map["zoneCount"] = self.zoneCount!
        }
        if self.clientToken != nil {
            map["clientToken"] = self.clientToken!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["clientNodeConfiguration"] as? [String: Any?] {
            var model = ClientNodeConfiguration()
            model.fromMap(value)
            self.clientNodeConfiguration = model
        }
        if let value = dict["description"] as? String {
            self.description_ = value
        }
        if let value = dict["elasticDataNodeConfiguration"] as? [String: Any?] {
            var model = ElasticDataNodeConfiguration()
            model.fromMap(value)
            self.elasticDataNodeConfiguration = model
        }
        if let value = dict["esAdminPassword"] as? String {
            self.esAdminPassword = value
        }
        if let value = dict["esVersion"] as? String {
            self.esVersion = value
        }
        if let value = dict["instanceCategory"] as? String {
            self.instanceCategory = value
        }
        if let value = dict["kibanaConfiguration"] as? [String: Any?] {
            var model = KibanaNodeConfiguration()
            model.fromMap(value)
            self.kibanaConfiguration = model
        }
        if let value = dict["masterConfiguration"] as? [String: Any?] {
            var model = MasterNodeConfiguration()
            model.fromMap(value)
            self.masterConfiguration = model
        }
        if let value = dict["networkConfig"] as? [String: Any?] {
            var model = NetworkConfig()
            model.fromMap(value)
            self.networkConfig = model
        }
        if let value = dict["nodeAmount"] as? Int32 {
            self.nodeAmount = value
        }
        if let value = dict["nodeSpec"] as? [String: Any?] {
            var model = NodeSpec()
            model.fromMap(value)
            self.nodeSpec = model
        }
        if let value = dict["paymentInfo"] as? [String: Any?] {
            var model = PaymentInfo()
            model.fromMap(value)
            self.paymentInfo = model
        }
        if let value = dict["paymentType"] as? String {
            self.paymentType = value
        }
        if let value = dict["resourceGroupId"] as? String {
            self.resourceGroupId = value
        }
        if let value = dict["tags"] as? [Any?] {
            var tmp : [CreateInstanceRequest.Tags] = []
            for v in value {
                if v != nil {
                    var model = CreateInstanceRequest.Tags()
                    if v != nil {
                        model.fromMap(v as? [String: Any?])
                    }
                    tmp.append(model)
                }
            }
            self.tags = tmp
        }
        if let value = dict["warmNodeConfiguration"] as? [String: Any?] {
            var model = WarmNodeConfiguration()
            model.fromMap(value)
            self.warmNodeConfiguration = model
        }
        if let value = dict["zoneCount"] as? Int32 {
            self.zoneCount = value
        }
        if let value = dict["clientToken"] as? String {
            self.clientToken = value
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any?]?) -> Void {
        guard let dict else { return }
        if let value = dict["headers"] as? [String: String] {
            self.headers = value
        }
        if let value = dict["statusCode"] as? Int32 {
            self.statusCode = value
        }
    }
}
