import Foundation
import Tea
import TeaUtils
import AlibabacloudOpenApi
import AlibabaCloudOpenApiUtil
import AlibabacloudEndpointUtil

public class AcceptInquiredSystemEventRequest : Tea.TeaModel {
    public var choice: String?

    public var eventId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.choice != nil {
            map["Choice"] = self.choice!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Choice") {
            self.choice = dict["Choice"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AcceptInquiredSystemEventResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AcceptInquiredSystemEventResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AcceptInquiredSystemEventResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AcceptInquiredSystemEventResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ActivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class ActivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ActivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ActivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ActivateRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddBandwidthPackageIpsRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ipCount: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipCount != nil {
            map["IpCount"] = self.ipCount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("IpCount") {
            self.ipCount = dict["IpCount"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AddBandwidthPackageIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddBandwidthPackageIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddBandwidthPackageIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddBandwidthPackageIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AddTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [AddTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [AddTagsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AddTagsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class AddTagsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AddTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AddTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AddTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateDedicatedHostsRequest : Tea.TeaModel {
    public class NetworkAttributes : Tea.TeaModel {
        public var slbUdpTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbUdpTimeout != nil {
                map["SlbUdpTimeout"] = self.slbUdpTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbUdpTimeout") {
                self.slbUdpTimeout = dict["SlbUdpTimeout"] as! Int32
            }
            if dict.keys.contains("UdpTimeout") {
                self.udpTimeout = dict["UdpTimeout"] as! Int32
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var networkAttributes: AllocateDedicatedHostsRequest.NetworkAttributes?

    public var actionOnMaintenance: String?

    public var autoPlacement: String?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var chargeType: String?

    public var clientToken: String?

    public var cpuOverCommitRatio: Double?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostName: String?

    public var dedicatedHostType: String?

    public var description_: String?

    public var minQuantity: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var quantity: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [AllocateDedicatedHostsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAttributes != nil {
            map["NetworkAttributes"] = self.networkAttributes?.toMap()
        }
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.autoPlacement != nil {
            map["AutoPlacement"] = self.autoPlacement!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.cpuOverCommitRatio != nil {
            map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.minQuantity != nil {
            map["MinQuantity"] = self.minQuantity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.quantity != nil {
            map["Quantity"] = self.quantity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAttributes") {
            var model = AllocateDedicatedHostsRequest.NetworkAttributes()
            model.fromMap(dict["NetworkAttributes"] as! [String: Any])
            self.networkAttributes = model
        }
        if dict.keys.contains("ActionOnMaintenance") {
            self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
        }
        if dict.keys.contains("AutoPlacement") {
            self.autoPlacement = dict["AutoPlacement"] as! String
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CpuOverCommitRatio") {
            self.cpuOverCommitRatio = dict["CpuOverCommitRatio"] as! Double
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostName") {
            self.dedicatedHostName = dict["DedicatedHostName"] as! String
        }
        if dict.keys.contains("DedicatedHostType") {
            self.dedicatedHostType = dict["DedicatedHostType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MinQuantity") {
            self.minQuantity = dict["MinQuantity"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Quantity") {
            self.quantity = dict["Quantity"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [AllocateDedicatedHostsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = AllocateDedicatedHostsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class AllocateDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHostIdSets : Tea.TeaModel {
        public var dedicatedHostId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostId") {
                self.dedicatedHostId = dict["DedicatedHostId"] as! [String]
            }
        }
    }
    public var dedicatedHostIdSets: AllocateDedicatedHostsResponseBody.DedicatedHostIdSets?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostIdSets != nil {
            map["DedicatedHostIdSets"] = self.dedicatedHostIdSets?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostIdSets") {
            var model = AllocateDedicatedHostsResponseBody.DedicatedHostIdSets()
            model.fromMap(dict["DedicatedHostIdSets"] as! [String: Any])
            self.dedicatedHostIdSets = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllocateDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateDedicatedHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocateEipAddressRequest : Tea.TeaModel {
    public var activityId: Int64?

    public var bandwidth: String?

    public var clientToken: String?

    public var ISP: String?

    public var internetChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activityId != nil {
            map["ActivityId"] = self.activityId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivityId") {
            self.activityId = dict["ActivityId"] as! Int64
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ISP") {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AllocateEipAddressResponseBody : Tea.TeaModel {
    public var allocationId: String?

    public var eipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("EipAddress") {
            self.eipAddress = dict["EipAddress"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllocateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocateEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AllocatePublicIpAddressRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ipAddress: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vlanId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! String
        }
    }
}

public class AllocatePublicIpAddressResponseBody : Tea.TeaModel {
    public var ipAddress: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AllocatePublicIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AllocatePublicIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AllocatePublicIpAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ApplyAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var autoSnapshotPolicyId: String?

    public var diskIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.autoSnapshotPolicyId != nil {
            map["autoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.diskIds != nil {
            map["diskIds"] = self.diskIds!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("autoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["autoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("diskIds") {
            self.diskIds = dict["diskIds"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
    }
}

public class ApplyAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ApplyAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ApplyAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ApplyAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignIpv6AddressesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var ipv6Prefix: [String]?

    public var ipv6PrefixCount: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.ipv6Prefix != nil {
            map["Ipv6Prefix"] = self.ipv6Prefix!
        }
        if self.ipv6PrefixCount != nil {
            map["Ipv6PrefixCount"] = self.ipv6PrefixCount!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("Ipv6Prefix") {
            self.ipv6Prefix = dict["Ipv6Prefix"] as! [String]
        }
        if dict.keys.contains("Ipv6PrefixCount") {
            self.ipv6PrefixCount = dict["Ipv6PrefixCount"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AssignIpv6AddressesResponseBody : Tea.TeaModel {
    public class Ipv6PrefixSets : Tea.TeaModel {
        public var ipv6Prefix: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Prefix != nil {
                map["Ipv6Prefix"] = self.ipv6Prefix!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6Prefix") {
                self.ipv6Prefix = dict["Ipv6Prefix"] as! [String]
            }
        }
    }
    public class Ipv6Sets : Tea.TeaModel {
        public var ipv6Address: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Address != nil {
                map["Ipv6Address"] = self.ipv6Address!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6Address") {
                self.ipv6Address = dict["Ipv6Address"] as! [String]
            }
        }
    }
    public var ipv6PrefixSets: AssignIpv6AddressesResponseBody.Ipv6PrefixSets?

    public var ipv6Sets: AssignIpv6AddressesResponseBody.Ipv6Sets?

    public var networkInterfaceId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv6PrefixSets?.validate()
        try self.ipv6Sets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6PrefixSets != nil {
            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
        }
        if self.ipv6Sets != nil {
            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6PrefixSets") {
            var model = AssignIpv6AddressesResponseBody.Ipv6PrefixSets()
            model.fromMap(dict["Ipv6PrefixSets"] as! [String: Any])
            self.ipv6PrefixSets = model
        }
        if dict.keys.contains("Ipv6Sets") {
            var model = AssignIpv6AddressesResponseBody.Ipv6Sets()
            model.fromMap(dict["Ipv6Sets"] as! [String: Any])
            self.ipv6Sets = model
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssignIpv6AddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignIpv6AddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssignIpv6AddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssignPrivateIpAddressesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ipv4Prefix: [String]?

    public var ipv4PrefixCount: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var secondaryPrivateIpAddressCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.ipv4PrefixCount != nil {
            map["Ipv4PrefixCount"] = self.ipv4PrefixCount!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.secondaryPrivateIpAddressCount != nil {
            map["SecondaryPrivateIpAddressCount"] = self.secondaryPrivateIpAddressCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Ipv4Prefix") {
            self.ipv4Prefix = dict["Ipv4Prefix"] as! [String]
        }
        if dict.keys.contains("Ipv4PrefixCount") {
            self.ipv4PrefixCount = dict["Ipv4PrefixCount"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecondaryPrivateIpAddressCount") {
            self.secondaryPrivateIpAddressCount = dict["SecondaryPrivateIpAddressCount"] as! Int32
        }
    }
}

public class AssignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public class AssignedPrivateIpAddressesSet : Tea.TeaModel {
        public class Ipv4PrefixSet : Tea.TeaModel {
            public var ipv4Prefixes: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv4Prefixes != nil {
                    map["Ipv4Prefixes"] = self.ipv4Prefixes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv4Prefixes") {
                    self.ipv4Prefixes = dict["Ipv4Prefixes"] as! [String]
                }
            }
        }
        public class PrivateIpSet : Tea.TeaModel {
            public var privateIpAddress: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("PrivateIpAddress") {
                    self.privateIpAddress = dict["PrivateIpAddress"] as! [String]
                }
            }
        }
        public var ipv4PrefixSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.Ipv4PrefixSet?

        public var networkInterfaceId: String?

        public var privateIpSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.PrivateIpSet?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.ipv4PrefixSet?.validate()
            try self.privateIpSet?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4PrefixSet != nil {
                map["Ipv4PrefixSet"] = self.ipv4PrefixSet?.toMap()
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.privateIpSet != nil {
                map["PrivateIpSet"] = self.privateIpSet?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4PrefixSet") {
                var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.Ipv4PrefixSet()
                model.fromMap(dict["Ipv4PrefixSet"] as! [String: Any])
                self.ipv4PrefixSet = model
            }
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
            }
            if dict.keys.contains("PrivateIpSet") {
                var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet.PrivateIpSet()
                model.fromMap(dict["PrivateIpSet"] as! [String: Any])
                self.privateIpSet = model
            }
        }
    }
    public var assignedPrivateIpAddressesSet: AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.assignedPrivateIpAddressesSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.assignedPrivateIpAddressesSet != nil {
            map["AssignedPrivateIpAddressesSet"] = self.assignedPrivateIpAddressesSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssignedPrivateIpAddressesSet") {
            var model = AssignPrivateIpAddressesResponseBody.AssignedPrivateIpAddressesSet()
            model.fromMap(dict["AssignedPrivateIpAddressesSet"] as! [String: Any])
            self.assignedPrivateIpAddressesSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssignPrivateIpAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AssociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AssociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AssociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AssociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AssociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AssociateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachClassicLinkVpcRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class AttachClassicLinkVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachClassicLinkVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachClassicLinkVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachClassicLinkVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachDiskRequest : Tea.TeaModel {
    public var bootable: Bool?

    public var deleteWithInstance: Bool?

    public var device: String?

    public var diskId: String?

    public var force: Bool?

    public var instanceId: String?

    public var keyPairName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bootable != nil {
            map["Bootable"] = self.bootable!
        }
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.device != nil {
            map["Device"] = self.device!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bootable") {
            self.bootable = dict["Bootable"] as! Bool
        }
        if dict.keys.contains("DeleteWithInstance") {
            self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
        }
        if dict.keys.contains("Device") {
            self.device = dict["Device"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AttachDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachInstanceRamRoleRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var policy: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AttachInstanceRamRoleResponseBody : Tea.TeaModel {
    public class AttachInstanceRamRoleResults : Tea.TeaModel {
        public class AttachInstanceRamRoleResult : Tea.TeaModel {
            public var code: String?

            public var instanceId: String?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var attachInstanceRamRoleResult: [AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults.AttachInstanceRamRoleResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.attachInstanceRamRoleResult != nil {
                var tmp : [Any] = []
                for k in self.attachInstanceRamRoleResult! {
                    tmp.append(k.toMap())
                }
                map["AttachInstanceRamRoleResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AttachInstanceRamRoleResult") {
                var tmp : [AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults.AttachInstanceRamRoleResult] = []
                for v in dict["AttachInstanceRamRoleResult"] as! [Any] {
                    var model = AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults.AttachInstanceRamRoleResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.attachInstanceRamRoleResult = tmp
            }
        }
    }
    public var attachInstanceRamRoleResults: AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults?

    public var failCount: Int32?

    public var ramRoleName: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.attachInstanceRamRoleResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attachInstanceRamRoleResults != nil {
            map["AttachInstanceRamRoleResults"] = self.attachInstanceRamRoleResults?.toMap()
        }
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttachInstanceRamRoleResults") {
            var model = AttachInstanceRamRoleResponseBody.AttachInstanceRamRoleResults()
            model.fromMap(dict["AttachInstanceRamRoleResults"] as! [String: Any])
            self.attachInstanceRamRoleResults = model
        }
        if dict.keys.contains("FailCount") {
            self.failCount = dict["FailCount"] as! Int32
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class AttachInstanceRamRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachInstanceRamRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachInstanceRamRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachKeyPairRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class AttachKeyPairResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var code: String?

            public var instanceId: String?

            public var message: String?

            public var success: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! String
                }
            }
        }
        public var result: [AttachKeyPairResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                var tmp : [AttachKeyPairResponseBody.Results.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = AttachKeyPairResponseBody.Results.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var failCount: String?

    public var keyPairName: String?

    public var requestId: String?

    public var results: AttachKeyPairResponseBody.Results?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailCount") {
            self.failCount = dict["FailCount"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var model = AttachKeyPairResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class AttachKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AttachNetworkInterfaceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkCardIndex: Int32?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trunkNetworkInstanceId: String?

    public var waitForNetworkConfigurationReady: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkCardIndex != nil {
            map["NetworkCardIndex"] = self.networkCardIndex!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trunkNetworkInstanceId != nil {
            map["TrunkNetworkInstanceId"] = self.trunkNetworkInstanceId!
        }
        if self.waitForNetworkConfigurationReady != nil {
            map["WaitForNetworkConfigurationReady"] = self.waitForNetworkConfigurationReady!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkCardIndex") {
            self.networkCardIndex = dict["NetworkCardIndex"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrunkNetworkInstanceId") {
            self.trunkNetworkInstanceId = dict["TrunkNetworkInstanceId"] as! String
        }
        if dict.keys.contains("WaitForNetworkConfigurationReady") {
            self.waitForNetworkConfigurationReady = dict["WaitForNetworkConfigurationReady"] as! Bool
        }
    }
}

public class AttachNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AttachNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AttachNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AttachNetworkInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourceGroupId: String?

        public var sourceGroupOwnerAccount: String?

        public var sourceGroupOwnerId: Int64?

        public var sourcePortRange: String?

        public var sourcePrefixListId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourceGroupId != nil {
                map["SourceGroupId"] = self.sourceGroupId!
            }
            if self.sourceGroupOwnerAccount != nil {
                map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
            }
            if self.sourceGroupOwnerId != nil {
                map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            if self.sourcePrefixListId != nil {
                map["SourcePrefixListId"] = self.sourcePrefixListId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestCidrIp") {
                self.destCidrIp = dict["DestCidrIp"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Ipv6DestCidrIp") {
                self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
            }
            if dict.keys.contains("Ipv6SourceCidrIp") {
                self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
            }
            if dict.keys.contains("NicType") {
                self.nicType = dict["NicType"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
            if dict.keys.contains("SourceGroupId") {
                self.sourceGroupId = dict["SourceGroupId"] as! String
            }
            if dict.keys.contains("SourceGroupOwnerAccount") {
                self.sourceGroupOwnerAccount = dict["SourceGroupOwnerAccount"] as! String
            }
            if dict.keys.contains("SourceGroupOwnerId") {
                self.sourceGroupOwnerId = dict["SourceGroupOwnerId"] as! Int64
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
            if dict.keys.contains("SourcePrefixListId") {
                self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [AuthorizeSecurityGroupRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourceGroupId: String?

    public var sourceGroupOwnerAccount: String?

    public var sourceGroupOwnerId: Int64?

    public var sourcePortRange: String?

    public var sourcePrefixListId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourceGroupId != nil {
            map["SourceGroupId"] = self.sourceGroupId!
        }
        if self.sourceGroupOwnerAccount != nil {
            map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
        }
        if self.sourceGroupOwnerId != nil {
            map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.sourcePrefixListId != nil {
            map["SourcePrefixListId"] = self.sourcePrefixListId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Ipv6DestCidrIp") {
            self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
        }
        if dict.keys.contains("Ipv6SourceCidrIp") {
            self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Permissions") {
            var tmp : [AuthorizeSecurityGroupRequest.Permissions] = []
            for v in dict["Permissions"] as! [Any] {
                var model = AuthorizeSecurityGroupRequest.Permissions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.permissions = tmp
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourceGroupId") {
            self.sourceGroupId = dict["SourceGroupId"] as! String
        }
        if dict.keys.contains("SourceGroupOwnerAccount") {
            self.sourceGroupOwnerAccount = dict["SourceGroupOwnerAccount"] as! String
        }
        if dict.keys.contains("SourceGroupOwnerId") {
            self.sourceGroupOwnerId = dict["SourceGroupOwnerId"] as! Int64
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("SourcePrefixListId") {
            self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
        }
    }
}

public class AuthorizeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AuthorizeSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class AuthorizeSecurityGroupEgressRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var destGroupId: String?

        public var destGroupOwnerAccount: String?

        public var destGroupOwnerId: Int64?

        public var destPrefixListId: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.destGroupId != nil {
                map["DestGroupId"] = self.destGroupId!
            }
            if self.destGroupOwnerAccount != nil {
                map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
            }
            if self.destGroupOwnerId != nil {
                map["DestGroupOwnerId"] = self.destGroupOwnerId!
            }
            if self.destPrefixListId != nil {
                map["DestPrefixListId"] = self.destPrefixListId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestCidrIp") {
                self.destCidrIp = dict["DestCidrIp"] as! String
            }
            if dict.keys.contains("DestGroupId") {
                self.destGroupId = dict["DestGroupId"] as! String
            }
            if dict.keys.contains("DestGroupOwnerAccount") {
                self.destGroupOwnerAccount = dict["DestGroupOwnerAccount"] as! String
            }
            if dict.keys.contains("DestGroupOwnerId") {
                self.destGroupOwnerId = dict["DestGroupOwnerId"] as! Int64
            }
            if dict.keys.contains("DestPrefixListId") {
                self.destPrefixListId = dict["DestPrefixListId"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Ipv6DestCidrIp") {
                self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
            }
            if dict.keys.contains("Ipv6SourceCidrIp") {
                self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
            }
            if dict.keys.contains("NicType") {
                self.nicType = dict["NicType"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var destGroupId: String?

    public var destGroupOwnerAccount: String?

    public var destGroupOwnerId: Int64?

    public var destPrefixListId: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [AuthorizeSecurityGroupEgressRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.destGroupId != nil {
            map["DestGroupId"] = self.destGroupId!
        }
        if self.destGroupOwnerAccount != nil {
            map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
        }
        if self.destGroupOwnerId != nil {
            map["DestGroupOwnerId"] = self.destGroupOwnerId!
        }
        if self.destPrefixListId != nil {
            map["DestPrefixListId"] = self.destPrefixListId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("DestGroupId") {
            self.destGroupId = dict["DestGroupId"] as! String
        }
        if dict.keys.contains("DestGroupOwnerAccount") {
            self.destGroupOwnerAccount = dict["DestGroupOwnerAccount"] as! String
        }
        if dict.keys.contains("DestGroupOwnerId") {
            self.destGroupOwnerId = dict["DestGroupOwnerId"] as! Int64
        }
        if dict.keys.contains("DestPrefixListId") {
            self.destPrefixListId = dict["DestPrefixListId"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Ipv6DestCidrIp") {
            self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
        }
        if dict.keys.contains("Ipv6SourceCidrIp") {
            self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Permissions") {
            var tmp : [AuthorizeSecurityGroupEgressRequest.Permissions] = []
            for v in dict["Permissions"] as! [Any] {
                var model = AuthorizeSecurityGroupEgressRequest.Permissions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.permissions = tmp
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class AuthorizeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class AuthorizeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: AuthorizeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = AuthorizeSecurityGroupEgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var diskIds: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.diskIds != nil {
            map["diskIds"] = self.diskIds!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("diskIds") {
            self.diskIds = dict["diskIds"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
    }
}

public class CancelAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelCopyImageRequest : Tea.TeaModel {
    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelCopyImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelCopyImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelCopyImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelCopyImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelImagePipelineExecutionRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var executionId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateTag: [CancelImagePipelineExecutionRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionId != nil {
            map["ExecutionId"] = self.executionId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecutionId") {
            self.executionId = dict["ExecutionId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateTag") {
            var tmp : [CancelImagePipelineExecutionRequest.TemplateTag] = []
            for v in dict["TemplateTag"] as! [Any] {
                var model = CancelImagePipelineExecutionRequest.TemplateTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateTag = tmp
        }
    }
}

public class CancelImagePipelineExecutionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelImagePipelineExecutionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelImagePipelineExecutionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelImagePipelineExecutionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelPhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
    }
}

public class CancelPhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelSimulatedSystemEventsRequest : Tea.TeaModel {
    public var eventId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CancelSimulatedSystemEventsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelSimulatedSystemEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelSimulatedSystemEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelSimulatedSystemEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CancelTaskRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class CancelTaskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CancelTaskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CancelTaskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CancelTaskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConnectRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class ConnectRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConnectRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConnectRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConnectRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ConvertNatPublicIpToEipRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ConvertNatPublicIpToEipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ConvertNatPublicIpToEipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ConvertNatPublicIpToEipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ConvertNatPublicIpToEipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopyImageRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var destinationDescription: String?

    public var destinationImageName: String?

    public var destinationRegionId: String?

    public var encryptAlgorithm: String?

    public var encrypted: Bool?

    public var imageId: String?

    public var KMSKeyId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CopyImageRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationDescription != nil {
            map["DestinationDescription"] = self.destinationDescription!
        }
        if self.destinationImageName != nil {
            map["DestinationImageName"] = self.destinationImageName!
        }
        if self.destinationRegionId != nil {
            map["DestinationRegionId"] = self.destinationRegionId!
        }
        if self.encryptAlgorithm != nil {
            map["EncryptAlgorithm"] = self.encryptAlgorithm!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationDescription") {
            self.destinationDescription = dict["DestinationDescription"] as! String
        }
        if dict.keys.contains("DestinationImageName") {
            self.destinationImageName = dict["DestinationImageName"] as! String
        }
        if dict.keys.contains("DestinationRegionId") {
            self.destinationRegionId = dict["DestinationRegionId"] as! String
        }
        if dict.keys.contains("EncryptAlgorithm") {
            self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CopyImageRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CopyImageRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CopyImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CopyImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopyImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopyImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CopySnapshotRequest : Tea.TeaModel {
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssumeRoleFor") {
                self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
            if dict.keys.contains("Rolearn") {
                self.rolearn = dict["Rolearn"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var arn: [CopySnapshotRequest.Arn]?

    public var clientToken: String?

    public var destinationRegionId: String?

    public var destinationSnapshotDescription: String?

    public var destinationSnapshotName: String?

    public var destinationStorageLocationArn: String?

    public var encrypted: Bool?

    public var KMSKeyId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentionDays: Int32?

    public var snapshotId: String?

    public var tag: [CopySnapshotRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationRegionId != nil {
            map["DestinationRegionId"] = self.destinationRegionId!
        }
        if self.destinationSnapshotDescription != nil {
            map["DestinationSnapshotDescription"] = self.destinationSnapshotDescription!
        }
        if self.destinationSnapshotName != nil {
            map["DestinationSnapshotName"] = self.destinationSnapshotName!
        }
        if self.destinationStorageLocationArn != nil {
            map["DestinationStorageLocationArn"] = self.destinationStorageLocationArn!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Arn") {
            var tmp : [CopySnapshotRequest.Arn] = []
            for v in dict["Arn"] as! [Any] {
                var model = CopySnapshotRequest.Arn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.arn = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DestinationRegionId") {
            self.destinationRegionId = dict["DestinationRegionId"] as! String
        }
        if dict.keys.contains("DestinationSnapshotDescription") {
            self.destinationSnapshotDescription = dict["DestinationSnapshotDescription"] as! String
        }
        if dict.keys.contains("DestinationSnapshotName") {
            self.destinationSnapshotName = dict["DestinationSnapshotName"] as! String
        }
        if dict.keys.contains("DestinationStorageLocationArn") {
            self.destinationStorageLocationArn = dict["DestinationStorageLocationArn"] as! String
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RetentionDays") {
            self.retentionDays = dict["RetentionDays"] as! Int32
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CopySnapshotRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CopySnapshotRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CopySnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class CopySnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CopySnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CopySnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateActivationRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var description_: String?

    public var instanceCount: Int32?

    public var instanceName: String?

    public var ipAddressRange: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateActivationRequest.Tag]?

    public var timeToLiveInHours: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceCount != nil {
            map["InstanceCount"] = self.instanceCount!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.ipAddressRange != nil {
            map["IpAddressRange"] = self.ipAddressRange!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timeToLiveInHours != nil {
            map["TimeToLiveInHours"] = self.timeToLiveInHours!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceCount") {
            self.instanceCount = dict["InstanceCount"] as! Int32
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("IpAddressRange") {
            self.ipAddressRange = dict["IpAddressRange"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateActivationRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateActivationRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TimeToLiveInHours") {
            self.timeToLiveInHours = dict["TimeToLiveInHours"] as! Int64
        }
    }
}

public class CreateActivationResponseBody : Tea.TeaModel {
    public var activationCode: String?

    public var activationId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationCode != nil {
            map["ActivationCode"] = self.activationCode!
        }
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivationCode") {
            self.activationCode = dict["ActivationCode"] as! String
        }
        if dict.keys.contains("ActivationId") {
            self.activationId = dict["ActivationId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateActivationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateActivationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateActivationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAutoProvisioningGroupRequest : Tea.TeaModel {
    public class LaunchConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssumeRoleFor") {
                    self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
                }
                if dict.keys.contains("RoleType") {
                    self.roleType = dict["RoleType"] as! String
                }
                if dict.keys.contains("Rolearn") {
                    self.rolearn = dict["Rolearn"] as! String
                }
            }
        }
        public class DataDisk : Tea.TeaModel {
            public var burstingEnabled: Bool?

            public var category: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var device: String?

            public var diskName: String?

            public var encryptAlgorithm: String?

            public var encrypted: Bool?

            public var kmsKeyId: String?

            public var performanceLevel: String?

            public var provisionedIops: Int64?

            public var size: Int32?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.kmsKeyId != nil {
                    map["KmsKeyId"] = self.kmsKeyId!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BurstingEnabled") {
                    self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("DeleteWithInstance") {
                    self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Device") {
                    self.device = dict["Device"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("EncryptAlgorithm") {
                    self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! Bool
                }
                if dict.keys.contains("KmsKeyId") {
                    self.kmsKeyId = dict["KmsKeyId"] as! String
                }
                if dict.keys.contains("PerformanceLevel") {
                    self.performanceLevel = dict["PerformanceLevel"] as! String
                }
                if dict.keys.contains("ProvisionedIops") {
                    self.provisionedIops = dict["ProvisionedIops"] as! Int64
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
            }
        }
        public class SystemDisk : Tea.TeaModel {
            public var burstingEnabled: Bool?

            public var encryptAlgorithm: String?

            public var encrypted: String?

            public var KMSKeyId: String?

            public var provisionedIops: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BurstingEnabled") {
                    self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                }
                if dict.keys.contains("EncryptAlgorithm") {
                    self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! String
                }
                if dict.keys.contains("KMSKeyId") {
                    self.KMSKeyId = dict["KMSKeyId"] as! String
                }
                if dict.keys.contains("ProvisionedIops") {
                    self.provisionedIops = dict["ProvisionedIops"] as! Int64
                }
            }
        }
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var arn: [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Arn]?

        public var autoReleaseTime: String?

        public var creditSpecification: String?

        public var dataDisk: [CreateAutoProvisioningGroupRequest.LaunchConfiguration.DataDisk]?

        public var deploymentSetId: String?

        public var hostName: String?

        public var hostNames: [String]?

        public var imageFamily: String?

        public var imageId: String?

        public var instanceDescription: String?

        public var instanceName: String?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var keyPairName: String?

        public var password: String?

        public var passwordInherit: Bool?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var systemDisk: CreateAutoProvisioningGroupRequest.LaunchConfiguration.SystemDisk?

        public var systemDiskCategory: String?

        public var systemDiskDescription: String?

        public var systemDiskName: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskSize: Int32?

        public var tag: [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Tag]?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.systemDisk?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.autoReleaseTime != nil {
                map["AutoReleaseTime"] = self.autoReleaseTime!
            }
            if self.creditSpecification != nil {
                map["CreditSpecification"] = self.creditSpecification!
            }
            if self.dataDisk != nil {
                var tmp : [Any] = []
                for k in self.dataDisk! {
                    tmp.append(k.toMap())
                }
                map["DataDisk"] = tmp
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.hostNames != nil {
                map["HostNames"] = self.hostNames!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.systemDisk != nil {
                map["SystemDisk"] = self.systemDisk?.toMap()
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskDescription != nil {
                map["SystemDiskDescription"] = self.systemDiskDescription!
            }
            if self.systemDiskName != nil {
                map["SystemDiskName"] = self.systemDiskName!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") {
                var tmp : [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Arn] = []
                for v in dict["Arn"] as! [Any] {
                    var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.Arn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.arn = tmp
            }
            if dict.keys.contains("AutoReleaseTime") {
                self.autoReleaseTime = dict["AutoReleaseTime"] as! String
            }
            if dict.keys.contains("CreditSpecification") {
                self.creditSpecification = dict["CreditSpecification"] as! String
            }
            if dict.keys.contains("DataDisk") {
                var tmp : [CreateAutoProvisioningGroupRequest.LaunchConfiguration.DataDisk] = []
                for v in dict["DataDisk"] as! [Any] {
                    var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.DataDisk()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataDisk = tmp
            }
            if dict.keys.contains("DeploymentSetId") {
                self.deploymentSetId = dict["DeploymentSetId"] as! String
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("HostNames") {
                self.hostNames = dict["HostNames"] as! [String]
            }
            if dict.keys.contains("ImageFamily") {
                self.imageFamily = dict["ImageFamily"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("InstanceDescription") {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("InternetMaxBandwidthIn") {
                self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
            }
            if dict.keys.contains("InternetMaxBandwidthOut") {
                self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
            }
            if dict.keys.contains("IoOptimized") {
                self.ioOptimized = dict["IoOptimized"] as! String
            }
            if dict.keys.contains("KeyPairName") {
                self.keyPairName = dict["KeyPairName"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("PasswordInherit") {
                self.passwordInherit = dict["PasswordInherit"] as! Bool
            }
            if dict.keys.contains("RamRoleName") {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityEnhancementStrategy") {
                self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("SystemDisk") {
                var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.SystemDisk()
                model.fromMap(dict["SystemDisk"] as! [String: Any])
                self.systemDisk = model
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskDescription") {
                self.systemDiskDescription = dict["SystemDiskDescription"] as! String
            }
            if dict.keys.contains("SystemDiskName") {
                self.systemDiskName = dict["SystemDiskName"] as! String
            }
            if dict.keys.contains("SystemDiskPerformanceLevel") {
                self.systemDiskPerformanceLevel = dict["SystemDiskPerformanceLevel"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
            if dict.keys.contains("Tag") {
                var tmp : [CreateAutoProvisioningGroupRequest.LaunchConfiguration.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public class DataDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskCategory") {
                self.diskCategory = dict["DiskCategory"] as! String
            }
        }
    }
    public class LaunchTemplateConfig : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: [Int32]?

        public var excludedInstanceTypes: [String]?

        public var instanceFamilyLevel: String?

        public var instanceType: String?

        public var maxPrice: Double?

        public var maxQuantity: Int32?

        public var memories: [Double]?

        public var priority: Int32?

        public var vSwitchId: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maxQuantity != nil {
                map["MaxQuantity"] = self.maxQuantity!
            }
            if self.memories != nil {
                map["Memories"] = self.memories!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") {
                self.cores = dict["Cores"] as! [Int32]
            }
            if dict.keys.contains("ExcludedInstanceTypes") {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("MaxQuantity") {
                self.maxQuantity = dict["MaxQuantity"] as! Int32
            }
            if dict.keys.contains("Memories") {
                self.memories = dict["Memories"] as! [Double]
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Double
            }
        }
    }
    public class ResourcePoolOptions : Tea.TeaModel {
        public var privatePoolIds: [String]?

        public var strategy: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolIds != nil {
                map["PrivatePoolIds"] = self.privatePoolIds!
            }
            if self.strategy != nil {
                map["Strategy"] = self.strategy!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivatePoolIds") {
                self.privatePoolIds = dict["PrivatePoolIds"] as! [String]
            }
            if dict.keys.contains("Strategy") {
                self.strategy = dict["Strategy"] as! String
            }
        }
    }
    public class SystemDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskCategory") {
                self.diskCategory = dict["DiskCategory"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var launchConfiguration: CreateAutoProvisioningGroupRequest.LaunchConfiguration?

    public var autoProvisioningGroupName: String?

    public var autoProvisioningGroupType: String?

    public var clientToken: String?

    public var dataDiskConfig: [CreateAutoProvisioningGroupRequest.DataDiskConfig]?

    public var defaultTargetCapacityType: String?

    public var description_: String?

    public var excessCapacityTerminationPolicy: String?

    public var hibernationOptionsConfigured: Bool?

    public var launchTemplateConfig: [CreateAutoProvisioningGroupRequest.LaunchTemplateConfig]?

    public var launchTemplateId: String?

    public var launchTemplateVersion: String?

    public var maxSpotPrice: Double?

    public var minTargetCapacity: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payAsYouGoAllocationStrategy: String?

    public var payAsYouGoTargetCapacity: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolOptions: CreateAutoProvisioningGroupRequest.ResourcePoolOptions?

    public var spotAllocationStrategy: String?

    public var spotInstanceInterruptionBehavior: String?

    public var spotInstancePoolsToUseCount: Int32?

    public var spotTargetCapacity: String?

    public var systemDiskConfig: [CreateAutoProvisioningGroupRequest.SystemDiskConfig]?

    public var tag: [CreateAutoProvisioningGroupRequest.Tag]?

    public var terminateInstances: Bool?

    public var terminateInstancesWithExpiration: Bool?

    public var totalTargetCapacity: String?

    public var validFrom: String?

    public var validUntil: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchConfiguration?.validate()
        try self.resourcePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchConfiguration != nil {
            map["LaunchConfiguration"] = self.launchConfiguration?.toMap()
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.autoProvisioningGroupType != nil {
            map["AutoProvisioningGroupType"] = self.autoProvisioningGroupType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.dataDiskConfig! {
                tmp.append(k.toMap())
            }
            map["DataDiskConfig"] = tmp
        }
        if self.defaultTargetCapacityType != nil {
            map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excessCapacityTerminationPolicy != nil {
            map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
        }
        if self.hibernationOptionsConfigured != nil {
            map["HibernationOptionsConfigured"] = self.hibernationOptionsConfigured!
        }
        if self.launchTemplateConfig != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateConfig! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateConfig"] = tmp
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxSpotPrice != nil {
            map["MaxSpotPrice"] = self.maxSpotPrice!
        }
        if self.minTargetCapacity != nil {
            map["MinTargetCapacity"] = self.minTargetCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payAsYouGoAllocationStrategy != nil {
            map["PayAsYouGoAllocationStrategy"] = self.payAsYouGoAllocationStrategy!
        }
        if self.payAsYouGoTargetCapacity != nil {
            map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolOptions != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptions?.toMap()
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstanceInterruptionBehavior != nil {
            map["SpotInstanceInterruptionBehavior"] = self.spotInstanceInterruptionBehavior!
        }
        if self.spotInstancePoolsToUseCount != nil {
            map["SpotInstancePoolsToUseCount"] = self.spotInstancePoolsToUseCount!
        }
        if self.spotTargetCapacity != nil {
            map["SpotTargetCapacity"] = self.spotTargetCapacity!
        }
        if self.systemDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.systemDiskConfig! {
                tmp.append(k.toMap())
            }
            map["SystemDiskConfig"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminateInstances != nil {
            map["TerminateInstances"] = self.terminateInstances!
        }
        if self.terminateInstancesWithExpiration != nil {
            map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
        }
        if self.totalTargetCapacity != nil {
            map["TotalTargetCapacity"] = self.totalTargetCapacity!
        }
        if self.validFrom != nil {
            map["ValidFrom"] = self.validFrom!
        }
        if self.validUntil != nil {
            map["ValidUntil"] = self.validUntil!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchConfiguration") {
            var model = CreateAutoProvisioningGroupRequest.LaunchConfiguration()
            model.fromMap(dict["LaunchConfiguration"] as! [String: Any])
            self.launchConfiguration = model
        }
        if dict.keys.contains("AutoProvisioningGroupName") {
            self.autoProvisioningGroupName = dict["AutoProvisioningGroupName"] as! String
        }
        if dict.keys.contains("AutoProvisioningGroupType") {
            self.autoProvisioningGroupType = dict["AutoProvisioningGroupType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DataDiskConfig") {
            var tmp : [CreateAutoProvisioningGroupRequest.DataDiskConfig] = []
            for v in dict["DataDiskConfig"] as! [Any] {
                var model = CreateAutoProvisioningGroupRequest.DataDiskConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDiskConfig = tmp
        }
        if dict.keys.contains("DefaultTargetCapacityType") {
            self.defaultTargetCapacityType = dict["DefaultTargetCapacityType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExcessCapacityTerminationPolicy") {
            self.excessCapacityTerminationPolicy = dict["ExcessCapacityTerminationPolicy"] as! String
        }
        if dict.keys.contains("HibernationOptionsConfigured") {
            self.hibernationOptionsConfigured = dict["HibernationOptionsConfigured"] as! Bool
        }
        if dict.keys.contains("LaunchTemplateConfig") {
            var tmp : [CreateAutoProvisioningGroupRequest.LaunchTemplateConfig] = []
            for v in dict["LaunchTemplateConfig"] as! [Any] {
                var model = CreateAutoProvisioningGroupRequest.LaunchTemplateConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateConfig = tmp
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("MaxSpotPrice") {
            self.maxSpotPrice = dict["MaxSpotPrice"] as! Double
        }
        if dict.keys.contains("MinTargetCapacity") {
            self.minTargetCapacity = dict["MinTargetCapacity"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PayAsYouGoAllocationStrategy") {
            self.payAsYouGoAllocationStrategy = dict["PayAsYouGoAllocationStrategy"] as! String
        }
        if dict.keys.contains("PayAsYouGoTargetCapacity") {
            self.payAsYouGoTargetCapacity = dict["PayAsYouGoTargetCapacity"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourcePoolOptions") {
            var model = CreateAutoProvisioningGroupRequest.ResourcePoolOptions()
            model.fromMap(dict["ResourcePoolOptions"] as! [String: Any])
            self.resourcePoolOptions = model
        }
        if dict.keys.contains("SpotAllocationStrategy") {
            self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
        }
        if dict.keys.contains("SpotInstanceInterruptionBehavior") {
            self.spotInstanceInterruptionBehavior = dict["SpotInstanceInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotInstancePoolsToUseCount") {
            self.spotInstancePoolsToUseCount = dict["SpotInstancePoolsToUseCount"] as! Int32
        }
        if dict.keys.contains("SpotTargetCapacity") {
            self.spotTargetCapacity = dict["SpotTargetCapacity"] as! String
        }
        if dict.keys.contains("SystemDiskConfig") {
            var tmp : [CreateAutoProvisioningGroupRequest.SystemDiskConfig] = []
            for v in dict["SystemDiskConfig"] as! [Any] {
                var model = CreateAutoProvisioningGroupRequest.SystemDiskConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.systemDiskConfig = tmp
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateAutoProvisioningGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateAutoProvisioningGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TerminateInstances") {
            self.terminateInstances = dict["TerminateInstances"] as! Bool
        }
        if dict.keys.contains("TerminateInstancesWithExpiration") {
            self.terminateInstancesWithExpiration = dict["TerminateInstancesWithExpiration"] as! Bool
        }
        if dict.keys.contains("TotalTargetCapacity") {
            self.totalTargetCapacity = dict["TotalTargetCapacity"] as! String
        }
        if dict.keys.contains("ValidFrom") {
            self.validFrom = dict["ValidFrom"] as! String
        }
        if dict.keys.contains("ValidUntil") {
            self.validUntil = dict["ValidUntil"] as! String
        }
    }
}

public class CreateAutoProvisioningGroupShrinkRequest : Tea.TeaModel {
    public class LaunchConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssumeRoleFor") {
                    self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
                }
                if dict.keys.contains("RoleType") {
                    self.roleType = dict["RoleType"] as! String
                }
                if dict.keys.contains("Rolearn") {
                    self.rolearn = dict["Rolearn"] as! String
                }
            }
        }
        public class DataDisk : Tea.TeaModel {
            public var burstingEnabled: Bool?

            public var category: String?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var device: String?

            public var diskName: String?

            public var encryptAlgorithm: String?

            public var encrypted: Bool?

            public var kmsKeyId: String?

            public var performanceLevel: String?

            public var provisionedIops: Int64?

            public var size: Int32?

            public var snapshotId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.kmsKeyId != nil {
                    map["KmsKeyId"] = self.kmsKeyId!
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BurstingEnabled") {
                    self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("DeleteWithInstance") {
                    self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Device") {
                    self.device = dict["Device"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("EncryptAlgorithm") {
                    self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! Bool
                }
                if dict.keys.contains("KmsKeyId") {
                    self.kmsKeyId = dict["KmsKeyId"] as! String
                }
                if dict.keys.contains("PerformanceLevel") {
                    self.performanceLevel = dict["PerformanceLevel"] as! String
                }
                if dict.keys.contains("ProvisionedIops") {
                    self.provisionedIops = dict["ProvisionedIops"] as! Int64
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
            }
        }
        public class SystemDisk : Tea.TeaModel {
            public var burstingEnabled: Bool?

            public var encryptAlgorithm: String?

            public var encrypted: String?

            public var KMSKeyId: String?

            public var provisionedIops: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.encryptAlgorithm != nil {
                    map["EncryptAlgorithm"] = self.encryptAlgorithm!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BurstingEnabled") {
                    self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                }
                if dict.keys.contains("EncryptAlgorithm") {
                    self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! String
                }
                if dict.keys.contains("KMSKeyId") {
                    self.KMSKeyId = dict["KMSKeyId"] as! String
                }
                if dict.keys.contains("ProvisionedIops") {
                    self.provisionedIops = dict["ProvisionedIops"] as! Int64
                }
            }
        }
        public class Tag : Tea.TeaModel {
            public var key: String?

            public var value: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.key != nil {
                    map["Key"] = self.key!
                }
                if self.value != nil {
                    map["Value"] = self.value!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Key") {
                    self.key = dict["Key"] as! String
                }
                if dict.keys.contains("Value") {
                    self.value = dict["Value"] as! String
                }
            }
        }
        public var arn: [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Arn]?

        public var autoReleaseTime: String?

        public var creditSpecification: String?

        public var dataDisk: [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.DataDisk]?

        public var deploymentSetId: String?

        public var hostName: String?

        public var hostNames: [String]?

        public var imageFamily: String?

        public var imageId: String?

        public var instanceDescription: String?

        public var instanceName: String?

        public var internetChargeType: String?

        public var internetMaxBandwidthIn: Int32?

        public var internetMaxBandwidthOut: Int32?

        public var ioOptimized: String?

        public var keyPairName: String?

        public var password: String?

        public var passwordInherit: Bool?

        public var ramRoleName: String?

        public var resourceGroupId: String?

        public var securityEnhancementStrategy: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var systemDisk: CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.SystemDisk?

        public var systemDiskCategory: String?

        public var systemDiskDescription: String?

        public var systemDiskName: String?

        public var systemDiskPerformanceLevel: String?

        public var systemDiskSize: Int32?

        public var tag: [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Tag]?

        public var userData: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.systemDisk?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.autoReleaseTime != nil {
                map["AutoReleaseTime"] = self.autoReleaseTime!
            }
            if self.creditSpecification != nil {
                map["CreditSpecification"] = self.creditSpecification!
            }
            if self.dataDisk != nil {
                var tmp : [Any] = []
                for k in self.dataDisk! {
                    tmp.append(k.toMap())
                }
                map["DataDisk"] = tmp
            }
            if self.deploymentSetId != nil {
                map["DeploymentSetId"] = self.deploymentSetId!
            }
            if self.hostName != nil {
                map["HostName"] = self.hostName!
            }
            if self.hostNames != nil {
                map["HostNames"] = self.hostNames!
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.instanceDescription != nil {
                map["InstanceDescription"] = self.instanceDescription!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.internetMaxBandwidthIn != nil {
                map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.ioOptimized != nil {
                map["IoOptimized"] = self.ioOptimized!
            }
            if self.keyPairName != nil {
                map["KeyPairName"] = self.keyPairName!
            }
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.passwordInherit != nil {
                map["PasswordInherit"] = self.passwordInherit!
            }
            if self.ramRoleName != nil {
                map["RamRoleName"] = self.ramRoleName!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.securityEnhancementStrategy != nil {
                map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.systemDisk != nil {
                map["SystemDisk"] = self.systemDisk?.toMap()
            }
            if self.systemDiskCategory != nil {
                map["SystemDiskCategory"] = self.systemDiskCategory!
            }
            if self.systemDiskDescription != nil {
                map["SystemDiskDescription"] = self.systemDiskDescription!
            }
            if self.systemDiskName != nil {
                map["SystemDiskName"] = self.systemDiskName!
            }
            if self.systemDiskPerformanceLevel != nil {
                map["SystemDiskPerformanceLevel"] = self.systemDiskPerformanceLevel!
            }
            if self.systemDiskSize != nil {
                map["SystemDiskSize"] = self.systemDiskSize!
            }
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            if self.userData != nil {
                map["UserData"] = self.userData!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") {
                var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Arn] = []
                for v in dict["Arn"] as! [Any] {
                    var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Arn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.arn = tmp
            }
            if dict.keys.contains("AutoReleaseTime") {
                self.autoReleaseTime = dict["AutoReleaseTime"] as! String
            }
            if dict.keys.contains("CreditSpecification") {
                self.creditSpecification = dict["CreditSpecification"] as! String
            }
            if dict.keys.contains("DataDisk") {
                var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.DataDisk] = []
                for v in dict["DataDisk"] as! [Any] {
                    var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.DataDisk()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataDisk = tmp
            }
            if dict.keys.contains("DeploymentSetId") {
                self.deploymentSetId = dict["DeploymentSetId"] as! String
            }
            if dict.keys.contains("HostName") {
                self.hostName = dict["HostName"] as! String
            }
            if dict.keys.contains("HostNames") {
                self.hostNames = dict["HostNames"] as! [String]
            }
            if dict.keys.contains("ImageFamily") {
                self.imageFamily = dict["ImageFamily"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("InstanceDescription") {
                self.instanceDescription = dict["InstanceDescription"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("InternetMaxBandwidthIn") {
                self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
            }
            if dict.keys.contains("InternetMaxBandwidthOut") {
                self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
            }
            if dict.keys.contains("IoOptimized") {
                self.ioOptimized = dict["IoOptimized"] as! String
            }
            if dict.keys.contains("KeyPairName") {
                self.keyPairName = dict["KeyPairName"] as! String
            }
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("PasswordInherit") {
                self.passwordInherit = dict["PasswordInherit"] as! Bool
            }
            if dict.keys.contains("RamRoleName") {
                self.ramRoleName = dict["RamRoleName"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("SecurityEnhancementStrategy") {
                self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("SystemDisk") {
                var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.SystemDisk()
                model.fromMap(dict["SystemDisk"] as! [String: Any])
                self.systemDisk = model
            }
            if dict.keys.contains("SystemDiskCategory") {
                self.systemDiskCategory = dict["SystemDiskCategory"] as! String
            }
            if dict.keys.contains("SystemDiskDescription") {
                self.systemDiskDescription = dict["SystemDiskDescription"] as! String
            }
            if dict.keys.contains("SystemDiskName") {
                self.systemDiskName = dict["SystemDiskName"] as! String
            }
            if dict.keys.contains("SystemDiskPerformanceLevel") {
                self.systemDiskPerformanceLevel = dict["SystemDiskPerformanceLevel"] as! String
            }
            if dict.keys.contains("SystemDiskSize") {
                self.systemDiskSize = dict["SystemDiskSize"] as! Int32
            }
            if dict.keys.contains("Tag") {
                var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
            if dict.keys.contains("UserData") {
                self.userData = dict["UserData"] as! String
            }
        }
    }
    public class DataDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskCategory") {
                self.diskCategory = dict["DiskCategory"] as! String
            }
        }
    }
    public class LaunchTemplateConfig : Tea.TeaModel {
        public var architectures: [String]?

        public var burstablePerformance: String?

        public var cores: [Int32]?

        public var excludedInstanceTypes: [String]?

        public var instanceFamilyLevel: String?

        public var instanceType: String?

        public var maxPrice: Double?

        public var maxQuantity: Int32?

        public var memories: [Double]?

        public var priority: Int32?

        public var vSwitchId: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architectures != nil {
                map["Architectures"] = self.architectures!
            }
            if self.burstablePerformance != nil {
                map["BurstablePerformance"] = self.burstablePerformance!
            }
            if self.cores != nil {
                map["Cores"] = self.cores!
            }
            if self.excludedInstanceTypes != nil {
                map["ExcludedInstanceTypes"] = self.excludedInstanceTypes!
            }
            if self.instanceFamilyLevel != nil {
                map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.maxQuantity != nil {
                map["MaxQuantity"] = self.maxQuantity!
            }
            if self.memories != nil {
                map["Memories"] = self.memories!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architectures") {
                self.architectures = dict["Architectures"] as! [String]
            }
            if dict.keys.contains("BurstablePerformance") {
                self.burstablePerformance = dict["BurstablePerformance"] as! String
            }
            if dict.keys.contains("Cores") {
                self.cores = dict["Cores"] as! [Int32]
            }
            if dict.keys.contains("ExcludedInstanceTypes") {
                self.excludedInstanceTypes = dict["ExcludedInstanceTypes"] as! [String]
            }
            if dict.keys.contains("InstanceFamilyLevel") {
                self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("MaxQuantity") {
                self.maxQuantity = dict["MaxQuantity"] as! Int32
            }
            if dict.keys.contains("Memories") {
                self.memories = dict["Memories"] as! [Double]
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Double
            }
        }
    }
    public class SystemDiskConfig : Tea.TeaModel {
        public var diskCategory: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskCategory != nil {
                map["DiskCategory"] = self.diskCategory!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskCategory") {
                self.diskCategory = dict["DiskCategory"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var launchConfiguration: CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration?

    public var autoProvisioningGroupName: String?

    public var autoProvisioningGroupType: String?

    public var clientToken: String?

    public var dataDiskConfig: [CreateAutoProvisioningGroupShrinkRequest.DataDiskConfig]?

    public var defaultTargetCapacityType: String?

    public var description_: String?

    public var excessCapacityTerminationPolicy: String?

    public var hibernationOptionsConfigured: Bool?

    public var launchTemplateConfig: [CreateAutoProvisioningGroupShrinkRequest.LaunchTemplateConfig]?

    public var launchTemplateId: String?

    public var launchTemplateVersion: String?

    public var maxSpotPrice: Double?

    public var minTargetCapacity: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payAsYouGoAllocationStrategy: String?

    public var payAsYouGoTargetCapacity: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourcePoolOptionsShrink: String?

    public var spotAllocationStrategy: String?

    public var spotInstanceInterruptionBehavior: String?

    public var spotInstancePoolsToUseCount: Int32?

    public var spotTargetCapacity: String?

    public var systemDiskConfig: [CreateAutoProvisioningGroupShrinkRequest.SystemDiskConfig]?

    public var tag: [CreateAutoProvisioningGroupShrinkRequest.Tag]?

    public var terminateInstances: Bool?

    public var terminateInstancesWithExpiration: Bool?

    public var totalTargetCapacity: String?

    public var validFrom: String?

    public var validUntil: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchConfiguration != nil {
            map["LaunchConfiguration"] = self.launchConfiguration?.toMap()
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.autoProvisioningGroupType != nil {
            map["AutoProvisioningGroupType"] = self.autoProvisioningGroupType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dataDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.dataDiskConfig! {
                tmp.append(k.toMap())
            }
            map["DataDiskConfig"] = tmp
        }
        if self.defaultTargetCapacityType != nil {
            map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.excessCapacityTerminationPolicy != nil {
            map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
        }
        if self.hibernationOptionsConfigured != nil {
            map["HibernationOptionsConfigured"] = self.hibernationOptionsConfigured!
        }
        if self.launchTemplateConfig != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateConfig! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateConfig"] = tmp
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxSpotPrice != nil {
            map["MaxSpotPrice"] = self.maxSpotPrice!
        }
        if self.minTargetCapacity != nil {
            map["MinTargetCapacity"] = self.minTargetCapacity!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payAsYouGoAllocationStrategy != nil {
            map["PayAsYouGoAllocationStrategy"] = self.payAsYouGoAllocationStrategy!
        }
        if self.payAsYouGoTargetCapacity != nil {
            map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourcePoolOptionsShrink != nil {
            map["ResourcePoolOptions"] = self.resourcePoolOptionsShrink!
        }
        if self.spotAllocationStrategy != nil {
            map["SpotAllocationStrategy"] = self.spotAllocationStrategy!
        }
        if self.spotInstanceInterruptionBehavior != nil {
            map["SpotInstanceInterruptionBehavior"] = self.spotInstanceInterruptionBehavior!
        }
        if self.spotInstancePoolsToUseCount != nil {
            map["SpotInstancePoolsToUseCount"] = self.spotInstancePoolsToUseCount!
        }
        if self.spotTargetCapacity != nil {
            map["SpotTargetCapacity"] = self.spotTargetCapacity!
        }
        if self.systemDiskConfig != nil {
            var tmp : [Any] = []
            for k in self.systemDiskConfig! {
                tmp.append(k.toMap())
            }
            map["SystemDiskConfig"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminateInstances != nil {
            map["TerminateInstances"] = self.terminateInstances!
        }
        if self.terminateInstancesWithExpiration != nil {
            map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
        }
        if self.totalTargetCapacity != nil {
            map["TotalTargetCapacity"] = self.totalTargetCapacity!
        }
        if self.validFrom != nil {
            map["ValidFrom"] = self.validFrom!
        }
        if self.validUntil != nil {
            map["ValidUntil"] = self.validUntil!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchConfiguration") {
            var model = CreateAutoProvisioningGroupShrinkRequest.LaunchConfiguration()
            model.fromMap(dict["LaunchConfiguration"] as! [String: Any])
            self.launchConfiguration = model
        }
        if dict.keys.contains("AutoProvisioningGroupName") {
            self.autoProvisioningGroupName = dict["AutoProvisioningGroupName"] as! String
        }
        if dict.keys.contains("AutoProvisioningGroupType") {
            self.autoProvisioningGroupType = dict["AutoProvisioningGroupType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DataDiskConfig") {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.DataDiskConfig] = []
            for v in dict["DataDiskConfig"] as! [Any] {
                var model = CreateAutoProvisioningGroupShrinkRequest.DataDiskConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDiskConfig = tmp
        }
        if dict.keys.contains("DefaultTargetCapacityType") {
            self.defaultTargetCapacityType = dict["DefaultTargetCapacityType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ExcessCapacityTerminationPolicy") {
            self.excessCapacityTerminationPolicy = dict["ExcessCapacityTerminationPolicy"] as! String
        }
        if dict.keys.contains("HibernationOptionsConfigured") {
            self.hibernationOptionsConfigured = dict["HibernationOptionsConfigured"] as! Bool
        }
        if dict.keys.contains("LaunchTemplateConfig") {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.LaunchTemplateConfig] = []
            for v in dict["LaunchTemplateConfig"] as! [Any] {
                var model = CreateAutoProvisioningGroupShrinkRequest.LaunchTemplateConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateConfig = tmp
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
        }
        if dict.keys.contains("MaxSpotPrice") {
            self.maxSpotPrice = dict["MaxSpotPrice"] as! Double
        }
        if dict.keys.contains("MinTargetCapacity") {
            self.minTargetCapacity = dict["MinTargetCapacity"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PayAsYouGoAllocationStrategy") {
            self.payAsYouGoAllocationStrategy = dict["PayAsYouGoAllocationStrategy"] as! String
        }
        if dict.keys.contains("PayAsYouGoTargetCapacity") {
            self.payAsYouGoTargetCapacity = dict["PayAsYouGoTargetCapacity"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourcePoolOptions") {
            self.resourcePoolOptionsShrink = dict["ResourcePoolOptions"] as! String
        }
        if dict.keys.contains("SpotAllocationStrategy") {
            self.spotAllocationStrategy = dict["SpotAllocationStrategy"] as! String
        }
        if dict.keys.contains("SpotInstanceInterruptionBehavior") {
            self.spotInstanceInterruptionBehavior = dict["SpotInstanceInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotInstancePoolsToUseCount") {
            self.spotInstancePoolsToUseCount = dict["SpotInstancePoolsToUseCount"] as! Int32
        }
        if dict.keys.contains("SpotTargetCapacity") {
            self.spotTargetCapacity = dict["SpotTargetCapacity"] as! String
        }
        if dict.keys.contains("SystemDiskConfig") {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.SystemDiskConfig] = []
            for v in dict["SystemDiskConfig"] as! [Any] {
                var model = CreateAutoProvisioningGroupShrinkRequest.SystemDiskConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.systemDiskConfig = tmp
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateAutoProvisioningGroupShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateAutoProvisioningGroupShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TerminateInstances") {
            self.terminateInstances = dict["TerminateInstances"] as! Bool
        }
        if dict.keys.contains("TerminateInstancesWithExpiration") {
            self.terminateInstancesWithExpiration = dict["TerminateInstancesWithExpiration"] as! Bool
        }
        if dict.keys.contains("TotalTargetCapacity") {
            self.totalTargetCapacity = dict["TotalTargetCapacity"] as! String
        }
        if dict.keys.contains("ValidFrom") {
            self.validFrom = dict["ValidFrom"] as! String
        }
        if dict.keys.contains("ValidUntil") {
            self.validUntil = dict["ValidUntil"] as! String
        }
    }
}

public class CreateAutoProvisioningGroupResponseBody : Tea.TeaModel {
    public class LaunchResults : Tea.TeaModel {
        public class LaunchResult : Tea.TeaModel {
            public class InstanceIds : Tea.TeaModel {
                public var instanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! [String]
                    }
                }
            }
            public var amount: Int32?

            public var errorCode: String?

            public var errorMsg: String?

            public var instanceIds: CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult.InstanceIds?

            public var instanceType: String?

            public var spotStrategy: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.amount != nil {
                    map["Amount"] = self.amount!
                }
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.instanceIds != nil {
                    map["InstanceIds"] = self.instanceIds?.toMap()
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Amount") {
                    self.amount = dict["Amount"] as! Int32
                }
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("InstanceIds") {
                    var model = CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult.InstanceIds()
                    model.fromMap(dict["InstanceIds"] as! [String: Any])
                    self.instanceIds = model
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("SpotStrategy") {
                    self.spotStrategy = dict["SpotStrategy"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var launchResult: [CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchResult != nil {
                var tmp : [Any] = []
                for k in self.launchResult! {
                    tmp.append(k.toMap())
                }
                map["LaunchResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LaunchResult") {
                var tmp : [CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult] = []
                for v in dict["LaunchResult"] as! [Any] {
                    var model = CreateAutoProvisioningGroupResponseBody.LaunchResults.LaunchResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchResult = tmp
            }
        }
    }
    public var autoProvisioningGroupId: String?

    public var launchResults: CreateAutoProvisioningGroupResponseBody.LaunchResults?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.launchResults != nil {
            map["LaunchResults"] = self.launchResults?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupId") {
            self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! String
        }
        if dict.keys.contains("LaunchResults") {
            var model = CreateAutoProvisioningGroupResponseBody.LaunchResults()
            model.fromMap(dict["LaunchResults"] as! [String: Any])
            self.launchResults = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAutoProvisioningGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAutoProvisioningGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAutoProvisioningGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateAutoSnapshotPolicyRequest : Tea.TeaModel {
    public class CopyEncryptionConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssumeRoleFor") {
                    self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
                }
                if dict.keys.contains("RoleType") {
                    self.roleType = dict["RoleType"] as! String
                }
                if dict.keys.contains("Rolearn") {
                    self.rolearn = dict["Rolearn"] as! String
                }
            }
        }
        public var arn: [CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration.Arn]?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") {
                var tmp : [CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration.Arn] = []
                for v in dict["Arn"] as! [Any] {
                    var model = CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration.Arn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.arn = tmp
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var copiedSnapshotsRetentionDays: Int32?

    public var copyEncryptionConfiguration: CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration?

    public var enableCrossRegionCopy: Bool?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageLocationArn: String?

    public var tag: [CreateAutoSnapshotPolicyRequest.Tag]?

    public var targetCopyRegions: String?

    public var autoSnapshotPolicyName: String?

    public var regionId: String?

    public var repeatWeekdays: String?

    public var retentionDays: Int32?

    public var timePoints: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.copyEncryptionConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copiedSnapshotsRetentionDays != nil {
            map["CopiedSnapshotsRetentionDays"] = self.copiedSnapshotsRetentionDays!
        }
        if self.copyEncryptionConfiguration != nil {
            map["CopyEncryptionConfiguration"] = self.copyEncryptionConfiguration?.toMap()
        }
        if self.enableCrossRegionCopy != nil {
            map["EnableCrossRegionCopy"] = self.enableCrossRegionCopy!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.targetCopyRegions != nil {
            map["TargetCopyRegions"] = self.targetCopyRegions!
        }
        if self.autoSnapshotPolicyName != nil {
            map["autoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.repeatWeekdays != nil {
            map["repeatWeekdays"] = self.repeatWeekdays!
        }
        if self.retentionDays != nil {
            map["retentionDays"] = self.retentionDays!
        }
        if self.timePoints != nil {
            map["timePoints"] = self.timePoints!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CopiedSnapshotsRetentionDays") {
            self.copiedSnapshotsRetentionDays = dict["CopiedSnapshotsRetentionDays"] as! Int32
        }
        if dict.keys.contains("CopyEncryptionConfiguration") {
            var model = CreateAutoSnapshotPolicyRequest.CopyEncryptionConfiguration()
            model.fromMap(dict["CopyEncryptionConfiguration"] as! [String: Any])
            self.copyEncryptionConfiguration = model
        }
        if dict.keys.contains("EnableCrossRegionCopy") {
            self.enableCrossRegionCopy = dict["EnableCrossRegionCopy"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageLocationArn") {
            self.storageLocationArn = dict["StorageLocationArn"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateAutoSnapshotPolicyRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateAutoSnapshotPolicyRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TargetCopyRegions") {
            self.targetCopyRegions = dict["TargetCopyRegions"] as! String
        }
        if dict.keys.contains("autoSnapshotPolicyName") {
            self.autoSnapshotPolicyName = dict["autoSnapshotPolicyName"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("repeatWeekdays") {
            self.repeatWeekdays = dict["repeatWeekdays"] as! String
        }
        if dict.keys.contains("retentionDays") {
            self.retentionDays = dict["retentionDays"] as! Int32
        }
        if dict.keys.contains("timePoints") {
            self.timePoints = dict["timePoints"] as! String
        }
    }
}

public class CreateAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var autoSnapshotPolicyId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCapacityReservationRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var matchCriteria: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var privatePoolOptions: CreateCapacityReservationRequest.PrivatePoolOptions?

    public var clientToken: String?

    public var description_: String?

    public var endTime: String?

    public var endTimeType: String?

    public var instanceAmount: Int32?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [CreateCapacityReservationRequest.Tag]?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimeType != nil {
            map["EndTimeType"] = self.endTimeType!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = CreateCapacityReservationRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndTimeType") {
            self.endTimeType = dict["EndTimeType"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateCapacityReservationRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateCapacityReservationRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! [String]
        }
    }
}

public class CreateCapacityReservationResponseBody : Tea.TeaModel {
    public var privatePoolOptionsId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptionsId != nil {
            map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptionsId") {
            self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCapacityReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateCommandRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var commandContent: String?

    public var contentEncoding: String?

    public var description_: String?

    public var enableParameter: Bool?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateCommandRequest.Tag]?

    public var timeout: Int64?

    public var type: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableParameter") {
            self.enableParameter = dict["EnableParameter"] as! Bool
        }
        if dict.keys.contains("Launcher") {
            self.launcher = dict["Launcher"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateCommandRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateCommandRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("WorkingDir") {
            self.workingDir = dict["WorkingDir"] as! String
        }
    }
}

public class CreateCommandResponseBody : Tea.TeaModel {
    public var commandId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDedicatedHostClusterRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dedicatedHostClusterName: String?

    public var description_: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateDedicatedHostClusterRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterName") {
            self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateDedicatedHostClusterRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDedicatedHostClusterRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDedicatedHostClusterResponseBody : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDedicatedHostClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDedicatedHostClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDedicatedHostClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDemandRequest : Tea.TeaModel {
    public var amount: Int32?

    public var clientToken: String?

    public var demandDescription: String?

    public var demandName: String?

    public var endTime: String?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.demandDescription != nil {
            map["DemandDescription"] = self.demandDescription!
        }
        if self.demandName != nil {
            map["DemandName"] = self.demandName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DemandDescription") {
            self.demandDescription = dict["DemandDescription"] as! String
        }
        if dict.keys.contains("DemandName") {
            self.demandName = dict["DemandName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDemandResponseBody : Tea.TeaModel {
    public var demandId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDemandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDemandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDemandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDeploymentSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var deploymentSetName: String?

    public var description_: String?

    public var domain: String?

    public var granularity: String?

    public var groupCount: Int64?

    public var onUnableToRedeployFailedInstance: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var strategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.granularity != nil {
            map["Granularity"] = self.granularity!
        }
        if self.groupCount != nil {
            map["GroupCount"] = self.groupCount!
        }
        if self.onUnableToRedeployFailedInstance != nil {
            map["OnUnableToRedeployFailedInstance"] = self.onUnableToRedeployFailedInstance!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DeploymentSetName") {
            self.deploymentSetName = dict["DeploymentSetName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("Granularity") {
            self.granularity = dict["Granularity"] as! String
        }
        if dict.keys.contains("GroupCount") {
            self.groupCount = dict["GroupCount"] as! Int64
        }
        if dict.keys.contains("OnUnableToRedeployFailedInstance") {
            self.onUnableToRedeployFailedInstance = dict["OnUnableToRedeployFailedInstance"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Strategy") {
            self.strategy = dict["Strategy"] as! String
        }
    }
}

public class CreateDeploymentSetResponseBody : Tea.TeaModel {
    public var deploymentSetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDeploymentSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDeploymentSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDeploymentSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiagnosticMetricSetRequest : Tea.TeaModel {
    public var description_: String?

    public var metricIds: [String]?

    public var metricSetName: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.metricIds != nil {
            map["MetricIds"] = self.metricIds!
        }
        if self.metricSetName != nil {
            map["MetricSetName"] = self.metricSetName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MetricIds") {
            self.metricIds = dict["MetricIds"] as! [String]
        }
        if dict.keys.contains("MetricSetName") {
            self.metricSetName = dict["MetricSetName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class CreateDiagnosticMetricSetResponseBody : Tea.TeaModel {
    public var metricSetId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricSetId") {
            self.metricSetId = dict["MetricSetId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDiagnosticMetricSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosticMetricSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiagnosticMetricSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiagnosticReportRequest : Tea.TeaModel {
    public var endTime: String?

    public var metricSetId: String?

    public var regionId: String?

    public var resourceId: String?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("MetricSetId") {
            self.metricSetId = dict["MetricSetId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class CreateDiagnosticReportResponseBody : Tea.TeaModel {
    public var reportId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDiagnosticReportResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiagnosticReportResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiagnosticReportResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateDiskRequest : Tea.TeaModel {
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssumeRoleFor") {
                self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
            if dict.keys.contains("Rolearn") {
                self.rolearn = dict["Rolearn"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var advancedFeatures: String?

    public var arn: [CreateDiskRequest.Arn]?

    public var burstingEnabled: Bool?

    public var clientToken: String?

    public var description_: String?

    public var diskCategory: String?

    public var diskName: String?

    public var encryptAlgorithm: String?

    public var encrypted: Bool?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var multiAttach: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceLevel: String?

    public var provisionedIops: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var size: Int32?

    public var snapshotId: String?

    public var storageClusterId: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [CreateDiskRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.advancedFeatures != nil {
            map["AdvancedFeatures"] = self.advancedFeatures!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.encryptAlgorithm != nil {
            map["EncryptAlgorithm"] = self.encryptAlgorithm!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.multiAttach != nil {
            map["MultiAttach"] = self.multiAttach!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.provisionedIops != nil {
            map["ProvisionedIops"] = self.provisionedIops!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.size != nil {
            map["Size"] = self.size!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.storageClusterId != nil {
            map["StorageClusterId"] = self.storageClusterId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdvancedFeatures") {
            self.advancedFeatures = dict["AdvancedFeatures"] as! String
        }
        if dict.keys.contains("Arn") {
            var tmp : [CreateDiskRequest.Arn] = []
            for v in dict["Arn"] as! [Any] {
                var model = CreateDiskRequest.Arn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.arn = tmp
        }
        if dict.keys.contains("BurstingEnabled") {
            self.burstingEnabled = dict["BurstingEnabled"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DiskCategory") {
            self.diskCategory = dict["DiskCategory"] as! String
        }
        if dict.keys.contains("DiskName") {
            self.diskName = dict["DiskName"] as! String
        }
        if dict.keys.contains("EncryptAlgorithm") {
            self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("MultiAttach") {
            self.multiAttach = dict["MultiAttach"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("ProvisionedIops") {
            self.provisionedIops = dict["ProvisionedIops"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Size") {
            self.size = dict["Size"] as! Int32
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("StorageClusterId") {
            self.storageClusterId = dict["StorageClusterId"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateDiskRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateDiskRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateDiskResponseBody : Tea.TeaModel {
    public var diskId: String?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateElasticityAssuranceRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var matchCriteria: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var privatePoolOptions: CreateElasticityAssuranceRequest.PrivatePoolOptions?

    public var assuranceTimes: String?

    public var clientToken: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var instanceCpuCoreCount: Int32?

    public var instanceType: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [CreateElasticityAssuranceRequest.Tag]?

    public var zoneId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.assuranceTimes != nil {
            map["AssuranceTimes"] = self.assuranceTimes!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceCpuCoreCount != nil {
            map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = CreateElasticityAssuranceRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("AssuranceTimes") {
            self.assuranceTimes = dict["AssuranceTimes"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceCpuCoreCount") {
            self.instanceCpuCoreCount = dict["InstanceCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateElasticityAssuranceRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateElasticityAssuranceRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! [String]
        }
    }
}

public class CreateElasticityAssuranceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var privatePoolOptionsId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.privatePoolOptionsId != nil {
            map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PrivatePoolOptionsId") {
            self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateElasticityAssuranceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateElasticityAssuranceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateElasticityAssuranceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateForwardEntryRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateForwardEntryResponseBody : Tea.TeaModel {
    public var forwardEntryId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var ipAddress: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipAddress != nil {
            map["IpAddress"] = self.ipAddress!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("IpAddress") {
            self.ipAddress = dict["IpAddress"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateHaVipResponseBody : Tea.TeaModel {
    public var haVipId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateHpcClusterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateHpcClusterResponseBody : Tea.TeaModel {
    public var hpcClusterId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateHpcClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateHpcClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateHpcClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImageRequest : Tea.TeaModel {
    public class DiskDeviceMapping : Tea.TeaModel {
        public var device: String?

        public var diskType: String?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskType != nil {
                map["DiskType"] = self.diskType!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskType") {
                self.diskType = dict["DiskType"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var architecture: String?

    public var bootMode: String?

    public var clientToken: String?

    public var description_: String?

    public var detectionStrategy: String?

    public var diskDeviceMapping: [CreateImageRequest.DiskDeviceMapping]?

    public var imageFamily: String?

    public var imageName: String?

    public var imageVersion: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public var tag: [CreateImageRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.bootMode != nil {
            map["BootMode"] = self.bootMode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.detectionStrategy != nil {
            map["DetectionStrategy"] = self.detectionStrategy!
        }
        if self.diskDeviceMapping != nil {
            var tmp : [Any] = []
            for k in self.diskDeviceMapping! {
                tmp.append(k.toMap())
            }
            map["DiskDeviceMapping"] = tmp
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.imageVersion != nil {
            map["ImageVersion"] = self.imageVersion!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Architecture") {
            self.architecture = dict["Architecture"] as! String
        }
        if dict.keys.contains("BootMode") {
            self.bootMode = dict["BootMode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DetectionStrategy") {
            self.detectionStrategy = dict["DetectionStrategy"] as! String
        }
        if dict.keys.contains("DiskDeviceMapping") {
            var tmp : [CreateImageRequest.DiskDeviceMapping] = []
            for v in dict["DiskDeviceMapping"] as! [Any] {
                var model = CreateImageRequest.DiskDeviceMapping()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.diskDeviceMapping = tmp
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("ImageVersion") {
            self.imageVersion = dict["ImageVersion"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateImageRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateImageRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImageComponentRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var componentType: String?

    public var componentVersion: String?

    public var content: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var systemType: String?

    public var tag: [CreateImageComponentRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.componentVersion != nil {
            map["ComponentVersion"] = self.componentVersion!
        }
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ComponentType") {
            self.componentType = dict["ComponentType"] as! String
        }
        if dict.keys.contains("ComponentVersion") {
            self.componentVersion = dict["ComponentVersion"] as! String
        }
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SystemType") {
            self.systemType = dict["SystemType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateImageComponentRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateImageComponentRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateImageComponentResponseBody : Tea.TeaModel {
    public var imageComponentId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageComponentId != nil {
            map["ImageComponentId"] = self.imageComponentId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageComponentId") {
            self.imageComponentId = dict["ImageComponentId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateImageComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImageComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateImageComponentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateImagePipelineRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var addAccount: [Int64]?

    public var baseImage: String?

    public var baseImageType: String?

    public var buildContent: String?

    public var clientToken: String?

    public var deleteInstanceOnFailure: Bool?

    public var description_: String?

    public var imageFamily: String?

    public var imageName: String?

    public var instanceType: String?

    public var internetMaxBandwidthOut: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var repairMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var systemDiskSize: Int32?

    public var tag: [CreateImagePipelineRequest.Tag]?

    public var testContent: String?

    public var toRegionId: [String]?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addAccount != nil {
            map["AddAccount"] = self.addAccount!
        }
        if self.baseImage != nil {
            map["BaseImage"] = self.baseImage!
        }
        if self.baseImageType != nil {
            map["BaseImageType"] = self.baseImageType!
        }
        if self.buildContent != nil {
            map["BuildContent"] = self.buildContent!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.deleteInstanceOnFailure != nil {
            map["DeleteInstanceOnFailure"] = self.deleteInstanceOnFailure!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repairMode != nil {
            map["RepairMode"] = self.repairMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.systemDiskSize != nil {
            map["SystemDiskSize"] = self.systemDiskSize!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.testContent != nil {
            map["TestContent"] = self.testContent!
        }
        if self.toRegionId != nil {
            map["ToRegionId"] = self.toRegionId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddAccount") {
            self.addAccount = dict["AddAccount"] as! [Int64]
        }
        if dict.keys.contains("BaseImage") {
            self.baseImage = dict["BaseImage"] as! String
        }
        if dict.keys.contains("BaseImageType") {
            self.baseImageType = dict["BaseImageType"] as! String
        }
        if dict.keys.contains("BuildContent") {
            self.buildContent = dict["BuildContent"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DeleteInstanceOnFailure") {
            self.deleteInstanceOnFailure = dict["DeleteInstanceOnFailure"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepairMode") {
            self.repairMode = dict["RepairMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SystemDiskSize") {
            self.systemDiskSize = dict["SystemDiskSize"] as! Int32
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateImagePipelineRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateImagePipelineRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TestContent") {
            self.testContent = dict["TestContent"] as! String
        }
        if dict.keys.contains("ToRegionId") {
            self.toRegionId = dict["ToRegionId"] as! [String]
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateImagePipelineResponseBody : Tea.TeaModel {
    public var imagePipelineId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImagePipelineId") {
            self.imagePipelineId = dict["ImagePipelineId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateImagePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateImagePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateImagePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateInstanceRequest : Tea.TeaModel {
    public class HibernationOptions : Tea.TeaModel {
        public var configured: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configured != nil {
                map["Configured"] = self.configured!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Configured") {
                self.configured = dict["Configured"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var performanceLevel: String?

        public var size: Int32?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssumeRoleFor") {
                self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
            if dict.keys.contains("Rolearn") {
                self.rolearn = dict["Rolearn"] as! String
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var size: Int32?

        public var snapshotId: String?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var hibernationOptions: CreateInstanceRequest.HibernationOptions?

    public var privatePoolOptions: CreateInstanceRequest.PrivatePoolOptions?

    public var systemDisk: CreateInstanceRequest.SystemDisk?

    public var affinity: String?

    public var arn: [CreateInstanceRequest.Arn]?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var clusterId: String?

    public var creditSpecification: String?

    public var dataDisk: [CreateInstanceRequest.DataDisk]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetGroupNo: Int32?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var innerIpAddress: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var keyPairName: String?

    public var nodeControllerId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [CreateInstanceRequest.Tag]?

    public var tenancy: String?

    public var useAdditionalService: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public var vlanId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hibernationOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hibernationOptions != nil {
            map["HibernationOptions"] = self.hibernationOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.innerIpAddress != nil {
            map["InnerIpAddress"] = self.innerIpAddress!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.nodeControllerId != nil {
            map["NodeControllerId"] = self.nodeControllerId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.useAdditionalService != nil {
            map["UseAdditionalService"] = self.useAdditionalService!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HibernationOptions") {
            var model = CreateInstanceRequest.HibernationOptions()
            model.fromMap(dict["HibernationOptions"] as! [String: Any])
            self.hibernationOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = CreateInstanceRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = CreateInstanceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("Arn") {
            var tmp : [CreateInstanceRequest.Arn] = []
            for v in dict["Arn"] as! [Any] {
                var model = CreateInstanceRequest.Arn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.arn = tmp
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DataDisk") {
            var tmp : [CreateInstanceRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = CreateInstanceRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetGroupNo") {
            self.deploymentSetGroupNo = dict["DeploymentSetGroupNo"] as! Int32
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InnerIpAddress") {
            self.innerIpAddress = dict["InnerIpAddress"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("NodeControllerId") {
            self.nodeControllerId = dict["NodeControllerId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateInstanceRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateInstanceRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UseAdditionalService") {
            self.useAdditionalService = dict["UseAdditionalService"] as! Bool
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateInstanceResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var orderId: String?

    public var requestId: String?

    public var tradePrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TradePrice") {
            self.tradePrice = dict["TradePrice"] as! Double
        }
    }
}

public class CreateInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateKeyPairRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var keyPairName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [CreateKeyPairRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateKeyPairRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateKeyPairRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairId: String?

    public var keyPairName: String?

    public var privateKeyBody: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairId != nil {
            map["KeyPairId"] = self.keyPairId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.privateKeyBody != nil {
            map["PrivateKeyBody"] = self.privateKeyBody!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairFingerPrint") {
            self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
        }
        if dict.keys.contains("KeyPairId") {
            self.keyPairId = dict["KeyPairId"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("PrivateKeyBody") {
            self.privateKeyBody = dict["PrivateKeyBody"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLaunchTemplateRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var diskName: String?

        public var encrypted: String?

        public var iops: Int32?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.iops != nil {
                map["Iops"] = self.iops!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("Iops") {
                self.iops = dict["Iops"] as! Int32
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var description_: String?

        public var instanceType: String?

        public var networkInterfaceName: String?

        public var networkInterfaceTrafficMode: String?

        public var primaryIpAddress: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("NetworkInterfaceName") {
                self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("PrimaryIpAddress") {
                self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var systemDisk: CreateLaunchTemplateRequest.SystemDisk?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var creditSpecification: String?

    public var dataDisk: [CreateLaunchTemplateRequest.DataDisk]?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var description_: String?

    public var enableVmOsConfig: Bool?

    public var hostName: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageId: String?

    public var imageOwnerAlias: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var launchTemplateName: String?

    public var networkInterface: [CreateLaunchTemplateRequest.NetworkInterface]?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tag: [CreateLaunchTemplateRequest.Tag]?

    public var templateResourceGroupId: String?

    public var templateTag: [CreateLaunchTemplateRequest.TemplateTag]?

    public var userData: String?

    public var vSwitchId: String?

    public var versionDescription: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableVmOsConfig != nil {
            map["EnableVmOsConfig"] = self.enableVmOsConfig!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageOwnerAlias != nil {
            map["ImageOwnerAlias"] = self.imageOwnerAlias!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.templateResourceGroupId != nil {
            map["TemplateResourceGroupId"] = self.templateResourceGroupId!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.versionDescription != nil {
            map["VersionDescription"] = self.versionDescription!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SystemDisk") {
            var model = CreateLaunchTemplateRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DataDisk") {
            var tmp : [CreateLaunchTemplateRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = CreateLaunchTemplateRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableVmOsConfig") {
            self.enableVmOsConfig = dict["EnableVmOsConfig"] as! Bool
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageOwnerAlias") {
            self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("NetworkInterface") {
            var tmp : [CreateLaunchTemplateRequest.NetworkInterface] = []
            for v in dict["NetworkInterface"] as! [Any] {
                var model = CreateLaunchTemplateRequest.NetworkInterface()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInterface = tmp
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateLaunchTemplateRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateLaunchTemplateRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TemplateResourceGroupId") {
            self.templateResourceGroupId = dict["TemplateResourceGroupId"] as! String
        }
        if dict.keys.contains("TemplateTag") {
            var tmp : [CreateLaunchTemplateRequest.TemplateTag] = []
            for v in dict["TemplateTag"] as! [Any] {
                var model = CreateLaunchTemplateRequest.TemplateTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateTag = tmp
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VersionDescription") {
            self.versionDescription = dict["VersionDescription"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateLaunchTemplateResponseBody : Tea.TeaModel {
    public var launchTemplateId: String?

    public var launchTemplateVersionNumber: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersionNumber != nil {
            map["LaunchTemplateVersionNumber"] = self.launchTemplateVersionNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersionNumber") {
            self.launchTemplateVersionNumber = dict["LaunchTemplateVersionNumber"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLaunchTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLaunchTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLaunchTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateLaunchTemplateVersionRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var diskName: String?

        public var encrypted: String?

        public var iops: Int32?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.iops != nil {
                map["Iops"] = self.iops!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("Iops") {
                self.iops = dict["Iops"] as! Int32
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encrypted: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var description_: String?

        public var instanceType: String?

        public var networkInterfaceName: String?

        public var networkInterfaceTrafficMode: String?

        public var primaryIpAddress: String?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("NetworkInterfaceName") {
                self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("PrimaryIpAddress") {
                self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var systemDisk: CreateLaunchTemplateVersionRequest.SystemDisk?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var creditSpecification: String?

    public var dataDisk: [CreateLaunchTemplateVersionRequest.DataDisk]?

    public var deletionProtection: Bool?

    public var deploymentSetId: String?

    public var description_: String?

    public var enableVmOsConfig: Bool?

    public var hostName: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageId: String?

    public var imageOwnerAlias: String?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6AddressCount: Int32?

    public var keyPairName: String?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var networkInterface: [CreateLaunchTemplateVersionRequest.NetworkInterface]?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var tag: [CreateLaunchTemplateVersionRequest.Tag]?

    public var userData: String?

    public var vSwitchId: String?

    public var versionDescription: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableVmOsConfig != nil {
            map["EnableVmOsConfig"] = self.enableVmOsConfig!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageOwnerAlias != nil {
            map["ImageOwnerAlias"] = self.imageOwnerAlias!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.versionDescription != nil {
            map["VersionDescription"] = self.versionDescription!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SystemDisk") {
            var model = CreateLaunchTemplateVersionRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DataDisk") {
            var tmp : [CreateLaunchTemplateVersionRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = CreateLaunchTemplateVersionRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableVmOsConfig") {
            self.enableVmOsConfig = dict["EnableVmOsConfig"] as! Bool
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageOwnerAlias") {
            self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("NetworkInterface") {
            var tmp : [CreateLaunchTemplateVersionRequest.NetworkInterface] = []
            for v in dict["NetworkInterface"] as! [Any] {
                var model = CreateLaunchTemplateVersionRequest.NetworkInterface()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInterface = tmp
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateLaunchTemplateVersionRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateLaunchTemplateVersionRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VersionDescription") {
            self.versionDescription = dict["VersionDescription"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateLaunchTemplateVersionResponseBody : Tea.TeaModel {
    public var launchTemplateId: String?

    public var launchTemplateVersionNumber: Int64?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersionNumber != nil {
            map["LaunchTemplateVersionNumber"] = self.launchTemplateVersionNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersionNumber") {
            self.launchTemplateVersionNumber = dict["LaunchTemplateVersionNumber"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateLaunchTemplateVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateLaunchTemplateVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateLaunchTemplateVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNatGatewayRequest : Tea.TeaModel {
    public class BandwidthPackage : Tea.TeaModel {
        public var bandwidth: Int32?

        public var ipCount: Int32?

        public var zone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.ipCount != nil {
                map["IpCount"] = self.ipCount!
            }
            if self.zone != nil {
                map["Zone"] = self.zone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("IpCount") {
                self.ipCount = dict["IpCount"] as! Int32
            }
            if dict.keys.contains("Zone") {
                self.zone = dict["Zone"] as! String
            }
        }
    }
    public var bandwidthPackage: [CreateNatGatewayRequest.BandwidthPackage]?

    public var clientToken: String?

    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackage != nil {
            var tmp : [Any] = []
            for k in self.bandwidthPackage! {
                tmp.append(k.toMap())
            }
            map["BandwidthPackage"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackage") {
            var tmp : [CreateNatGatewayRequest.BandwidthPackage] = []
            for v in dict["BandwidthPackage"] as! [Any] {
                var model = CreateNatGatewayRequest.BandwidthPackage()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.bandwidthPackage = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateNatGatewayResponseBody : Tea.TeaModel {
    public class BandwidthPackageIds : Tea.TeaModel {
        public var bandwidthPackageId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidthPackageId != nil {
                map["BandwidthPackageId"] = self.bandwidthPackageId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BandwidthPackageId") {
                self.bandwidthPackageId = dict["BandwidthPackageId"] as! [String]
            }
        }
    }
    public class ForwardTableIds : Tea.TeaModel {
        public var forwardTableId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableId != nil {
                map["ForwardTableId"] = self.forwardTableId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardTableId") {
                self.forwardTableId = dict["ForwardTableId"] as! [String]
            }
        }
    }
    public var bandwidthPackageIds: CreateNatGatewayResponseBody.BandwidthPackageIds?

    public var forwardTableIds: CreateNatGatewayResponseBody.ForwardTableIds?

    public var natGatewayId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidthPackageIds?.validate()
        try self.forwardTableIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageIds != nil {
            map["BandwidthPackageIds"] = self.bandwidthPackageIds?.toMap()
        }
        if self.forwardTableIds != nil {
            map["ForwardTableIds"] = self.forwardTableIds?.toMap()
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageIds") {
            var model = CreateNatGatewayResponseBody.BandwidthPackageIds()
            model.fromMap(dict["BandwidthPackageIds"] as! [String: Any])
            self.bandwidthPackageIds = model
        }
        if dict.keys.contains("ForwardTableIds") {
            var model = CreateNatGatewayResponseBody.ForwardTableIds()
            model.fromMap(dict["ForwardTableIds"] as! [String: Any])
            self.forwardTableIds = model
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkInterfaceRequest : Tea.TeaModel {
    public class ConnectionTrackingConfiguration : Tea.TeaModel {
        public var tcpClosedAndTimeWaitTimeout: Int32?

        public var tcpEstablishedTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tcpClosedAndTimeWaitTimeout != nil {
                map["TcpClosedAndTimeWaitTimeout"] = self.tcpClosedAndTimeWaitTimeout!
            }
            if self.tcpEstablishedTimeout != nil {
                map["TcpEstablishedTimeout"] = self.tcpEstablishedTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TcpClosedAndTimeWaitTimeout") {
                self.tcpClosedAndTimeWaitTimeout = dict["TcpClosedAndTimeWaitTimeout"] as! Int32
            }
            if dict.keys.contains("TcpEstablishedTimeout") {
                self.tcpEstablishedTimeout = dict["TcpEstablishedTimeout"] as! Int32
            }
            if dict.keys.contains("UdpTimeout") {
                self.udpTimeout = dict["UdpTimeout"] as! Int32
            }
        }
    }
    public class EnhancedNetwork : Tea.TeaModel {
        public var enableSriov: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableSriov != nil {
                map["EnableSriov"] = self.enableSriov!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableSriov") {
                self.enableSriov = dict["EnableSriov"] as! Bool
            }
        }
    }
    public class NetworkInterfaceTrafficConfig : Tea.TeaModel {
        public var networkInterfaceTrafficMode: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int32?

        public var rxQueueSize: Int32?

        public var txQueueSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            if self.rxQueueSize != nil {
                map["RxQueueSize"] = self.rxQueueSize!
            }
            if self.txQueueSize != nil {
                map["TxQueueSize"] = self.txQueueSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("QueueNumber") {
                self.queueNumber = dict["QueueNumber"] as! Int32
            }
            if dict.keys.contains("QueuePairNumber") {
                self.queuePairNumber = dict["QueuePairNumber"] as! Int32
            }
            if dict.keys.contains("RxQueueSize") {
                self.rxQueueSize = dict["RxQueueSize"] as! Int32
            }
            if dict.keys.contains("TxQueueSize") {
                self.txQueueSize = dict["TxQueueSize"] as! Int32
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var businessType: String?

    public var clientToken: String?

    public var connectionTrackingConfiguration: CreateNetworkInterfaceRequest.ConnectionTrackingConfiguration?

    public var deleteOnRelease: Bool?

    public var description_: String?

    public var enhancedNetwork: CreateNetworkInterfaceRequest.EnhancedNetwork?

    public var instanceType: String?

    public var ipv4Prefix: [String]?

    public var ipv4PrefixCount: Int32?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var ipv6Prefix: [String]?

    public var ipv6PrefixCount: Int32?

    public var networkInterfaceName: String?

    public var networkInterfaceTrafficConfig: CreateNetworkInterfaceRequest.NetworkInterfaceTrafficConfig?

    public var networkInterfaceTrafficMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var primaryIpAddress: String?

    public var privateIpAddress: [String]?

    public var queueNumber: Int32?

    public var queuePairNumber: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var rxQueueSize: Int32?

    public var secondaryPrivateIpAddressCount: Int32?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var tag: [CreateNetworkInterfaceRequest.Tag]?

    public var txQueueSize: Int32?

    public var vSwitchId: String?

    public var visible: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.connectionTrackingConfiguration?.validate()
        try self.enhancedNetwork?.validate()
        try self.networkInterfaceTrafficConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.businessType != nil {
            map["BusinessType"] = self.businessType!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.connectionTrackingConfiguration != nil {
            map["ConnectionTrackingConfiguration"] = self.connectionTrackingConfiguration?.toMap()
        }
        if self.deleteOnRelease != nil {
            map["DeleteOnRelease"] = self.deleteOnRelease!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enhancedNetwork != nil {
            map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.ipv4PrefixCount != nil {
            map["Ipv4PrefixCount"] = self.ipv4PrefixCount!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.ipv6Prefix != nil {
            map["Ipv6Prefix"] = self.ipv6Prefix!
        }
        if self.ipv6PrefixCount != nil {
            map["Ipv6PrefixCount"] = self.ipv6PrefixCount!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.networkInterfaceTrafficConfig != nil {
            map["NetworkInterfaceTrafficConfig"] = self.networkInterfaceTrafficConfig?.toMap()
        }
        if self.networkInterfaceTrafficMode != nil {
            map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.primaryIpAddress != nil {
            map["PrimaryIpAddress"] = self.primaryIpAddress!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.queueNumber != nil {
            map["QueueNumber"] = self.queueNumber!
        }
        if self.queuePairNumber != nil {
            map["QueuePairNumber"] = self.queuePairNumber!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.rxQueueSize != nil {
            map["RxQueueSize"] = self.rxQueueSize!
        }
        if self.secondaryPrivateIpAddressCount != nil {
            map["SecondaryPrivateIpAddressCount"] = self.secondaryPrivateIpAddressCount!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.txQueueSize != nil {
            map["TxQueueSize"] = self.txQueueSize!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.visible != nil {
            map["Visible"] = self.visible!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BusinessType") {
            self.businessType = dict["BusinessType"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ConnectionTrackingConfiguration") {
            var model = CreateNetworkInterfaceRequest.ConnectionTrackingConfiguration()
            model.fromMap(dict["ConnectionTrackingConfiguration"] as! [String: Any])
            self.connectionTrackingConfiguration = model
        }
        if dict.keys.contains("DeleteOnRelease") {
            self.deleteOnRelease = dict["DeleteOnRelease"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnhancedNetwork") {
            var model = CreateNetworkInterfaceRequest.EnhancedNetwork()
            model.fromMap(dict["EnhancedNetwork"] as! [String: Any])
            self.enhancedNetwork = model
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Ipv4Prefix") {
            self.ipv4Prefix = dict["Ipv4Prefix"] as! [String]
        }
        if dict.keys.contains("Ipv4PrefixCount") {
            self.ipv4PrefixCount = dict["Ipv4PrefixCount"] as! Int32
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("Ipv6Prefix") {
            self.ipv6Prefix = dict["Ipv6Prefix"] as! [String]
        }
        if dict.keys.contains("Ipv6PrefixCount") {
            self.ipv6PrefixCount = dict["Ipv6PrefixCount"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaceName") {
            self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
        }
        if dict.keys.contains("NetworkInterfaceTrafficConfig") {
            var model = CreateNetworkInterfaceRequest.NetworkInterfaceTrafficConfig()
            model.fromMap(dict["NetworkInterfaceTrafficConfig"] as! [String: Any])
            self.networkInterfaceTrafficConfig = model
        }
        if dict.keys.contains("NetworkInterfaceTrafficMode") {
            self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrimaryIpAddress") {
            self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! [String]
        }
        if dict.keys.contains("QueueNumber") {
            self.queueNumber = dict["QueueNumber"] as! Int32
        }
        if dict.keys.contains("QueuePairNumber") {
            self.queuePairNumber = dict["QueuePairNumber"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RxQueueSize") {
            self.rxQueueSize = dict["RxQueueSize"] as! Int32
        }
        if dict.keys.contains("SecondaryPrivateIpAddressCount") {
            self.secondaryPrivateIpAddressCount = dict["SecondaryPrivateIpAddressCount"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateNetworkInterfaceRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateNetworkInterfaceRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TxQueueSize") {
            self.txQueueSize = dict["TxQueueSize"] as! Int32
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("Visible") {
            self.visible = dict["Visible"] as! Bool
        }
    }
}

public class CreateNetworkInterfaceResponseBody : Tea.TeaModel {
    public class Ipv4PrefixSets : Tea.TeaModel {
        public class Ipv4PrefixSet : Tea.TeaModel {
            public var ipv4Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv4Prefix != nil {
                    map["Ipv4Prefix"] = self.ipv4Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv4Prefix") {
                    self.ipv4Prefix = dict["Ipv4Prefix"] as! String
                }
            }
        }
        public var ipv4PrefixSet: [CreateNetworkInterfaceResponseBody.Ipv4PrefixSets.Ipv4PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv4PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv4PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4PrefixSet") {
                var tmp : [CreateNetworkInterfaceResponseBody.Ipv4PrefixSets.Ipv4PrefixSet] = []
                for v in dict["Ipv4PrefixSet"] as! [Any] {
                    var model = CreateNetworkInterfaceResponseBody.Ipv4PrefixSets.Ipv4PrefixSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv4PrefixSet = tmp
            }
        }
    }
    public class Ipv6PrefixSets : Tea.TeaModel {
        public class Ipv6PrefixSet : Tea.TeaModel {
            public var ipv6Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Prefix != nil {
                    map["Ipv6Prefix"] = self.ipv6Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv6Prefix") {
                    self.ipv6Prefix = dict["Ipv6Prefix"] as! String
                }
            }
        }
        public var ipv6PrefixSet: [CreateNetworkInterfaceResponseBody.Ipv6PrefixSets.Ipv6PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv6PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv6PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6PrefixSet") {
                var tmp : [CreateNetworkInterfaceResponseBody.Ipv6PrefixSets.Ipv6PrefixSet] = []
                for v in dict["Ipv6PrefixSet"] as! [Any] {
                    var model = CreateNetworkInterfaceResponseBody.Ipv6PrefixSets.Ipv6PrefixSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6PrefixSet = tmp
            }
        }
    }
    public class Ipv6Sets : Tea.TeaModel {
        public class Ipv6Set : Tea.TeaModel {
            public var ipv6Address: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Address != nil {
                    map["Ipv6Address"] = self.ipv6Address!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv6Address") {
                    self.ipv6Address = dict["Ipv6Address"] as! String
                }
            }
        }
        public var ipv6Set: [CreateNetworkInterfaceResponseBody.Ipv6Sets.Ipv6Set]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Set != nil {
                var tmp : [Any] = []
                for k in self.ipv6Set! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Set"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6Set") {
                var tmp : [CreateNetworkInterfaceResponseBody.Ipv6Sets.Ipv6Set] = []
                for v in dict["Ipv6Set"] as! [Any] {
                    var model = CreateNetworkInterfaceResponseBody.Ipv6Sets.Ipv6Set()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6Set = tmp
            }
        }
    }
    public class PrivateIpSets : Tea.TeaModel {
        public class PrivateIpSet : Tea.TeaModel {
            public var primary: Bool?

            public var privateIpAddress: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Primary") {
                    self.primary = dict["Primary"] as! Bool
                }
                if dict.keys.contains("PrivateIpAddress") {
                    self.privateIpAddress = dict["PrivateIpAddress"] as! String
                }
            }
        }
        public var privateIpSet: [CreateNetworkInterfaceResponseBody.PrivateIpSets.PrivateIpSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateIpSet != nil {
                var tmp : [Any] = []
                for k in self.privateIpSet! {
                    tmp.append(k.toMap())
                }
                map["PrivateIpSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivateIpSet") {
                var tmp : [CreateNetworkInterfaceResponseBody.PrivateIpSets.PrivateIpSet] = []
                for v in dict["PrivateIpSet"] as! [Any] {
                    var model = CreateNetworkInterfaceResponseBody.PrivateIpSets.PrivateIpSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.privateIpSet = tmp
            }
        }
    }
    public class SecurityGroupIds : Tea.TeaModel {
        public var securityGroupId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! [String]
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tag: [CreateNetworkInterfaceResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [CreateNetworkInterfaceResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = CreateNetworkInterfaceResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var description_: String?

    public var ipv4PrefixSets: CreateNetworkInterfaceResponseBody.Ipv4PrefixSets?

    public var ipv6PrefixSets: CreateNetworkInterfaceResponseBody.Ipv6PrefixSets?

    public var ipv6Sets: CreateNetworkInterfaceResponseBody.Ipv6Sets?

    public var macAddress: String?

    public var networkInterfaceId: String?

    public var networkInterfaceName: String?

    public var ownerId: String?

    public var privateIpAddress: String?

    public var privateIpSets: CreateNetworkInterfaceResponseBody.PrivateIpSets?

    public var requestId: String?

    public var resourceGroupId: String?

    public var securityGroupIds: CreateNetworkInterfaceResponseBody.SecurityGroupIds?

    public var serviceID: Int64?

    public var serviceManaged: Bool?

    public var status: String?

    public var tags: CreateNetworkInterfaceResponseBody.Tags?

    public var type: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.ipv4PrefixSets?.validate()
        try self.ipv6PrefixSets?.validate()
        try self.ipv6Sets?.validate()
        try self.privateIpSets?.validate()
        try self.securityGroupIds?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ipv4PrefixSets != nil {
            map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
        }
        if self.ipv6PrefixSets != nil {
            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
        }
        if self.ipv6Sets != nil {
            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
        }
        if self.macAddress != nil {
            map["MacAddress"] = self.macAddress!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.privateIpSets != nil {
            map["PrivateIpSets"] = self.privateIpSets?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
        }
        if self.serviceID != nil {
            map["ServiceID"] = self.serviceID!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Ipv4PrefixSets") {
            var model = CreateNetworkInterfaceResponseBody.Ipv4PrefixSets()
            model.fromMap(dict["Ipv4PrefixSets"] as! [String: Any])
            self.ipv4PrefixSets = model
        }
        if dict.keys.contains("Ipv6PrefixSets") {
            var model = CreateNetworkInterfaceResponseBody.Ipv6PrefixSets()
            model.fromMap(dict["Ipv6PrefixSets"] as! [String: Any])
            self.ipv6PrefixSets = model
        }
        if dict.keys.contains("Ipv6Sets") {
            var model = CreateNetworkInterfaceResponseBody.Ipv6Sets()
            model.fromMap(dict["Ipv6Sets"] as! [String: Any])
            self.ipv6Sets = model
        }
        if dict.keys.contains("MacAddress") {
            self.macAddress = dict["MacAddress"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceName") {
            self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PrivateIpSets") {
            var model = CreateNetworkInterfaceResponseBody.PrivateIpSets()
            model.fromMap(dict["PrivateIpSets"] as! [String: Any])
            self.privateIpSets = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            var model = CreateNetworkInterfaceResponseBody.SecurityGroupIds()
            model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
            self.securityGroupIds = model
        }
        if dict.keys.contains("ServiceID") {
            self.serviceID = dict["ServiceID"] as! Int64
        }
        if dict.keys.contains("ServiceManaged") {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = CreateNetworkInterfaceResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateNetworkInterfacePermissionRequest : Tea.TeaModel {
    public var accountId: Int64?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permission: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountId != nil {
            map["AccountId"] = self.accountId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permission != nil {
            map["Permission"] = self.permission!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountId") {
            self.accountId = dict["AccountId"] as! Int64
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Permission") {
            self.permission = dict["Permission"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateNetworkInterfacePermissionResponseBody : Tea.TeaModel {
    public class NetworkInterfacePermission : Tea.TeaModel {
        public var accountId: Int64?

        public var networkInterfaceId: String?

        public var networkInterfacePermissionId: String?

        public var permission: String?

        public var permissionState: String?

        public var serviceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountId != nil {
                map["AccountId"] = self.accountId!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.networkInterfacePermissionId != nil {
                map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
            }
            if self.permission != nil {
                map["Permission"] = self.permission!
            }
            if self.permissionState != nil {
                map["PermissionState"] = self.permissionState!
            }
            if self.serviceName != nil {
                map["ServiceName"] = self.serviceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountId") {
                self.accountId = dict["AccountId"] as! Int64
            }
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
            }
            if dict.keys.contains("NetworkInterfacePermissionId") {
                self.networkInterfacePermissionId = dict["NetworkInterfacePermissionId"] as! String
            }
            if dict.keys.contains("Permission") {
                self.permission = dict["Permission"] as! String
            }
            if dict.keys.contains("PermissionState") {
                self.permissionState = dict["PermissionState"] as! String
            }
            if dict.keys.contains("ServiceName") {
                self.serviceName = dict["ServiceName"] as! String
            }
        }
    }
    public var networkInterfacePermission: CreateNetworkInterfacePermissionResponseBody.NetworkInterfacePermission?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfacePermission?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfacePermission != nil {
            map["NetworkInterfacePermission"] = self.networkInterfacePermission?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfacePermission") {
            var model = CreateNetworkInterfacePermissionResponseBody.NetworkInterfacePermission()
            model.fromMap(dict["NetworkInterfacePermission"] as! [String: Any])
            self.networkInterfacePermission = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateNetworkInterfacePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateNetworkInterfacePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateNetworkInterfacePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePhysicalConnectionRequest : Tea.TeaModel {
    public var accessPointId: String?

    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var lineOperator: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public var userCidr: String?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointId") {
            self.accessPointId = dict["AccessPointId"] as! String
        }
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LineOperator") {
            self.lineOperator = dict["LineOperator"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerLocation") {
            self.peerLocation = dict["PeerLocation"] as! String
        }
        if dict.keys.contains("PortType") {
            self.portType = dict["PortType"] as! String
        }
        if dict.keys.contains("RedundantPhysicalConnectionId") {
            self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("bandwidth") {
            self.bandwidth = dict["bandwidth"] as! Int32
        }
    }
}

public class CreatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var physicalConnectionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreatePrefixListRequest : Tea.TeaModel {
    public class Entry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidr") {
                self.cidr = dict["Cidr"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public var addressFamily: String?

    public var clientToken: String?

    public var description_: String?

    public var entry: [CreatePrefixListRequest.Entry]?

    public var maxEntries: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressFamily != nil {
            map["AddressFamily"] = self.addressFamily!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.entry != nil {
            var tmp : [Any] = []
            for k in self.entry! {
                tmp.append(k.toMap())
            }
            map["Entry"] = tmp
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressFamily") {
            self.addressFamily = dict["AddressFamily"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Entry") {
            var tmp : [CreatePrefixListRequest.Entry] = []
            for v in dict["Entry"] as! [Any] {
                var model = CreatePrefixListRequest.Entry()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.entry = tmp
        }
        if dict.keys.contains("MaxEntries") {
            self.maxEntries = dict["MaxEntries"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListName") {
            self.prefixListName = dict["PrefixListName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreatePrefixListResponseBody : Tea.TeaModel {
    public var prefixListId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreatePrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreatePrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreatePrefixListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextHopId") {
                self.nextHopId = dict["NextHopId"] as! String
            }
            if dict.keys.contains("NextHopType") {
                self.nextHopType = dict["NextHopType"] as! String
            }
        }
    }
    public var clientToken: String?

    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopList: [CreateRouteEntryRequest.NextHopList]?

    public var nextHopType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.nextHopType != nil {
            map["NextHopType"] = self.nextHopType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopList") {
            var tmp : [CreateRouteEntryRequest.NextHopList] = []
            for v in dict["NextHopList"] as! [Any] {
                var model = CreateRouteEntryRequest.NextHopList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nextHopList = tmp
        }
        if dict.keys.contains("NextHopType") {
            self.nextHopType = dict["NextHopType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class CreateRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateRouterInterfaceRequest : Tea.TeaModel {
    public var accessPointId: String?

    public var autoPay: Bool?

    public var clientToken: String?

    public var description_: String?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var instanceChargeType: String?

    public var name: String?

    public var oppositeAccessPointId: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: String?

    public var oppositeRegionId: String?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var pricingCycle: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var role: String?

    public var routerId: String?

    public var routerType: String?

    public var spec: String?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointId != nil {
            map["AccessPointId"] = self.accessPointId!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeAccessPointId != nil {
            map["OppositeAccessPointId"] = self.oppositeAccessPointId!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRegionId != nil {
            map["OppositeRegionId"] = self.oppositeRegionId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.pricingCycle != nil {
            map["PricingCycle"] = self.pricingCycle!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.role != nil {
            map["Role"] = self.role!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointId") {
            self.accessPointId = dict["AccessPointId"] as! String
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HealthCheckSourceIp") {
            self.healthCheckSourceIp = dict["HealthCheckSourceIp"] as! String
        }
        if dict.keys.contains("HealthCheckTargetIp") {
            self.healthCheckTargetIp = dict["HealthCheckTargetIp"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OppositeAccessPointId") {
            self.oppositeAccessPointId = dict["OppositeAccessPointId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceId") {
            self.oppositeInterfaceId = dict["OppositeInterfaceId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceOwnerId") {
            self.oppositeInterfaceOwnerId = dict["OppositeInterfaceOwnerId"] as! String
        }
        if dict.keys.contains("OppositeRegionId") {
            self.oppositeRegionId = dict["OppositeRegionId"] as! String
        }
        if dict.keys.contains("OppositeRouterId") {
            self.oppositeRouterId = dict["OppositeRouterId"] as! String
        }
        if dict.keys.contains("OppositeRouterType") {
            self.oppositeRouterType = dict["OppositeRouterType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PricingCycle") {
            self.pricingCycle = dict["PricingCycle"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Role") {
            self.role = dict["Role"] as! String
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
        if dict.keys.contains("RouterType") {
            self.routerType = dict["RouterType"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
    }
}

public class CreateRouterInterfaceResponseBody : Tea.TeaModel {
    public var orderId: Int64?

    public var requestId: String?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class CreateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSavingsPlanRequest : Tea.TeaModel {
    public var chargeType: String?

    public var committedAmount: String?

    public var instanceTypeFamily: String?

    public var offeringType: String?

    public var period: String?

    public var periodUnit: String?

    public var planType: String?

    public var regionId: String?

    public var resourceId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.committedAmount != nil {
            map["CommittedAmount"] = self.committedAmount!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("CommittedAmount") {
            self.committedAmount = dict["CommittedAmount"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PlanType") {
            self.planType = dict["PlanType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
    }
}

public class CreateSavingsPlanResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public var savingsPlanId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.savingsPlanId != nil {
            map["SavingsPlanId"] = self.savingsPlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SavingsPlanId") {
            self.savingsPlanId = dict["SavingsPlanId"] as! String
        }
    }
}

public class CreateSavingsPlanResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSavingsPlanResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSavingsPlanResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSecurityGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupName: String?

    public var securityGroupType: String?

    public var serviceManaged: Bool?

    public var tag: [CreateSecurityGroupRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.securityGroupType != nil {
            map["SecurityGroupType"] = self.securityGroupType!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("SecurityGroupType") {
            self.securityGroupType = dict["SecurityGroupType"] as! String
        }
        if dict.keys.contains("ServiceManaged") {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateSecurityGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateSecurityGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class CreateSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSimulatedSystemEventsRequest : Tea.TeaModel {
    public var eventType: String?

    public var instanceId: [String]?

    public var notBefore: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.notBefore != nil {
            map["NotBefore"] = self.notBefore!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("NotBefore") {
            self.notBefore = dict["NotBefore"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class CreateSimulatedSystemEventsResponseBody : Tea.TeaModel {
    public class EventIdSet : Tea.TeaModel {
        public var eventId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eventId != nil {
                map["EventId"] = self.eventId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EventId") {
                self.eventId = dict["EventId"] as! [String]
            }
        }
    }
    public var eventIdSet: CreateSimulatedSystemEventsResponseBody.EventIdSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventIdSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventIdSet != nil {
            map["EventIdSet"] = self.eventIdSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventIdSet") {
            var model = CreateSimulatedSystemEventsResponseBody.EventIdSet()
            model.fromMap(dict["EventIdSet"] as! [String: Any])
            self.eventIdSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class CreateSimulatedSystemEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSimulatedSystemEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSimulatedSystemEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnapshotRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var category: String?

    public var clientToken: String?

    public var description_: String?

    public var diskId: String?

    public var instantAccess: Bool?

    public var instantAccessRetentionDays: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentionDays: Int32?

    public var snapshotName: String?

    public var storageLocationArn: String?

    public var tag: [CreateSnapshotRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instantAccess != nil {
            map["InstantAccess"] = self.instantAccess!
        }
        if self.instantAccessRetentionDays != nil {
            map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("InstantAccess") {
            self.instantAccess = dict["InstantAccess"] as! Bool
        }
        if dict.keys.contains("InstantAccessRetentionDays") {
            self.instantAccessRetentionDays = dict["InstantAccessRetentionDays"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RetentionDays") {
            self.retentionDays = dict["RetentionDays"] as! Int32
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
        if dict.keys.contains("StorageLocationArn") {
            self.storageLocationArn = dict["StorageLocationArn"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateSnapshotRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateSnapshotRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class CreateSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateSnapshotGroupRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var diskId: [String]?

    public var excludeDiskId: [String]?

    public var instanceId: String?

    public var instantAccess: Bool?

    public var instantAccessRetentionDays: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageLocationArn: String?

    public var tag: [CreateSnapshotGroupRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.excludeDiskId != nil {
            map["ExcludeDiskId"] = self.excludeDiskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instantAccess != nil {
            map["InstantAccess"] = self.instantAccess!
        }
        if self.instantAccessRetentionDays != nil {
            map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! [String]
        }
        if dict.keys.contains("ExcludeDiskId") {
            self.excludeDiskId = dict["ExcludeDiskId"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstantAccess") {
            self.instantAccess = dict["InstantAccess"] as! Bool
        }
        if dict.keys.contains("InstantAccessRetentionDays") {
            self.instantAccessRetentionDays = dict["InstantAccessRetentionDays"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageLocationArn") {
            self.storageLocationArn = dict["StorageLocationArn"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [CreateSnapshotGroupRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = CreateSnapshotGroupRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class CreateSnapshotGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotGroupId") {
            self.snapshotGroupId = dict["SnapshotGroupId"] as! String
        }
    }
}

public class CreateSnapshotGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateSnapshotGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateSnapshotGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateStorageSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var maxPartitionNumber: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetName: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.maxPartitionNumber != nil {
            map["MaxPartitionNumber"] = self.maxPartitionNumber!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MaxPartitionNumber") {
            self.maxPartitionNumber = dict["MaxPartitionNumber"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetName") {
            self.storageSetName = dict["StorageSetName"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateStorageSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var storageSetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
    }
}

public class CreateStorageSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateStorageSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateStorageSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVSwitchRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchName: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class CreateVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class CreateVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVirtualBorderRouterRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var localGatewayIp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peeringSubnetMask: String?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrOwnerId: Int64?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrOwnerId != nil {
            map["VbrOwnerId"] = self.vbrOwnerId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LocalGatewayIp") {
            self.localGatewayIp = dict["LocalGatewayIp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerGatewayIp") {
            self.peerGatewayIp = dict["PeerGatewayIp"] as! String
        }
        if dict.keys.contains("PeeringSubnetMask") {
            self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VbrOwnerId") {
            self.vbrOwnerId = dict["VbrOwnerId"] as! Int64
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! Int32
        }
    }
}

public class CreateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class CreateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class CreateVpcRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VpcName") {
            self.vpcName = dict["VpcName"] as! String
        }
    }
}

public class CreateVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var routeTableId: String?

    public var VRouterId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class CreateVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: CreateVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = CreateVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeactivateRouterInterfaceRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class DeactivateRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeactivateRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeactivateRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeactivateRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteActivationRequest : Tea.TeaModel {
    public var activationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivationId") {
            self.activationId = dict["ActivationId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteActivationResponseBody : Tea.TeaModel {
    public class Activation : Tea.TeaModel {
        public var activationId: String?

        public var creationTime: String?

        public var deregisteredCount: Int32?

        public var description_: String?

        public var instanceCount: Int32?

        public var instanceName: String?

        public var ipAddressRange: String?

        public var registeredCount: Int32?

        public var timeToLiveInHours: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deregisteredCount != nil {
                map["DeregisteredCount"] = self.deregisteredCount!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.ipAddressRange != nil {
                map["IpAddressRange"] = self.ipAddressRange!
            }
            if self.registeredCount != nil {
                map["RegisteredCount"] = self.registeredCount!
            }
            if self.timeToLiveInHours != nil {
                map["TimeToLiveInHours"] = self.timeToLiveInHours!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivationId") {
                self.activationId = dict["ActivationId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DeregisteredCount") {
                self.deregisteredCount = dict["DeregisteredCount"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IpAddressRange") {
                self.ipAddressRange = dict["IpAddressRange"] as! String
            }
            if dict.keys.contains("RegisteredCount") {
                self.registeredCount = dict["RegisteredCount"] as! Int32
            }
            if dict.keys.contains("TimeToLiveInHours") {
                self.timeToLiveInHours = dict["TimeToLiveInHours"] as! Int64
            }
        }
    }
    public var activation: DeleteActivationResponseBody.Activation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.activation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activation != nil {
            map["Activation"] = self.activation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Activation") {
            var model = DeleteActivationResponseBody.Activation()
            model.fromMap(dict["Activation"] as! [String: Any])
            self.activation = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteActivationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteActivationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteActivationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAutoProvisioningGroupRequest : Tea.TeaModel {
    public var autoProvisioningGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var terminateInstances: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.terminateInstances != nil {
            map["TerminateInstances"] = self.terminateInstances!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupId") {
            self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TerminateInstances") {
            self.terminateInstances = dict["TerminateInstances"] as! Bool
        }
    }
}

public class DeleteAutoProvisioningGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAutoProvisioningGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAutoProvisioningGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAutoProvisioningGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var autoSnapshotPolicyId: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.autoSnapshotPolicyId != nil {
            map["autoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("autoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["autoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
    }
}

public class DeleteAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteBandwidthPackageRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteBandwidthPackageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteBandwidthPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteBandwidthPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteBandwidthPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteCommandRequest : Tea.TeaModel {
    public var commandId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDedicatedHostClusterRequest : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDedicatedHostClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDedicatedHostClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDedicatedHostClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDedicatedHostClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDemandRequest : Tea.TeaModel {
    public var clientToken: String?

    public var demandId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var reason: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDemandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDemandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDemandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDemandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDeploymentSetRequest : Tea.TeaModel {
    public var deploymentSetId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDeploymentSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDeploymentSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDeploymentSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDeploymentSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDiagnosticMetricSetsRequest : Tea.TeaModel {
    public var metricSetIds: [String]?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricSetIds != nil {
            map["MetricSetIds"] = self.metricSetIds!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricSetIds") {
            self.metricSetIds = dict["MetricSetIds"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class DeleteDiagnosticMetricSetsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDiagnosticMetricSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiagnosticMetricSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDiagnosticMetricSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDiagnosticReportsRequest : Tea.TeaModel {
    public var regionId: String?

    public var reportIds: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportIds != nil {
            map["ReportIds"] = self.reportIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReportIds") {
            self.reportIds = dict["ReportIds"] as! [String]
        }
    }
}

public class DeleteDiagnosticReportsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDiagnosticReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiagnosticReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDiagnosticReportsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteForwardEntryRequest : Tea.TeaModel {
    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var haVipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteHpcClusterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var hpcClusterId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteHpcClusterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteHpcClusterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteHpcClusterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteHpcClusterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageRequest : Tea.TeaModel {
    public var force: Bool?

    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteImageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImageComponentRequest : Tea.TeaModel {
    public var imageComponentId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageComponentId != nil {
            map["ImageComponentId"] = self.imageComponentId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageComponentId") {
            self.imageComponentId = dict["ImageComponentId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteImageComponentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImageComponentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImageComponentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteImageComponentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteImagePipelineRequest : Tea.TeaModel {
    public var imagePipelineId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImagePipelineId") {
            self.imagePipelineId = dict["ImagePipelineId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteImagePipelineResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteImagePipelineResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteImagePipelineResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteImagePipelineResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstanceRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var force: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var terminateSubscription: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.terminateSubscription != nil {
            map["TerminateSubscription"] = self.terminateSubscription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TerminateSubscription") {
            self.terminateSubscription = dict["TerminateSubscription"] as! Bool
        }
    }
}

public class DeleteInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteInstancesRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dryRun: Bool?

    public var force: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var terminateSubscription: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.terminateSubscription != nil {
            map["TerminateSubscription"] = self.terminateSubscription!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TerminateSubscription") {
            self.terminateSubscription = dict["TerminateSubscription"] as! Bool
        }
    }
}

public class DeleteInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteKeyPairsRequest : Tea.TeaModel {
    public var keyPairNames: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairNames != nil {
            map["KeyPairNames"] = self.keyPairNames!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairNames") {
            self.keyPairNames = dict["KeyPairNames"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteKeyPairsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteKeyPairsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLaunchTemplateRequest : Tea.TeaModel {
    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteLaunchTemplateResponseBody : Tea.TeaModel {
    public class LaunchTemplateVersionNumbers : Tea.TeaModel {
        public var versionNumbers: [Int64]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.versionNumbers != nil {
                map["versionNumbers"] = self.versionNumbers!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("versionNumbers") {
                self.versionNumbers = dict["versionNumbers"] as! [Int64]
            }
        }
    }
    public var launchTemplateId: String?

    public var launchTemplateVersionNumbers: DeleteLaunchTemplateResponseBody.LaunchTemplateVersionNumbers?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateVersionNumbers?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateVersionNumbers != nil {
            map["LaunchTemplateVersionNumbers"] = self.launchTemplateVersionNumbers?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersionNumbers") {
            var model = DeleteLaunchTemplateResponseBody.LaunchTemplateVersionNumbers()
            model.fromMap(dict["LaunchTemplateVersionNumbers"] as! [String: Any])
            self.launchTemplateVersionNumbers = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLaunchTemplateResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLaunchTemplateResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLaunchTemplateResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteLaunchTemplateVersionRequest : Tea.TeaModel {
    public var deleteVersion: [Int64]?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteVersion != nil {
            map["DeleteVersion"] = self.deleteVersion!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteVersion") {
            self.deleteVersion = dict["DeleteVersion"] as! [Int64]
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteLaunchTemplateVersionResponseBody : Tea.TeaModel {
    public class LaunchTemplateVersions : Tea.TeaModel {
        public class LaunchTemplateVersion : Tea.TeaModel {
            public var launchTemplateId: String?

            public var launchTemplateVersionNumber: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateVersionNumber != nil {
                    map["LaunchTemplateVersionNumber"] = self.launchTemplateVersionNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LaunchTemplateId") {
                    self.launchTemplateId = dict["LaunchTemplateId"] as! String
                }
                if dict.keys.contains("LaunchTemplateVersionNumber") {
                    self.launchTemplateVersionNumber = dict["LaunchTemplateVersionNumber"] as! Int64
                }
            }
        }
        public var launchTemplateVersion: [DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions.LaunchTemplateVersion]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchTemplateVersion != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateVersion! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateVersion"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LaunchTemplateVersion") {
                var tmp : [DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions.LaunchTemplateVersion] = []
                for v in dict["LaunchTemplateVersion"] as! [Any] {
                    var model = DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions.LaunchTemplateVersion()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchTemplateVersion = tmp
            }
        }
    }
    public var launchTemplateVersions: DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateVersions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateVersions != nil {
            map["LaunchTemplateVersions"] = self.launchTemplateVersions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateVersions") {
            var model = DeleteLaunchTemplateVersionResponseBody.LaunchTemplateVersions()
            model.fromMap(dict["LaunchTemplateVersions"] as! [String: Any])
            self.launchTemplateVersions = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteLaunchTemplateVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteLaunchTemplateVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteLaunchTemplateVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNatGatewayRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNatGatewayResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNatGatewayResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNatGatewayResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNatGatewayResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkInterfaceRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteNetworkInterfacePermissionRequest : Tea.TeaModel {
    public var force: Bool?

    public var networkInterfacePermissionId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.networkInterfacePermissionId != nil {
            map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("NetworkInterfacePermissionId") {
            self.networkInterfacePermissionId = dict["NetworkInterfacePermissionId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeleteNetworkInterfacePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteNetworkInterfacePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteNetworkInterfacePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteNetworkInterfacePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeletePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeletePrefixListRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeletePrefixListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeletePrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeletePrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeletePrefixListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouteEntryRequest : Tea.TeaModel {
    public class NextHopList : Tea.TeaModel {
        public var nextHopId: String?

        public var nextHopType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nextHopId != nil {
                map["NextHopId"] = self.nextHopId!
            }
            if self.nextHopType != nil {
                map["NextHopType"] = self.nextHopType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NextHopId") {
                self.nextHopId = dict["NextHopId"] as! String
            }
            if dict.keys.contains("NextHopType") {
                self.nextHopType = dict["NextHopType"] as! String
            }
        }
    }
    public var destinationCidrBlock: String?

    public var nextHopId: String?

    public var nextHopList: [DeleteRouteEntryRequest.NextHopList]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.destinationCidrBlock != nil {
            map["DestinationCidrBlock"] = self.destinationCidrBlock!
        }
        if self.nextHopId != nil {
            map["NextHopId"] = self.nextHopId!
        }
        if self.nextHopList != nil {
            var tmp : [Any] = []
            for k in self.nextHopList! {
                tmp.append(k.toMap())
            }
            map["NextHopList"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DestinationCidrBlock") {
            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
        }
        if dict.keys.contains("NextHopId") {
            self.nextHopId = dict["NextHopId"] as! String
        }
        if dict.keys.contains("NextHopList") {
            var tmp : [DeleteRouteEntryRequest.NextHopList] = []
            for v in dict["NextHopList"] as! [Any] {
                var model = DeleteRouteEntryRequest.NextHopList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.nextHopList = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
    }
}

public class DeleteRouteEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRouteEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouteEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRouteEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteRouterInterfaceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
    }
}

public class DeleteRouterInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteRouterInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteRouterInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteRouterInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSecurityGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class DeleteSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnapshotRequest : Tea.TeaModel {
    public var force: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class DeleteSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteSnapshotGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotGroupId") {
            self.snapshotGroupId = dict["SnapshotGroupId"] as! String
        }
    }
}

public class DeleteSnapshotGroupResponseBody : Tea.TeaModel {
    public class OperationProgressSet : Tea.TeaModel {
        public class OperationProgress : Tea.TeaModel {
            public class RelatedItemSet : Tea.TeaModel {
                public class RelatedItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var relatedItem: [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relatedItem != nil {
                        var tmp : [Any] = []
                        for k in self.relatedItem! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RelatedItem") {
                        var tmp : [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem] = []
                        for v in dict["RelatedItem"] as! [Any] {
                            var model = DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.relatedItem = tmp
                    }
                }
            }
            public var errorCode: String?

            public var errorMsg: String?

            public var operationStatus: String?

            public var relatedItemSet: DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.relatedItemSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.operationStatus != nil {
                    map["OperationStatus"] = self.operationStatus!
                }
                if self.relatedItemSet != nil {
                    map["RelatedItemSet"] = self.relatedItemSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("OperationStatus") {
                    self.operationStatus = dict["OperationStatus"] as! String
                }
                if dict.keys.contains("RelatedItemSet") {
                    var model = DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet()
                    model.fromMap(dict["RelatedItemSet"] as! [String: Any])
                    self.relatedItemSet = model
                }
            }
        }
        public var operationProgress: [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationProgress != nil {
                var tmp : [Any] = []
                for k in self.operationProgress! {
                    tmp.append(k.toMap())
                }
                map["OperationProgress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OperationProgress") {
                var tmp : [DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress] = []
                for v in dict["OperationProgress"] as! [Any] {
                    var model = DeleteSnapshotGroupResponseBody.OperationProgressSet.OperationProgress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operationProgress = tmp
            }
        }
    }
    public var operationProgressSet: DeleteSnapshotGroupResponseBody.OperationProgressSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operationProgressSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationProgressSet != nil {
            map["OperationProgressSet"] = self.operationProgressSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationProgressSet") {
            var model = DeleteSnapshotGroupResponseBody.OperationProgressSet()
            model.fromMap(dict["OperationProgressSet"] as! [String: Any])
            self.operationProgressSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteSnapshotGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteSnapshotGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteSnapshotGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteStorageSetRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
    }
}

public class DeleteStorageSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteStorageSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteStorageSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteStorageSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVSwitchRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
    }
}

public class DeleteVSwitchResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVSwitchResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVSwitchResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVSwitchResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class DeleteVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeleteVpcRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DeleteVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeleteVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeleteVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeleteVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DeregisterManagedInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DeregisterManagedInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var activationId: String?

        public var agentVersion: String?

        public var hostname: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var invocationCount: Int64?

        public var lastInvokedTime: String?

        public var machineId: String?

        public var osType: String?

        public var osVersion: String?

        public var registrationTime: String?

        public var resourceGroupId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.agentVersion != nil {
                map["AgentVersion"] = self.agentVersion!
            }
            if self.hostname != nil {
                map["Hostname"] = self.hostname!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.invocationCount != nil {
                map["InvocationCount"] = self.invocationCount!
            }
            if self.lastInvokedTime != nil {
                map["LastInvokedTime"] = self.lastInvokedTime!
            }
            if self.machineId != nil {
                map["MachineId"] = self.machineId!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.osVersion != nil {
                map["OsVersion"] = self.osVersion!
            }
            if self.registrationTime != nil {
                map["RegistrationTime"] = self.registrationTime!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivationId") {
                self.activationId = dict["ActivationId"] as! String
            }
            if dict.keys.contains("AgentVersion") {
                self.agentVersion = dict["AgentVersion"] as! String
            }
            if dict.keys.contains("Hostname") {
                self.hostname = dict["Hostname"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("InvocationCount") {
                self.invocationCount = dict["InvocationCount"] as! Int64
            }
            if dict.keys.contains("LastInvokedTime") {
                self.lastInvokedTime = dict["LastInvokedTime"] as! String
            }
            if dict.keys.contains("MachineId") {
                self.machineId = dict["MachineId"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("OsVersion") {
                self.osVersion = dict["OsVersion"] as! String
            }
            if dict.keys.contains("RegistrationTime") {
                self.registrationTime = dict["RegistrationTime"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
        }
    }
    public var instance: DeregisterManagedInstanceResponseBody.Instance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instance") {
            var model = DeregisterManagedInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DeregisterManagedInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DeregisterManagedInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DeregisterManagedInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccessPointsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var filter: [DescribeAccessPointsRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeAccessPointsRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeAccessPointsRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeAccessPointsResponseBody : Tea.TeaModel {
    public class AccessPointSet : Tea.TeaModel {
        public class AccessPointType : Tea.TeaModel {
            public var accessPointId: String?

            public var attachedRegionNo: String?

            public var description_: String?

            public var hostOperator: String?

            public var location: String?

            public var name: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.attachedRegionNo != nil {
                    map["AttachedRegionNo"] = self.attachedRegionNo!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hostOperator != nil {
                    map["HostOperator"] = self.hostOperator!
                }
                if self.location != nil {
                    map["Location"] = self.location!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("AttachedRegionNo") {
                    self.attachedRegionNo = dict["AttachedRegionNo"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HostOperator") {
                    self.hostOperator = dict["HostOperator"] as! String
                }
                if dict.keys.contains("Location") {
                    self.location = dict["Location"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var accessPointType: [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accessPointType != nil {
                var tmp : [Any] = []
                for k in self.accessPointType! {
                    tmp.append(k.toMap())
                }
                map["AccessPointType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccessPointType") {
                var tmp : [DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType] = []
                for v in dict["AccessPointType"] as! [Any] {
                    var model = DescribeAccessPointsResponseBody.AccessPointSet.AccessPointType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.accessPointType = tmp
            }
        }
    }
    public var accessPointSet: DescribeAccessPointsResponseBody.AccessPointSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accessPointSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accessPointSet != nil {
            map["AccessPointSet"] = self.accessPointSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccessPointSet") {
            var model = DescribeAccessPointsResponseBody.AccessPointSet()
            model.fromMap(dict["AccessPointSet"] as! [String: Any])
            self.accessPointSet = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAccessPointsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccessPointsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccessPointsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAccountAttributesRequest : Tea.TeaModel {
    public var attributeName: [String]?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributeName != nil {
            map["AttributeName"] = self.attributeName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AttributeName") {
            self.attributeName = dict["AttributeName"] as! [String]
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeAccountAttributesResponseBody : Tea.TeaModel {
    public class AccountAttributeItems : Tea.TeaModel {
        public class AccountAttributeItem : Tea.TeaModel {
            public class AttributeValues : Tea.TeaModel {
                public class ValueItem : Tea.TeaModel {
                    public var count: Int32?

                    public var diskCategory: String?

                    public var expiredTime: String?

                    public var instanceChargeType: String?

                    public var instanceType: String?

                    public var value: String?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.count != nil {
                            map["Count"] = self.count!
                        }
                        if self.diskCategory != nil {
                            map["DiskCategory"] = self.diskCategory!
                        }
                        if self.expiredTime != nil {
                            map["ExpiredTime"] = self.expiredTime!
                        }
                        if self.instanceChargeType != nil {
                            map["InstanceChargeType"] = self.instanceChargeType!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Count") {
                            self.count = dict["Count"] as! Int32
                        }
                        if dict.keys.contains("DiskCategory") {
                            self.diskCategory = dict["DiskCategory"] as! String
                        }
                        if dict.keys.contains("ExpiredTime") {
                            self.expiredTime = dict["ExpiredTime"] as! String
                        }
                        if dict.keys.contains("InstanceChargeType") {
                            self.instanceChargeType = dict["InstanceChargeType"] as! String
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                        if dict.keys.contains("ZoneId") {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var valueItem: [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.valueItem != nil {
                        var tmp : [Any] = []
                        for k in self.valueItem! {
                            tmp.append(k.toMap())
                        }
                        map["ValueItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ValueItem") {
                        var tmp : [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem] = []
                        for v in dict["ValueItem"] as! [Any] {
                            var model = DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues.ValueItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.valueItem = tmp
                    }
                }
            }
            public var attributeName: String?

            public var attributeValues: DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attributeValues?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attributeName != nil {
                    map["AttributeName"] = self.attributeName!
                }
                if self.attributeValues != nil {
                    map["AttributeValues"] = self.attributeValues?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AttributeName") {
                    self.attributeName = dict["AttributeName"] as! String
                }
                if dict.keys.contains("AttributeValues") {
                    var model = DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem.AttributeValues()
                    model.fromMap(dict["AttributeValues"] as! [String: Any])
                    self.attributeValues = model
                }
            }
        }
        public var accountAttributeItem: [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.accountAttributeItem != nil {
                var tmp : [Any] = []
                for k in self.accountAttributeItem! {
                    tmp.append(k.toMap())
                }
                map["AccountAttributeItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AccountAttributeItem") {
                var tmp : [DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem] = []
                for v in dict["AccountAttributeItem"] as! [Any] {
                    var model = DescribeAccountAttributesResponseBody.AccountAttributeItems.AccountAttributeItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.accountAttributeItem = tmp
            }
        }
    }
    public var accountAttributeItems: DescribeAccountAttributesResponseBody.AccountAttributeItems?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accountAttributeItems?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accountAttributeItems != nil {
            map["AccountAttributeItems"] = self.accountAttributeItems?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AccountAttributeItems") {
            var model = DescribeAccountAttributesResponseBody.AccountAttributeItems()
            model.fromMap(dict["AccountAttributeItems"] as! [String: Any])
            self.accountAttributeItems = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAccountAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAccountAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAccountAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeActivationsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var activationId: String?

    public var instanceName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeActivationsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivationId") {
            self.activationId = dict["ActivationId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeActivationsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeActivationsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeActivationsResponseBody : Tea.TeaModel {
    public class ActivationList : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var activationId: String?

        public var creationTime: String?

        public var deregisteredCount: Int32?

        public var description_: String?

        public var disabled: Bool?

        public var instanceCount: Int32?

        public var instanceName: String?

        public var ipAddressRange: String?

        public var registeredCount: Int32?

        public var resourceGroupId: String?

        public var tags: [DescribeActivationsResponseBody.ActivationList.Tags]?

        public var timeToLiveInHours: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deregisteredCount != nil {
                map["DeregisteredCount"] = self.deregisteredCount!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.ipAddressRange != nil {
                map["IpAddressRange"] = self.ipAddressRange!
            }
            if self.registeredCount != nil {
                map["RegisteredCount"] = self.registeredCount!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            if self.timeToLiveInHours != nil {
                map["TimeToLiveInHours"] = self.timeToLiveInHours!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivationId") {
                self.activationId = dict["ActivationId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DeregisteredCount") {
                self.deregisteredCount = dict["DeregisteredCount"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Disabled") {
                self.disabled = dict["Disabled"] as! Bool
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IpAddressRange") {
                self.ipAddressRange = dict["IpAddressRange"] as! String
            }
            if dict.keys.contains("RegisteredCount") {
                self.registeredCount = dict["RegisteredCount"] as! Int32
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeActivationsResponseBody.ActivationList.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeActivationsResponseBody.ActivationList.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
            if dict.keys.contains("TimeToLiveInHours") {
                self.timeToLiveInHours = dict["TimeToLiveInHours"] as! Int64
            }
        }
    }
    public var activationList: [DescribeActivationsResponseBody.ActivationList]?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationList != nil {
            var tmp : [Any] = []
            for k in self.activationList! {
                tmp.append(k.toMap())
            }
            map["ActivationList"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivationList") {
            var tmp : [DescribeActivationsResponseBody.ActivationList] = []
            for v in dict["ActivationList"] as! [Any] {
                var model = DescribeActivationsResponseBody.ActivationList()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.activationList = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeActivationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeActivationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeActivationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoProvisioningGroupHistoryRequest : Tea.TeaModel {
    public var autoProvisioningGroupId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupId") {
            self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeAutoProvisioningGroupHistoryResponseBody : Tea.TeaModel {
    public class AutoProvisioningGroupHistories : Tea.TeaModel {
        public class AutoProvisioningGroupHistory : Tea.TeaModel {
            public class ActivityDetails : Tea.TeaModel {
                public class ActivityDetail : Tea.TeaModel {
                    public var detail: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.detail != nil {
                            map["Detail"] = self.detail!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Detail") {
                            self.detail = dict["Detail"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var activityDetail: [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails.ActivityDetail]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.activityDetail != nil {
                        var tmp : [Any] = []
                        for k in self.activityDetail! {
                            tmp.append(k.toMap())
                        }
                        map["ActivityDetail"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ActivityDetail") {
                        var tmp : [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails.ActivityDetail] = []
                        for v in dict["ActivityDetail"] as! [Any] {
                            var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails.ActivityDetail()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.activityDetail = tmp
                    }
                }
            }
            public var activityDetails: DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails?

            public var lastEventTime: String?

            public var startTime: String?

            public var status: String?

            public var taskId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.activityDetails?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activityDetails != nil {
                    map["ActivityDetails"] = self.activityDetails?.toMap()
                }
                if self.lastEventTime != nil {
                    map["LastEventTime"] = self.lastEventTime!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivityDetails") {
                    var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory.ActivityDetails()
                    model.fromMap(dict["ActivityDetails"] as! [String: Any])
                    self.activityDetails = model
                }
                if dict.keys.contains("LastEventTime") {
                    self.lastEventTime = dict["LastEventTime"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
            }
        }
        public var autoProvisioningGroupHistory: [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoProvisioningGroupHistory != nil {
                var tmp : [Any] = []
                for k in self.autoProvisioningGroupHistory! {
                    tmp.append(k.toMap())
                }
                map["AutoProvisioningGroupHistory"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoProvisioningGroupHistory") {
                var tmp : [DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory] = []
                for v in dict["AutoProvisioningGroupHistory"] as! [Any] {
                    var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories.AutoProvisioningGroupHistory()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.autoProvisioningGroupHistory = tmp
            }
        }
    }
    public var autoProvisioningGroupHistories: DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.autoProvisioningGroupHistories?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupHistories != nil {
            map["AutoProvisioningGroupHistories"] = self.autoProvisioningGroupHistories?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupHistories") {
            var model = DescribeAutoProvisioningGroupHistoryResponseBody.AutoProvisioningGroupHistories()
            model.fromMap(dict["AutoProvisioningGroupHistories"] as! [String: Any])
            self.autoProvisioningGroupHistories = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAutoProvisioningGroupHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoProvisioningGroupHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoProvisioningGroupHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoProvisioningGroupInstancesRequest : Tea.TeaModel {
    public var autoProvisioningGroupId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupId") {
            self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeAutoProvisioningGroupInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var CPU: Int32?

            public var creationTime: String?

            public var instanceId: String?

            public var instanceType: String?

            public var ioOptimized: Bool?

            public var isSpot: Bool?

            public var memory: Int32?

            public var networkType: String?

            public var osType: String?

            public var regionId: String?

            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.CPU != nil {
                    map["CPU"] = self.CPU!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ioOptimized != nil {
                    map["IoOptimized"] = self.ioOptimized!
                }
                if self.isSpot != nil {
                    map["IsSpot"] = self.isSpot!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.osType != nil {
                    map["OsType"] = self.osType!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CPU") {
                    self.CPU = dict["CPU"] as! Int32
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("IoOptimized") {
                    self.ioOptimized = dict["IoOptimized"] as! Bool
                }
                if dict.keys.contains("IsSpot") {
                    self.isSpot = dict["IsSpot"] as! Bool
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("OsType") {
                    self.osType = dict["OsType"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var instance: [DescribeAutoProvisioningGroupInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [DescribeAutoProvisioningGroupInstancesResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = DescribeAutoProvisioningGroupInstancesResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeAutoProvisioningGroupInstancesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = DescribeAutoProvisioningGroupInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAutoProvisioningGroupInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoProvisioningGroupInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoProvisioningGroupInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoProvisioningGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoProvisioningGroupId: [String]?

    public var autoProvisioningGroupName: String?

    public var autoProvisioningGroupStatus: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeAutoProvisioningGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.autoProvisioningGroupStatus != nil {
            map["AutoProvisioningGroupStatus"] = self.autoProvisioningGroupStatus!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupId") {
            self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! [String]
        }
        if dict.keys.contains("AutoProvisioningGroupName") {
            self.autoProvisioningGroupName = dict["AutoProvisioningGroupName"] as! String
        }
        if dict.keys.contains("AutoProvisioningGroupStatus") {
            self.autoProvisioningGroupStatus = dict["AutoProvisioningGroupStatus"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeAutoProvisioningGroupsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeAutoProvisioningGroupsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeAutoProvisioningGroupsResponseBody : Tea.TeaModel {
    public class AutoProvisioningGroups : Tea.TeaModel {
        public class AutoProvisioningGroup : Tea.TeaModel {
            public class LaunchTemplateConfigs : Tea.TeaModel {
                public class LaunchTemplateConfig : Tea.TeaModel {
                    public var instanceType: String?

                    public var maxPrice: Double?

                    public var priority: Double?

                    public var vSwitchId: String?

                    public var weightedCapacity: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.maxPrice != nil {
                            map["MaxPrice"] = self.maxPrice!
                        }
                        if self.priority != nil {
                            map["Priority"] = self.priority!
                        }
                        if self.vSwitchId != nil {
                            map["VSwitchId"] = self.vSwitchId!
                        }
                        if self.weightedCapacity != nil {
                            map["WeightedCapacity"] = self.weightedCapacity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("MaxPrice") {
                            self.maxPrice = dict["MaxPrice"] as! Double
                        }
                        if dict.keys.contains("Priority") {
                            self.priority = dict["Priority"] as! Double
                        }
                        if dict.keys.contains("VSwitchId") {
                            self.vSwitchId = dict["VSwitchId"] as! String
                        }
                        if dict.keys.contains("WeightedCapacity") {
                            self.weightedCapacity = dict["WeightedCapacity"] as! Double
                        }
                    }
                }
                public var launchTemplateConfig: [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs.LaunchTemplateConfig]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.launchTemplateConfig != nil {
                        var tmp : [Any] = []
                        for k in self.launchTemplateConfig! {
                            tmp.append(k.toMap())
                        }
                        map["LaunchTemplateConfig"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LaunchTemplateConfig") {
                        var tmp : [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs.LaunchTemplateConfig] = []
                        for v in dict["LaunchTemplateConfig"] as! [Any] {
                            var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs.LaunchTemplateConfig()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.launchTemplateConfig = tmp
                    }
                }
            }
            public class PayAsYouGoOptions : Tea.TeaModel {
                public var allocationStrategy: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationStrategy != nil {
                        map["AllocationStrategy"] = self.allocationStrategy!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocationStrategy") {
                        self.allocationStrategy = dict["AllocationStrategy"] as! String
                    }
                }
            }
            public class SpotOptions : Tea.TeaModel {
                public var allocationStrategy: String?

                public var instanceInterruptionBehavior: String?

                public var instancePoolsToUseCount: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationStrategy != nil {
                        map["AllocationStrategy"] = self.allocationStrategy!
                    }
                    if self.instanceInterruptionBehavior != nil {
                        map["InstanceInterruptionBehavior"] = self.instanceInterruptionBehavior!
                    }
                    if self.instancePoolsToUseCount != nil {
                        map["InstancePoolsToUseCount"] = self.instancePoolsToUseCount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocationStrategy") {
                        self.allocationStrategy = dict["AllocationStrategy"] as! String
                    }
                    if dict.keys.contains("InstanceInterruptionBehavior") {
                        self.instanceInterruptionBehavior = dict["InstanceInterruptionBehavior"] as! String
                    }
                    if dict.keys.contains("InstancePoolsToUseCount") {
                        self.instancePoolsToUseCount = dict["InstancePoolsToUseCount"] as! Int32
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class TargetCapacitySpecification : Tea.TeaModel {
                public var defaultTargetCapacityType: String?

                public var payAsYouGoTargetCapacity: Double?

                public var spotTargetCapacity: Double?

                public var totalTargetCapacity: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultTargetCapacityType != nil {
                        map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
                    }
                    if self.payAsYouGoTargetCapacity != nil {
                        map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
                    }
                    if self.spotTargetCapacity != nil {
                        map["SpotTargetCapacity"] = self.spotTargetCapacity!
                    }
                    if self.totalTargetCapacity != nil {
                        map["TotalTargetCapacity"] = self.totalTargetCapacity!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultTargetCapacityType") {
                        self.defaultTargetCapacityType = dict["DefaultTargetCapacityType"] as! String
                    }
                    if dict.keys.contains("PayAsYouGoTargetCapacity") {
                        self.payAsYouGoTargetCapacity = dict["PayAsYouGoTargetCapacity"] as! Double
                    }
                    if dict.keys.contains("SpotTargetCapacity") {
                        self.spotTargetCapacity = dict["SpotTargetCapacity"] as! Double
                    }
                    if dict.keys.contains("TotalTargetCapacity") {
                        self.totalTargetCapacity = dict["TotalTargetCapacity"] as! Double
                    }
                }
            }
            public var autoProvisioningGroupId: String?

            public var autoProvisioningGroupName: String?

            public var autoProvisioningGroupType: String?

            public var creationTime: String?

            public var excessCapacityTerminationPolicy: String?

            public var launchTemplateConfigs: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs?

            public var launchTemplateId: String?

            public var launchTemplateVersion: String?

            public var maxSpotPrice: Double?

            public var payAsYouGoOptions: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.PayAsYouGoOptions?

            public var regionId: String?

            public var resourceGroupId: String?

            public var spotOptions: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.SpotOptions?

            public var state: String?

            public var status: String?

            public var tags: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags?

            public var targetCapacitySpecification: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.TargetCapacitySpecification?

            public var terminateInstances: Bool?

            public var terminateInstancesWithExpiration: Bool?

            public var validFrom: String?

            public var validUntil: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.launchTemplateConfigs?.validate()
                try self.payAsYouGoOptions?.validate()
                try self.spotOptions?.validate()
                try self.tags?.validate()
                try self.targetCapacitySpecification?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoProvisioningGroupId != nil {
                    map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
                }
                if self.autoProvisioningGroupName != nil {
                    map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
                }
                if self.autoProvisioningGroupType != nil {
                    map["AutoProvisioningGroupType"] = self.autoProvisioningGroupType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.excessCapacityTerminationPolicy != nil {
                    map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
                }
                if self.launchTemplateConfigs != nil {
                    map["LaunchTemplateConfigs"] = self.launchTemplateConfigs?.toMap()
                }
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateVersion != nil {
                    map["LaunchTemplateVersion"] = self.launchTemplateVersion!
                }
                if self.maxSpotPrice != nil {
                    map["MaxSpotPrice"] = self.maxSpotPrice!
                }
                if self.payAsYouGoOptions != nil {
                    map["PayAsYouGoOptions"] = self.payAsYouGoOptions?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.spotOptions != nil {
                    map["SpotOptions"] = self.spotOptions?.toMap()
                }
                if self.state != nil {
                    map["State"] = self.state!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.targetCapacitySpecification != nil {
                    map["TargetCapacitySpecification"] = self.targetCapacitySpecification?.toMap()
                }
                if self.terminateInstances != nil {
                    map["TerminateInstances"] = self.terminateInstances!
                }
                if self.terminateInstancesWithExpiration != nil {
                    map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
                }
                if self.validFrom != nil {
                    map["ValidFrom"] = self.validFrom!
                }
                if self.validUntil != nil {
                    map["ValidUntil"] = self.validUntil!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoProvisioningGroupId") {
                    self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! String
                }
                if dict.keys.contains("AutoProvisioningGroupName") {
                    self.autoProvisioningGroupName = dict["AutoProvisioningGroupName"] as! String
                }
                if dict.keys.contains("AutoProvisioningGroupType") {
                    self.autoProvisioningGroupType = dict["AutoProvisioningGroupType"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ExcessCapacityTerminationPolicy") {
                    self.excessCapacityTerminationPolicy = dict["ExcessCapacityTerminationPolicy"] as! String
                }
                if dict.keys.contains("LaunchTemplateConfigs") {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.LaunchTemplateConfigs()
                    model.fromMap(dict["LaunchTemplateConfigs"] as! [String: Any])
                    self.launchTemplateConfigs = model
                }
                if dict.keys.contains("LaunchTemplateId") {
                    self.launchTemplateId = dict["LaunchTemplateId"] as! String
                }
                if dict.keys.contains("LaunchTemplateVersion") {
                    self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! String
                }
                if dict.keys.contains("MaxSpotPrice") {
                    self.maxSpotPrice = dict["MaxSpotPrice"] as! Double
                }
                if dict.keys.contains("PayAsYouGoOptions") {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.PayAsYouGoOptions()
                    model.fromMap(dict["PayAsYouGoOptions"] as! [String: Any])
                    self.payAsYouGoOptions = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SpotOptions") {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.SpotOptions()
                    model.fromMap(dict["SpotOptions"] as! [String: Any])
                    self.spotOptions = model
                }
                if dict.keys.contains("State") {
                    self.state = dict["State"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TargetCapacitySpecification") {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup.TargetCapacitySpecification()
                    model.fromMap(dict["TargetCapacitySpecification"] as! [String: Any])
                    self.targetCapacitySpecification = model
                }
                if dict.keys.contains("TerminateInstances") {
                    self.terminateInstances = dict["TerminateInstances"] as! Bool
                }
                if dict.keys.contains("TerminateInstancesWithExpiration") {
                    self.terminateInstancesWithExpiration = dict["TerminateInstancesWithExpiration"] as! Bool
                }
                if dict.keys.contains("ValidFrom") {
                    self.validFrom = dict["ValidFrom"] as! String
                }
                if dict.keys.contains("ValidUntil") {
                    self.validUntil = dict["ValidUntil"] as! String
                }
            }
        }
        public var autoProvisioningGroup: [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoProvisioningGroup != nil {
                var tmp : [Any] = []
                for k in self.autoProvisioningGroup! {
                    tmp.append(k.toMap())
                }
                map["AutoProvisioningGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoProvisioningGroup") {
                var tmp : [DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup] = []
                for v in dict["AutoProvisioningGroup"] as! [Any] {
                    var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups.AutoProvisioningGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.autoProvisioningGroup = tmp
            }
        }
    }
    public var autoProvisioningGroups: DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.autoProvisioningGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroups != nil {
            map["AutoProvisioningGroups"] = self.autoProvisioningGroups?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroups") {
            var model = DescribeAutoProvisioningGroupsResponseBody.AutoProvisioningGroups()
            model.fromMap(dict["AutoProvisioningGroups"] as! [String: Any])
            self.autoProvisioningGroups = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAutoProvisioningGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoProvisioningGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoProvisioningGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAutoSnapshotPolicyExRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoSnapshotPolicyId: String?

    public var autoSnapshotPolicyName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeAutoSnapshotPolicyExRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.autoSnapshotPolicyName != nil {
            map["AutoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("AutoSnapshotPolicyName") {
            self.autoSnapshotPolicyName = dict["AutoSnapshotPolicyName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeAutoSnapshotPolicyExRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeAutoSnapshotPolicyExRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeAutoSnapshotPolicyExResponseBody : Tea.TeaModel {
    public class AutoSnapshotPolicies : Tea.TeaModel {
        public class AutoSnapshotPolicy : Tea.TeaModel {
            public class CopyEncryptionConfiguration : Tea.TeaModel {
                public var encrypted: Bool?

                public var KMSKeyId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.encrypted != nil {
                        map["Encrypted"] = self.encrypted!
                    }
                    if self.KMSKeyId != nil {
                        map["KMSKeyId"] = self.KMSKeyId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Encrypted") {
                        self.encrypted = dict["Encrypted"] as! Bool
                    }
                    if dict.keys.contains("KMSKeyId") {
                        self.KMSKeyId = dict["KMSKeyId"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var autoSnapshotPolicyId: String?

            public var autoSnapshotPolicyName: String?

            public var copiedSnapshotsRetentionDays: Int32?

            public var copyEncryptionConfiguration: DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.CopyEncryptionConfiguration?

            public var creationTime: String?

            public var diskNums: Int32?

            public var enableCrossRegionCopy: Bool?

            public var regionId: String?

            public var repeatWeekdays: String?

            public var resourceGroupId: String?

            public var retentionDays: Int32?

            public var status: String?

            public var tags: DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags?

            public var targetCopyRegions: String?

            public var timePoints: String?

            public var type: String?

            public var volumeNums: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.copyEncryptionConfiguration?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.autoSnapshotPolicyName != nil {
                    map["AutoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
                }
                if self.copiedSnapshotsRetentionDays != nil {
                    map["CopiedSnapshotsRetentionDays"] = self.copiedSnapshotsRetentionDays!
                }
                if self.copyEncryptionConfiguration != nil {
                    map["CopyEncryptionConfiguration"] = self.copyEncryptionConfiguration?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskNums != nil {
                    map["DiskNums"] = self.diskNums!
                }
                if self.enableCrossRegionCopy != nil {
                    map["EnableCrossRegionCopy"] = self.enableCrossRegionCopy!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.repeatWeekdays != nil {
                    map["RepeatWeekdays"] = self.repeatWeekdays!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.retentionDays != nil {
                    map["RetentionDays"] = self.retentionDays!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.targetCopyRegions != nil {
                    map["TargetCopyRegions"] = self.targetCopyRegions!
                }
                if self.timePoints != nil {
                    map["TimePoints"] = self.timePoints!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.volumeNums != nil {
                    map["VolumeNums"] = self.volumeNums!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoSnapshotPolicyId") {
                    self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
                }
                if dict.keys.contains("AutoSnapshotPolicyName") {
                    self.autoSnapshotPolicyName = dict["AutoSnapshotPolicyName"] as! String
                }
                if dict.keys.contains("CopiedSnapshotsRetentionDays") {
                    self.copiedSnapshotsRetentionDays = dict["CopiedSnapshotsRetentionDays"] as! Int32
                }
                if dict.keys.contains("CopyEncryptionConfiguration") {
                    var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.CopyEncryptionConfiguration()
                    model.fromMap(dict["CopyEncryptionConfiguration"] as! [String: Any])
                    self.copyEncryptionConfiguration = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiskNums") {
                    self.diskNums = dict["DiskNums"] as! Int32
                }
                if dict.keys.contains("EnableCrossRegionCopy") {
                    self.enableCrossRegionCopy = dict["EnableCrossRegionCopy"] as! Bool
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RepeatWeekdays") {
                    self.repeatWeekdays = dict["RepeatWeekdays"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RetentionDays") {
                    self.retentionDays = dict["RetentionDays"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TargetCopyRegions") {
                    self.targetCopyRegions = dict["TargetCopyRegions"] as! String
                }
                if dict.keys.contains("TimePoints") {
                    self.timePoints = dict["TimePoints"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VolumeNums") {
                    self.volumeNums = dict["VolumeNums"] as! Int32
                }
            }
        }
        public var autoSnapshotPolicy: [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicy != nil {
                var tmp : [Any] = []
                for k in self.autoSnapshotPolicy! {
                    tmp.append(k.toMap())
                }
                map["AutoSnapshotPolicy"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicy") {
                var tmp : [DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy] = []
                for v in dict["AutoSnapshotPolicy"] as! [Any] {
                    var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies.AutoSnapshotPolicy()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.autoSnapshotPolicy = tmp
            }
        }
    }
    public var autoSnapshotPolicies: DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.autoSnapshotPolicies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoSnapshotPolicies != nil {
            map["AutoSnapshotPolicies"] = self.autoSnapshotPolicies?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoSnapshotPolicies") {
            var model = DescribeAutoSnapshotPolicyExResponseBody.AutoSnapshotPolicies()
            model.fromMap(dict["AutoSnapshotPolicies"] as! [String: Any])
            self.autoSnapshotPolicies = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeAutoSnapshotPolicyExResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAutoSnapshotPolicyExResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAutoSnapshotPolicyExResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeAvailableResourceRequest : Tea.TeaModel {
    public var cores: Int32?

    public var dataDiskCategory: String?

    public var dedicatedHostId: String?

    public var destinationResource: String?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var ioOptimized: String?

    public var memory: Double?

    public var networkCategory: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var scope: String?

    public var spotDuration: Int32?

    public var spotStrategy: String?

    public var systemDiskCategory: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.dataDiskCategory != nil {
            map["DataDiskCategory"] = self.dataDiskCategory!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.destinationResource != nil {
            map["DestinationResource"] = self.destinationResource!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkCategory != nil {
            map["NetworkCategory"] = self.networkCategory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("DataDiskCategory") {
            self.dataDiskCategory = dict["DataDiskCategory"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DestinationResource") {
            self.destinationResource = dict["DestinationResource"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NetworkCategory") {
            self.networkCategory = dict["NetworkCategory"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDiskCategory") {
            self.systemDiskCategory = dict["SystemDiskCategory"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeAvailableResourceResponseBody : Tea.TeaModel {
    public class AvailableZones : Tea.TeaModel {
        public class AvailableZone : Tea.TeaModel {
            public class AvailableResources : Tea.TeaModel {
                public class AvailableResource : Tea.TeaModel {
                    public class SupportedResources : Tea.TeaModel {
                        public class SupportedResource : Tea.TeaModel {
                            public var max: Int32?

                            public var min: Int32?

                            public var status: String?

                            public var statusCategory: String?

                            public var unit: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                if self.status != nil {
                                    map["Status"] = self.status!
                                }
                                if self.statusCategory != nil {
                                    map["StatusCategory"] = self.statusCategory!
                                }
                                if self.unit != nil {
                                    map["Unit"] = self.unit!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! Int32
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! Int32
                                }
                                if dict.keys.contains("Status") {
                                    self.status = dict["Status"] as! String
                                }
                                if dict.keys.contains("StatusCategory") {
                                    self.statusCategory = dict["StatusCategory"] as! String
                                }
                                if dict.keys.contains("Unit") {
                                    self.unit = dict["Unit"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var supportedResource: [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedResource != nil {
                                var tmp : [Any] = []
                                for k in self.supportedResource! {
                                    tmp.append(k.toMap())
                                }
                                map["SupportedResource"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SupportedResource") {
                                var tmp : [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource] = []
                                for v in dict["SupportedResource"] as! [Any] {
                                    var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.supportedResource = tmp
                            }
                        }
                    }
                    public var supportedResources: DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.supportedResources?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedResources != nil {
                            map["SupportedResources"] = self.supportedResources?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SupportedResources") {
                            var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources()
                            model.fromMap(dict["SupportedResources"] as! [String: Any])
                            self.supportedResources = model
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var availableResource: [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableResource != nil {
                        var tmp : [Any] = []
                        for k in self.availableResource! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableResource") {
                        var tmp : [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource] = []
                        for v in dict["AvailableResource"] as! [Any] {
                            var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.availableResource = tmp
                    }
                }
            }
            public var availableResources: DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources?

            public var regionId: String?

            public var status: String?

            public var statusCategory: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableResources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableResources != nil {
                    map["AvailableResources"] = self.availableResources?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusCategory != nil {
                    map["StatusCategory"] = self.statusCategory!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableResources") {
                    var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone.AvailableResources()
                    model.fromMap(dict["AvailableResources"] as! [String: Any])
                    self.availableResources = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StatusCategory") {
                    self.statusCategory = dict["StatusCategory"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var availableZone: [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableZone != nil {
                var tmp : [Any] = []
                for k in self.availableZone! {
                    tmp.append(k.toMap())
                }
                map["AvailableZone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableZone") {
                var tmp : [DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone] = []
                for v in dict["AvailableZone"] as! [Any] {
                    var model = DescribeAvailableResourceResponseBody.AvailableZones.AvailableZone()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableZone = tmp
            }
        }
    }
    public var availableZones: DescribeAvailableResourceResponseBody.AvailableZones?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableZones != nil {
            map["AvailableZones"] = self.availableZones?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableZones") {
            var model = DescribeAvailableResourceResponseBody.AvailableZones()
            model.fromMap(dict["AvailableZones"] as! [String: Any])
            self.availableZones = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeAvailableResourceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeAvailableResourceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeAvailableResourceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandwidthLimitationRequest : Tea.TeaModel {
    public var instanceChargeType: String?

    public var instanceType: String?

    public var operationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OperationType") {
            self.operationType = dict["OperationType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
    }
}

public class DescribeBandwidthLimitationResponseBody : Tea.TeaModel {
    public class Bandwidths : Tea.TeaModel {
        public class Bandwidth : Tea.TeaModel {
            public var internetChargeType: String?

            public var max: Int32?

            public var min: Int32?

            public var unit: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.max != nil {
                    map["Max"] = self.max!
                }
                if self.min != nil {
                    map["Min"] = self.min!
                }
                if self.unit != nil {
                    map["Unit"] = self.unit!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("Max") {
                    self.max = dict["Max"] as! Int32
                }
                if dict.keys.contains("Min") {
                    self.min = dict["Min"] as! Int32
                }
                if dict.keys.contains("Unit") {
                    self.unit = dict["Unit"] as! String
                }
            }
        }
        public var bandwidth: [DescribeBandwidthLimitationResponseBody.Bandwidths.Bandwidth]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidth != nil {
                var tmp : [Any] = []
                for k in self.bandwidth! {
                    tmp.append(k.toMap())
                }
                map["Bandwidth"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Bandwidth") {
                var tmp : [DescribeBandwidthLimitationResponseBody.Bandwidths.Bandwidth] = []
                for v in dict["Bandwidth"] as! [Any] {
                    var model = DescribeBandwidthLimitationResponseBody.Bandwidths.Bandwidth()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bandwidth = tmp
            }
        }
    }
    public var bandwidths: DescribeBandwidthLimitationResponseBody.Bandwidths?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidths?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidths != nil {
            map["Bandwidths"] = self.bandwidths?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidths") {
            var model = DescribeBandwidthLimitationResponseBody.Bandwidths()
            model.fromMap(dict["Bandwidths"] as! [String: Any])
            self.bandwidths = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeBandwidthLimitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwidthLimitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBandwidthLimitationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeBandwidthPackagesRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeBandwidthPackagesResponseBody : Tea.TeaModel {
    public class BandwidthPackages : Tea.TeaModel {
        public class BandwidthPackage : Tea.TeaModel {
            public class PublicIpAddresses : Tea.TeaModel {
                public class PublicIpAddresse : Tea.TeaModel {
                    public var allocationId: String?

                    public var ipAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.allocationId != nil {
                            map["AllocationId"] = self.allocationId!
                        }
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AllocationId") {
                            self.allocationId = dict["AllocationId"] as! String
                        }
                        if dict.keys.contains("IpAddress") {
                            self.ipAddress = dict["IpAddress"] as! String
                        }
                    }
                }
                public var publicIpAddresse: [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses.PublicIpAddresse]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.publicIpAddresse != nil {
                        var tmp : [Any] = []
                        for k in self.publicIpAddresse! {
                            tmp.append(k.toMap())
                        }
                        map["PublicIpAddresse"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PublicIpAddresse") {
                        var tmp : [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses.PublicIpAddresse] = []
                        for v in dict["PublicIpAddresse"] as! [Any] {
                            var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses.PublicIpAddresse()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.publicIpAddresse = tmp
                    }
                }
            }
            public var bandwidth: String?

            public var bandwidthPackageId: String?

            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var ISP: String?

            public var instanceChargeType: String?

            public var internetChargeType: String?

            public var ipCount: String?

            public var name: String?

            public var natGatewayId: String?

            public var publicIpAddresses: DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses?

            public var regionId: String?

            public var status: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.publicIpAddresses?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.bandwidthPackageId != nil {
                    map["BandwidthPackageId"] = self.bandwidthPackageId!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipCount != nil {
                    map["IpCount"] = self.ipCount!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.publicIpAddresses != nil {
                    map["PublicIpAddresses"] = self.publicIpAddresses?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! String
                }
                if dict.keys.contains("BandwidthPackageId") {
                    self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ISP") {
                    self.ISP = dict["ISP"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("IpCount") {
                    self.ipCount = dict["IpCount"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NatGatewayId") {
                    self.natGatewayId = dict["NatGatewayId"] as! String
                }
                if dict.keys.contains("PublicIpAddresses") {
                    var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage.PublicIpAddresses()
                    model.fromMap(dict["PublicIpAddresses"] as! [String: Any])
                    self.publicIpAddresses = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var bandwidthPackage: [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bandwidthPackage != nil {
                var tmp : [Any] = []
                for k in self.bandwidthPackage! {
                    tmp.append(k.toMap())
                }
                map["BandwidthPackage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BandwidthPackage") {
                var tmp : [DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage] = []
                for v in dict["BandwidthPackage"] as! [Any] {
                    var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages.BandwidthPackage()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.bandwidthPackage = tmp
            }
        }
    }
    public var bandwidthPackages: DescribeBandwidthPackagesResponseBody.BandwidthPackages?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.bandwidthPackages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackages != nil {
            map["BandwidthPackages"] = self.bandwidthPackages?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackages") {
            var model = DescribeBandwidthPackagesResponseBody.BandwidthPackages()
            model.fromMap(dict["BandwidthPackages"] as! [String: Any])
            self.bandwidthPackages = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeBandwidthPackagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeBandwidthPackagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeBandwidthPackagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCapacityReservationInstancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var privatePoolOptions: DescribeCapacityReservationInstancesRequest.PrivatePoolOptions?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = DescribeCapacityReservationInstancesRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeCapacityReservationInstancesResponseBody : Tea.TeaModel {
    public class CapacityReservationItem : Tea.TeaModel {
        public class InstanceIdSet : Tea.TeaModel {
            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var instanceIdSet: [DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem.InstanceIdSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                var tmp : [Any] = []
                for k in self.instanceIdSet! {
                    tmp.append(k.toMap())
                }
                map["InstanceIdSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceIdSet") {
                var tmp : [DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem.InstanceIdSet] = []
                for v in dict["InstanceIdSet"] as! [Any] {
                    var model = DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem.InstanceIdSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceIdSet = tmp
            }
        }
    }
    public var capacityReservationItem: DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityReservationItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationItem != nil {
            map["CapacityReservationItem"] = self.capacityReservationItem?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationItem") {
            var model = DescribeCapacityReservationInstancesResponseBody.CapacityReservationItem()
            model.fromMap(dict["CapacityReservationItem"] as! [String: Any])
            self.capacityReservationItem = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCapacityReservationInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCapacityReservationInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCapacityReservationInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCapacityReservationsRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var ids: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ids != nil {
                map["Ids"] = self.ids!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ids") {
                self.ids = dict["Ids"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var privatePoolOptions: DescribeCapacityReservationsRequest.PrivatePoolOptions?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeCapacityReservationsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = DescribeCapacityReservationsRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeCapacityReservationsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeCapacityReservationsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeCapacityReservationsResponseBody : Tea.TeaModel {
    public class CapacityReservationSet : Tea.TeaModel {
        public class CapacityReservationItem : Tea.TeaModel {
            public class AllocatedResources : Tea.TeaModel {
                public class AllocatedResource : Tea.TeaModel {
                    public class CapacityReservationUsages : Tea.TeaModel {
                        public class CapacityReservationUsage : Tea.TeaModel {
                            public var accountId: String?

                            public var serviceName: String?

                            public var usedAmount: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.accountId != nil {
                                    map["AccountId"] = self.accountId!
                                }
                                if self.serviceName != nil {
                                    map["ServiceName"] = self.serviceName!
                                }
                                if self.usedAmount != nil {
                                    map["UsedAmount"] = self.usedAmount!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AccountId") {
                                    self.accountId = dict["AccountId"] as! String
                                }
                                if dict.keys.contains("ServiceName") {
                                    self.serviceName = dict["ServiceName"] as! String
                                }
                                if dict.keys.contains("UsedAmount") {
                                    self.usedAmount = dict["UsedAmount"] as! Int32
                                }
                            }
                        }
                        public var capacityReservationUsage: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages.CapacityReservationUsage]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.capacityReservationUsage != nil {
                                var tmp : [Any] = []
                                for k in self.capacityReservationUsage! {
                                    tmp.append(k.toMap())
                                }
                                map["CapacityReservationUsage"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CapacityReservationUsage") {
                                var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages.CapacityReservationUsage] = []
                                for v in dict["CapacityReservationUsage"] as! [Any] {
                                    var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages.CapacityReservationUsage()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.capacityReservationUsage = tmp
                            }
                        }
                    }
                    public var availableAmount: Int32?

                    public var capacityReservationUsages: DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages?

                    public var instanceType: String?

                    public var totalAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.capacityReservationUsages?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableAmount != nil {
                            map["AvailableAmount"] = self.availableAmount!
                        }
                        if self.capacityReservationUsages != nil {
                            map["CapacityReservationUsages"] = self.capacityReservationUsages?.toMap()
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.totalAmount != nil {
                            map["TotalAmount"] = self.totalAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["zoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableAmount") {
                            self.availableAmount = dict["AvailableAmount"] as! Int32
                        }
                        if dict.keys.contains("CapacityReservationUsages") {
                            var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource.CapacityReservationUsages()
                            model.fromMap(dict["CapacityReservationUsages"] as! [String: Any])
                            self.capacityReservationUsages = model
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("TotalAmount") {
                            self.totalAmount = dict["TotalAmount"] as! Int32
                        }
                        if dict.keys.contains("UsedAmount") {
                            self.usedAmount = dict["UsedAmount"] as! Int32
                        }
                        if dict.keys.contains("zoneId") {
                            self.zoneId = dict["zoneId"] as! String
                        }
                    }
                }
                public var allocatedResource: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocatedResource != nil {
                        var tmp : [Any] = []
                        for k in self.allocatedResource! {
                            tmp.append(k.toMap())
                        }
                        map["AllocatedResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocatedResource") {
                        var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource] = []
                        for v in dict["AllocatedResource"] as! [Any] {
                            var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources.AllocatedResource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.allocatedResource = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocatedResources: DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources?

            public var capacityReservationOwnerId: String?

            public var description_: String?

            public var endTime: String?

            public var endTimeType: String?

            public var instanceChargeType: String?

            public var platform: String?

            public var privatePoolOptionsId: String?

            public var privatePoolOptionsMatchCriteria: String?

            public var privatePoolOptionsName: String?

            public var regionId: String?

            public var reservedInstanceId: String?

            public var resourceGroupId: String?

            public var savingPlanId: String?

            public var startTime: String?

            public var startTimeType: String?

            public var status: String?

            public var tags: DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags?

            public var timeSlot: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.allocatedResources?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocatedResources != nil {
                    map["AllocatedResources"] = self.allocatedResources?.toMap()
                }
                if self.capacityReservationOwnerId != nil {
                    map["CapacityReservationOwnerId"] = self.capacityReservationOwnerId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.endTimeType != nil {
                    map["EndTimeType"] = self.endTimeType!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.privatePoolOptionsMatchCriteria != nil {
                    map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
                }
                if self.privatePoolOptionsName != nil {
                    map["PrivatePoolOptionsName"] = self.privatePoolOptionsName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.savingPlanId != nil {
                    map["SavingPlanId"] = self.savingPlanId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimeType != nil {
                    map["StartTimeType"] = self.startTimeType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.timeSlot != nil {
                    map["TimeSlot"] = self.timeSlot!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocatedResources") {
                    var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.AllocatedResources()
                    model.fromMap(dict["AllocatedResources"] as! [String: Any])
                    self.allocatedResources = model
                }
                if dict.keys.contains("CapacityReservationOwnerId") {
                    self.capacityReservationOwnerId = dict["CapacityReservationOwnerId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("EndTimeType") {
                    self.endTimeType = dict["EndTimeType"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsId") {
                    self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsMatchCriteria") {
                    self.privatePoolOptionsMatchCriteria = dict["PrivatePoolOptionsMatchCriteria"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsName") {
                    self.privatePoolOptionsName = dict["PrivatePoolOptionsName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReservedInstanceId") {
                    self.reservedInstanceId = dict["ReservedInstanceId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SavingPlanId") {
                    self.savingPlanId = dict["SavingPlanId"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StartTimeType") {
                    self.startTimeType = dict["StartTimeType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TimeSlot") {
                    self.timeSlot = dict["TimeSlot"] as! String
                }
            }
        }
        public var capacityReservationItem: [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.capacityReservationItem != nil {
                var tmp : [Any] = []
                for k in self.capacityReservationItem! {
                    tmp.append(k.toMap())
                }
                map["CapacityReservationItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("CapacityReservationItem") {
                var tmp : [DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem] = []
                for v in dict["CapacityReservationItem"] as! [Any] {
                    var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet.CapacityReservationItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.capacityReservationItem = tmp
            }
        }
    }
    public var capacityReservationSet: DescribeCapacityReservationsResponseBody.CapacityReservationSet?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.capacityReservationSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.capacityReservationSet != nil {
            map["CapacityReservationSet"] = self.capacityReservationSet?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CapacityReservationSet") {
            var model = DescribeCapacityReservationsResponseBody.CapacityReservationSet()
            model.fromMap(dict["CapacityReservationSet"] as! [String: Any])
            self.capacityReservationSet = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeCapacityReservationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCapacityReservationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCapacityReservationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClassicLinkInstancesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeClassicLinkInstancesResponseBody : Tea.TeaModel {
    public class Links : Tea.TeaModel {
        public class Link : Tea.TeaModel {
            public var instanceId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var link: [DescribeClassicLinkInstancesResponseBody.Links.Link]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.link != nil {
                var tmp : [Any] = []
                for k in self.link! {
                    tmp.append(k.toMap())
                }
                map["Link"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Link") {
                var tmp : [DescribeClassicLinkInstancesResponseBody.Links.Link] = []
                for v in dict["Link"] as! [Any] {
                    var model = DescribeClassicLinkInstancesResponseBody.Links.Link()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.link = tmp
            }
        }
    }
    public var links: DescribeClassicLinkInstancesResponseBody.Links?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.links?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.links != nil {
            map["Links"] = self.links?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Links") {
            var model = DescribeClassicLinkInstancesResponseBody.Links()
            model.fromMap(dict["Links"] as! [String: Any])
            self.links = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeClassicLinkInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClassicLinkInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeClassicLinkInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudAssistantSettingsRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var settingType: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.settingType != nil {
            map["SettingType"] = self.settingType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SettingType") {
            self.settingType = dict["SettingType"] as! [String]
        }
    }
}

public class DescribeCloudAssistantSettingsResponseBody : Tea.TeaModel {
    public class AgentUpgradeConfig : Tea.TeaModel {
        public class AllowedUpgradeWindows : Tea.TeaModel {
            public var allowedUpgradeWindow: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allowedUpgradeWindow != nil {
                    map["AllowedUpgradeWindow"] = self.allowedUpgradeWindow!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllowedUpgradeWindow") {
                    self.allowedUpgradeWindow = dict["AllowedUpgradeWindow"] as! [String]
                }
            }
        }
        public var allowedUpgradeWindows: DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig.AllowedUpgradeWindows?

        public var enabled: Bool?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.allowedUpgradeWindows?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowedUpgradeWindows != nil {
                map["AllowedUpgradeWindows"] = self.allowedUpgradeWindows?.toMap()
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowedUpgradeWindows") {
                var model = DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig.AllowedUpgradeWindows()
                model.fromMap(dict["AllowedUpgradeWindows"] as! [String: Any])
                self.allowedUpgradeWindows = model
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class OssDeliveryConfigs : Tea.TeaModel {
        public class OssDeliveryConfig : Tea.TeaModel {
            public var bucketName: String?

            public var deliveryType: String?

            public var enabled: Bool?

            public var encryptionAlgorithm: String?

            public var encryptionKeyId: String?

            public var encryptionType: String?

            public var prefix_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bucketName != nil {
                    map["BucketName"] = self.bucketName!
                }
                if self.deliveryType != nil {
                    map["DeliveryType"] = self.deliveryType!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.encryptionAlgorithm != nil {
                    map["EncryptionAlgorithm"] = self.encryptionAlgorithm!
                }
                if self.encryptionKeyId != nil {
                    map["EncryptionKeyId"] = self.encryptionKeyId!
                }
                if self.encryptionType != nil {
                    map["EncryptionType"] = self.encryptionType!
                }
                if self.prefix_ != nil {
                    map["Prefix"] = self.prefix_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BucketName") {
                    self.bucketName = dict["BucketName"] as! String
                }
                if dict.keys.contains("DeliveryType") {
                    self.deliveryType = dict["DeliveryType"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("EncryptionAlgorithm") {
                    self.encryptionAlgorithm = dict["EncryptionAlgorithm"] as! String
                }
                if dict.keys.contains("EncryptionKeyId") {
                    self.encryptionKeyId = dict["EncryptionKeyId"] as! String
                }
                if dict.keys.contains("EncryptionType") {
                    self.encryptionType = dict["EncryptionType"] as! String
                }
                if dict.keys.contains("Prefix") {
                    self.prefix_ = dict["Prefix"] as! String
                }
            }
        }
        public var ossDeliveryConfig: [DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs.OssDeliveryConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ossDeliveryConfig != nil {
                var tmp : [Any] = []
                for k in self.ossDeliveryConfig! {
                    tmp.append(k.toMap())
                }
                map["OssDeliveryConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OssDeliveryConfig") {
                var tmp : [DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs.OssDeliveryConfig] = []
                for v in dict["OssDeliveryConfig"] as! [Any] {
                    var model = DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs.OssDeliveryConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ossDeliveryConfig = tmp
            }
        }
    }
    public class SlsDeliveryConfigs : Tea.TeaModel {
        public class SlsDeliveryConfig : Tea.TeaModel {
            public var deliveryType: String?

            public var enabled: Bool?

            public var logstoreName: String?

            public var projectName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.deliveryType != nil {
                    map["DeliveryType"] = self.deliveryType!
                }
                if self.enabled != nil {
                    map["Enabled"] = self.enabled!
                }
                if self.logstoreName != nil {
                    map["LogstoreName"] = self.logstoreName!
                }
                if self.projectName != nil {
                    map["ProjectName"] = self.projectName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DeliveryType") {
                    self.deliveryType = dict["DeliveryType"] as! String
                }
                if dict.keys.contains("Enabled") {
                    self.enabled = dict["Enabled"] as! Bool
                }
                if dict.keys.contains("LogstoreName") {
                    self.logstoreName = dict["LogstoreName"] as! String
                }
                if dict.keys.contains("ProjectName") {
                    self.projectName = dict["ProjectName"] as! String
                }
            }
        }
        public var slsDeliveryConfig: [DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs.SlsDeliveryConfig]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slsDeliveryConfig != nil {
                var tmp : [Any] = []
                for k in self.slsDeliveryConfig! {
                    tmp.append(k.toMap())
                }
                map["SlsDeliveryConfig"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlsDeliveryConfig") {
                var tmp : [DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs.SlsDeliveryConfig] = []
                for v in dict["SlsDeliveryConfig"] as! [Any] {
                    var model = DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs.SlsDeliveryConfig()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.slsDeliveryConfig = tmp
            }
        }
    }
    public var agentUpgradeConfig: DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig?

    public var ossDeliveryConfigs: DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs?

    public var requestId: String?

    public var slsDeliveryConfigs: DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.agentUpgradeConfig?.validate()
        try self.ossDeliveryConfigs?.validate()
        try self.slsDeliveryConfigs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentUpgradeConfig != nil {
            map["AgentUpgradeConfig"] = self.agentUpgradeConfig?.toMap()
        }
        if self.ossDeliveryConfigs != nil {
            map["OssDeliveryConfigs"] = self.ossDeliveryConfigs?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.slsDeliveryConfigs != nil {
            map["SlsDeliveryConfigs"] = self.slsDeliveryConfigs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentUpgradeConfig") {
            var model = DescribeCloudAssistantSettingsResponseBody.AgentUpgradeConfig()
            model.fromMap(dict["AgentUpgradeConfig"] as! [String: Any])
            self.agentUpgradeConfig = model
        }
        if dict.keys.contains("OssDeliveryConfigs") {
            var model = DescribeCloudAssistantSettingsResponseBody.OssDeliveryConfigs()
            model.fromMap(dict["OssDeliveryConfigs"] as! [String: Any])
            self.ossDeliveryConfigs = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SlsDeliveryConfigs") {
            var model = DescribeCloudAssistantSettingsResponseBody.SlsDeliveryConfigs()
            model.fromMap(dict["SlsDeliveryConfigs"] as! [String: Any])
            self.slsDeliveryConfigs = model
        }
    }
}

public class DescribeCloudAssistantSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudAssistantSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudAssistantSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCloudAssistantStatusRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var maxResults: Int32?

    public var nextToken: String?

    public var OSType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OSType") {
            self.OSType = dict["OSType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeCloudAssistantStatusResponseBody : Tea.TeaModel {
    public class InstanceCloudAssistantStatusSet : Tea.TeaModel {
        public class InstanceCloudAssistantStatus : Tea.TeaModel {
            public var activeTaskCount: Int64?

            public var cloudAssistantStatus: String?

            public var cloudAssistantVersion: String?

            public var instanceId: String?

            public var invocationCount: Int64?

            public var lastHeartbeatTime: String?

            public var lastInvokedTime: String?

            public var OSType: String?

            public var supportSessionManager: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activeTaskCount != nil {
                    map["ActiveTaskCount"] = self.activeTaskCount!
                }
                if self.cloudAssistantStatus != nil {
                    map["CloudAssistantStatus"] = self.cloudAssistantStatus!
                }
                if self.cloudAssistantVersion != nil {
                    map["CloudAssistantVersion"] = self.cloudAssistantVersion!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.invocationCount != nil {
                    map["InvocationCount"] = self.invocationCount!
                }
                if self.lastHeartbeatTime != nil {
                    map["LastHeartbeatTime"] = self.lastHeartbeatTime!
                }
                if self.lastInvokedTime != nil {
                    map["LastInvokedTime"] = self.lastInvokedTime!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                if self.supportSessionManager != nil {
                    map["SupportSessionManager"] = self.supportSessionManager!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActiveTaskCount") {
                    self.activeTaskCount = dict["ActiveTaskCount"] as! Int64
                }
                if dict.keys.contains("CloudAssistantStatus") {
                    self.cloudAssistantStatus = dict["CloudAssistantStatus"] as! String
                }
                if dict.keys.contains("CloudAssistantVersion") {
                    self.cloudAssistantVersion = dict["CloudAssistantVersion"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InvocationCount") {
                    self.invocationCount = dict["InvocationCount"] as! Int64
                }
                if dict.keys.contains("LastHeartbeatTime") {
                    self.lastHeartbeatTime = dict["LastHeartbeatTime"] as! String
                }
                if dict.keys.contains("LastInvokedTime") {
                    self.lastInvokedTime = dict["LastInvokedTime"] as! String
                }
                if dict.keys.contains("OSType") {
                    self.OSType = dict["OSType"] as! String
                }
                if dict.keys.contains("SupportSessionManager") {
                    self.supportSessionManager = dict["SupportSessionManager"] as! Bool
                }
            }
        }
        public var instanceCloudAssistantStatus: [DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet.InstanceCloudAssistantStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceCloudAssistantStatus != nil {
                var tmp : [Any] = []
                for k in self.instanceCloudAssistantStatus! {
                    tmp.append(k.toMap())
                }
                map["InstanceCloudAssistantStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceCloudAssistantStatus") {
                var tmp : [DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet.InstanceCloudAssistantStatus] = []
                for v in dict["InstanceCloudAssistantStatus"] as! [Any] {
                    var model = DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet.InstanceCloudAssistantStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceCloudAssistantStatus = tmp
            }
        }
    }
    public var instanceCloudAssistantStatusSet: DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceCloudAssistantStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceCloudAssistantStatusSet != nil {
            map["InstanceCloudAssistantStatusSet"] = self.instanceCloudAssistantStatusSet?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceCloudAssistantStatusSet") {
            var model = DescribeCloudAssistantStatusResponseBody.InstanceCloudAssistantStatusSet()
            model.fromMap(dict["InstanceCloudAssistantStatusSet"] as! [String: Any])
            self.instanceCloudAssistantStatusSet = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeCloudAssistantStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCloudAssistantStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCloudAssistantStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeClustersRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeClustersResponseBody : Tea.TeaModel {
    public class Clusters : Tea.TeaModel {
        public class Cluster : Tea.TeaModel {
            public var clusterId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
            }
        }
        public var cluster: [DescribeClustersResponseBody.Clusters.Cluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cluster != nil {
                var tmp : [Any] = []
                for k in self.cluster! {
                    tmp.append(k.toMap())
                }
                map["Cluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cluster") {
                var tmp : [DescribeClustersResponseBody.Clusters.Cluster] = []
                for v in dict["Cluster"] as! [Any] {
                    var model = DescribeClustersResponseBody.Clusters.Cluster()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.cluster = tmp
            }
        }
    }
    public var clusters: DescribeClustersResponseBody.Clusters?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.clusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusters != nil {
            map["Clusters"] = self.clusters?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Clusters") {
            var model = DescribeClustersResponseBody.Clusters()
            model.fromMap(dict["Clusters"] as! [String: Any])
            self.clusters = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeCommandsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var commandId: String?

    public var contentEncoding: String?

    public var description_: String?

    public var latest: Bool?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var provider: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeCommandsRequest.Tag]?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.latest != nil {
            map["Latest"] = self.latest!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.provider != nil {
            map["Provider"] = self.provider!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Latest") {
            self.latest = dict["Latest"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("Provider") {
            self.provider = dict["Provider"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeCommandsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeCommandsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeCommandsResponseBody : Tea.TeaModel {
    public class Commands : Tea.TeaModel {
        public class Command : Tea.TeaModel {
            public class ParameterDefinitions : Tea.TeaModel {
                public class ParameterDefinition : Tea.TeaModel {
                    public class PossibleValues : Tea.TeaModel {
                        public var possibleValue: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.possibleValue != nil {
                                map["PossibleValue"] = self.possibleValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("PossibleValue") {
                                self.possibleValue = dict["PossibleValue"] as! [String]
                            }
                        }
                    }
                    public var defaultValue: String?

                    public var description_: String?

                    public var parameterName: String?

                    public var possibleValues: DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition.PossibleValues?

                    public var required_: Bool?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.possibleValues?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.parameterName != nil {
                            map["ParameterName"] = self.parameterName!
                        }
                        if self.possibleValues != nil {
                            map["PossibleValues"] = self.possibleValues?.toMap()
                        }
                        if self.required_ != nil {
                            map["Required"] = self.required_!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("ParameterName") {
                            self.parameterName = dict["ParameterName"] as! String
                        }
                        if dict.keys.contains("PossibleValues") {
                            var model = DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition.PossibleValues()
                            model.fromMap(dict["PossibleValues"] as! [String: Any])
                            self.possibleValues = model
                        }
                        if dict.keys.contains("Required") {
                            self.required_ = dict["Required"] as! Bool
                        }
                    }
                }
                public var parameterDefinition: [DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterDefinition != nil {
                        var tmp : [Any] = []
                        for k in self.parameterDefinition! {
                            tmp.append(k.toMap())
                        }
                        map["ParameterDefinition"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ParameterDefinition") {
                        var tmp : [DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition] = []
                        for v in dict["ParameterDefinition"] as! [Any] {
                            var model = DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions.ParameterDefinition()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.parameterDefinition = tmp
                    }
                }
            }
            public class ParameterNames : Tea.TeaModel {
                public var parameterName: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameterName != nil {
                        map["ParameterName"] = self.parameterName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ParameterName") {
                        self.parameterName = dict["ParameterName"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeCommandsResponseBody.Commands.Command.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeCommandsResponseBody.Commands.Command.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeCommandsResponseBody.Commands.Command.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var category: String?

            public var commandContent: String?

            public var commandId: String?

            public var creationTime: String?

            public var description_: String?

            public var enableParameter: Bool?

            public var invokeTimes: Int32?

            public var latest: Bool?

            public var launcher: String?

            public var name: String?

            public var parameterDefinitions: DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions?

            public var parameterNames: DescribeCommandsResponseBody.Commands.Command.ParameterNames?

            public var provider: String?

            public var resourceGroupId: String?

            public var tags: DescribeCommandsResponseBody.Commands.Command.Tags?

            public var timeout: Int64?

            public var type: String?

            public var version: Int32?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.parameterDefinitions?.validate()
                try self.parameterNames?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.commandContent != nil {
                    map["CommandContent"] = self.commandContent!
                }
                if self.commandId != nil {
                    map["CommandId"] = self.commandId!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enableParameter != nil {
                    map["EnableParameter"] = self.enableParameter!
                }
                if self.invokeTimes != nil {
                    map["InvokeTimes"] = self.invokeTimes!
                }
                if self.latest != nil {
                    map["Latest"] = self.latest!
                }
                if self.launcher != nil {
                    map["Launcher"] = self.launcher!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.parameterDefinitions != nil {
                    map["ParameterDefinitions"] = self.parameterDefinitions?.toMap()
                }
                if self.parameterNames != nil {
                    map["ParameterNames"] = self.parameterNames?.toMap()
                }
                if self.provider != nil {
                    map["Provider"] = self.provider!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.version != nil {
                    map["Version"] = self.version!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CommandContent") {
                    self.commandContent = dict["CommandContent"] as! String
                }
                if dict.keys.contains("CommandId") {
                    self.commandId = dict["CommandId"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnableParameter") {
                    self.enableParameter = dict["EnableParameter"] as! Bool
                }
                if dict.keys.contains("InvokeTimes") {
                    self.invokeTimes = dict["InvokeTimes"] as! Int32
                }
                if dict.keys.contains("Latest") {
                    self.latest = dict["Latest"] as! Bool
                }
                if dict.keys.contains("Launcher") {
                    self.launcher = dict["Launcher"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ParameterDefinitions") {
                    var model = DescribeCommandsResponseBody.Commands.Command.ParameterDefinitions()
                    model.fromMap(dict["ParameterDefinitions"] as! [String: Any])
                    self.parameterDefinitions = model
                }
                if dict.keys.contains("ParameterNames") {
                    var model = DescribeCommandsResponseBody.Commands.Command.ParameterNames()
                    model.fromMap(dict["ParameterNames"] as! [String: Any])
                    self.parameterNames = model
                }
                if dict.keys.contains("Provider") {
                    self.provider = dict["Provider"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeCommandsResponseBody.Commands.Command.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("Version") {
                    self.version = dict["Version"] as! Int32
                }
                if dict.keys.contains("WorkingDir") {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public var command: [DescribeCommandsResponseBody.Commands.Command]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.command != nil {
                var tmp : [Any] = []
                for k in self.command! {
                    tmp.append(k.toMap())
                }
                map["Command"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Command") {
                var tmp : [DescribeCommandsResponseBody.Commands.Command] = []
                for v in dict["Command"] as! [Any] {
                    var model = DescribeCommandsResponseBody.Commands.Command()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.command = tmp
            }
        }
    }
    public var commands: DescribeCommandsResponseBody.Commands?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.commands?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commands != nil {
            map["Commands"] = self.commands?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Commands") {
            var model = DescribeCommandsResponseBody.Commands()
            model.fromMap(dict["Commands"] as! [String: Any])
            self.commands = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeCommandsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeCommandsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeCommandsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostAutoRenewRequest : Tea.TeaModel {
    public var dedicatedHostIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostIds") {
            self.dedicatedHostIds = dict["DedicatedHostIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeDedicatedHostAutoRenewResponseBody : Tea.TeaModel {
    public class DedicatedHostRenewAttributes : Tea.TeaModel {
        public class DedicatedHostRenewAttribute : Tea.TeaModel {
            public var autoRenewEnabled: Bool?

            public var autoRenewWithEcs: String?

            public var dedicatedHostId: String?

            public var duration: Int32?

            public var periodUnit: String?

            public var renewalStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewEnabled != nil {
                    map["AutoRenewEnabled"] = self.autoRenewEnabled!
                }
                if self.autoRenewWithEcs != nil {
                    map["AutoRenewWithEcs"] = self.autoRenewWithEcs!
                }
                if self.dedicatedHostId != nil {
                    map["DedicatedHostId"] = self.dedicatedHostId!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewEnabled") {
                    self.autoRenewEnabled = dict["AutoRenewEnabled"] as! Bool
                }
                if dict.keys.contains("AutoRenewWithEcs") {
                    self.autoRenewWithEcs = dict["AutoRenewWithEcs"] as! String
                }
                if dict.keys.contains("DedicatedHostId") {
                    self.dedicatedHostId = dict["DedicatedHostId"] as! String
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("PeriodUnit") {
                    self.periodUnit = dict["PeriodUnit"] as! String
                }
                if dict.keys.contains("RenewalStatus") {
                    self.renewalStatus = dict["RenewalStatus"] as! String
                }
            }
        }
        public var dedicatedHostRenewAttribute: [DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes.DedicatedHostRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostRenewAttribute") {
                var tmp : [DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes.DedicatedHostRenewAttribute] = []
                for v in dict["DedicatedHostRenewAttribute"] as! [Any] {
                    var model = DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes.DedicatedHostRenewAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dedicatedHostRenewAttribute = tmp
            }
        }
    }
    public var dedicatedHostRenewAttributes: DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostRenewAttributes != nil {
            map["DedicatedHostRenewAttributes"] = self.dedicatedHostRenewAttributes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostRenewAttributes") {
            var model = DescribeDedicatedHostAutoRenewResponseBody.DedicatedHostRenewAttributes()
            model.fromMap(dict["DedicatedHostRenewAttributes"] as! [String: Any])
            self.dedicatedHostRenewAttributes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDedicatedHostAutoRenewResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostAutoRenewResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostAutoRenewResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostClustersRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dedicatedHostClusterIds: String?

    public var dedicatedHostClusterName: String?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeDedicatedHostClustersRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterIds != nil {
            map["DedicatedHostClusterIds"] = self.dedicatedHostClusterIds!
        }
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterIds") {
            self.dedicatedHostClusterIds = dict["DedicatedHostClusterIds"] as! String
        }
        if dict.keys.contains("DedicatedHostClusterName") {
            self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeDedicatedHostClustersRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDedicatedHostClustersRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDedicatedHostClustersResponseBody : Tea.TeaModel {
    public class DedicatedHostClusters : Tea.TeaModel {
        public class DedicatedHostCluster : Tea.TeaModel {
            public class DedicatedHostClusterCapacity : Tea.TeaModel {
                public class AvailableInstanceTypes : Tea.TeaModel {
                    public class AvailableInstanceType : Tea.TeaModel {
                        public var availableInstanceCapacity: Int32?

                        public var instanceType: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableInstanceCapacity != nil {
                                map["AvailableInstanceCapacity"] = self.availableInstanceCapacity!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvailableInstanceCapacity") {
                                self.availableInstanceCapacity = dict["AvailableInstanceCapacity"] as! Int32
                            }
                            if dict.keys.contains("InstanceType") {
                                self.instanceType = dict["InstanceType"] as! String
                            }
                        }
                    }
                    public var availableInstanceType: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableInstanceType != nil {
                            var tmp : [Any] = []
                            for k in self.availableInstanceType! {
                                tmp.append(k.toMap())
                            }
                            map["AvailableInstanceType"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableInstanceType") {
                            var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType] = []
                            for v in dict["AvailableInstanceType"] as! [Any] {
                                var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes.AvailableInstanceType()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.availableInstanceType = tmp
                        }
                    }
                }
                public class LocalStorageCapacities : Tea.TeaModel {
                    public class LocalStorageCapacity : Tea.TeaModel {
                        public var availableDisk: Int32?

                        public var dataDiskCategory: String?

                        public var totalDisk: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableDisk != nil {
                                map["AvailableDisk"] = self.availableDisk!
                            }
                            if self.dataDiskCategory != nil {
                                map["DataDiskCategory"] = self.dataDiskCategory!
                            }
                            if self.totalDisk != nil {
                                map["TotalDisk"] = self.totalDisk!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvailableDisk") {
                                self.availableDisk = dict["AvailableDisk"] as! Int32
                            }
                            if dict.keys.contains("DataDiskCategory") {
                                self.dataDiskCategory = dict["DataDiskCategory"] as! String
                            }
                            if dict.keys.contains("TotalDisk") {
                                self.totalDisk = dict["TotalDisk"] as! Int32
                            }
                        }
                    }
                    public var localStorageCapacity: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.localStorageCapacity != nil {
                            var tmp : [Any] = []
                            for k in self.localStorageCapacity! {
                                tmp.append(k.toMap())
                            }
                            map["LocalStorageCapacity"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LocalStorageCapacity") {
                            var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity] = []
                            for v in dict["LocalStorageCapacity"] as! [Any] {
                                var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities.LocalStorageCapacity()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.localStorageCapacity = tmp
                        }
                    }
                }
                public var availableInstanceTypes: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes?

                public var availableMemory: Int32?

                public var availableVcpus: Int32?

                public var localStorageCapacities: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities?

                public var totalMemory: Int32?

                public var totalVcpus: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.availableInstanceTypes?.validate()
                    try self.localStorageCapacities?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableInstanceTypes != nil {
                        map["AvailableInstanceTypes"] = self.availableInstanceTypes?.toMap()
                    }
                    if self.availableMemory != nil {
                        map["AvailableMemory"] = self.availableMemory!
                    }
                    if self.availableVcpus != nil {
                        map["AvailableVcpus"] = self.availableVcpus!
                    }
                    if self.localStorageCapacities != nil {
                        map["LocalStorageCapacities"] = self.localStorageCapacities?.toMap()
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.totalVcpus != nil {
                        map["TotalVcpus"] = self.totalVcpus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableInstanceTypes") {
                        var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.AvailableInstanceTypes()
                        model.fromMap(dict["AvailableInstanceTypes"] as! [String: Any])
                        self.availableInstanceTypes = model
                    }
                    if dict.keys.contains("AvailableMemory") {
                        self.availableMemory = dict["AvailableMemory"] as! Int32
                    }
                    if dict.keys.contains("AvailableVcpus") {
                        self.availableVcpus = dict["AvailableVcpus"] as! Int32
                    }
                    if dict.keys.contains("LocalStorageCapacities") {
                        var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity.LocalStorageCapacities()
                        model.fromMap(dict["LocalStorageCapacities"] as! [String: Any])
                        self.localStorageCapacities = model
                    }
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Int32
                    }
                    if dict.keys.contains("TotalVcpus") {
                        self.totalVcpus = dict["TotalVcpus"] as! Int32
                    }
                }
            }
            public class DedicatedHostIds : Tea.TeaModel {
                public var dedicatedHostId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostId != nil {
                        map["DedicatedHostId"] = self.dedicatedHostId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DedicatedHostId") {
                        self.dedicatedHostId = dict["DedicatedHostId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var dedicatedHostClusterCapacity: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity?

            public var dedicatedHostClusterId: String?

            public var dedicatedHostClusterName: String?

            public var dedicatedHostIds: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostIds?

            public var description_: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var tags: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.dedicatedHostClusterCapacity?.validate()
                try self.dedicatedHostIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dedicatedHostClusterCapacity != nil {
                    map["DedicatedHostClusterCapacity"] = self.dedicatedHostClusterCapacity?.toMap()
                }
                if self.dedicatedHostClusterId != nil {
                    map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                }
                if self.dedicatedHostClusterName != nil {
                    map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
                }
                if self.dedicatedHostIds != nil {
                    map["DedicatedHostIds"] = self.dedicatedHostIds?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DedicatedHostClusterCapacity") {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostClusterCapacity()
                    model.fromMap(dict["DedicatedHostClusterCapacity"] as! [String: Any])
                    self.dedicatedHostClusterCapacity = model
                }
                if dict.keys.contains("DedicatedHostClusterId") {
                    self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
                }
                if dict.keys.contains("DedicatedHostClusterName") {
                    self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
                }
                if dict.keys.contains("DedicatedHostIds") {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.DedicatedHostIds()
                    model.fromMap(dict["DedicatedHostIds"] as! [String: Any])
                    self.dedicatedHostIds = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var dedicatedHostCluster: [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostCluster != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostCluster! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostCluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostCluster") {
                var tmp : [DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster] = []
                for v in dict["DedicatedHostCluster"] as! [Any] {
                    var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters.DedicatedHostCluster()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dedicatedHostCluster = tmp
            }
        }
    }
    public var dedicatedHostClusters: DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostClusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusters != nil {
            map["DedicatedHostClusters"] = self.dedicatedHostClusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusters") {
            var model = DescribeDedicatedHostClustersResponseBody.DedicatedHostClusters()
            model.fromMap(dict["DedicatedHostClusters"] as! [String: Any])
            self.dedicatedHostClusters = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDedicatedHostClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostTypesRequest : Tea.TeaModel {
    public var dedicatedHostType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var supportedInstanceTypeFamily: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.supportedInstanceTypeFamily != nil {
            map["SupportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostType") {
            self.dedicatedHostType = dict["DedicatedHostType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SupportedInstanceTypeFamily") {
            self.supportedInstanceTypeFamily = dict["SupportedInstanceTypeFamily"] as! String
        }
    }
}

public class DescribeDedicatedHostTypesResponseBody : Tea.TeaModel {
    public class DedicatedHostTypes : Tea.TeaModel {
        public class DedicatedHostType : Tea.TeaModel {
            public class SupportedInstanceTypeFamilies : Tea.TeaModel {
                public var supportedInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypeFamily != nil {
                        map["SupportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedInstanceTypeFamily") {
                        self.supportedInstanceTypeFamily = dict["SupportedInstanceTypeFamily"] as! [String]
                    }
                }
            }
            public class SupportedInstanceTypesList : Tea.TeaModel {
                public var supportedInstanceTypesList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypesList != nil {
                        map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedInstanceTypesList") {
                        self.supportedInstanceTypesList = dict["SupportedInstanceTypesList"] as! [String]
                    }
                }
            }
            public var cores: Int32?

            public var cpuOverCommitRatioRange: String?

            public var dedicatedHostType: String?

            public var GPUSpec: String?

            public var localStorageAmount: Int32?

            public var localStorageCapacity: Int64?

            public var localStorageCategory: String?

            public var memorySize: Double?

            public var physicalGpus: Int32?

            public var sockets: Int32?

            public var supportCpuOverCommitRatio: Bool?

            public var supportedInstanceTypeFamilies: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypeFamilies?

            public var supportedInstanceTypesList: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypesList?

            public var totalVcpus: Int32?

            public var totalVgpus: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.supportedInstanceTypeFamilies?.validate()
                try self.supportedInstanceTypesList?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.cpuOverCommitRatioRange != nil {
                    map["CpuOverCommitRatioRange"] = self.cpuOverCommitRatioRange!
                }
                if self.dedicatedHostType != nil {
                    map["DedicatedHostType"] = self.dedicatedHostType!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.localStorageAmount != nil {
                    map["LocalStorageAmount"] = self.localStorageAmount!
                }
                if self.localStorageCapacity != nil {
                    map["LocalStorageCapacity"] = self.localStorageCapacity!
                }
                if self.localStorageCategory != nil {
                    map["LocalStorageCategory"] = self.localStorageCategory!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                if self.physicalGpus != nil {
                    map["PhysicalGpus"] = self.physicalGpus!
                }
                if self.sockets != nil {
                    map["Sockets"] = self.sockets!
                }
                if self.supportCpuOverCommitRatio != nil {
                    map["SupportCpuOverCommitRatio"] = self.supportCpuOverCommitRatio!
                }
                if self.supportedInstanceTypeFamilies != nil {
                    map["SupportedInstanceTypeFamilies"] = self.supportedInstanceTypeFamilies?.toMap()
                }
                if self.supportedInstanceTypesList != nil {
                    map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList?.toMap()
                }
                if self.totalVcpus != nil {
                    map["TotalVcpus"] = self.totalVcpus!
                }
                if self.totalVgpus != nil {
                    map["TotalVgpus"] = self.totalVgpus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cores") {
                    self.cores = dict["Cores"] as! Int32
                }
                if dict.keys.contains("CpuOverCommitRatioRange") {
                    self.cpuOverCommitRatioRange = dict["CpuOverCommitRatioRange"] as! String
                }
                if dict.keys.contains("DedicatedHostType") {
                    self.dedicatedHostType = dict["DedicatedHostType"] as! String
                }
                if dict.keys.contains("GPUSpec") {
                    self.GPUSpec = dict["GPUSpec"] as! String
                }
                if dict.keys.contains("LocalStorageAmount") {
                    self.localStorageAmount = dict["LocalStorageAmount"] as! Int32
                }
                if dict.keys.contains("LocalStorageCapacity") {
                    self.localStorageCapacity = dict["LocalStorageCapacity"] as! Int64
                }
                if dict.keys.contains("LocalStorageCategory") {
                    self.localStorageCategory = dict["LocalStorageCategory"] as! String
                }
                if dict.keys.contains("MemorySize") {
                    self.memorySize = dict["MemorySize"] as! Double
                }
                if dict.keys.contains("PhysicalGpus") {
                    self.physicalGpus = dict["PhysicalGpus"] as! Int32
                }
                if dict.keys.contains("Sockets") {
                    self.sockets = dict["Sockets"] as! Int32
                }
                if dict.keys.contains("SupportCpuOverCommitRatio") {
                    self.supportCpuOverCommitRatio = dict["SupportCpuOverCommitRatio"] as! Bool
                }
                if dict.keys.contains("SupportedInstanceTypeFamilies") {
                    var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypeFamilies()
                    model.fromMap(dict["SupportedInstanceTypeFamilies"] as! [String: Any])
                    self.supportedInstanceTypeFamilies = model
                }
                if dict.keys.contains("SupportedInstanceTypesList") {
                    var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType.SupportedInstanceTypesList()
                    model.fromMap(dict["SupportedInstanceTypesList"] as! [String: Any])
                    self.supportedInstanceTypesList = model
                }
                if dict.keys.contains("TotalVcpus") {
                    self.totalVcpus = dict["TotalVcpus"] as! Int32
                }
                if dict.keys.contains("TotalVgpus") {
                    self.totalVgpus = dict["TotalVgpus"] as! Int32
                }
            }
        }
        public var dedicatedHostType: [DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostType != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHostType! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHostType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostType") {
                var tmp : [DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType] = []
                for v in dict["DedicatedHostType"] as! [Any] {
                    var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes.DedicatedHostType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dedicatedHostType = tmp
            }
        }
    }
    public var dedicatedHostTypes: DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostTypes != nil {
            map["DedicatedHostTypes"] = self.dedicatedHostTypes?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostTypes") {
            var model = DescribeDedicatedHostTypesResponseBody.DedicatedHostTypes()
            model.fromMap(dict["DedicatedHostTypes"] as! [String: Any])
            self.dedicatedHostTypes = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDedicatedHostTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDedicatedHostsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dedicatedHostClusterId: String?

    public var dedicatedHostIds: String?

    public var dedicatedHostName: String?

    public var dedicatedHostType: String?

    public var lockReason: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var socketDetails: String?

    public var status: String?

    public var tag: [DescribeDedicatedHostsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.socketDetails != nil {
            map["SocketDetails"] = self.socketDetails!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostIds") {
            self.dedicatedHostIds = dict["DedicatedHostIds"] as! String
        }
        if dict.keys.contains("DedicatedHostName") {
            self.dedicatedHostName = dict["DedicatedHostName"] as! String
        }
        if dict.keys.contains("DedicatedHostType") {
            self.dedicatedHostType = dict["DedicatedHostType"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SocketDetails") {
            self.socketDetails = dict["SocketDetails"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeDedicatedHostsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDedicatedHostsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDedicatedHostsResponseBody : Tea.TeaModel {
    public class DedicatedHosts : Tea.TeaModel {
        public class DedicatedHost : Tea.TeaModel {
            public class SchedulerOptions : Tea.TeaModel {
                public var managedPrivateSpaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.managedPrivateSpaceId != nil {
                        map["ManagedPrivateSpaceId"] = self.managedPrivateSpaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ManagedPrivateSpaceId") {
                        self.managedPrivateSpaceId = dict["ManagedPrivateSpaceId"] as! String
                    }
                }
            }
            public class Capacity : Tea.TeaModel {
                public class SocketCapacities : Tea.TeaModel {
                    public class SocketCapacity : Tea.TeaModel {
                        public var availableMemory: Double?

                        public var availableVcpu: Int32?

                        public var socketId: Int32?

                        public var totalMemory: Double?

                        public var totalVcpu: Int32?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.availableMemory != nil {
                                map["AvailableMemory"] = self.availableMemory!
                            }
                            if self.availableVcpu != nil {
                                map["AvailableVcpu"] = self.availableVcpu!
                            }
                            if self.socketId != nil {
                                map["SocketId"] = self.socketId!
                            }
                            if self.totalMemory != nil {
                                map["TotalMemory"] = self.totalMemory!
                            }
                            if self.totalVcpu != nil {
                                map["TotalVcpu"] = self.totalVcpu!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AvailableMemory") {
                                self.availableMemory = dict["AvailableMemory"] as! Double
                            }
                            if dict.keys.contains("AvailableVcpu") {
                                self.availableVcpu = dict["AvailableVcpu"] as! Int32
                            }
                            if dict.keys.contains("SocketId") {
                                self.socketId = dict["SocketId"] as! Int32
                            }
                            if dict.keys.contains("TotalMemory") {
                                self.totalMemory = dict["TotalMemory"] as! Double
                            }
                            if dict.keys.contains("TotalVcpu") {
                                self.totalVcpu = dict["TotalVcpu"] as! Int32
                            }
                        }
                    }
                    public var socketCapacity: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities.SocketCapacity]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.socketCapacity != nil {
                            var tmp : [Any] = []
                            for k in self.socketCapacity! {
                                tmp.append(k.toMap())
                            }
                            map["SocketCapacity"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SocketCapacity") {
                            var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities.SocketCapacity] = []
                            for v in dict["SocketCapacity"] as! [Any] {
                                var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities.SocketCapacity()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.socketCapacity = tmp
                        }
                    }
                }
                public var availableLocalStorage: Int32?

                public var availableMemory: Double?

                public var availableVcpus: Int32?

                public var availableVgpus: Int32?

                public var localStorageCategory: String?

                public var socketCapacities: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities?

                public var totalLocalStorage: Int32?

                public var totalMemory: Double?

                public var totalVcpus: Int32?

                public var totalVgpus: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.socketCapacities?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableLocalStorage != nil {
                        map["AvailableLocalStorage"] = self.availableLocalStorage!
                    }
                    if self.availableMemory != nil {
                        map["AvailableMemory"] = self.availableMemory!
                    }
                    if self.availableVcpus != nil {
                        map["AvailableVcpus"] = self.availableVcpus!
                    }
                    if self.availableVgpus != nil {
                        map["AvailableVgpus"] = self.availableVgpus!
                    }
                    if self.localStorageCategory != nil {
                        map["LocalStorageCategory"] = self.localStorageCategory!
                    }
                    if self.socketCapacities != nil {
                        map["SocketCapacities"] = self.socketCapacities?.toMap()
                    }
                    if self.totalLocalStorage != nil {
                        map["TotalLocalStorage"] = self.totalLocalStorage!
                    }
                    if self.totalMemory != nil {
                        map["TotalMemory"] = self.totalMemory!
                    }
                    if self.totalVcpus != nil {
                        map["TotalVcpus"] = self.totalVcpus!
                    }
                    if self.totalVgpus != nil {
                        map["TotalVgpus"] = self.totalVgpus!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableLocalStorage") {
                        self.availableLocalStorage = dict["AvailableLocalStorage"] as! Int32
                    }
                    if dict.keys.contains("AvailableMemory") {
                        self.availableMemory = dict["AvailableMemory"] as! Double
                    }
                    if dict.keys.contains("AvailableVcpus") {
                        self.availableVcpus = dict["AvailableVcpus"] as! Int32
                    }
                    if dict.keys.contains("AvailableVgpus") {
                        self.availableVgpus = dict["AvailableVgpus"] as! Int32
                    }
                    if dict.keys.contains("LocalStorageCategory") {
                        self.localStorageCategory = dict["LocalStorageCategory"] as! String
                    }
                    if dict.keys.contains("SocketCapacities") {
                        var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity.SocketCapacities()
                        model.fromMap(dict["SocketCapacities"] as! [String: Any])
                        self.socketCapacities = model
                    }
                    if dict.keys.contains("TotalLocalStorage") {
                        self.totalLocalStorage = dict["TotalLocalStorage"] as! Int32
                    }
                    if dict.keys.contains("TotalMemory") {
                        self.totalMemory = dict["TotalMemory"] as! Double
                    }
                    if dict.keys.contains("TotalVcpus") {
                        self.totalVcpus = dict["TotalVcpus"] as! Int32
                    }
                    if dict.keys.contains("TotalVgpus") {
                        self.totalVgpus = dict["TotalVgpus"] as! Int32
                    }
                }
            }
            public class HostDetailInfo : Tea.TeaModel {
                public var serialNumber: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.serialNumber != nil {
                        map["SerialNumber"] = self.serialNumber!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SerialNumber") {
                        self.serialNumber = dict["SerialNumber"] as! String
                    }
                }
            }
            public class Instances : Tea.TeaModel {
                public class Instance : Tea.TeaModel {
                    public var instanceId: String?

                    public var instanceOwnerId: Int64?

                    public var instanceType: String?

                    public var socketId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceOwnerId != nil {
                            map["InstanceOwnerId"] = self.instanceOwnerId!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.socketId != nil {
                            map["SocketId"] = self.socketId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("InstanceOwnerId") {
                            self.instanceOwnerId = dict["InstanceOwnerId"] as! Int64
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("SocketId") {
                            self.socketId = dict["SocketId"] as! String
                        }
                    }
                }
                public var instance: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instance != nil {
                        var tmp : [Any] = []
                        for k in self.instance! {
                            tmp.append(k.toMap())
                        }
                        map["Instance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Instance") {
                        var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance] = []
                        for v in dict["Instance"] as! [Any] {
                            var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances.Instance()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.instance = tmp
                    }
                }
            }
            public class NetworkAttributes : Tea.TeaModel {
                public var slbUdpTimeout: Int32?

                public var udpTimeout: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.slbUdpTimeout != nil {
                        map["SlbUdpTimeout"] = self.slbUdpTimeout!
                    }
                    if self.udpTimeout != nil {
                        map["UdpTimeout"] = self.udpTimeout!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SlbUdpTimeout") {
                        self.slbUdpTimeout = dict["SlbUdpTimeout"] as! Int32
                    }
                    if dict.keys.contains("UdpTimeout") {
                        self.udpTimeout = dict["UdpTimeout"] as! Int32
                    }
                }
            }
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var operationLock: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OperationLock") {
                        var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock] = []
                        for v in dict["OperationLock"] as! [Any] {
                            var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks.OperationLock()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.operationLock = tmp
                    }
                }
            }
            public class SupportedCustomInstanceTypeFamilies : Tea.TeaModel {
                public var supportedCustomInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedCustomInstanceTypeFamily != nil {
                        map["SupportedCustomInstanceTypeFamily"] = self.supportedCustomInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedCustomInstanceTypeFamily") {
                        self.supportedCustomInstanceTypeFamily = dict["SupportedCustomInstanceTypeFamily"] as! [String]
                    }
                }
            }
            public class SupportedInstanceTypeFamilies : Tea.TeaModel {
                public var supportedInstanceTypeFamily: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypeFamily != nil {
                        map["SupportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedInstanceTypeFamily") {
                        self.supportedInstanceTypeFamily = dict["SupportedInstanceTypeFamily"] as! [String]
                    }
                }
            }
            public class SupportedInstanceTypesList : Tea.TeaModel {
                public var supportedInstanceTypesList: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedInstanceTypesList != nil {
                        map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedInstanceTypesList") {
                        self.supportedInstanceTypesList = dict["SupportedInstanceTypesList"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var schedulerOptions: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SchedulerOptions?

            public var actionOnMaintenance: String?

            public var autoPlacement: String?

            public var autoReleaseTime: String?

            public var capacity: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity?

            public var chargeType: String?

            public var cores: Int32?

            public var cpuOverCommitRatio: Double?

            public var creationTime: String?

            public var dedicatedHostClusterId: String?

            public var dedicatedHostId: String?

            public var dedicatedHostName: String?

            public var dedicatedHostOwnerId: Int64?

            public var dedicatedHostType: String?

            public var description_: String?

            public var expiredTime: String?

            public var GPUSpec: String?

            public var hostDetailInfo: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.HostDetailInfo?

            public var instances: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances?

            public var machineId: String?

            public var networkAttributes: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.NetworkAttributes?

            public var operationLocks: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks?

            public var physicalGpus: Int32?

            public var regionId: String?

            public var resourceGroupId: String?

            public var saleCycle: String?

            public var sockets: Int32?

            public var status: String?

            public var supportedCustomInstanceTypeFamilies: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedCustomInstanceTypeFamilies?

            public var supportedInstanceTypeFamilies: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypeFamilies?

            public var supportedInstanceTypesList: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypesList?

            public var tags: DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.schedulerOptions?.validate()
                try self.capacity?.validate()
                try self.hostDetailInfo?.validate()
                try self.instances?.validate()
                try self.networkAttributes?.validate()
                try self.operationLocks?.validate()
                try self.supportedCustomInstanceTypeFamilies?.validate()
                try self.supportedInstanceTypeFamilies?.validate()
                try self.supportedInstanceTypesList?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.schedulerOptions != nil {
                    map["SchedulerOptions"] = self.schedulerOptions?.toMap()
                }
                if self.actionOnMaintenance != nil {
                    map["ActionOnMaintenance"] = self.actionOnMaintenance!
                }
                if self.autoPlacement != nil {
                    map["AutoPlacement"] = self.autoPlacement!
                }
                if self.autoReleaseTime != nil {
                    map["AutoReleaseTime"] = self.autoReleaseTime!
                }
                if self.capacity != nil {
                    map["Capacity"] = self.capacity?.toMap()
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.cores != nil {
                    map["Cores"] = self.cores!
                }
                if self.cpuOverCommitRatio != nil {
                    map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.dedicatedHostClusterId != nil {
                    map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                }
                if self.dedicatedHostId != nil {
                    map["DedicatedHostId"] = self.dedicatedHostId!
                }
                if self.dedicatedHostName != nil {
                    map["DedicatedHostName"] = self.dedicatedHostName!
                }
                if self.dedicatedHostOwnerId != nil {
                    map["DedicatedHostOwnerId"] = self.dedicatedHostOwnerId!
                }
                if self.dedicatedHostType != nil {
                    map["DedicatedHostType"] = self.dedicatedHostType!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.hostDetailInfo != nil {
                    map["HostDetailInfo"] = self.hostDetailInfo?.toMap()
                }
                if self.instances != nil {
                    map["Instances"] = self.instances?.toMap()
                }
                if self.machineId != nil {
                    map["MachineId"] = self.machineId!
                }
                if self.networkAttributes != nil {
                    map["NetworkAttributes"] = self.networkAttributes?.toMap()
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.physicalGpus != nil {
                    map["PhysicalGpus"] = self.physicalGpus!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.saleCycle != nil {
                    map["SaleCycle"] = self.saleCycle!
                }
                if self.sockets != nil {
                    map["Sockets"] = self.sockets!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supportedCustomInstanceTypeFamilies != nil {
                    map["SupportedCustomInstanceTypeFamilies"] = self.supportedCustomInstanceTypeFamilies?.toMap()
                }
                if self.supportedInstanceTypeFamilies != nil {
                    map["SupportedInstanceTypeFamilies"] = self.supportedInstanceTypeFamilies?.toMap()
                }
                if self.supportedInstanceTypesList != nil {
                    map["SupportedInstanceTypesList"] = self.supportedInstanceTypesList?.toMap()
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SchedulerOptions") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SchedulerOptions()
                    model.fromMap(dict["SchedulerOptions"] as! [String: Any])
                    self.schedulerOptions = model
                }
                if dict.keys.contains("ActionOnMaintenance") {
                    self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
                }
                if dict.keys.contains("AutoPlacement") {
                    self.autoPlacement = dict["AutoPlacement"] as! String
                }
                if dict.keys.contains("AutoReleaseTime") {
                    self.autoReleaseTime = dict["AutoReleaseTime"] as! String
                }
                if dict.keys.contains("Capacity") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Capacity()
                    model.fromMap(dict["Capacity"] as! [String: Any])
                    self.capacity = model
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("Cores") {
                    self.cores = dict["Cores"] as! Int32
                }
                if dict.keys.contains("CpuOverCommitRatio") {
                    self.cpuOverCommitRatio = dict["CpuOverCommitRatio"] as! Double
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DedicatedHostClusterId") {
                    self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
                }
                if dict.keys.contains("DedicatedHostId") {
                    self.dedicatedHostId = dict["DedicatedHostId"] as! String
                }
                if dict.keys.contains("DedicatedHostName") {
                    self.dedicatedHostName = dict["DedicatedHostName"] as! String
                }
                if dict.keys.contains("DedicatedHostOwnerId") {
                    self.dedicatedHostOwnerId = dict["DedicatedHostOwnerId"] as! Int64
                }
                if dict.keys.contains("DedicatedHostType") {
                    self.dedicatedHostType = dict["DedicatedHostType"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("GPUSpec") {
                    self.GPUSpec = dict["GPUSpec"] as! String
                }
                if dict.keys.contains("HostDetailInfo") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.HostDetailInfo()
                    model.fromMap(dict["HostDetailInfo"] as! [String: Any])
                    self.hostDetailInfo = model
                }
                if dict.keys.contains("Instances") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Instances()
                    model.fromMap(dict["Instances"] as! [String: Any])
                    self.instances = model
                }
                if dict.keys.contains("MachineId") {
                    self.machineId = dict["MachineId"] as! String
                }
                if dict.keys.contains("NetworkAttributes") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.NetworkAttributes()
                    model.fromMap(dict["NetworkAttributes"] as! [String: Any])
                    self.networkAttributes = model
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("PhysicalGpus") {
                    self.physicalGpus = dict["PhysicalGpus"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SaleCycle") {
                    self.saleCycle = dict["SaleCycle"] as! String
                }
                if dict.keys.contains("Sockets") {
                    self.sockets = dict["Sockets"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SupportedCustomInstanceTypeFamilies") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedCustomInstanceTypeFamilies()
                    model.fromMap(dict["SupportedCustomInstanceTypeFamilies"] as! [String: Any])
                    self.supportedCustomInstanceTypeFamilies = model
                }
                if dict.keys.contains("SupportedInstanceTypeFamilies") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypeFamilies()
                    model.fromMap(dict["SupportedInstanceTypeFamilies"] as! [String: Any])
                    self.supportedInstanceTypeFamilies = model
                }
                if dict.keys.contains("SupportedInstanceTypesList") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.SupportedInstanceTypesList()
                    model.fromMap(dict["SupportedInstanceTypesList"] as! [String: Any])
                    self.supportedInstanceTypesList = model
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var dedicatedHost: [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHost != nil {
                var tmp : [Any] = []
                for k in self.dedicatedHost! {
                    tmp.append(k.toMap())
                }
                map["DedicatedHost"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHost") {
                var tmp : [DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost] = []
                for v in dict["DedicatedHost"] as! [Any] {
                    var model = DescribeDedicatedHostsResponseBody.DedicatedHosts.DedicatedHost()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dedicatedHost = tmp
            }
        }
    }
    public var dedicatedHosts: DescribeDedicatedHostsResponseBody.DedicatedHosts?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHosts?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHosts != nil {
            map["DedicatedHosts"] = self.dedicatedHosts?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHosts") {
            var model = DescribeDedicatedHostsResponseBody.DedicatedHosts()
            model.fromMap(dict["DedicatedHosts"] as! [String: Any])
            self.dedicatedHosts = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDedicatedHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDemandsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var demandId: String?

    public var demandStatus: [String]?

    public var demandType: String?

    public var dryRun: Bool?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var instanceTypeFamily: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeDemandsRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.demandStatus != nil {
            map["DemandStatus"] = self.demandStatus!
        }
        if self.demandType != nil {
            map["DemandType"] = self.demandType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("DemandStatus") {
            self.demandStatus = dict["DemandStatus"] as! [String]
        }
        if dict.keys.contains("DemandType") {
            self.demandType = dict["DemandType"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeDemandsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDemandsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDemandsResponseBody : Tea.TeaModel {
    public class Demands : Tea.TeaModel {
        public class Demand : Tea.TeaModel {
            public class SupplyInfos : Tea.TeaModel {
                public class SupplyInfo : Tea.TeaModel {
                    public var amount: Int32?

                    public var privatePoolId: String?

                    public var supplyEndTime: String?

                    public var supplyStartTime: String?

                    public var supplyStatus: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.amount != nil {
                            map["Amount"] = self.amount!
                        }
                        if self.privatePoolId != nil {
                            map["PrivatePoolId"] = self.privatePoolId!
                        }
                        if self.supplyEndTime != nil {
                            map["SupplyEndTime"] = self.supplyEndTime!
                        }
                        if self.supplyStartTime != nil {
                            map["SupplyStartTime"] = self.supplyStartTime!
                        }
                        if self.supplyStatus != nil {
                            map["SupplyStatus"] = self.supplyStatus!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Amount") {
                            self.amount = dict["Amount"] as! Int32
                        }
                        if dict.keys.contains("PrivatePoolId") {
                            self.privatePoolId = dict["PrivatePoolId"] as! String
                        }
                        if dict.keys.contains("SupplyEndTime") {
                            self.supplyEndTime = dict["SupplyEndTime"] as! String
                        }
                        if dict.keys.contains("SupplyStartTime") {
                            self.supplyStartTime = dict["SupplyStartTime"] as! String
                        }
                        if dict.keys.contains("SupplyStatus") {
                            self.supplyStatus = dict["SupplyStatus"] as! String
                        }
                    }
                }
                public var supplyInfo: [DescribeDemandsResponseBody.Demands.Demand.SupplyInfos.SupplyInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supplyInfo != nil {
                        var tmp : [Any] = []
                        for k in self.supplyInfo! {
                            tmp.append(k.toMap())
                        }
                        map["SupplyInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupplyInfo") {
                        var tmp : [DescribeDemandsResponseBody.Demands.Demand.SupplyInfos.SupplyInfo] = []
                        for v in dict["SupplyInfo"] as! [Any] {
                            var model = DescribeDemandsResponseBody.Demands.Demand.SupplyInfos.SupplyInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.supplyInfo = tmp
                    }
                }
            }
            public var availableAmount: Int32?

            public var comment: String?

            public var deliveringAmount: Int32?

            public var demandDescription: String?

            public var demandId: String?

            public var demandName: String?

            public var demandStatus: String?

            public var demandTime: String?

            public var endTime: String?

            public var instanceChargeType: String?

            public var instanceType: String?

            public var instanceTypeFamily: String?

            public var period: Int32?

            public var periodUnit: String?

            public var startTime: String?

            public var supplyInfos: DescribeDemandsResponseBody.Demands.Demand.SupplyInfos?

            public var totalAmount: Int32?

            public var usedAmount: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.supplyInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableAmount != nil {
                    map["AvailableAmount"] = self.availableAmount!
                }
                if self.comment != nil {
                    map["Comment"] = self.comment!
                }
                if self.deliveringAmount != nil {
                    map["DeliveringAmount"] = self.deliveringAmount!
                }
                if self.demandDescription != nil {
                    map["DemandDescription"] = self.demandDescription!
                }
                if self.demandId != nil {
                    map["DemandId"] = self.demandId!
                }
                if self.demandName != nil {
                    map["DemandName"] = self.demandName!
                }
                if self.demandStatus != nil {
                    map["DemandStatus"] = self.demandStatus!
                }
                if self.demandTime != nil {
                    map["DemandTime"] = self.demandTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.period != nil {
                    map["Period"] = self.period!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.supplyInfos != nil {
                    map["SupplyInfos"] = self.supplyInfos?.toMap()
                }
                if self.totalAmount != nil {
                    map["TotalAmount"] = self.totalAmount!
                }
                if self.usedAmount != nil {
                    map["UsedAmount"] = self.usedAmount!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableAmount") {
                    self.availableAmount = dict["AvailableAmount"] as! Int32
                }
                if dict.keys.contains("Comment") {
                    self.comment = dict["Comment"] as! String
                }
                if dict.keys.contains("DeliveringAmount") {
                    self.deliveringAmount = dict["DeliveringAmount"] as! Int32
                }
                if dict.keys.contains("DemandDescription") {
                    self.demandDescription = dict["DemandDescription"] as! String
                }
                if dict.keys.contains("DemandId") {
                    self.demandId = dict["DemandId"] as! String
                }
                if dict.keys.contains("DemandName") {
                    self.demandName = dict["DemandName"] as! String
                }
                if dict.keys.contains("DemandStatus") {
                    self.demandStatus = dict["DemandStatus"] as! String
                }
                if dict.keys.contains("DemandTime") {
                    self.demandTime = dict["DemandTime"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InstanceTypeFamily") {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("Period") {
                    self.period = dict["Period"] as! Int32
                }
                if dict.keys.contains("PeriodUnit") {
                    self.periodUnit = dict["PeriodUnit"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("SupplyInfos") {
                    var model = DescribeDemandsResponseBody.Demands.Demand.SupplyInfos()
                    model.fromMap(dict["SupplyInfos"] as! [String: Any])
                    self.supplyInfos = model
                }
                if dict.keys.contains("TotalAmount") {
                    self.totalAmount = dict["TotalAmount"] as! Int32
                }
                if dict.keys.contains("UsedAmount") {
                    self.usedAmount = dict["UsedAmount"] as! Int32
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var demand: [DescribeDemandsResponseBody.Demands.Demand]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.demand != nil {
                var tmp : [Any] = []
                for k in self.demand! {
                    tmp.append(k.toMap())
                }
                map["Demand"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Demand") {
                var tmp : [DescribeDemandsResponseBody.Demands.Demand] = []
                for v in dict["Demand"] as! [Any] {
                    var model = DescribeDemandsResponseBody.Demands.Demand()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.demand = tmp
            }
        }
    }
    public var demands: DescribeDemandsResponseBody.Demands?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.demands?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.demands != nil {
            map["Demands"] = self.demands?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Demands") {
            var model = DescribeDemandsResponseBody.Demands()
            model.fromMap(dict["Demands"] as! [String: Any])
            self.demands = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDemandsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDemandsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDemandsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeploymentSetSupportedInstanceTypeFamilyRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var strategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Strategy") {
            self.strategy = dict["Strategy"] as! String
        }
    }
}

public class DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody : Tea.TeaModel {
    public var instanceTypeFamilies: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTypeFamilies") {
            self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDeploymentSetSupportedInstanceTypeFamilyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDeploymentSetSupportedInstanceTypeFamilyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDeploymentSetsRequest : Tea.TeaModel {
    public var deploymentSetIds: String?

    public var deploymentSetName: String?

    public var domain: String?

    public var granularity: String?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var strategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetIds != nil {
            map["DeploymentSetIds"] = self.deploymentSetIds!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.domain != nil {
            map["Domain"] = self.domain!
        }
        if self.granularity != nil {
            map["Granularity"] = self.granularity!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.strategy != nil {
            map["Strategy"] = self.strategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentSetIds") {
            self.deploymentSetIds = dict["DeploymentSetIds"] as! String
        }
        if dict.keys.contains("DeploymentSetName") {
            self.deploymentSetName = dict["DeploymentSetName"] as! String
        }
        if dict.keys.contains("Domain") {
            self.domain = dict["Domain"] as! String
        }
        if dict.keys.contains("Granularity") {
            self.granularity = dict["Granularity"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Strategy") {
            self.strategy = dict["Strategy"] as! String
        }
    }
}

public class DescribeDeploymentSetsResponseBody : Tea.TeaModel {
    public class DeploymentSets : Tea.TeaModel {
        public class DeploymentSet : Tea.TeaModel {
            public class Capacities : Tea.TeaModel {
                public class Capacity : Tea.TeaModel {
                    public var availableAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableAmount != nil {
                            map["AvailableAmount"] = self.availableAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["ZoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableAmount") {
                            self.availableAmount = dict["AvailableAmount"] as! Int32
                        }
                        if dict.keys.contains("UsedAmount") {
                            self.usedAmount = dict["UsedAmount"] as! Int32
                        }
                        if dict.keys.contains("ZoneId") {
                            self.zoneId = dict["ZoneId"] as! String
                        }
                    }
                }
                public var capacity: [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.capacity != nil {
                        var tmp : [Any] = []
                        for k in self.capacity! {
                            tmp.append(k.toMap())
                        }
                        map["Capacity"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Capacity") {
                        var tmp : [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity] = []
                        for v in dict["Capacity"] as! [Any] {
                            var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities.Capacity()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.capacity = tmp
                    }
                }
            }
            public class InstanceIds : Tea.TeaModel {
                public var instanceId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! [String]
                    }
                }
            }
            public var capacities: DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities?

            public var creationTime: String?

            public var deploymentSetDescription: String?

            public var deploymentSetId: String?

            public var deploymentSetName: String?

            public var deploymentStrategy: String?

            public var domain: String?

            public var granularity: String?

            public var groupCount: Int32?

            public var instanceAmount: Int32?

            public var instanceIds: DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.InstanceIds?

            public var strategy: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.capacities?.validate()
                try self.instanceIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.capacities != nil {
                    map["Capacities"] = self.capacities?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deploymentSetDescription != nil {
                    map["DeploymentSetDescription"] = self.deploymentSetDescription!
                }
                if self.deploymentSetId != nil {
                    map["DeploymentSetId"] = self.deploymentSetId!
                }
                if self.deploymentSetName != nil {
                    map["DeploymentSetName"] = self.deploymentSetName!
                }
                if self.deploymentStrategy != nil {
                    map["DeploymentStrategy"] = self.deploymentStrategy!
                }
                if self.domain != nil {
                    map["Domain"] = self.domain!
                }
                if self.granularity != nil {
                    map["Granularity"] = self.granularity!
                }
                if self.groupCount != nil {
                    map["GroupCount"] = self.groupCount!
                }
                if self.instanceAmount != nil {
                    map["InstanceAmount"] = self.instanceAmount!
                }
                if self.instanceIds != nil {
                    map["InstanceIds"] = self.instanceIds?.toMap()
                }
                if self.strategy != nil {
                    map["Strategy"] = self.strategy!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Capacities") {
                    var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.Capacities()
                    model.fromMap(dict["Capacities"] as! [String: Any])
                    self.capacities = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeploymentSetDescription") {
                    self.deploymentSetDescription = dict["DeploymentSetDescription"] as! String
                }
                if dict.keys.contains("DeploymentSetId") {
                    self.deploymentSetId = dict["DeploymentSetId"] as! String
                }
                if dict.keys.contains("DeploymentSetName") {
                    self.deploymentSetName = dict["DeploymentSetName"] as! String
                }
                if dict.keys.contains("DeploymentStrategy") {
                    self.deploymentStrategy = dict["DeploymentStrategy"] as! String
                }
                if dict.keys.contains("Domain") {
                    self.domain = dict["Domain"] as! String
                }
                if dict.keys.contains("Granularity") {
                    self.granularity = dict["Granularity"] as! String
                }
                if dict.keys.contains("GroupCount") {
                    self.groupCount = dict["GroupCount"] as! Int32
                }
                if dict.keys.contains("InstanceAmount") {
                    self.instanceAmount = dict["InstanceAmount"] as! Int32
                }
                if dict.keys.contains("InstanceIds") {
                    var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet.InstanceIds()
                    model.fromMap(dict["InstanceIds"] as! [String: Any])
                    self.instanceIds = model
                }
                if dict.keys.contains("Strategy") {
                    self.strategy = dict["Strategy"] as! String
                }
            }
        }
        public var deploymentSet: [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deploymentSet != nil {
                var tmp : [Any] = []
                for k in self.deploymentSet! {
                    tmp.append(k.toMap())
                }
                map["DeploymentSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeploymentSet") {
                var tmp : [DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet] = []
                for v in dict["DeploymentSet"] as! [Any] {
                    var model = DescribeDeploymentSetsResponseBody.DeploymentSets.DeploymentSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.deploymentSet = tmp
            }
        }
    }
    public var deploymentSets: DescribeDeploymentSetsResponseBody.DeploymentSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.deploymentSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSets != nil {
            map["DeploymentSets"] = self.deploymentSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentSets") {
            var model = DescribeDeploymentSetsResponseBody.DeploymentSets()
            model.fromMap(dict["DeploymentSets"] as! [String: Any])
            self.deploymentSets = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDeploymentSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDeploymentSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDeploymentSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosticMetricSetsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var metricSetIds: [String]?

    public var nextToken: String?

    public var regionId: String?

    public var resourceType: String?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.metricSetIds != nil {
            map["MetricSetIds"] = self.metricSetIds!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MetricSetIds") {
            self.metricSetIds = dict["MetricSetIds"] as! [String]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class DescribeDiagnosticMetricSetsResponseBody : Tea.TeaModel {
    public class MetricSets : Tea.TeaModel {
        public var description_: String?

        public var metricIds: [String]?

        public var metricSetId: String?

        public var metricSetName: String?

        public var resourceType: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.metricIds != nil {
                map["MetricIds"] = self.metricIds!
            }
            if self.metricSetId != nil {
                map["MetricSetId"] = self.metricSetId!
            }
            if self.metricSetName != nil {
                map["MetricSetName"] = self.metricSetName!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("MetricIds") {
                self.metricIds = dict["MetricIds"] as! [String]
            }
            if dict.keys.contains("MetricSetId") {
                self.metricSetId = dict["MetricSetId"] as! String
            }
            if dict.keys.contains("MetricSetName") {
                self.metricSetName = dict["MetricSetName"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var metricSets: [DescribeDiagnosticMetricSetsResponseBody.MetricSets]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metricSets != nil {
            var tmp : [Any] = []
            for k in self.metricSets! {
                tmp.append(k.toMap())
            }
            map["MetricSets"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MetricSets") {
            var tmp : [DescribeDiagnosticMetricSetsResponseBody.MetricSets] = []
            for v in dict["MetricSets"] as! [Any] {
                var model = DescribeDiagnosticMetricSetsResponseBody.MetricSets()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metricSets = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiagnosticMetricSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticMetricSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosticMetricSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosticMetricsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var metricIds: [String]?

    public var nextToken: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.metricIds != nil {
            map["MetricIds"] = self.metricIds!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MetricIds") {
            self.metricIds = dict["MetricIds"] as! [String]
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeDiagnosticMetricsResponseBody : Tea.TeaModel {
    public class Metrics : Tea.TeaModel {
        public var description_: String?

        public var guestMetric: Bool?

        public var metricCategory: String?

        public var metricId: String?

        public var metricName: String?

        public var resourceType: String?

        public var supportedOperatingSystem: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.guestMetric != nil {
                map["GuestMetric"] = self.guestMetric!
            }
            if self.metricCategory != nil {
                map["MetricCategory"] = self.metricCategory!
            }
            if self.metricId != nil {
                map["MetricId"] = self.metricId!
            }
            if self.metricName != nil {
                map["MetricName"] = self.metricName!
            }
            if self.resourceType != nil {
                map["ResourceType"] = self.resourceType!
            }
            if self.supportedOperatingSystem != nil {
                map["SupportedOperatingSystem"] = self.supportedOperatingSystem!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("GuestMetric") {
                self.guestMetric = dict["GuestMetric"] as! Bool
            }
            if dict.keys.contains("MetricCategory") {
                self.metricCategory = dict["MetricCategory"] as! String
            }
            if dict.keys.contains("MetricId") {
                self.metricId = dict["MetricId"] as! String
            }
            if dict.keys.contains("MetricName") {
                self.metricName = dict["MetricName"] as! String
            }
            if dict.keys.contains("ResourceType") {
                self.resourceType = dict["ResourceType"] as! String
            }
            if dict.keys.contains("SupportedOperatingSystem") {
                self.supportedOperatingSystem = dict["SupportedOperatingSystem"] as! String
            }
        }
    }
    public var metrics: [DescribeDiagnosticMetricsResponseBody.Metrics]?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.metrics != nil {
            var tmp : [Any] = []
            for k in self.metrics! {
                tmp.append(k.toMap())
            }
            map["Metrics"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Metrics") {
            var tmp : [DescribeDiagnosticMetricsResponseBody.Metrics] = []
            for v in dict["Metrics"] as! [Any] {
                var model = DescribeDiagnosticMetricsResponseBody.Metrics()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.metrics = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiagnosticMetricsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticMetricsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosticMetricsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosticReportAttributesRequest : Tea.TeaModel {
    public var regionId: String?

    public var reportId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
    }
}

public class DescribeDiagnosticReportAttributesResponseBody : Tea.TeaModel {
    public class MetricResults : Tea.TeaModel {
        public class MetricResult : Tea.TeaModel {
            public class Issues : Tea.TeaModel {
                public class Issue : Tea.TeaModel {
                    public var additional: String?

                    public var issueId: String?

                    public var occurrenceTime: String?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.additional != nil {
                            map["Additional"] = self.additional!
                        }
                        if self.issueId != nil {
                            map["IssueId"] = self.issueId!
                        }
                        if self.occurrenceTime != nil {
                            map["OccurrenceTime"] = self.occurrenceTime!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Additional") {
                            self.additional = dict["Additional"] as! String
                        }
                        if dict.keys.contains("IssueId") {
                            self.issueId = dict["IssueId"] as! String
                        }
                        if dict.keys.contains("OccurrenceTime") {
                            self.occurrenceTime = dict["OccurrenceTime"] as! String
                        }
                        if dict.keys.contains("Severity") {
                            self.severity = dict["Severity"] as! String
                        }
                    }
                }
                public var issue: [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues.Issue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.issue != nil {
                        var tmp : [Any] = []
                        for k in self.issue! {
                            tmp.append(k.toMap())
                        }
                        map["Issue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Issue") {
                        var tmp : [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues.Issue] = []
                        for v in dict["Issue"] as! [Any] {
                            var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues.Issue()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.issue = tmp
                    }
                }
            }
            public var issues: DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues?

            public var metricCategory: String?

            public var metricId: String?

            public var severity: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.issues?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.issues != nil {
                    map["Issues"] = self.issues?.toMap()
                }
                if self.metricCategory != nil {
                    map["MetricCategory"] = self.metricCategory!
                }
                if self.metricId != nil {
                    map["MetricId"] = self.metricId!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Issues") {
                    var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult.Issues()
                    model.fromMap(dict["Issues"] as! [String: Any])
                    self.issues = model
                }
                if dict.keys.contains("MetricCategory") {
                    self.metricCategory = dict["MetricCategory"] as! String
                }
                if dict.keys.contains("MetricId") {
                    self.metricId = dict["MetricId"] as! String
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var metricResult: [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.metricResult != nil {
                var tmp : [Any] = []
                for k in self.metricResult! {
                    tmp.append(k.toMap())
                }
                map["MetricResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MetricResult") {
                var tmp : [DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult] = []
                for v in dict["MetricResult"] as! [Any] {
                    var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults.MetricResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.metricResult = tmp
            }
        }
    }
    public var attributes: String?

    public var creationTime: String?

    public var endTime: String?

    public var finishedTime: String?

    public var metricResults: DescribeDiagnosticReportAttributesResponseBody.MetricResults?

    public var metricSetId: String?

    public var reportId: String?

    public var requestId: String?

    public var resourceId: String?

    public var resourceType: String?

    public var severity: String?

    public var startTime: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.metricResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attributes != nil {
            map["Attributes"] = self.attributes!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.finishedTime != nil {
            map["FinishedTime"] = self.finishedTime!
        }
        if self.metricResults != nil {
            map["MetricResults"] = self.metricResults?.toMap()
        }
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.reportId != nil {
            map["ReportId"] = self.reportId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attributes") {
            self.attributes = dict["Attributes"] as! String
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("FinishedTime") {
            self.finishedTime = dict["FinishedTime"] as! String
        }
        if dict.keys.contains("MetricResults") {
            var model = DescribeDiagnosticReportAttributesResponseBody.MetricResults()
            model.fromMap(dict["MetricResults"] as! [String: Any])
            self.metricResults = model
        }
        if dict.keys.contains("MetricSetId") {
            self.metricSetId = dict["MetricSetId"] as! String
        }
        if dict.keys.contains("ReportId") {
            self.reportId = dict["ReportId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeDiagnosticReportAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticReportAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosticReportAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiagnosticReportsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var regionId: String?

    public var reportIds: [String]?

    public var resourceIds: [String]?

    public var severity: String?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reportIds != nil {
            map["ReportIds"] = self.reportIds!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.severity != nil {
            map["Severity"] = self.severity!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReportIds") {
            self.reportIds = dict["ReportIds"] as! [String]
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("Severity") {
            self.severity = dict["Severity"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeDiagnosticReportsResponseBody : Tea.TeaModel {
    public class Reports : Tea.TeaModel {
        public class Report : Tea.TeaModel {
            public class Issues : Tea.TeaModel {
                public class Issue : Tea.TeaModel {
                    public var issueId: String?

                    public var metricCategory: String?

                    public var metricId: String?

                    public var severity: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.issueId != nil {
                            map["IssueId"] = self.issueId!
                        }
                        if self.metricCategory != nil {
                            map["MetricCategory"] = self.metricCategory!
                        }
                        if self.metricId != nil {
                            map["MetricId"] = self.metricId!
                        }
                        if self.severity != nil {
                            map["Severity"] = self.severity!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IssueId") {
                            self.issueId = dict["IssueId"] as! String
                        }
                        if dict.keys.contains("MetricCategory") {
                            self.metricCategory = dict["MetricCategory"] as! String
                        }
                        if dict.keys.contains("MetricId") {
                            self.metricId = dict["MetricId"] as! String
                        }
                        if dict.keys.contains("Severity") {
                            self.severity = dict["Severity"] as! String
                        }
                    }
                }
                public var issue: [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.issue != nil {
                        var tmp : [Any] = []
                        for k in self.issue! {
                            tmp.append(k.toMap())
                        }
                        map["Issue"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Issue") {
                        var tmp : [DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue] = []
                        for v in dict["Issue"] as! [Any] {
                            var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Issues.Issue()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.issue = tmp
                    }
                }
            }
            public var creationTime: String?

            public var endTime: String?

            public var finishedTime: String?

            public var issues: DescribeDiagnosticReportsResponseBody.Reports.Report.Issues?

            public var metricSetId: String?

            public var reportId: String?

            public var resourceId: String?

            public var resourceType: String?

            public var severity: String?

            public var startTime: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.issues?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.issues != nil {
                    map["Issues"] = self.issues?.toMap()
                }
                if self.metricSetId != nil {
                    map["MetricSetId"] = self.metricSetId!
                }
                if self.reportId != nil {
                    map["ReportId"] = self.reportId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.severity != nil {
                    map["Severity"] = self.severity!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! String
                }
                if dict.keys.contains("Issues") {
                    var model = DescribeDiagnosticReportsResponseBody.Reports.Report.Issues()
                    model.fromMap(dict["Issues"] as! [String: Any])
                    self.issues = model
                }
                if dict.keys.contains("MetricSetId") {
                    self.metricSetId = dict["MetricSetId"] as! String
                }
                if dict.keys.contains("ReportId") {
                    self.reportId = dict["ReportId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("Severity") {
                    self.severity = dict["Severity"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var report: [DescribeDiagnosticReportsResponseBody.Reports.Report]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.report != nil {
                var tmp : [Any] = []
                for k in self.report! {
                    tmp.append(k.toMap())
                }
                map["Report"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Report") {
                var tmp : [DescribeDiagnosticReportsResponseBody.Reports.Report] = []
                for v in dict["Report"] as! [Any] {
                    var model = DescribeDiagnosticReportsResponseBody.Reports.Report()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.report = tmp
            }
        }
    }
    public var nextToken: String?

    public var reports: DescribeDiagnosticReportsResponseBody.Reports?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reports?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.reports != nil {
            map["Reports"] = self.reports?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Reports") {
            var model = DescribeDiagnosticReportsResponseBody.Reports()
            model.fromMap(dict["Reports"] as! [String: Any])
            self.reports = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiagnosticReportsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiagnosticReportsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiagnosticReportsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiskDefaultKMSKeyIdRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeDiskDefaultKMSKeyIdResponseBody : Tea.TeaModel {
    public var KMSKeyId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiskDefaultKMSKeyIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskDefaultKMSKeyIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiskDefaultKMSKeyIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiskEncryptionByDefaultStatusRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeDiskEncryptionByDefaultStatusResponseBody : Tea.TeaModel {
    public var encrypted: Bool?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeDiskEncryptionByDefaultStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskEncryptionByDefaultStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiskEncryptionByDefaultStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDiskMonitorDataRequest : Tea.TeaModel {
    public var diskId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeDiskMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class DiskMonitorData : Tea.TeaModel {
            public var BPSRead: Int32?

            public var BPSTotal: Int32?

            public var BPSWrite: Int32?

            public var diskId: String?

            public var IOPSRead: Int32?

            public var IOPSTotal: Int32?

            public var IOPSWrite: Int32?

            public var latencyRead: Int32?

            public var latencyWrite: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.BPSRead != nil {
                    map["BPSRead"] = self.BPSRead!
                }
                if self.BPSTotal != nil {
                    map["BPSTotal"] = self.BPSTotal!
                }
                if self.BPSWrite != nil {
                    map["BPSWrite"] = self.BPSWrite!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.IOPSRead != nil {
                    map["IOPSRead"] = self.IOPSRead!
                }
                if self.IOPSTotal != nil {
                    map["IOPSTotal"] = self.IOPSTotal!
                }
                if self.IOPSWrite != nil {
                    map["IOPSWrite"] = self.IOPSWrite!
                }
                if self.latencyRead != nil {
                    map["LatencyRead"] = self.latencyRead!
                }
                if self.latencyWrite != nil {
                    map["LatencyWrite"] = self.latencyWrite!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BPSRead") {
                    self.BPSRead = dict["BPSRead"] as! Int32
                }
                if dict.keys.contains("BPSTotal") {
                    self.BPSTotal = dict["BPSTotal"] as! Int32
                }
                if dict.keys.contains("BPSWrite") {
                    self.BPSWrite = dict["BPSWrite"] as! Int32
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("IOPSRead") {
                    self.IOPSRead = dict["IOPSRead"] as! Int32
                }
                if dict.keys.contains("IOPSTotal") {
                    self.IOPSTotal = dict["IOPSTotal"] as! Int32
                }
                if dict.keys.contains("IOPSWrite") {
                    self.IOPSWrite = dict["IOPSWrite"] as! Int32
                }
                if dict.keys.contains("LatencyRead") {
                    self.latencyRead = dict["LatencyRead"] as! Int32
                }
                if dict.keys.contains("LatencyWrite") {
                    self.latencyWrite = dict["LatencyWrite"] as! Int32
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var diskMonitorData: [DescribeDiskMonitorDataResponseBody.MonitorData.DiskMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskMonitorData != nil {
                var tmp : [Any] = []
                for k in self.diskMonitorData! {
                    tmp.append(k.toMap())
                }
                map["DiskMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskMonitorData") {
                var tmp : [DescribeDiskMonitorDataResponseBody.MonitorData.DiskMonitorData] = []
                for v in dict["DiskMonitorData"] as! [Any] {
                    var model = DescribeDiskMonitorDataResponseBody.MonitorData.DiskMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diskMonitorData = tmp
            }
        }
    }
    public var monitorData: DescribeDiskMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorData") {
            var model = DescribeDiskMonitorDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDiskMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDiskMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDiskMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDisksRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeDisksRequest.Filter]?

    public var additionalAttributes: [String]?

    public var autoSnapshotPolicyId: String?

    public var category: String?

    public var deleteAutoSnapshot: Bool?

    public var deleteWithInstance: Bool?

    public var diskChargeType: String?

    public var diskIds: String?

    public var diskName: String?

    public var diskType: String?

    public var dryRun: Bool?

    public var enableAutoSnapshot: Bool?

    public var enableAutomatedSnapshotPolicy: Bool?

    public var enableShared: Bool?

    public var encrypted: Bool?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var lockReason: String?

    public var maxResults: Int32?

    public var multiAttach: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var portable: Bool?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public var status: String?

    public var tag: [DescribeDisksRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.additionalAttributes != nil {
            map["AdditionalAttributes"] = self.additionalAttributes!
        }
        if self.autoSnapshotPolicyId != nil {
            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.deleteAutoSnapshot != nil {
            map["DeleteAutoSnapshot"] = self.deleteAutoSnapshot!
        }
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskChargeType != nil {
            map["DiskChargeType"] = self.diskChargeType!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.diskType != nil {
            map["DiskType"] = self.diskType!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.enableAutoSnapshot != nil {
            map["EnableAutoSnapshot"] = self.enableAutoSnapshot!
        }
        if self.enableAutomatedSnapshotPolicy != nil {
            map["EnableAutomatedSnapshotPolicy"] = self.enableAutomatedSnapshotPolicy!
        }
        if self.enableShared != nil {
            map["EnableShared"] = self.enableShared!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.multiAttach != nil {
            map["MultiAttach"] = self.multiAttach!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.portable != nil {
            map["Portable"] = self.portable!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeDisksRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeDisksRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("AdditionalAttributes") {
            self.additionalAttributes = dict["AdditionalAttributes"] as! [String]
        }
        if dict.keys.contains("AutoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("DeleteAutoSnapshot") {
            self.deleteAutoSnapshot = dict["DeleteAutoSnapshot"] as! Bool
        }
        if dict.keys.contains("DeleteWithInstance") {
            self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
        }
        if dict.keys.contains("DiskChargeType") {
            self.diskChargeType = dict["DiskChargeType"] as! String
        }
        if dict.keys.contains("DiskIds") {
            self.diskIds = dict["DiskIds"] as! String
        }
        if dict.keys.contains("DiskName") {
            self.diskName = dict["DiskName"] as! String
        }
        if dict.keys.contains("DiskType") {
            self.diskType = dict["DiskType"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EnableAutoSnapshot") {
            self.enableAutoSnapshot = dict["EnableAutoSnapshot"] as! Bool
        }
        if dict.keys.contains("EnableAutomatedSnapshotPolicy") {
            self.enableAutomatedSnapshotPolicy = dict["EnableAutomatedSnapshotPolicy"] as! Bool
        }
        if dict.keys.contains("EnableShared") {
            self.enableShared = dict["EnableShared"] as! Bool
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("MultiAttach") {
            self.multiAttach = dict["MultiAttach"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("Portable") {
            self.portable = dict["Portable"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeDisksRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDisksRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeDisksResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Disk : Tea.TeaModel {
            public class Attachments : Tea.TeaModel {
                public class Attachment : Tea.TeaModel {
                    public var attachedTime: String?

                    public var device: String?

                    public var instanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.attachedTime != nil {
                            map["AttachedTime"] = self.attachedTime!
                        }
                        if self.device != nil {
                            map["Device"] = self.device!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AttachedTime") {
                            self.attachedTime = dict["AttachedTime"] as! String
                        }
                        if dict.keys.contains("Device") {
                            self.device = dict["Device"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                    }
                }
                public var attachment: [DescribeDisksResponseBody.Disks.Disk.Attachments.Attachment]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.attachment != nil {
                        var tmp : [Any] = []
                        for k in self.attachment! {
                            tmp.append(k.toMap())
                        }
                        map["Attachment"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Attachment") {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.Attachments.Attachment] = []
                        for v in dict["Attachment"] as! [Any] {
                            var model = DescribeDisksResponseBody.Disks.Disk.Attachments.Attachment()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.attachment = tmp
                    }
                }
            }
            public class MountInstances : Tea.TeaModel {
                public class MountInstance : Tea.TeaModel {
                    public var attachedTime: String?

                    public var device: String?

                    public var instanceId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.attachedTime != nil {
                            map["AttachedTime"] = self.attachedTime!
                        }
                        if self.device != nil {
                            map["Device"] = self.device!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AttachedTime") {
                            self.attachedTime = dict["AttachedTime"] as! String
                        }
                        if dict.keys.contains("Device") {
                            self.device = dict["Device"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                    }
                }
                public var mountInstance: [DescribeDisksResponseBody.Disks.Disk.MountInstances.MountInstance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.mountInstance != nil {
                        var tmp : [Any] = []
                        for k in self.mountInstance! {
                            tmp.append(k.toMap())
                        }
                        map["MountInstance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MountInstance") {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.MountInstances.MountInstance] = []
                        for v in dict["MountInstance"] as! [Any] {
                            var model = DescribeDisksResponseBody.Disks.Disk.MountInstances.MountInstance()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.mountInstance = tmp
                    }
                }
            }
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var operationLock: [DescribeDisksResponseBody.Disks.Disk.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OperationLock") {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.OperationLocks.OperationLock] = []
                        for v in dict["OperationLock"] as! [Any] {
                            var model = DescribeDisksResponseBody.Disks.Disk.OperationLocks.OperationLock()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.operationLock = tmp
                    }
                }
            }
            public class Placement : Tea.TeaModel {
                public var zoneIds: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.zoneIds != nil {
                        map["ZoneIds"] = self.zoneIds!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ZoneIds") {
                        self.zoneIds = dict["ZoneIds"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeDisksResponseBody.Disks.Disk.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeDisksResponseBody.Disks.Disk.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeDisksResponseBody.Disks.Disk.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var attachedTime: String?

            public var attachments: DescribeDisksResponseBody.Disks.Disk.Attachments?

            public var autoSnapshotPolicyId: String?

            public var bdfId: String?

            public var burstingEnabled: Bool?

            public var category: String?

            public var creationTime: String?

            public var deleteAutoSnapshot: Bool?

            public var deleteWithInstance: Bool?

            public var description_: String?

            public var detachedTime: String?

            public var device: String?

            public var diskChargeType: String?

            public var diskId: String?

            public var diskName: String?

            public var enableAutoSnapshot: Bool?

            public var enableAutomatedSnapshotPolicy: Bool?

            public var encrypted: Bool?

            public var expiredTime: String?

            public var IOPS: Int32?

            public var IOPSRead: Int32?

            public var IOPSWrite: Int32?

            public var imageId: String?

            public var instanceId: String?

            public var KMSKeyId: String?

            public var mountInstanceNum: Int32?

            public var mountInstances: DescribeDisksResponseBody.Disks.Disk.MountInstances?

            public var multiAttach: String?

            public var operationLocks: DescribeDisksResponseBody.Disks.Disk.OperationLocks?

            public var performanceLevel: String?

            public var placement: DescribeDisksResponseBody.Disks.Disk.Placement?

            public var portable: Bool?

            public var productCode: String?

            public var provisionedIops: Int64?

            public var regionId: String?

            public var resourceGroupId: String?

            public var serialNumber: String?

            public var size: Int32?

            public var sourceSnapshotId: String?

            public var status: String?

            public var storageClusterId: String?

            public var storageSetId: String?

            public var storageSetPartitionNumber: Int32?

            public var tags: DescribeDisksResponseBody.Disks.Disk.Tags?

            public var throughput: Int32?

            public var throughputRead: Int32?

            public var throughputWrite: Int32?

            public var type: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.attachments?.validate()
                try self.mountInstances?.validate()
                try self.operationLocks?.validate()
                try self.placement?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.attachedTime != nil {
                    map["AttachedTime"] = self.attachedTime!
                }
                if self.attachments != nil {
                    map["Attachments"] = self.attachments?.toMap()
                }
                if self.autoSnapshotPolicyId != nil {
                    map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                }
                if self.bdfId != nil {
                    map["BdfId"] = self.bdfId!
                }
                if self.burstingEnabled != nil {
                    map["BurstingEnabled"] = self.burstingEnabled!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deleteAutoSnapshot != nil {
                    map["DeleteAutoSnapshot"] = self.deleteAutoSnapshot!
                }
                if self.deleteWithInstance != nil {
                    map["DeleteWithInstance"] = self.deleteWithInstance!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detachedTime != nil {
                    map["DetachedTime"] = self.detachedTime!
                }
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskChargeType != nil {
                    map["DiskChargeType"] = self.diskChargeType!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.enableAutoSnapshot != nil {
                    map["EnableAutoSnapshot"] = self.enableAutoSnapshot!
                }
                if self.enableAutomatedSnapshotPolicy != nil {
                    map["EnableAutomatedSnapshotPolicy"] = self.enableAutomatedSnapshotPolicy!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.IOPS != nil {
                    map["IOPS"] = self.IOPS!
                }
                if self.IOPSRead != nil {
                    map["IOPSRead"] = self.IOPSRead!
                }
                if self.IOPSWrite != nil {
                    map["IOPSWrite"] = self.IOPSWrite!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.mountInstanceNum != nil {
                    map["MountInstanceNum"] = self.mountInstanceNum!
                }
                if self.mountInstances != nil {
                    map["MountInstances"] = self.mountInstances?.toMap()
                }
                if self.multiAttach != nil {
                    map["MultiAttach"] = self.multiAttach!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.performanceLevel != nil {
                    map["PerformanceLevel"] = self.performanceLevel!
                }
                if self.placement != nil {
                    map["Placement"] = self.placement?.toMap()
                }
                if self.portable != nil {
                    map["Portable"] = self.portable!
                }
                if self.productCode != nil {
                    map["ProductCode"] = self.productCode!
                }
                if self.provisionedIops != nil {
                    map["ProvisionedIops"] = self.provisionedIops!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.sourceSnapshotId != nil {
                    map["SourceSnapshotId"] = self.sourceSnapshotId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageClusterId != nil {
                    map["StorageClusterId"] = self.storageClusterId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.throughput != nil {
                    map["Throughput"] = self.throughput!
                }
                if self.throughputRead != nil {
                    map["ThroughputRead"] = self.throughputRead!
                }
                if self.throughputWrite != nil {
                    map["ThroughputWrite"] = self.throughputWrite!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AttachedTime") {
                    self.attachedTime = dict["AttachedTime"] as! String
                }
                if dict.keys.contains("Attachments") {
                    var model = DescribeDisksResponseBody.Disks.Disk.Attachments()
                    model.fromMap(dict["Attachments"] as! [String: Any])
                    self.attachments = model
                }
                if dict.keys.contains("AutoSnapshotPolicyId") {
                    self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
                }
                if dict.keys.contains("BdfId") {
                    self.bdfId = dict["BdfId"] as! String
                }
                if dict.keys.contains("BurstingEnabled") {
                    self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeleteAutoSnapshot") {
                    self.deleteAutoSnapshot = dict["DeleteAutoSnapshot"] as! Bool
                }
                if dict.keys.contains("DeleteWithInstance") {
                    self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DetachedTime") {
                    self.detachedTime = dict["DetachedTime"] as! String
                }
                if dict.keys.contains("Device") {
                    self.device = dict["Device"] as! String
                }
                if dict.keys.contains("DiskChargeType") {
                    self.diskChargeType = dict["DiskChargeType"] as! String
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("EnableAutoSnapshot") {
                    self.enableAutoSnapshot = dict["EnableAutoSnapshot"] as! Bool
                }
                if dict.keys.contains("EnableAutomatedSnapshotPolicy") {
                    self.enableAutomatedSnapshotPolicy = dict["EnableAutomatedSnapshotPolicy"] as! Bool
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! Bool
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("IOPS") {
                    self.IOPS = dict["IOPS"] as! Int32
                }
                if dict.keys.contains("IOPSRead") {
                    self.IOPSRead = dict["IOPSRead"] as! Int32
                }
                if dict.keys.contains("IOPSWrite") {
                    self.IOPSWrite = dict["IOPSWrite"] as! Int32
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("KMSKeyId") {
                    self.KMSKeyId = dict["KMSKeyId"] as! String
                }
                if dict.keys.contains("MountInstanceNum") {
                    self.mountInstanceNum = dict["MountInstanceNum"] as! Int32
                }
                if dict.keys.contains("MountInstances") {
                    var model = DescribeDisksResponseBody.Disks.Disk.MountInstances()
                    model.fromMap(dict["MountInstances"] as! [String: Any])
                    self.mountInstances = model
                }
                if dict.keys.contains("MultiAttach") {
                    self.multiAttach = dict["MultiAttach"] as! String
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeDisksResponseBody.Disks.Disk.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("PerformanceLevel") {
                    self.performanceLevel = dict["PerformanceLevel"] as! String
                }
                if dict.keys.contains("Placement") {
                    var model = DescribeDisksResponseBody.Disks.Disk.Placement()
                    model.fromMap(dict["Placement"] as! [String: Any])
                    self.placement = model
                }
                if dict.keys.contains("Portable") {
                    self.portable = dict["Portable"] as! Bool
                }
                if dict.keys.contains("ProductCode") {
                    self.productCode = dict["ProductCode"] as! String
                }
                if dict.keys.contains("ProvisionedIops") {
                    self.provisionedIops = dict["ProvisionedIops"] as! Int64
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SerialNumber") {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("SourceSnapshotId") {
                    self.sourceSnapshotId = dict["SourceSnapshotId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageClusterId") {
                    self.storageClusterId = dict["StorageClusterId"] as! String
                }
                if dict.keys.contains("StorageSetId") {
                    self.storageSetId = dict["StorageSetId"] as! String
                }
                if dict.keys.contains("StorageSetPartitionNumber") {
                    self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeDisksResponseBody.Disks.Disk.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Throughput") {
                    self.throughput = dict["Throughput"] as! Int32
                }
                if dict.keys.contains("ThroughputRead") {
                    self.throughputRead = dict["ThroughputRead"] as! Int32
                }
                if dict.keys.contains("ThroughputWrite") {
                    self.throughputWrite = dict["ThroughputWrite"] as! Int32
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var disk: [DescribeDisksResponseBody.Disks.Disk]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                var tmp : [Any] = []
                for k in self.disk! {
                    tmp.append(k.toMap())
                }
                map["Disk"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Disk") {
                var tmp : [DescribeDisksResponseBody.Disks.Disk] = []
                for v in dict["Disk"] as! [Any] {
                    var model = DescribeDisksResponseBody.Disks.Disk()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.disk = tmp
            }
        }
    }
    public var disks: DescribeDisksResponseBody.Disks?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.disks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disks != nil {
            map["Disks"] = self.disks?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Disks") {
            var model = DescribeDisksResponseBody.Disks()
            model.fromMap(dict["Disks"] as! [String: Any])
            self.disks = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDisksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeDisksFullStatusRequest : Tea.TeaModel {
    public class EventTime : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("End") {
                self.end = dict["End"] as! String
            }
            if dict.keys.contains("Start") {
                self.start = dict["Start"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var eventTime: DescribeDisksFullStatusRequest.EventTime?

    public var diskId: [String]?

    public var eventId: [String]?

    public var eventType: String?

    public var healthStatus: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeDisksFullStatusRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventTime?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventTime != nil {
            map["EventTime"] = self.eventTime?.toMap()
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventTime") {
            var model = DescribeDisksFullStatusRequest.EventTime()
            model.fromMap(dict["EventTime"] as! [String: Any])
            self.eventTime = model
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! [String]
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! [String]
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeDisksFullStatusRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeDisksFullStatusRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeDisksFullStatusResponseBody : Tea.TeaModel {
    public class DiskFullStatusSet : Tea.TeaModel {
        public class DiskFullStatusType : Tea.TeaModel {
            public class DiskEventSet : Tea.TeaModel {
                public class DiskEventType : Tea.TeaModel {
                    public class EventType : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Code") {
                                self.code = dict["Code"] as! Int32
                            }
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                        }
                    }
                    public var eventEndTime: String?

                    public var eventId: String?

                    public var eventTime: String?

                    public var eventType: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType.EventType?

                    public var impactLevel: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.eventType?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventEndTime != nil {
                            map["EventEndTime"] = self.eventEndTime!
                        }
                        if self.eventId != nil {
                            map["EventId"] = self.eventId!
                        }
                        if self.eventTime != nil {
                            map["EventTime"] = self.eventTime!
                        }
                        if self.eventType != nil {
                            map["EventType"] = self.eventType?.toMap()
                        }
                        if self.impactLevel != nil {
                            map["ImpactLevel"] = self.impactLevel!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EventEndTime") {
                            self.eventEndTime = dict["EventEndTime"] as! String
                        }
                        if dict.keys.contains("EventId") {
                            self.eventId = dict["EventId"] as! String
                        }
                        if dict.keys.contains("EventTime") {
                            self.eventTime = dict["EventTime"] as! String
                        }
                        if dict.keys.contains("EventType") {
                            var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType.EventType()
                            model.fromMap(dict["EventType"] as! [String: Any])
                            self.eventType = model
                        }
                        if dict.keys.contains("ImpactLevel") {
                            self.impactLevel = dict["ImpactLevel"] as! String
                        }
                    }
                }
                public var diskEventType: [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskEventType != nil {
                        var tmp : [Any] = []
                        for k in self.diskEventType! {
                            tmp.append(k.toMap())
                        }
                        map["DiskEventType"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskEventType") {
                        var tmp : [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType] = []
                        for v in dict["DiskEventType"] as! [Any] {
                            var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet.DiskEventType()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.diskEventType = tmp
                    }
                }
            }
            public class HealthStatus : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class Status : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var device: String?

            public var diskEventSet: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet?

            public var diskId: String?

            public var healthStatus: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.HealthStatus?

            public var instanceId: String?

            public var status: DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.Status?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.diskEventSet?.validate()
                try self.healthStatus?.validate()
                try self.status?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.device != nil {
                    map["Device"] = self.device!
                }
                if self.diskEventSet != nil {
                    map["DiskEventSet"] = self.diskEventSet?.toMap()
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.status != nil {
                    map["Status"] = self.status?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Device") {
                    self.device = dict["Device"] as! String
                }
                if dict.keys.contains("DiskEventSet") {
                    var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.DiskEventSet()
                    model.fromMap(dict["DiskEventSet"] as! [String: Any])
                    self.diskEventSet = model
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("HealthStatus") {
                    var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.HealthStatus()
                    model.fromMap(dict["HealthStatus"] as! [String: Any])
                    self.healthStatus = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Status") {
                    var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType.Status()
                    model.fromMap(dict["Status"] as! [String: Any])
                    self.status = model
                }
            }
        }
        public var diskFullStatusType: [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskFullStatusType != nil {
                var tmp : [Any] = []
                for k in self.diskFullStatusType! {
                    tmp.append(k.toMap())
                }
                map["DiskFullStatusType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskFullStatusType") {
                var tmp : [DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType] = []
                for v in dict["DiskFullStatusType"] as! [Any] {
                    var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet.DiskFullStatusType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.diskFullStatusType = tmp
            }
        }
    }
    public var diskFullStatusSet: DescribeDisksFullStatusResponseBody.DiskFullStatusSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.diskFullStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskFullStatusSet != nil {
            map["DiskFullStatusSet"] = self.diskFullStatusSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskFullStatusSet") {
            var model = DescribeDisksFullStatusResponseBody.DiskFullStatusSet()
            model.fromMap(dict["DiskFullStatusSet"] as! [String: Any])
            self.diskFullStatusSet = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeDisksFullStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeDisksFullStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeDisksFullStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEipAddressesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeEipAddressesRequest.Filter]?

    public var allocationId: String?

    public var associatedInstanceId: String?

    public var associatedInstanceType: String?

    public var chargeType: String?

    public var eipAddress: String?

    public var ISP: String?

    public var lockReason: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.associatedInstanceId != nil {
            map["AssociatedInstanceId"] = self.associatedInstanceId!
        }
        if self.associatedInstanceType != nil {
            map["AssociatedInstanceType"] = self.associatedInstanceType!
        }
        if self.chargeType != nil {
            map["ChargeType"] = self.chargeType!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeEipAddressesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeEipAddressesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceId") {
            self.associatedInstanceId = dict["AssociatedInstanceId"] as! String
        }
        if dict.keys.contains("AssociatedInstanceType") {
            self.associatedInstanceType = dict["AssociatedInstanceType"] as! String
        }
        if dict.keys.contains("ChargeType") {
            self.chargeType = dict["ChargeType"] as! String
        }
        if dict.keys.contains("EipAddress") {
            self.eipAddress = dict["EipAddress"] as! String
        }
        if dict.keys.contains("ISP") {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeEipAddressesResponseBody : Tea.TeaModel {
    public class EipAddresses : Tea.TeaModel {
        public class EipAddress : Tea.TeaModel {
            public class OperationLocks : Tea.TeaModel {
                public class LockReason : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var lockReason: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lockReason != nil {
                        var tmp : [Any] = []
                        for k in self.lockReason! {
                            tmp.append(k.toMap())
                        }
                        map["LockReason"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LockReason") {
                        var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason] = []
                        for v in dict["LockReason"] as! [Any] {
                            var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks.LockReason()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.lockReason = tmp
                    }
                }
            }
            public var allocationId: String?

            public var allocationTime: String?

            public var bandwidth: String?

            public var chargeType: String?

            public var eipBandwidth: String?

            public var expiredTime: String?

            public var instanceId: String?

            public var instanceType: String?

            public var internetChargeType: String?

            public var ipAddress: String?

            public var operationLocks: DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks?

            public var regionId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.operationLocks?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationId != nil {
                    map["AllocationId"] = self.allocationId!
                }
                if self.allocationTime != nil {
                    map["AllocationTime"] = self.allocationTime!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationId") {
                    self.allocationId = dict["AllocationId"] as! String
                }
                if dict.keys.contains("AllocationTime") {
                    self.allocationTime = dict["AllocationTime"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("EipBandwidth") {
                    self.eipBandwidth = dict["EipBandwidth"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var eipAddress: [DescribeEipAddressesResponseBody.EipAddresses.EipAddress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipAddress != nil {
                var tmp : [Any] = []
                for k in self.eipAddress! {
                    tmp.append(k.toMap())
                }
                map["EipAddress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipAddress") {
                var tmp : [DescribeEipAddressesResponseBody.EipAddresses.EipAddress] = []
                for v in dict["EipAddress"] as! [Any] {
                    var model = DescribeEipAddressesResponseBody.EipAddresses.EipAddress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipAddress = tmp
            }
        }
    }
    public var eipAddresses: DescribeEipAddressesResponseBody.EipAddresses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipAddresses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipAddresses") {
            var model = DescribeEipAddressesResponseBody.EipAddresses()
            model.fromMap(dict["EipAddresses"] as! [String: Any])
            self.eipAddresses = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEipAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEipAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEipMonitorDataRequest : Tea.TeaModel {
    public var allocationId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeEipMonitorDataResponseBody : Tea.TeaModel {
    public class EipMonitorDatas : Tea.TeaModel {
        public class EipMonitorData : Tea.TeaModel {
            public var eipBandwidth: Int32?

            public var eipFlow: Int32?

            public var eipPackets: Int32?

            public var eipRX: Int32?

            public var eipTX: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.eipFlow != nil {
                    map["EipFlow"] = self.eipFlow!
                }
                if self.eipPackets != nil {
                    map["EipPackets"] = self.eipPackets!
                }
                if self.eipRX != nil {
                    map["EipRX"] = self.eipRX!
                }
                if self.eipTX != nil {
                    map["EipTX"] = self.eipTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EipBandwidth") {
                    self.eipBandwidth = dict["EipBandwidth"] as! Int32
                }
                if dict.keys.contains("EipFlow") {
                    self.eipFlow = dict["EipFlow"] as! Int32
                }
                if dict.keys.contains("EipPackets") {
                    self.eipPackets = dict["EipPackets"] as! Int32
                }
                if dict.keys.contains("EipRX") {
                    self.eipRX = dict["EipRX"] as! Int32
                }
                if dict.keys.contains("EipTX") {
                    self.eipTX = dict["EipTX"] as! Int32
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var eipMonitorData: [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eipMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EipMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipMonitorData") {
                var tmp : [DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData] = []
                for v in dict["EipMonitorData"] as! [Any] {
                    var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipMonitorData = tmp
            }
        }
    }
    public var eipMonitorDatas: DescribeEipMonitorDataResponseBody.EipMonitorDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipMonitorDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipMonitorDatas != nil {
            map["EipMonitorDatas"] = self.eipMonitorDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipMonitorDatas") {
            var model = DescribeEipMonitorDataResponseBody.EipMonitorDatas()
            model.fromMap(dict["EipMonitorDatas"] as! [String: Any])
            self.eipMonitorDatas = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeEipMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEipMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEipMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeElasticityAssuranceInstancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var privatePoolOptions: DescribeElasticityAssuranceInstancesRequest.PrivatePoolOptions?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = DescribeElasticityAssuranceInstancesRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeElasticityAssuranceInstancesResponseBody : Tea.TeaModel {
    public class ElasticityAssuranceItem : Tea.TeaModel {
        public class InstanceIdSet : Tea.TeaModel {
            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var instanceIdSet: [DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem.InstanceIdSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                var tmp : [Any] = []
                for k in self.instanceIdSet! {
                    tmp.append(k.toMap())
                }
                map["InstanceIdSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceIdSet") {
                var tmp : [DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem.InstanceIdSet] = []
                for v in dict["InstanceIdSet"] as! [Any] {
                    var model = DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem.InstanceIdSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceIdSet = tmp
            }
        }
    }
    public var elasticityAssuranceItem: DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.elasticityAssuranceItem?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticityAssuranceItem != nil {
            map["ElasticityAssuranceItem"] = self.elasticityAssuranceItem?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ElasticityAssuranceItem") {
            var model = DescribeElasticityAssuranceInstancesResponseBody.ElasticityAssuranceItem()
            model.fromMap(dict["ElasticityAssuranceItem"] as! [String: Any])
            self.elasticityAssuranceItem = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeElasticityAssuranceInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticityAssuranceInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeElasticityAssuranceInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeElasticityAssurancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var ids: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ids != nil {
                map["Ids"] = self.ids!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ids") {
                self.ids = dict["Ids"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var privatePoolOptions: DescribeElasticityAssurancesRequest.PrivatePoolOptions?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeElasticityAssurancesRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = DescribeElasticityAssurancesRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeElasticityAssurancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeElasticityAssurancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeElasticityAssurancesResponseBody : Tea.TeaModel {
    public class ElasticityAssuranceSet : Tea.TeaModel {
        public class ElasticityAssuranceItem : Tea.TeaModel {
            public class AllocatedResources : Tea.TeaModel {
                public class AllocatedResource : Tea.TeaModel {
                    public class ElasticityAssuranceUsages : Tea.TeaModel {
                        public class ElasticityAssuranceUsage : Tea.TeaModel {
                            public var accountId: String?

                            public var serviceName: String?

                            public var usedAmount: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.accountId != nil {
                                    map["AccountId"] = self.accountId!
                                }
                                if self.serviceName != nil {
                                    map["ServiceName"] = self.serviceName!
                                }
                                if self.usedAmount != nil {
                                    map["UsedAmount"] = self.usedAmount!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("AccountId") {
                                    self.accountId = dict["AccountId"] as! String
                                }
                                if dict.keys.contains("ServiceName") {
                                    self.serviceName = dict["ServiceName"] as! String
                                }
                                if dict.keys.contains("UsedAmount") {
                                    self.usedAmount = dict["UsedAmount"] as! Int32
                                }
                            }
                        }
                        public var elasticityAssuranceUsage: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages.ElasticityAssuranceUsage]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.elasticityAssuranceUsage != nil {
                                var tmp : [Any] = []
                                for k in self.elasticityAssuranceUsage! {
                                    tmp.append(k.toMap())
                                }
                                map["ElasticityAssuranceUsage"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ElasticityAssuranceUsage") {
                                var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages.ElasticityAssuranceUsage] = []
                                for v in dict["ElasticityAssuranceUsage"] as! [Any] {
                                    var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages.ElasticityAssuranceUsage()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.elasticityAssuranceUsage = tmp
                            }
                        }
                    }
                    public var availableAmount: Int32?

                    public var elasticityAssuranceUsages: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages?

                    public var instanceType: String?

                    public var totalAmount: Int32?

                    public var usedAmount: Int32?

                    public var zoneId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.elasticityAssuranceUsages?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.availableAmount != nil {
                            map["AvailableAmount"] = self.availableAmount!
                        }
                        if self.elasticityAssuranceUsages != nil {
                            map["ElasticityAssuranceUsages"] = self.elasticityAssuranceUsages?.toMap()
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.totalAmount != nil {
                            map["TotalAmount"] = self.totalAmount!
                        }
                        if self.usedAmount != nil {
                            map["UsedAmount"] = self.usedAmount!
                        }
                        if self.zoneId != nil {
                            map["zoneId"] = self.zoneId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AvailableAmount") {
                            self.availableAmount = dict["AvailableAmount"] as! Int32
                        }
                        if dict.keys.contains("ElasticityAssuranceUsages") {
                            var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource.ElasticityAssuranceUsages()
                            model.fromMap(dict["ElasticityAssuranceUsages"] as! [String: Any])
                            self.elasticityAssuranceUsages = model
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("TotalAmount") {
                            self.totalAmount = dict["TotalAmount"] as! Int32
                        }
                        if dict.keys.contains("UsedAmount") {
                            self.usedAmount = dict["UsedAmount"] as! Int32
                        }
                        if dict.keys.contains("zoneId") {
                            self.zoneId = dict["zoneId"] as! String
                        }
                    }
                }
                public var allocatedResource: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocatedResource != nil {
                        var tmp : [Any] = []
                        for k in self.allocatedResource! {
                            tmp.append(k.toMap())
                        }
                        map["AllocatedResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocatedResource") {
                        var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource] = []
                        for v in dict["AllocatedResource"] as! [Any] {
                            var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources.AllocatedResource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.allocatedResource = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocatedResources: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources?

            public var description_: String?

            public var elasticityAssuranceOwnerId: String?

            public var endTime: String?

            public var instanceChargeType: String?

            public var latestStartTime: String?

            public var privatePoolOptionsId: String?

            public var privatePoolOptionsMatchCriteria: String?

            public var privatePoolOptionsName: String?

            public var regionId: String?

            public var resourceGroupId: String?

            public var startTime: String?

            public var startTimeType: String?

            public var status: String?

            public var tags: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags?

            public var totalAssuranceTimes: String?

            public var usedAssuranceTimes: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.allocatedResources?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocatedResources != nil {
                    map["AllocatedResources"] = self.allocatedResources?.toMap()
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.elasticityAssuranceOwnerId != nil {
                    map["ElasticityAssuranceOwnerId"] = self.elasticityAssuranceOwnerId!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.latestStartTime != nil {
                    map["LatestStartTime"] = self.latestStartTime!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.privatePoolOptionsMatchCriteria != nil {
                    map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
                }
                if self.privatePoolOptionsName != nil {
                    map["PrivatePoolOptionsName"] = self.privatePoolOptionsName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.startTimeType != nil {
                    map["StartTimeType"] = self.startTimeType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.totalAssuranceTimes != nil {
                    map["TotalAssuranceTimes"] = self.totalAssuranceTimes!
                }
                if self.usedAssuranceTimes != nil {
                    map["UsedAssuranceTimes"] = self.usedAssuranceTimes!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocatedResources") {
                    var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.AllocatedResources()
                    model.fromMap(dict["AllocatedResources"] as! [String: Any])
                    self.allocatedResources = model
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ElasticityAssuranceOwnerId") {
                    self.elasticityAssuranceOwnerId = dict["ElasticityAssuranceOwnerId"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("LatestStartTime") {
                    self.latestStartTime = dict["LatestStartTime"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsId") {
                    self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsMatchCriteria") {
                    self.privatePoolOptionsMatchCriteria = dict["PrivatePoolOptionsMatchCriteria"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsName") {
                    self.privatePoolOptionsName = dict["PrivatePoolOptionsName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("StartTimeType") {
                    self.startTimeType = dict["StartTimeType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TotalAssuranceTimes") {
                    self.totalAssuranceTimes = dict["TotalAssuranceTimes"] as! String
                }
                if dict.keys.contains("UsedAssuranceTimes") {
                    self.usedAssuranceTimes = dict["UsedAssuranceTimes"] as! Int32
                }
            }
        }
        public var elasticityAssuranceItem: [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.elasticityAssuranceItem != nil {
                var tmp : [Any] = []
                for k in self.elasticityAssuranceItem! {
                    tmp.append(k.toMap())
                }
                map["ElasticityAssuranceItem"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ElasticityAssuranceItem") {
                var tmp : [DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem] = []
                for v in dict["ElasticityAssuranceItem"] as! [Any] {
                    var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet.ElasticityAssuranceItem()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.elasticityAssuranceItem = tmp
            }
        }
    }
    public var elasticityAssuranceSet: DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.elasticityAssuranceSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.elasticityAssuranceSet != nil {
            map["ElasticityAssuranceSet"] = self.elasticityAssuranceSet?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ElasticityAssuranceSet") {
            var model = DescribeElasticityAssurancesResponseBody.ElasticityAssuranceSet()
            model.fromMap(dict["ElasticityAssuranceSet"] as! [String: Any])
            self.elasticityAssuranceSet = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeElasticityAssurancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeElasticityAssurancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeElasticityAssurancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeEniMonitorDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var eniId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.eniId != nil {
            map["EniId"] = self.eniId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EniId") {
            self.eniId = dict["EniId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeEniMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class EniMonitorData : Tea.TeaModel {
            public var dropPacketRx: String?

            public var dropPacketTx: String?

            public var eniId: String?

            public var intranetRx: String?

            public var intranetTx: String?

            public var packetRx: String?

            public var packetTx: String?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.dropPacketRx != nil {
                    map["DropPacketRx"] = self.dropPacketRx!
                }
                if self.dropPacketTx != nil {
                    map["DropPacketTx"] = self.dropPacketTx!
                }
                if self.eniId != nil {
                    map["EniId"] = self.eniId!
                }
                if self.intranetRx != nil {
                    map["IntranetRx"] = self.intranetRx!
                }
                if self.intranetTx != nil {
                    map["IntranetTx"] = self.intranetTx!
                }
                if self.packetRx != nil {
                    map["PacketRx"] = self.packetRx!
                }
                if self.packetTx != nil {
                    map["PacketTx"] = self.packetTx!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DropPacketRx") {
                    self.dropPacketRx = dict["DropPacketRx"] as! String
                }
                if dict.keys.contains("DropPacketTx") {
                    self.dropPacketTx = dict["DropPacketTx"] as! String
                }
                if dict.keys.contains("EniId") {
                    self.eniId = dict["EniId"] as! String
                }
                if dict.keys.contains("IntranetRx") {
                    self.intranetRx = dict["IntranetRx"] as! String
                }
                if dict.keys.contains("IntranetTx") {
                    self.intranetTx = dict["IntranetTx"] as! String
                }
                if dict.keys.contains("PacketRx") {
                    self.packetRx = dict["PacketRx"] as! String
                }
                if dict.keys.contains("PacketTx") {
                    self.packetTx = dict["PacketTx"] as! String
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var eniMonitorData: [DescribeEniMonitorDataResponseBody.MonitorData.EniMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eniMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eniMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EniMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EniMonitorData") {
                var tmp : [DescribeEniMonitorDataResponseBody.MonitorData.EniMonitorData] = []
                for v in dict["EniMonitorData"] as! [Any] {
                    var model = DescribeEniMonitorDataResponseBody.MonitorData.EniMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eniMonitorData = tmp
            }
        }
    }
    public var monitorData: DescribeEniMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorData") {
            var model = DescribeEniMonitorDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeEniMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeEniMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeEniMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeForwardTableEntriesRequest : Tea.TeaModel {
    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeForwardTableEntriesResponseBody : Tea.TeaModel {
    public class ForwardTableEntries : Tea.TeaModel {
        public class ForwardTableEntry : Tea.TeaModel {
            public var externalIp: String?

            public var externalPort: String?

            public var forwardEntryId: String?

            public var forwardTableId: String?

            public var internalIp: String?

            public var internalPort: String?

            public var ipProtocol: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.externalIp != nil {
                    map["ExternalIp"] = self.externalIp!
                }
                if self.externalPort != nil {
                    map["ExternalPort"] = self.externalPort!
                }
                if self.forwardEntryId != nil {
                    map["ForwardEntryId"] = self.forwardEntryId!
                }
                if self.forwardTableId != nil {
                    map["ForwardTableId"] = self.forwardTableId!
                }
                if self.internalIp != nil {
                    map["InternalIp"] = self.internalIp!
                }
                if self.internalPort != nil {
                    map["InternalPort"] = self.internalPort!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ExternalIp") {
                    self.externalIp = dict["ExternalIp"] as! String
                }
                if dict.keys.contains("ExternalPort") {
                    self.externalPort = dict["ExternalPort"] as! String
                }
                if dict.keys.contains("ForwardEntryId") {
                    self.forwardEntryId = dict["ForwardEntryId"] as! String
                }
                if dict.keys.contains("ForwardTableId") {
                    self.forwardTableId = dict["ForwardTableId"] as! String
                }
                if dict.keys.contains("InternalIp") {
                    self.internalIp = dict["InternalIp"] as! String
                }
                if dict.keys.contains("InternalPort") {
                    self.internalPort = dict["InternalPort"] as! String
                }
                if dict.keys.contains("IpProtocol") {
                    self.ipProtocol = dict["IpProtocol"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var forwardTableEntry: [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.forwardTableEntry != nil {
                var tmp : [Any] = []
                for k in self.forwardTableEntry! {
                    tmp.append(k.toMap())
                }
                map["ForwardTableEntry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ForwardTableEntry") {
                var tmp : [DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry] = []
                for v in dict["ForwardTableEntry"] as! [Any] {
                    var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries.ForwardTableEntry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.forwardTableEntry = tmp
            }
        }
    }
    public var forwardTableEntries: DescribeForwardTableEntriesResponseBody.ForwardTableEntries?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.forwardTableEntries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forwardTableEntries != nil {
            map["ForwardTableEntries"] = self.forwardTableEntries?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForwardTableEntries") {
            var model = DescribeForwardTableEntriesResponseBody.ForwardTableEntries()
            model.fromMap(dict["ForwardTableEntries"] as! [String: Any])
            self.forwardTableEntries = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeForwardTableEntriesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeForwardTableEntriesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeForwardTableEntriesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHaVipsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var filter: [DescribeHaVipsRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeHaVipsRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeHaVipsRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeHaVipsResponseBody : Tea.TeaModel {
    public class HaVips : Tea.TeaModel {
        public class HaVip : Tea.TeaModel {
            public class AssociatedEipAddresses : Tea.TeaModel {
                public var associatedEipAddresse: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedEipAddresse != nil {
                        map["associatedEipAddresse"] = self.associatedEipAddresse!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("associatedEipAddresse") {
                        self.associatedEipAddresse = dict["associatedEipAddresse"] as! [String]
                    }
                }
            }
            public class AssociatedInstances : Tea.TeaModel {
                public var associatedInstance: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.associatedInstance != nil {
                        map["associatedInstance"] = self.associatedInstance!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("associatedInstance") {
                        self.associatedInstance = dict["associatedInstance"] as! [String]
                    }
                }
            }
            public var associatedEipAddresses: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses?

            public var associatedInstances: DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances?

            public var createTime: String?

            public var description_: String?

            public var haVipId: String?

            public var ipAddress: String?

            public var masterInstanceId: String?

            public var regionId: String?

            public var status: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedEipAddresses?.validate()
                try self.associatedInstances?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedEipAddresses != nil {
                    map["AssociatedEipAddresses"] = self.associatedEipAddresses?.toMap()
                }
                if self.associatedInstances != nil {
                    map["AssociatedInstances"] = self.associatedInstances?.toMap()
                }
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.haVipId != nil {
                    map["HaVipId"] = self.haVipId!
                }
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                if self.masterInstanceId != nil {
                    map["MasterInstanceId"] = self.masterInstanceId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociatedEipAddresses") {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedEipAddresses()
                    model.fromMap(dict["AssociatedEipAddresses"] as! [String: Any])
                    self.associatedEipAddresses = model
                }
                if dict.keys.contains("AssociatedInstances") {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip.AssociatedInstances()
                    model.fromMap(dict["AssociatedInstances"] as! [String: Any])
                    self.associatedInstances = model
                }
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HaVipId") {
                    self.haVipId = dict["HaVipId"] as! String
                }
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! String
                }
                if dict.keys.contains("MasterInstanceId") {
                    self.masterInstanceId = dict["MasterInstanceId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var haVip: [DescribeHaVipsResponseBody.HaVips.HaVip]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.haVip != nil {
                var tmp : [Any] = []
                for k in self.haVip! {
                    tmp.append(k.toMap())
                }
                map["HaVip"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HaVip") {
                var tmp : [DescribeHaVipsResponseBody.HaVips.HaVip] = []
                for v in dict["HaVip"] as! [Any] {
                    var model = DescribeHaVipsResponseBody.HaVips.HaVip()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.haVip = tmp
            }
        }
    }
    public var haVips: DescribeHaVipsResponseBody.HaVips?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.haVips?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.haVips != nil {
            map["HaVips"] = self.haVips?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HaVips") {
            var model = DescribeHaVipsResponseBody.HaVips()
            model.fromMap(dict["HaVips"] as! [String: Any])
            self.haVips = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeHaVipsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHaVipsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHaVipsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeHpcClustersRequest : Tea.TeaModel {
    public var clientToken: String?

    public var hpcClusterIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.hpcClusterIds != nil {
            map["HpcClusterIds"] = self.hpcClusterIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("HpcClusterIds") {
            self.hpcClusterIds = dict["HpcClusterIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeHpcClustersResponseBody : Tea.TeaModel {
    public class HpcClusters : Tea.TeaModel {
        public class HpcCluster : Tea.TeaModel {
            public var description_: String?

            public var hpcClusterId: String?

            public var name: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.hpcClusterId != nil {
                    map["HpcClusterId"] = self.hpcClusterId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("HpcClusterId") {
                    self.hpcClusterId = dict["HpcClusterId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
            }
        }
        public var hpcCluster: [DescribeHpcClustersResponseBody.HpcClusters.HpcCluster]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.hpcCluster != nil {
                var tmp : [Any] = []
                for k in self.hpcCluster! {
                    tmp.append(k.toMap())
                }
                map["HpcCluster"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("HpcCluster") {
                var tmp : [DescribeHpcClustersResponseBody.HpcClusters.HpcCluster] = []
                for v in dict["HpcCluster"] as! [Any] {
                    var model = DescribeHpcClustersResponseBody.HpcClusters.HpcCluster()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.hpcCluster = tmp
            }
        }
    }
    public var hpcClusters: DescribeHpcClustersResponseBody.HpcClusters?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.hpcClusters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.hpcClusters != nil {
            map["HpcClusters"] = self.hpcClusters?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HpcClusters") {
            var model = DescribeHpcClustersResponseBody.HpcClusters()
            model.fromMap(dict["HpcClusters"] as! [String: Any])
            self.hpcClusters = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeHpcClustersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeHpcClustersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeHpcClustersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageComponentsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var componentType: String?

    public var componentVersion: String?

    public var imageComponentId: [String]?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var owner: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var systemType: String?

    public var tag: [DescribeImageComponentsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.componentType != nil {
            map["ComponentType"] = self.componentType!
        }
        if self.componentVersion != nil {
            map["ComponentVersion"] = self.componentVersion!
        }
        if self.imageComponentId != nil {
            map["ImageComponentId"] = self.imageComponentId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.owner != nil {
            map["Owner"] = self.owner!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.systemType != nil {
            map["SystemType"] = self.systemType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ComponentType") {
            self.componentType = dict["ComponentType"] as! String
        }
        if dict.keys.contains("ComponentVersion") {
            self.componentVersion = dict["ComponentVersion"] as! String
        }
        if dict.keys.contains("ImageComponentId") {
            self.imageComponentId = dict["ImageComponentId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Owner") {
            self.owner = dict["Owner"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SystemType") {
            self.systemType = dict["SystemType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeImageComponentsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeImageComponentsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeImageComponentsResponseBody : Tea.TeaModel {
    public class ImageComponent : Tea.TeaModel {
        public class ImageComponentSet : Tea.TeaModel {
            public class Parameters : Tea.TeaModel {
                public class Parameter : Tea.TeaModel {
                    public var defaultValue: String?

                    public var name: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.defaultValue != nil {
                            map["DefaultValue"] = self.defaultValue!
                        }
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DefaultValue") {
                            self.defaultValue = dict["DefaultValue"] as! String
                        }
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var parameter: [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters.Parameter]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.parameter != nil {
                        var tmp : [Any] = []
                        for k in self.parameter! {
                            tmp.append(k.toMap())
                        }
                        map["Parameter"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Parameter") {
                        var tmp : [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters.Parameter] = []
                        for v in dict["Parameter"] as! [Any] {
                            var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters.Parameter()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.parameter = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var componentType: String?

            public var componentVersion: String?

            public var content: String?

            public var creationTime: String?

            public var description_: String?

            public var imageComponentId: String?

            public var name: String?

            public var owner: String?

            public var parameters: DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters?

            public var resourceGroupId: String?

            public var systemType: String?

            public var tags: DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.parameters?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.componentType != nil {
                    map["ComponentType"] = self.componentType!
                }
                if self.componentVersion != nil {
                    map["ComponentVersion"] = self.componentVersion!
                }
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.imageComponentId != nil {
                    map["ImageComponentId"] = self.imageComponentId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.owner != nil {
                    map["Owner"] = self.owner!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters?.toMap()
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.systemType != nil {
                    map["SystemType"] = self.systemType!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ComponentType") {
                    self.componentType = dict["ComponentType"] as! String
                }
                if dict.keys.contains("ComponentVersion") {
                    self.componentVersion = dict["ComponentVersion"] as! String
                }
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ImageComponentId") {
                    self.imageComponentId = dict["ImageComponentId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Owner") {
                    self.owner = dict["Owner"] as! String
                }
                if dict.keys.contains("Parameters") {
                    var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Parameters()
                    model.fromMap(dict["Parameters"] as! [String: Any])
                    self.parameters = model
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SystemType") {
                    self.systemType = dict["SystemType"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var imageComponentSet: [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imageComponentSet != nil {
                var tmp : [Any] = []
                for k in self.imageComponentSet! {
                    tmp.append(k.toMap())
                }
                map["ImageComponentSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImageComponentSet") {
                var tmp : [DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet] = []
                for v in dict["ImageComponentSet"] as! [Any] {
                    var model = DescribeImageComponentsResponseBody.ImageComponent.ImageComponentSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imageComponentSet = tmp
            }
        }
    }
    public var imageComponent: DescribeImageComponentsResponseBody.ImageComponent?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imageComponent?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageComponent != nil {
            map["ImageComponent"] = self.imageComponent?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageComponent") {
            var model = DescribeImageComponentsResponseBody.ImageComponent()
            model.fromMap(dict["ImageComponent"] as! [String: Any])
            self.imageComponent = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageComponentsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageComponentsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageComponentsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageFromFamilyRequest : Tea.TeaModel {
    public var imageFamily: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeImageFromFamilyResponseBody : Tea.TeaModel {
    public class Image : Tea.TeaModel {
        public class DiskDeviceMappings : Tea.TeaModel {
            public class DiskDeviceMapping : Tea.TeaModel {
                public var device: String?

                public var format: String?

                public var importOSSBucket: String?

                public var importOSSObject: String?

                public var size: String?

                public var snapshotId: String?

                public var type: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.device != nil {
                        map["Device"] = self.device!
                    }
                    if self.format != nil {
                        map["Format"] = self.format!
                    }
                    if self.importOSSBucket != nil {
                        map["ImportOSSBucket"] = self.importOSSBucket!
                    }
                    if self.importOSSObject != nil {
                        map["ImportOSSObject"] = self.importOSSObject!
                    }
                    if self.size != nil {
                        map["Size"] = self.size!
                    }
                    if self.snapshotId != nil {
                        map["SnapshotId"] = self.snapshotId!
                    }
                    if self.type != nil {
                        map["Type"] = self.type!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Device") {
                        self.device = dict["Device"] as! String
                    }
                    if dict.keys.contains("Format") {
                        self.format = dict["Format"] as! String
                    }
                    if dict.keys.contains("ImportOSSBucket") {
                        self.importOSSBucket = dict["ImportOSSBucket"] as! String
                    }
                    if dict.keys.contains("ImportOSSObject") {
                        self.importOSSObject = dict["ImportOSSObject"] as! String
                    }
                    if dict.keys.contains("Size") {
                        self.size = dict["Size"] as! String
                    }
                    if dict.keys.contains("SnapshotId") {
                        self.snapshotId = dict["SnapshotId"] as! String
                    }
                    if dict.keys.contains("Type") {
                        self.type = dict["Type"] as! String
                    }
                }
            }
            public var diskDeviceMapping: [DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings.DiskDeviceMapping]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.diskDeviceMapping != nil {
                    var tmp : [Any] = []
                    for k in self.diskDeviceMapping! {
                        tmp.append(k.toMap())
                    }
                    map["DiskDeviceMapping"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DiskDeviceMapping") {
                    var tmp : [DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings.DiskDeviceMapping] = []
                    for v in dict["DiskDeviceMapping"] as! [Any] {
                        var model = DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings.DiskDeviceMapping()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.diskDeviceMapping = tmp
                }
            }
        }
        public class Tags : Tea.TeaModel {
            public class Tag : Tea.TeaModel {
                public var tagKey: String?

                public var tagValue: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tagKey != nil {
                        map["TagKey"] = self.tagKey!
                    }
                    if self.tagValue != nil {
                        map["TagValue"] = self.tagValue!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("TagKey") {
                        self.tagKey = dict["TagKey"] as! String
                    }
                    if dict.keys.contains("TagValue") {
                        self.tagValue = dict["TagValue"] as! String
                    }
                }
            }
            public var tag: [DescribeImageFromFamilyResponseBody.Image.Tags.Tag]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tag != nil {
                    var tmp : [Any] = []
                    for k in self.tag! {
                        tmp.append(k.toMap())
                    }
                    map["Tag"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Tag") {
                    var tmp : [DescribeImageFromFamilyResponseBody.Image.Tags.Tag] = []
                    for v in dict["Tag"] as! [Any] {
                        var model = DescribeImageFromFamilyResponseBody.Image.Tags.Tag()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.tag = tmp
                }
            }
        }
        public var architecture: String?

        public var creationTime: String?

        public var description_: String?

        public var diskDeviceMappings: DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings?

        public var imageFamily: String?

        public var imageId: String?

        public var imageName: String?

        public var imageOwnerAlias: String?

        public var imageVersion: String?

        public var isCopied: Bool?

        public var isSelfShared: String?

        public var isSubscribed: Bool?

        public var isSupportCloudinit: Bool?

        public var isSupportIoOptimized: Bool?

        public var OSName: String?

        public var OSType: String?

        public var platform: String?

        public var productCode: String?

        public var progress: String?

        public var size: Int32?

        public var status: String?

        public var tags: DescribeImageFromFamilyResponseBody.Image.Tags?

        public var usage: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.diskDeviceMappings?.validate()
            try self.tags?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.architecture != nil {
                map["Architecture"] = self.architecture!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskDeviceMappings != nil {
                map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
            }
            if self.imageFamily != nil {
                map["ImageFamily"] = self.imageFamily!
            }
            if self.imageId != nil {
                map["ImageId"] = self.imageId!
            }
            if self.imageName != nil {
                map["ImageName"] = self.imageName!
            }
            if self.imageOwnerAlias != nil {
                map["ImageOwnerAlias"] = self.imageOwnerAlias!
            }
            if self.imageVersion != nil {
                map["ImageVersion"] = self.imageVersion!
            }
            if self.isCopied != nil {
                map["IsCopied"] = self.isCopied!
            }
            if self.isSelfShared != nil {
                map["IsSelfShared"] = self.isSelfShared!
            }
            if self.isSubscribed != nil {
                map["IsSubscribed"] = self.isSubscribed!
            }
            if self.isSupportCloudinit != nil {
                map["IsSupportCloudinit"] = self.isSupportCloudinit!
            }
            if self.isSupportIoOptimized != nil {
                map["IsSupportIoOptimized"] = self.isSupportIoOptimized!
            }
            if self.OSName != nil {
                map["OSName"] = self.OSName!
            }
            if self.OSType != nil {
                map["OSType"] = self.OSType!
            }
            if self.platform != nil {
                map["Platform"] = self.platform!
            }
            if self.productCode != nil {
                map["ProductCode"] = self.productCode!
            }
            if self.progress != nil {
                map["Progress"] = self.progress!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.status != nil {
                map["Status"] = self.status!
            }
            if self.tags != nil {
                map["Tags"] = self.tags?.toMap()
            }
            if self.usage != nil {
                map["Usage"] = self.usage!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Architecture") {
                self.architecture = dict["Architecture"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskDeviceMappings") {
                var model = DescribeImageFromFamilyResponseBody.Image.DiskDeviceMappings()
                model.fromMap(dict["DiskDeviceMappings"] as! [String: Any])
                self.diskDeviceMappings = model
            }
            if dict.keys.contains("ImageFamily") {
                self.imageFamily = dict["ImageFamily"] as! String
            }
            if dict.keys.contains("ImageId") {
                self.imageId = dict["ImageId"] as! String
            }
            if dict.keys.contains("ImageName") {
                self.imageName = dict["ImageName"] as! String
            }
            if dict.keys.contains("ImageOwnerAlias") {
                self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
            }
            if dict.keys.contains("ImageVersion") {
                self.imageVersion = dict["ImageVersion"] as! String
            }
            if dict.keys.contains("IsCopied") {
                self.isCopied = dict["IsCopied"] as! Bool
            }
            if dict.keys.contains("IsSelfShared") {
                self.isSelfShared = dict["IsSelfShared"] as! String
            }
            if dict.keys.contains("IsSubscribed") {
                self.isSubscribed = dict["IsSubscribed"] as! Bool
            }
            if dict.keys.contains("IsSupportCloudinit") {
                self.isSupportCloudinit = dict["IsSupportCloudinit"] as! Bool
            }
            if dict.keys.contains("IsSupportIoOptimized") {
                self.isSupportIoOptimized = dict["IsSupportIoOptimized"] as! Bool
            }
            if dict.keys.contains("OSName") {
                self.OSName = dict["OSName"] as! String
            }
            if dict.keys.contains("OSType") {
                self.OSType = dict["OSType"] as! String
            }
            if dict.keys.contains("Platform") {
                self.platform = dict["Platform"] as! String
            }
            if dict.keys.contains("ProductCode") {
                self.productCode = dict["ProductCode"] as! String
            }
            if dict.keys.contains("Progress") {
                self.progress = dict["Progress"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("Status") {
                self.status = dict["Status"] as! String
            }
            if dict.keys.contains("Tags") {
                var model = DescribeImageFromFamilyResponseBody.Image.Tags()
                model.fromMap(dict["Tags"] as! [String: Any])
                self.tags = model
            }
            if dict.keys.contains("Usage") {
                self.usage = dict["Usage"] as! String
            }
        }
    }
    public var image: DescribeImageFromFamilyResponseBody.Image?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.image?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.image != nil {
            map["Image"] = self.image?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Image") {
            var model = DescribeImageFromFamilyResponseBody.Image()
            model.fromMap(dict["Image"] as! [String: Any])
            self.image = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageFromFamilyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageFromFamilyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageFromFamilyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImagePipelineExecutionsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var executionId: String?

    public var imagePipelineId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public var tag: [DescribeImagePipelineExecutionsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionId != nil {
            map["ExecutionId"] = self.executionId!
        }
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecutionId") {
            self.executionId = dict["ExecutionId"] as! String
        }
        if dict.keys.contains("ImagePipelineId") {
            self.imagePipelineId = dict["ImagePipelineId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeImagePipelineExecutionsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeImagePipelineExecutionsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeImagePipelineExecutionsResponseBody : Tea.TeaModel {
    public class ImagePipelineExecution : Tea.TeaModel {
        public class ImagePipelineExecutionSet : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var executionId: String?

            public var imageId: String?

            public var imagePipelineId: String?

            public var message: String?

            public var modifiedTime: String?

            public var resourceGroupId: String?

            public var status: String?

            public var tags: DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.executionId != nil {
                    map["ExecutionId"] = self.executionId!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imagePipelineId != nil {
                    map["ImagePipelineId"] = self.imagePipelineId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ExecutionId") {
                    self.executionId = dict["ExecutionId"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImagePipelineId") {
                    self.imagePipelineId = dict["ImagePipelineId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var imagePipelineExecutionSet: [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imagePipelineExecutionSet != nil {
                var tmp : [Any] = []
                for k in self.imagePipelineExecutionSet! {
                    tmp.append(k.toMap())
                }
                map["ImagePipelineExecutionSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImagePipelineExecutionSet") {
                var tmp : [DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet] = []
                for v in dict["ImagePipelineExecutionSet"] as! [Any] {
                    var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution.ImagePipelineExecutionSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imagePipelineExecutionSet = tmp
            }
        }
    }
    public var imagePipelineExecution: DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imagePipelineExecution?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineExecution != nil {
            map["ImagePipelineExecution"] = self.imagePipelineExecution?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImagePipelineExecution") {
            var model = DescribeImagePipelineExecutionsResponseBody.ImagePipelineExecution()
            model.fromMap(dict["ImagePipelineExecution"] as! [String: Any])
            self.imagePipelineExecution = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImagePipelineExecutionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagePipelineExecutionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImagePipelineExecutionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImagePipelinesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var imagePipelineId: [String]?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeImagePipelinesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImagePipelineId") {
            self.imagePipelineId = dict["ImagePipelineId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeImagePipelinesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeImagePipelinesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeImagePipelinesResponseBody : Tea.TeaModel {
    public class ImagePipeline : Tea.TeaModel {
        public class ImagePipelineSet : Tea.TeaModel {
            public class AddAccounts : Tea.TeaModel {
                public var addAccount: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.addAccount != nil {
                        map["AddAccount"] = self.addAccount!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AddAccount") {
                        self.addAccount = dict["AddAccount"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class ToRegionIds : Tea.TeaModel {
                public var toRegionId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.toRegionId != nil {
                        map["ToRegionId"] = self.toRegionId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ToRegionId") {
                        self.toRegionId = dict["ToRegionId"] as! [String]
                    }
                }
            }
            public var addAccounts: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.AddAccounts?

            public var baseImage: String?

            public var baseImageType: String?

            public var buildContent: String?

            public var creationTime: String?

            public var deleteInstanceOnFailure: Bool?

            public var description_: String?

            public var imageFamily: String?

            public var imageName: String?

            public var imagePipelineId: String?

            public var instanceType: String?

            public var internetMaxBandwidthOut: Int32?

            public var name: String?

            public var repairMode: String?

            public var resourceGroupId: String?

            public var systemDiskSize: Int32?

            public var tags: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags?

            public var testContent: String?

            public var toRegionIds: DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ToRegionIds?

            public var vSwitchId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.addAccounts?.validate()
                try self.tags?.validate()
                try self.toRegionIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addAccounts != nil {
                    map["AddAccounts"] = self.addAccounts?.toMap()
                }
                if self.baseImage != nil {
                    map["BaseImage"] = self.baseImage!
                }
                if self.baseImageType != nil {
                    map["BaseImageType"] = self.baseImageType!
                }
                if self.buildContent != nil {
                    map["BuildContent"] = self.buildContent!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deleteInstanceOnFailure != nil {
                    map["DeleteInstanceOnFailure"] = self.deleteInstanceOnFailure!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.imageFamily != nil {
                    map["ImageFamily"] = self.imageFamily!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imagePipelineId != nil {
                    map["ImagePipelineId"] = self.imagePipelineId!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.repairMode != nil {
                    map["RepairMode"] = self.repairMode!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.systemDiskSize != nil {
                    map["SystemDiskSize"] = self.systemDiskSize!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.testContent != nil {
                    map["TestContent"] = self.testContent!
                }
                if self.toRegionIds != nil {
                    map["ToRegionIds"] = self.toRegionIds?.toMap()
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddAccounts") {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.AddAccounts()
                    model.fromMap(dict["AddAccounts"] as! [String: Any])
                    self.addAccounts = model
                }
                if dict.keys.contains("BaseImage") {
                    self.baseImage = dict["BaseImage"] as! String
                }
                if dict.keys.contains("BaseImageType") {
                    self.baseImageType = dict["BaseImageType"] as! String
                }
                if dict.keys.contains("BuildContent") {
                    self.buildContent = dict["BuildContent"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeleteInstanceOnFailure") {
                    self.deleteInstanceOnFailure = dict["DeleteInstanceOnFailure"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ImageFamily") {
                    self.imageFamily = dict["ImageFamily"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImagePipelineId") {
                    self.imagePipelineId = dict["ImagePipelineId"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InternetMaxBandwidthOut") {
                    self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RepairMode") {
                    self.repairMode = dict["RepairMode"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SystemDiskSize") {
                    self.systemDiskSize = dict["SystemDiskSize"] as! Int32
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TestContent") {
                    self.testContent = dict["TestContent"] as! String
                }
                if dict.keys.contains("ToRegionIds") {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet.ToRegionIds()
                    model.fromMap(dict["ToRegionIds"] as! [String: Any])
                    self.toRegionIds = model
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
            }
        }
        public var imagePipelineSet: [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.imagePipelineSet != nil {
                var tmp : [Any] = []
                for k in self.imagePipelineSet! {
                    tmp.append(k.toMap())
                }
                map["ImagePipelineSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ImagePipelineSet") {
                var tmp : [DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet] = []
                for v in dict["ImagePipelineSet"] as! [Any] {
                    var model = DescribeImagePipelinesResponseBody.ImagePipeline.ImagePipelineSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.imagePipelineSet = tmp
            }
        }
    }
    public var imagePipeline: DescribeImagePipelinesResponseBody.ImagePipeline?

    public var maxResults: Int32?

    public var nextToken: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.imagePipeline?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imagePipeline != nil {
            map["ImagePipeline"] = self.imagePipeline?.toMap()
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImagePipeline") {
            var model = DescribeImagePipelinesResponseBody.ImagePipeline()
            model.fromMap(dict["ImagePipeline"] as! [String: Any])
            self.imagePipeline = model
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImagePipelinesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagePipelinesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImagePipelinesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageSharePermissionRequest : Tea.TeaModel {
    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeImageSharePermissionResponseBody : Tea.TeaModel {
    public class Accounts : Tea.TeaModel {
        public class Account : Tea.TeaModel {
            public var aliyunId: String?

            public var sharedTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.aliyunId != nil {
                    map["AliyunId"] = self.aliyunId!
                }
                if self.sharedTime != nil {
                    map["SharedTime"] = self.sharedTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AliyunId") {
                    self.aliyunId = dict["AliyunId"] as! String
                }
                if dict.keys.contains("SharedTime") {
                    self.sharedTime = dict["SharedTime"] as! String
                }
            }
        }
        public var account: [DescribeImageSharePermissionResponseBody.Accounts.Account]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.account != nil {
                var tmp : [Any] = []
                for k in self.account! {
                    tmp.append(k.toMap())
                }
                map["Account"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Account") {
                var tmp : [DescribeImageSharePermissionResponseBody.Accounts.Account] = []
                for v in dict["Account"] as! [Any] {
                    var model = DescribeImageSharePermissionResponseBody.Accounts.Account()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.account = tmp
            }
        }
    }
    public class ShareGroups : Tea.TeaModel {
        public class ShareGroup : Tea.TeaModel {
            public var group: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.group != nil {
                    map["Group"] = self.group!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Group") {
                    self.group = dict["Group"] as! String
                }
            }
        }
        public var shareGroup: [DescribeImageSharePermissionResponseBody.ShareGroups.ShareGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.shareGroup != nil {
                var tmp : [Any] = []
                for k in self.shareGroup! {
                    tmp.append(k.toMap())
                }
                map["ShareGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ShareGroup") {
                var tmp : [DescribeImageSharePermissionResponseBody.ShareGroups.ShareGroup] = []
                for v in dict["ShareGroup"] as! [Any] {
                    var model = DescribeImageSharePermissionResponseBody.ShareGroups.ShareGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.shareGroup = tmp
            }
        }
    }
    public var accounts: DescribeImageSharePermissionResponseBody.Accounts?

    public var imageId: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var shareGroups: DescribeImageSharePermissionResponseBody.ShareGroups?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.accounts?.validate()
        try self.shareGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.accounts != nil {
            map["Accounts"] = self.accounts?.toMap()
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.shareGroups != nil {
            map["ShareGroups"] = self.shareGroups?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Accounts") {
            var model = DescribeImageSharePermissionResponseBody.Accounts()
            model.fromMap(dict["Accounts"] as! [String: Any])
            self.accounts = model
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ShareGroups") {
            var model = DescribeImageSharePermissionResponseBody.ShareGroups()
            model.fromMap(dict["ShareGroups"] as! [String: Any])
            self.shareGroups = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageSharePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImageSupportInstanceTypesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var actionType: String?

    public var filter: [DescribeImageSupportInstanceTypesRequest.Filter]?

    public var imageId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") {
            self.actionType = dict["ActionType"] as! String
        }
        if dict.keys.contains("Filter") {
            var tmp : [DescribeImageSupportInstanceTypesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeImageSupportInstanceTypesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeImageSupportInstanceTypesResponseBody : Tea.TeaModel {
    public class InstanceTypes : Tea.TeaModel {
        public class InstanceType : Tea.TeaModel {
            public var cpuCoreCount: Int32?

            public var instanceTypeFamily: String?

            public var instanceTypeId: String?

            public var memorySize: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cpuCoreCount != nil {
                    map["CpuCoreCount"] = self.cpuCoreCount!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.instanceTypeId != nil {
                    map["InstanceTypeId"] = self.instanceTypeId!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CpuCoreCount") {
                    self.cpuCoreCount = dict["CpuCoreCount"] as! Int32
                }
                if dict.keys.contains("InstanceTypeFamily") {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("InstanceTypeId") {
                    self.instanceTypeId = dict["InstanceTypeId"] as! String
                }
                if dict.keys.contains("MemorySize") {
                    self.memorySize = dict["MemorySize"] as! Double
                }
            }
        }
        public var instanceType: [DescribeImageSupportInstanceTypesResponseBody.InstanceTypes.InstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                var tmp : [Any] = []
                for k in self.instanceType! {
                    tmp.append(k.toMap())
                }
                map["InstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                var tmp : [DescribeImageSupportInstanceTypesResponseBody.InstanceTypes.InstanceType] = []
                for v in dict["InstanceType"] as! [Any] {
                    var model = DescribeImageSupportInstanceTypesResponseBody.InstanceTypes.InstanceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceType = tmp
            }
        }
    }
    public var imageId: String?

    public var instanceTypes: DescribeImageSupportInstanceTypesResponseBody.InstanceTypes?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            var model = DescribeImageSupportInstanceTypesResponseBody.InstanceTypes()
            model.fromMap(dict["InstanceTypes"] as! [String: Any])
            self.instanceTypes = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeImageSupportInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImageSupportInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImageSupportInstanceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeImagesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var actionType: String?

    public var architecture: String?

    public var dryRun: Bool?

    public var filter: [DescribeImagesRequest.Filter]?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var imageOwnerAlias: String?

    public var imageOwnerId: Int64?

    public var instanceType: String?

    public var isPublic: Bool?

    public var isSupportCloudinit: Bool?

    public var isSupportIoOptimized: Bool?

    public var OSType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var showExpired: Bool?

    public var snapshotId: String?

    public var status: String?

    public var tag: [DescribeImagesRequest.Tag]?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionType != nil {
            map["ActionType"] = self.actionType!
        }
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.imageOwnerAlias != nil {
            map["ImageOwnerAlias"] = self.imageOwnerAlias!
        }
        if self.imageOwnerId != nil {
            map["ImageOwnerId"] = self.imageOwnerId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.isPublic != nil {
            map["IsPublic"] = self.isPublic!
        }
        if self.isSupportCloudinit != nil {
            map["IsSupportCloudinit"] = self.isSupportCloudinit!
        }
        if self.isSupportIoOptimized != nil {
            map["IsSupportIoOptimized"] = self.isSupportIoOptimized!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.showExpired != nil {
            map["ShowExpired"] = self.showExpired!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionType") {
            self.actionType = dict["ActionType"] as! String
        }
        if dict.keys.contains("Architecture") {
            self.architecture = dict["Architecture"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Filter") {
            var tmp : [DescribeImagesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeImagesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("ImageOwnerAlias") {
            self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
        }
        if dict.keys.contains("ImageOwnerId") {
            self.imageOwnerId = dict["ImageOwnerId"] as! Int64
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("IsPublic") {
            self.isPublic = dict["IsPublic"] as! Bool
        }
        if dict.keys.contains("IsSupportCloudinit") {
            self.isSupportCloudinit = dict["IsSupportCloudinit"] as! Bool
        }
        if dict.keys.contains("IsSupportIoOptimized") {
            self.isSupportIoOptimized = dict["IsSupportIoOptimized"] as! Bool
        }
        if dict.keys.contains("OSType") {
            self.OSType = dict["OSType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ShowExpired") {
            self.showExpired = dict["ShowExpired"] as! Bool
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeImagesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeImagesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class DescribeImagesResponseBody : Tea.TeaModel {
    public class Images : Tea.TeaModel {
        public class Image : Tea.TeaModel {
            public class DetectionOptions : Tea.TeaModel {
                public class Items : Tea.TeaModel {
                    public class Item : Tea.TeaModel {
                        public var name: String?

                        public var riskCode: String?

                        public var riskLevel: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            if self.riskCode != nil {
                                map["RiskCode"] = self.riskCode!
                            }
                            if self.riskLevel != nil {
                                map["RiskLevel"] = self.riskLevel!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                            if dict.keys.contains("RiskCode") {
                                self.riskCode = dict["RiskCode"] as! String
                            }
                            if dict.keys.contains("RiskLevel") {
                                self.riskLevel = dict["RiskLevel"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var item: [DescribeImagesResponseBody.Images.Image.DetectionOptions.Items.Item]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.item != nil {
                            var tmp : [Any] = []
                            for k in self.item! {
                                tmp.append(k.toMap())
                            }
                            map["Item"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Item") {
                            var tmp : [DescribeImagesResponseBody.Images.Image.DetectionOptions.Items.Item] = []
                            for v in dict["Item"] as! [Any] {
                                var model = DescribeImagesResponseBody.Images.Image.DetectionOptions.Items.Item()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.item = tmp
                        }
                    }
                }
                public var items: DescribeImagesResponseBody.Images.Image.DetectionOptions.Items?

                public var status: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.items?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.items != nil {
                        map["Items"] = self.items?.toMap()
                    }
                    if self.status != nil {
                        map["Status"] = self.status!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Items") {
                        var model = DescribeImagesResponseBody.Images.Image.DetectionOptions.Items()
                        model.fromMap(dict["Items"] as! [String: Any])
                        self.items = model
                    }
                    if dict.keys.contains("Status") {
                        self.status = dict["Status"] as! String
                    }
                }
            }
            public class DiskDeviceMappings : Tea.TeaModel {
                public class DiskDeviceMapping : Tea.TeaModel {
                    public var device: String?

                    public var format: String?

                    public var importOSSBucket: String?

                    public var importOSSObject: String?

                    public var progress: String?

                    public var remainTime: Int32?

                    public var size: String?

                    public var snapshotId: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.device != nil {
                            map["Device"] = self.device!
                        }
                        if self.format != nil {
                            map["Format"] = self.format!
                        }
                        if self.importOSSBucket != nil {
                            map["ImportOSSBucket"] = self.importOSSBucket!
                        }
                        if self.importOSSObject != nil {
                            map["ImportOSSObject"] = self.importOSSObject!
                        }
                        if self.progress != nil {
                            map["Progress"] = self.progress!
                        }
                        if self.remainTime != nil {
                            map["RemainTime"] = self.remainTime!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        if self.snapshotId != nil {
                            map["SnapshotId"] = self.snapshotId!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Device") {
                            self.device = dict["Device"] as! String
                        }
                        if dict.keys.contains("Format") {
                            self.format = dict["Format"] as! String
                        }
                        if dict.keys.contains("ImportOSSBucket") {
                            self.importOSSBucket = dict["ImportOSSBucket"] as! String
                        }
                        if dict.keys.contains("ImportOSSObject") {
                            self.importOSSObject = dict["ImportOSSObject"] as! String
                        }
                        if dict.keys.contains("Progress") {
                            self.progress = dict["Progress"] as! String
                        }
                        if dict.keys.contains("RemainTime") {
                            self.remainTime = dict["RemainTime"] as! Int32
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! String
                        }
                        if dict.keys.contains("SnapshotId") {
                            self.snapshotId = dict["SnapshotId"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var diskDeviceMapping: [DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskDeviceMapping != nil {
                        var tmp : [Any] = []
                        for k in self.diskDeviceMapping! {
                            tmp.append(k.toMap())
                        }
                        map["DiskDeviceMapping"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskDeviceMapping") {
                        var tmp : [DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping] = []
                        for v in dict["DiskDeviceMapping"] as! [Any] {
                            var model = DescribeImagesResponseBody.Images.Image.DiskDeviceMappings.DiskDeviceMapping()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.diskDeviceMapping = tmp
                    }
                }
            }
            public class Features : Tea.TeaModel {
                public var nvmeSupport: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.nvmeSupport != nil {
                        map["NvmeSupport"] = self.nvmeSupport!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NvmeSupport") {
                        self.nvmeSupport = dict["NvmeSupport"] as! String
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeImagesResponseBody.Images.Image.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeImagesResponseBody.Images.Image.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeImagesResponseBody.Images.Image.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var architecture: String?

            public var bootMode: String?

            public var creationTime: String?

            public var description_: String?

            public var detectionOptions: DescribeImagesResponseBody.Images.Image.DetectionOptions?

            public var diskDeviceMappings: DescribeImagesResponseBody.Images.Image.DiskDeviceMappings?

            public var features: DescribeImagesResponseBody.Images.Image.Features?

            public var imageFamily: String?

            public var imageId: String?

            public var imageName: String?

            public var imageOwnerAlias: String?

            public var imageOwnerId: Int64?

            public var imageVersion: String?

            public var isCopied: Bool?

            public var isPublic: Bool?

            public var isSelfShared: String?

            public var isSubscribed: Bool?

            public var isSupportCloudinit: Bool?

            public var isSupportIoOptimized: Bool?

            public var loginAsNonRootSupported: Bool?

            public var OSName: String?

            public var OSNameEn: String?

            public var OSType: String?

            public var platform: String?

            public var productCode: String?

            public var progress: String?

            public var resourceGroupId: String?

            public var size: Int32?

            public var status: String?

            public var supplierName: String?

            public var tags: DescribeImagesResponseBody.Images.Image.Tags?

            public var usage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detectionOptions?.validate()
                try self.diskDeviceMappings?.validate()
                try self.features?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.architecture != nil {
                    map["Architecture"] = self.architecture!
                }
                if self.bootMode != nil {
                    map["BootMode"] = self.bootMode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.detectionOptions != nil {
                    map["DetectionOptions"] = self.detectionOptions?.toMap()
                }
                if self.diskDeviceMappings != nil {
                    map["DiskDeviceMappings"] = self.diskDeviceMappings?.toMap()
                }
                if self.features != nil {
                    map["Features"] = self.features?.toMap()
                }
                if self.imageFamily != nil {
                    map["ImageFamily"] = self.imageFamily!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageName != nil {
                    map["ImageName"] = self.imageName!
                }
                if self.imageOwnerAlias != nil {
                    map["ImageOwnerAlias"] = self.imageOwnerAlias!
                }
                if self.imageOwnerId != nil {
                    map["ImageOwnerId"] = self.imageOwnerId!
                }
                if self.imageVersion != nil {
                    map["ImageVersion"] = self.imageVersion!
                }
                if self.isCopied != nil {
                    map["IsCopied"] = self.isCopied!
                }
                if self.isPublic != nil {
                    map["IsPublic"] = self.isPublic!
                }
                if self.isSelfShared != nil {
                    map["IsSelfShared"] = self.isSelfShared!
                }
                if self.isSubscribed != nil {
                    map["IsSubscribed"] = self.isSubscribed!
                }
                if self.isSupportCloudinit != nil {
                    map["IsSupportCloudinit"] = self.isSupportCloudinit!
                }
                if self.isSupportIoOptimized != nil {
                    map["IsSupportIoOptimized"] = self.isSupportIoOptimized!
                }
                if self.loginAsNonRootSupported != nil {
                    map["LoginAsNonRootSupported"] = self.loginAsNonRootSupported!
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.OSNameEn != nil {
                    map["OSNameEn"] = self.OSNameEn!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.productCode != nil {
                    map["ProductCode"] = self.productCode!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.supplierName != nil {
                    map["SupplierName"] = self.supplierName!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Architecture") {
                    self.architecture = dict["Architecture"] as! String
                }
                if dict.keys.contains("BootMode") {
                    self.bootMode = dict["BootMode"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DetectionOptions") {
                    var model = DescribeImagesResponseBody.Images.Image.DetectionOptions()
                    model.fromMap(dict["DetectionOptions"] as! [String: Any])
                    self.detectionOptions = model
                }
                if dict.keys.contains("DiskDeviceMappings") {
                    var model = DescribeImagesResponseBody.Images.Image.DiskDeviceMappings()
                    model.fromMap(dict["DiskDeviceMappings"] as! [String: Any])
                    self.diskDeviceMappings = model
                }
                if dict.keys.contains("Features") {
                    var model = DescribeImagesResponseBody.Images.Image.Features()
                    model.fromMap(dict["Features"] as! [String: Any])
                    self.features = model
                }
                if dict.keys.contains("ImageFamily") {
                    self.imageFamily = dict["ImageFamily"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageName") {
                    self.imageName = dict["ImageName"] as! String
                }
                if dict.keys.contains("ImageOwnerAlias") {
                    self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                }
                if dict.keys.contains("ImageOwnerId") {
                    self.imageOwnerId = dict["ImageOwnerId"] as! Int64
                }
                if dict.keys.contains("ImageVersion") {
                    self.imageVersion = dict["ImageVersion"] as! String
                }
                if dict.keys.contains("IsCopied") {
                    self.isCopied = dict["IsCopied"] as! Bool
                }
                if dict.keys.contains("IsPublic") {
                    self.isPublic = dict["IsPublic"] as! Bool
                }
                if dict.keys.contains("IsSelfShared") {
                    self.isSelfShared = dict["IsSelfShared"] as! String
                }
                if dict.keys.contains("IsSubscribed") {
                    self.isSubscribed = dict["IsSubscribed"] as! Bool
                }
                if dict.keys.contains("IsSupportCloudinit") {
                    self.isSupportCloudinit = dict["IsSupportCloudinit"] as! Bool
                }
                if dict.keys.contains("IsSupportIoOptimized") {
                    self.isSupportIoOptimized = dict["IsSupportIoOptimized"] as! Bool
                }
                if dict.keys.contains("LoginAsNonRootSupported") {
                    self.loginAsNonRootSupported = dict["LoginAsNonRootSupported"] as! Bool
                }
                if dict.keys.contains("OSName") {
                    self.OSName = dict["OSName"] as! String
                }
                if dict.keys.contains("OSNameEn") {
                    self.OSNameEn = dict["OSNameEn"] as! String
                }
                if dict.keys.contains("OSType") {
                    self.OSType = dict["OSType"] as! String
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("ProductCode") {
                    self.productCode = dict["ProductCode"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int32
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("SupplierName") {
                    self.supplierName = dict["SupplierName"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeImagesResponseBody.Images.Image.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Usage") {
                    self.usage = dict["Usage"] as! String
                }
            }
        }
        public var image: [DescribeImagesResponseBody.Images.Image]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.image != nil {
                var tmp : [Any] = []
                for k in self.image! {
                    tmp.append(k.toMap())
                }
                map["Image"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Image") {
                var tmp : [DescribeImagesResponseBody.Images.Image] = []
                for v in dict["Image"] as! [Any] {
                    var model = DescribeImagesResponseBody.Images.Image()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.image = tmp
            }
        }
    }
    public var images: DescribeImagesResponseBody.Images?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.images?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.images != nil {
            map["Images"] = self.images?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Images") {
            var model = DescribeImagesResponseBody.Images()
            model.fromMap(dict["Images"] as! [String: Any])
            self.images = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeImagesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeImagesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeImagesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceAttachmentAttributesRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceAttachmentAttributesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public var instanceId: String?

            public var privatePoolOptionsId: String?

            public var privatePoolOptionsMatchCriteria: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.privatePoolOptionsId != nil {
                    map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
                }
                if self.privatePoolOptionsMatchCriteria != nil {
                    map["PrivatePoolOptionsMatchCriteria"] = self.privatePoolOptionsMatchCriteria!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsId") {
                    self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! String
                }
                if dict.keys.contains("PrivatePoolOptionsMatchCriteria") {
                    self.privatePoolOptionsMatchCriteria = dict["PrivatePoolOptionsMatchCriteria"] as! String
                }
            }
        }
        public var instance: [DescribeInstanceAttachmentAttributesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [DescribeInstanceAttachmentAttributesResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = DescribeInstanceAttachmentAttributesResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeInstanceAttachmentAttributesResponseBody.Instances?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = DescribeInstanceAttachmentAttributesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceAttachmentAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAttachmentAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceAttachmentAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceAttributeResponseBody : Tea.TeaModel {
    public class DedicatedHostAttribute : Tea.TeaModel {
        public var dedicatedHostId: String?

        public var dedicatedHostName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            if self.dedicatedHostName != nil {
                map["DedicatedHostName"] = self.dedicatedHostName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostId") {
                self.dedicatedHostId = dict["DedicatedHostId"] as! String
            }
            if dict.keys.contains("DedicatedHostName") {
                self.dedicatedHostName = dict["DedicatedHostName"] as! String
            }
        }
    }
    public class EipAddress : Tea.TeaModel {
        public var allocationId: String?

        public var bandwidth: Int32?

        public var internetChargeType: String?

        public var ipAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocationId != nil {
                map["AllocationId"] = self.allocationId!
            }
            if self.bandwidth != nil {
                map["Bandwidth"] = self.bandwidth!
            }
            if self.internetChargeType != nil {
                map["InternetChargeType"] = self.internetChargeType!
            }
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllocationId") {
                self.allocationId = dict["AllocationId"] as! String
            }
            if dict.keys.contains("Bandwidth") {
                self.bandwidth = dict["Bandwidth"] as! Int32
            }
            if dict.keys.contains("InternetChargeType") {
                self.internetChargeType = dict["InternetChargeType"] as! String
            }
            if dict.keys.contains("IpAddress") {
                self.ipAddress = dict["IpAddress"] as! String
            }
        }
    }
    public class InnerIpAddress : Tea.TeaModel {
        public var ipAddress: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpAddress") {
                self.ipAddress = dict["IpAddress"] as! [String]
            }
        }
    }
    public class OperationLocks : Tea.TeaModel {
        public class LockReason : Tea.TeaModel {
            public var lockReason: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.lockReason != nil {
                    map["LockReason"] = self.lockReason!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LockReason") {
                    self.lockReason = dict["LockReason"] as! String
                }
            }
        }
        public var lockReason: [DescribeInstanceAttributeResponseBody.OperationLocks.LockReason]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.lockReason != nil {
                var tmp : [Any] = []
                for k in self.lockReason! {
                    tmp.append(k.toMap())
                }
                map["LockReason"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LockReason") {
                var tmp : [DescribeInstanceAttributeResponseBody.OperationLocks.LockReason] = []
                for v in dict["LockReason"] as! [Any] {
                    var model = DescribeInstanceAttributeResponseBody.OperationLocks.LockReason()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.lockReason = tmp
            }
        }
    }
    public class PublicIpAddress : Tea.TeaModel {
        public var ipAddress: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipAddress != nil {
                map["IpAddress"] = self.ipAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IpAddress") {
                self.ipAddress = dict["IpAddress"] as! [String]
            }
        }
    }
    public class SecurityGroupIds : Tea.TeaModel {
        public var securityGroupId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! [String]
            }
        }
    }
    public class VpcAttributes : Tea.TeaModel {
        public class PrivateIpAddress : Tea.TeaModel {
            public var ipAddress: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipAddress != nil {
                    map["IpAddress"] = self.ipAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("IpAddress") {
                    self.ipAddress = dict["IpAddress"] as! [String]
                }
            }
        }
        public var natIpAddress: String?

        public var privateIpAddress: DescribeInstanceAttributeResponseBody.VpcAttributes.PrivateIpAddress?

        public var vSwitchId: String?

        public var vpcId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.privateIpAddress?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natIpAddress != nil {
                map["NatIpAddress"] = self.natIpAddress!
            }
            if self.privateIpAddress != nil {
                map["PrivateIpAddress"] = self.privateIpAddress?.toMap()
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.vpcId != nil {
                map["VpcId"] = self.vpcId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NatIpAddress") {
                self.natIpAddress = dict["NatIpAddress"] as! String
            }
            if dict.keys.contains("PrivateIpAddress") {
                var model = DescribeInstanceAttributeResponseBody.VpcAttributes.PrivateIpAddress()
                model.fromMap(dict["PrivateIpAddress"] as! [String: Any])
                self.privateIpAddress = model
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("VpcId") {
                self.vpcId = dict["VpcId"] as! String
            }
        }
    }
    public var clusterId: String?

    public var cpu: Int32?

    public var creationTime: String?

    public var creditSpecification: String?

    public var dedicatedHostAttribute: DescribeInstanceAttributeResponseBody.DedicatedHostAttribute?

    public var description_: String?

    public var eipAddress: DescribeInstanceAttributeResponseBody.EipAddress?

    public var enableJumboFrame: Bool?

    public var expiredTime: String?

    public var hostName: String?

    public var imageId: String?

    public var innerIpAddress: DescribeInstanceAttributeResponseBody.InnerIpAddress?

    public var instanceChargeType: String?

    public var instanceId: String?

    public var instanceName: String?

    public var instanceNetworkType: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var memory: Int32?

    public var operationLocks: DescribeInstanceAttributeResponseBody.OperationLocks?

    public var publicIpAddress: DescribeInstanceAttributeResponseBody.PublicIpAddress?

    public var regionId: String?

    public var requestId: String?

    public var securityGroupIds: DescribeInstanceAttributeResponseBody.SecurityGroupIds?

    public var serialNumber: String?

    public var status: String?

    public var stoppedMode: String?

    public var vlanId: String?

    public var vpcAttributes: DescribeInstanceAttributeResponseBody.VpcAttributes?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.dedicatedHostAttribute?.validate()
        try self.eipAddress?.validate()
        try self.innerIpAddress?.validate()
        try self.operationLocks?.validate()
        try self.publicIpAddress?.validate()
        try self.securityGroupIds?.validate()
        try self.vpcAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.cpu != nil {
            map["Cpu"] = self.cpu!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dedicatedHostAttribute != nil {
            map["DedicatedHostAttribute"] = self.dedicatedHostAttribute?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.eipAddress != nil {
            map["EipAddress"] = self.eipAddress?.toMap()
        }
        if self.enableJumboFrame != nil {
            map["EnableJumboFrame"] = self.enableJumboFrame!
        }
        if self.expiredTime != nil {
            map["ExpiredTime"] = self.expiredTime!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.innerIpAddress != nil {
            map["InnerIpAddress"] = self.innerIpAddress?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.operationLocks != nil {
            map["OperationLocks"] = self.operationLocks?.toMap()
        }
        if self.publicIpAddress != nil {
            map["PublicIpAddress"] = self.publicIpAddress?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
        }
        if self.serialNumber != nil {
            map["SerialNumber"] = self.serialNumber!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        if self.vpcAttributes != nil {
            map["VpcAttributes"] = self.vpcAttributes?.toMap()
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("Cpu") {
            self.cpu = dict["Cpu"] as! Int32
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DedicatedHostAttribute") {
            var model = DescribeInstanceAttributeResponseBody.DedicatedHostAttribute()
            model.fromMap(dict["DedicatedHostAttribute"] as! [String: Any])
            self.dedicatedHostAttribute = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EipAddress") {
            var model = DescribeInstanceAttributeResponseBody.EipAddress()
            model.fromMap(dict["EipAddress"] as! [String: Any])
            self.eipAddress = model
        }
        if dict.keys.contains("EnableJumboFrame") {
            self.enableJumboFrame = dict["EnableJumboFrame"] as! Bool
        }
        if dict.keys.contains("ExpiredTime") {
            self.expiredTime = dict["ExpiredTime"] as! String
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InnerIpAddress") {
            var model = DescribeInstanceAttributeResponseBody.InnerIpAddress()
            model.fromMap(dict["InnerIpAddress"] as! [String: Any])
            self.innerIpAddress = model
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceNetworkType") {
            self.instanceNetworkType = dict["InstanceNetworkType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Int32
        }
        if dict.keys.contains("OperationLocks") {
            var model = DescribeInstanceAttributeResponseBody.OperationLocks()
            model.fromMap(dict["OperationLocks"] as! [String: Any])
            self.operationLocks = model
        }
        if dict.keys.contains("PublicIpAddress") {
            var model = DescribeInstanceAttributeResponseBody.PublicIpAddress()
            model.fromMap(dict["PublicIpAddress"] as! [String: Any])
            self.publicIpAddress = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            var model = DescribeInstanceAttributeResponseBody.SecurityGroupIds()
            model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
            self.securityGroupIds = model
        }
        if dict.keys.contains("SerialNumber") {
            self.serialNumber = dict["SerialNumber"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("StoppedMode") {
            self.stoppedMode = dict["StoppedMode"] as! String
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! String
        }
        if dict.keys.contains("VpcAttributes") {
            var model = DescribeInstanceAttributeResponseBody.VpcAttributes()
            model.fromMap(dict["VpcAttributes"] as! [String: Any])
            self.vpcAttributes = model
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: String?

    public var pageSize: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! String
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RenewalStatus") {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public class InstanceRenewAttributes : Tea.TeaModel {
        public class InstanceRenewAttribute : Tea.TeaModel {
            public var autoRenewEnabled: Bool?

            public var duration: Int32?

            public var instanceId: String?

            public var periodUnit: String?

            public var renewalStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoRenewEnabled != nil {
                    map["AutoRenewEnabled"] = self.autoRenewEnabled!
                }
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoRenewEnabled") {
                    self.autoRenewEnabled = dict["AutoRenewEnabled"] as! Bool
                }
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PeriodUnit") {
                    self.periodUnit = dict["PeriodUnit"] as! String
                }
                if dict.keys.contains("RenewalStatus") {
                    self.renewalStatus = dict["RenewalStatus"] as! String
                }
            }
        }
        public var instanceRenewAttribute: [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.instanceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["InstanceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceRenewAttribute") {
                var tmp : [DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute] = []
                for v in dict["InstanceRenewAttribute"] as! [Any] {
                    var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes.InstanceRenewAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceRenewAttribute = tmp
            }
        }
    }
    public var instanceRenewAttributes: DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRenewAttributes != nil {
            map["InstanceRenewAttributes"] = self.instanceRenewAttributes?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRenewAttributes") {
            var model = DescribeInstanceAutoRenewAttributeResponseBody.InstanceRenewAttributes()
            model.fromMap(dict["InstanceRenewAttributes"] as! [String: Any])
            self.instanceRenewAttributes = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceHistoryEventsRequest : Tea.TeaModel {
    public class EventPublishTime : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("End") {
                self.end = dict["End"] as! String
            }
            if dict.keys.contains("Start") {
                self.start = dict["Start"] as! String
            }
        }
    }
    public class NotBefore : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("End") {
                self.end = dict["End"] as! String
            }
            if dict.keys.contains("Start") {
                self.start = dict["Start"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var eventPublishTime: DescribeInstanceHistoryEventsRequest.EventPublishTime?

    public var notBefore: DescribeInstanceHistoryEventsRequest.NotBefore?

    public var eventCycleStatus: String?

    public var eventId: [String]?

    public var eventType: String?

    public var impactLevel: String?

    public var instanceEventCycleStatus: [String]?

    public var instanceEventType: [String]?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeInstanceHistoryEventsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventPublishTime?.validate()
        try self.notBefore?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventPublishTime != nil {
            map["EventPublishTime"] = self.eventPublishTime?.toMap()
        }
        if self.notBefore != nil {
            map["NotBefore"] = self.notBefore?.toMap()
        }
        if self.eventCycleStatus != nil {
            map["EventCycleStatus"] = self.eventCycleStatus!
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.impactLevel != nil {
            map["ImpactLevel"] = self.impactLevel!
        }
        if self.instanceEventCycleStatus != nil {
            map["InstanceEventCycleStatus"] = self.instanceEventCycleStatus!
        }
        if self.instanceEventType != nil {
            map["InstanceEventType"] = self.instanceEventType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventPublishTime") {
            var model = DescribeInstanceHistoryEventsRequest.EventPublishTime()
            model.fromMap(dict["EventPublishTime"] as! [String: Any])
            self.eventPublishTime = model
        }
        if dict.keys.contains("NotBefore") {
            var model = DescribeInstanceHistoryEventsRequest.NotBefore()
            model.fromMap(dict["NotBefore"] as! [String: Any])
            self.notBefore = model
        }
        if dict.keys.contains("EventCycleStatus") {
            self.eventCycleStatus = dict["EventCycleStatus"] as! String
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! [String]
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("ImpactLevel") {
            self.impactLevel = dict["ImpactLevel"] as! String
        }
        if dict.keys.contains("InstanceEventCycleStatus") {
            self.instanceEventCycleStatus = dict["InstanceEventCycleStatus"] as! [String]
        }
        if dict.keys.contains("InstanceEventType") {
            self.instanceEventType = dict["InstanceEventType"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeInstanceHistoryEventsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeInstanceHistoryEventsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeInstanceHistoryEventsResponseBody : Tea.TeaModel {
    public class InstanceSystemEventSet : Tea.TeaModel {
        public class InstanceSystemEventType : Tea.TeaModel {
            public class EventCycleStatus : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class EventType : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class ExtendedAttribute : Tea.TeaModel {
                public class InactiveDisks : Tea.TeaModel {
                    public class InactiveDisk : Tea.TeaModel {
                        public var creationTime: String?

                        public var deviceCategory: String?

                        public var deviceSize: String?

                        public var deviceType: String?

                        public var releaseTime: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.creationTime != nil {
                                map["CreationTime"] = self.creationTime!
                            }
                            if self.deviceCategory != nil {
                                map["DeviceCategory"] = self.deviceCategory!
                            }
                            if self.deviceSize != nil {
                                map["DeviceSize"] = self.deviceSize!
                            }
                            if self.deviceType != nil {
                                map["DeviceType"] = self.deviceType!
                            }
                            if self.releaseTime != nil {
                                map["ReleaseTime"] = self.releaseTime!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("CreationTime") {
                                self.creationTime = dict["CreationTime"] as! String
                            }
                            if dict.keys.contains("DeviceCategory") {
                                self.deviceCategory = dict["DeviceCategory"] as! String
                            }
                            if dict.keys.contains("DeviceSize") {
                                self.deviceSize = dict["DeviceSize"] as! String
                            }
                            if dict.keys.contains("DeviceType") {
                                self.deviceType = dict["DeviceType"] as! String
                            }
                            if dict.keys.contains("ReleaseTime") {
                                self.releaseTime = dict["ReleaseTime"] as! String
                            }
                        }
                    }
                    public var inactiveDisk: [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.inactiveDisk != nil {
                            var tmp : [Any] = []
                            for k in self.inactiveDisk! {
                                tmp.append(k.toMap())
                            }
                            map["InactiveDisk"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InactiveDisk") {
                            var tmp : [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk] = []
                            for v in dict["InactiveDisk"] as! [Any] {
                                var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.inactiveDisk = tmp
                        }
                    }
                }
                public class MigrationOptions : Tea.TeaModel {
                    public var migrationOption: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.migrationOption != nil {
                            map["MigrationOption"] = self.migrationOption!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("MigrationOption") {
                            self.migrationOption = dict["MigrationOption"] as! [String]
                        }
                    }
                }
                public var canAccept: String?

                public var code: String?

                public var device: String?

                public var diskId: String?

                public var hostId: String?

                public var hostType: String?

                public var inactiveDisks: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks?

                public var migrationOptions: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.MigrationOptions?

                public var onlineRepairPolicy: String?

                public var punishDomain: String?

                public var punishType: String?

                public var punishUrl: String?

                public var rack: String?

                public var responseResult: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.inactiveDisks?.validate()
                    try self.migrationOptions?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.canAccept != nil {
                        map["CanAccept"] = self.canAccept!
                    }
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.device != nil {
                        map["Device"] = self.device!
                    }
                    if self.diskId != nil {
                        map["DiskId"] = self.diskId!
                    }
                    if self.hostId != nil {
                        map["HostId"] = self.hostId!
                    }
                    if self.hostType != nil {
                        map["HostType"] = self.hostType!
                    }
                    if self.inactiveDisks != nil {
                        map["InactiveDisks"] = self.inactiveDisks?.toMap()
                    }
                    if self.migrationOptions != nil {
                        map["MigrationOptions"] = self.migrationOptions?.toMap()
                    }
                    if self.onlineRepairPolicy != nil {
                        map["OnlineRepairPolicy"] = self.onlineRepairPolicy!
                    }
                    if self.punishDomain != nil {
                        map["PunishDomain"] = self.punishDomain!
                    }
                    if self.punishType != nil {
                        map["PunishType"] = self.punishType!
                    }
                    if self.punishUrl != nil {
                        map["PunishUrl"] = self.punishUrl!
                    }
                    if self.rack != nil {
                        map["Rack"] = self.rack!
                    }
                    if self.responseResult != nil {
                        map["ResponseResult"] = self.responseResult!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CanAccept") {
                        self.canAccept = dict["CanAccept"] as! String
                    }
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! String
                    }
                    if dict.keys.contains("Device") {
                        self.device = dict["Device"] as! String
                    }
                    if dict.keys.contains("DiskId") {
                        self.diskId = dict["DiskId"] as! String
                    }
                    if dict.keys.contains("HostId") {
                        self.hostId = dict["HostId"] as! String
                    }
                    if dict.keys.contains("HostType") {
                        self.hostType = dict["HostType"] as! String
                    }
                    if dict.keys.contains("InactiveDisks") {
                        var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.InactiveDisks()
                        model.fromMap(dict["InactiveDisks"] as! [String: Any])
                        self.inactiveDisks = model
                    }
                    if dict.keys.contains("MigrationOptions") {
                        var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute.MigrationOptions()
                        model.fromMap(dict["MigrationOptions"] as! [String: Any])
                        self.migrationOptions = model
                    }
                    if dict.keys.contains("OnlineRepairPolicy") {
                        self.onlineRepairPolicy = dict["OnlineRepairPolicy"] as! String
                    }
                    if dict.keys.contains("PunishDomain") {
                        self.punishDomain = dict["PunishDomain"] as! String
                    }
                    if dict.keys.contains("PunishType") {
                        self.punishType = dict["PunishType"] as! String
                    }
                    if dict.keys.contains("PunishUrl") {
                        self.punishUrl = dict["PunishUrl"] as! String
                    }
                    if dict.keys.contains("Rack") {
                        self.rack = dict["Rack"] as! String
                    }
                    if dict.keys.contains("ResponseResult") {
                        self.responseResult = dict["ResponseResult"] as! String
                    }
                }
            }
            public var eventCycleStatus: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventCycleStatus?

            public var eventFinishTime: String?

            public var eventId: String?

            public var eventPublishTime: String?

            public var eventType: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventType?

            public var extendedAttribute: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute?

            public var impactLevel: String?

            public var instanceId: String?

            public var notBefore: String?

            public var reason: String?

            public var reasonCode: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.eventCycleStatus?.validate()
                try self.eventType?.validate()
                try self.extendedAttribute?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eventCycleStatus != nil {
                    map["EventCycleStatus"] = self.eventCycleStatus?.toMap()
                }
                if self.eventFinishTime != nil {
                    map["EventFinishTime"] = self.eventFinishTime!
                }
                if self.eventId != nil {
                    map["EventId"] = self.eventId!
                }
                if self.eventPublishTime != nil {
                    map["EventPublishTime"] = self.eventPublishTime!
                }
                if self.eventType != nil {
                    map["EventType"] = self.eventType?.toMap()
                }
                if self.extendedAttribute != nil {
                    map["ExtendedAttribute"] = self.extendedAttribute?.toMap()
                }
                if self.impactLevel != nil {
                    map["ImpactLevel"] = self.impactLevel!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.notBefore != nil {
                    map["NotBefore"] = self.notBefore!
                }
                if self.reason != nil {
                    map["Reason"] = self.reason!
                }
                if self.reasonCode != nil {
                    map["ReasonCode"] = self.reasonCode!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EventCycleStatus") {
                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventCycleStatus()
                    model.fromMap(dict["EventCycleStatus"] as! [String: Any])
                    self.eventCycleStatus = model
                }
                if dict.keys.contains("EventFinishTime") {
                    self.eventFinishTime = dict["EventFinishTime"] as! String
                }
                if dict.keys.contains("EventId") {
                    self.eventId = dict["EventId"] as! String
                }
                if dict.keys.contains("EventPublishTime") {
                    self.eventPublishTime = dict["EventPublishTime"] as! String
                }
                if dict.keys.contains("EventType") {
                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.EventType()
                    model.fromMap(dict["EventType"] as! [String: Any])
                    self.eventType = model
                }
                if dict.keys.contains("ExtendedAttribute") {
                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType.ExtendedAttribute()
                    model.fromMap(dict["ExtendedAttribute"] as! [String: Any])
                    self.extendedAttribute = model
                }
                if dict.keys.contains("ImpactLevel") {
                    self.impactLevel = dict["ImpactLevel"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("NotBefore") {
                    self.notBefore = dict["NotBefore"] as! String
                }
                if dict.keys.contains("Reason") {
                    self.reason = dict["Reason"] as! String
                }
                if dict.keys.contains("ReasonCode") {
                    self.reasonCode = dict["ReasonCode"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
            }
        }
        public var instanceSystemEventType: [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceSystemEventType != nil {
                var tmp : [Any] = []
                for k in self.instanceSystemEventType! {
                    tmp.append(k.toMap())
                }
                map["InstanceSystemEventType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceSystemEventType") {
                var tmp : [DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType] = []
                for v in dict["InstanceSystemEventType"] as! [Any] {
                    var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet.InstanceSystemEventType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceSystemEventType = tmp
            }
        }
    }
    public var instanceSystemEventSet: DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceSystemEventSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceSystemEventSet != nil {
            map["InstanceSystemEventSet"] = self.instanceSystemEventSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceSystemEventSet") {
            var model = DescribeInstanceHistoryEventsResponseBody.InstanceSystemEventSet()
            model.fromMap(dict["InstanceSystemEventSet"] as! [String: Any])
            self.instanceSystemEventSet = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceHistoryEventsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceHistoryEventsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceHistoryEventsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceMaintenanceAttributesRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceMaintenanceAttributesResponseBody : Tea.TeaModel {
    public class MaintenanceAttributes : Tea.TeaModel {
        public class MaintenanceAttribute : Tea.TeaModel {
            public class ActionOnMaintenance : Tea.TeaModel {
                public class SupportedValues : Tea.TeaModel {
                    public var supportedValue: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedValue != nil {
                            map["SupportedValue"] = self.supportedValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SupportedValue") {
                            self.supportedValue = dict["SupportedValue"] as! [String]
                        }
                    }
                }
                public var defaultValue: String?

                public var supportedValues: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance.SupportedValues?

                public var value: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.supportedValues?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.defaultValue != nil {
                        map["DefaultValue"] = self.defaultValue!
                    }
                    if self.supportedValues != nil {
                        map["SupportedValues"] = self.supportedValues?.toMap()
                    }
                    if self.value != nil {
                        map["Value"] = self.value!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DefaultValue") {
                        self.defaultValue = dict["DefaultValue"] as! String
                    }
                    if dict.keys.contains("SupportedValues") {
                        var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance.SupportedValues()
                        model.fromMap(dict["SupportedValues"] as! [String: Any])
                        self.supportedValues = model
                    }
                    if dict.keys.contains("Value") {
                        self.value = dict["Value"] as! String
                    }
                }
            }
            public class MaintenanceWindows : Tea.TeaModel {
                public class MaintenanceWindow : Tea.TeaModel {
                    public var endTime: String?

                    public var startTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                    }
                }
                public var maintenanceWindow: [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.maintenanceWindow != nil {
                        var tmp : [Any] = []
                        for k in self.maintenanceWindow! {
                            tmp.append(k.toMap())
                        }
                        map["MaintenanceWindow"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("MaintenanceWindow") {
                        var tmp : [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow] = []
                        for v in dict["MaintenanceWindow"] as! [Any] {
                            var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows.MaintenanceWindow()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.maintenanceWindow = tmp
                    }
                }
            }
            public var actionOnMaintenance: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance?

            public var instanceId: String?

            public var maintenanceWindows: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows?

            public var notifyOnMaintenance: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.actionOnMaintenance?.validate()
                try self.maintenanceWindows?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.actionOnMaintenance != nil {
                    map["ActionOnMaintenance"] = self.actionOnMaintenance?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.maintenanceWindows != nil {
                    map["MaintenanceWindows"] = self.maintenanceWindows?.toMap()
                }
                if self.notifyOnMaintenance != nil {
                    map["NotifyOnMaintenance"] = self.notifyOnMaintenance!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActionOnMaintenance") {
                    var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.ActionOnMaintenance()
                    model.fromMap(dict["ActionOnMaintenance"] as! [String: Any])
                    self.actionOnMaintenance = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("MaintenanceWindows") {
                    var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute.MaintenanceWindows()
                    model.fromMap(dict["MaintenanceWindows"] as! [String: Any])
                    self.maintenanceWindows = model
                }
                if dict.keys.contains("NotifyOnMaintenance") {
                    self.notifyOnMaintenance = dict["NotifyOnMaintenance"] as! Bool
                }
            }
        }
        public var maintenanceAttribute: [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.maintenanceAttribute != nil {
                var tmp : [Any] = []
                for k in self.maintenanceAttribute! {
                    tmp.append(k.toMap())
                }
                map["MaintenanceAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("MaintenanceAttribute") {
                var tmp : [DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute] = []
                for v in dict["MaintenanceAttribute"] as! [Any] {
                    var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes.MaintenanceAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.maintenanceAttribute = tmp
            }
        }
    }
    public var maintenanceAttributes: DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.maintenanceAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maintenanceAttributes != nil {
            map["MaintenanceAttributes"] = self.maintenanceAttributes?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaintenanceAttributes") {
            var model = DescribeInstanceMaintenanceAttributesResponseBody.MaintenanceAttributes()
            model.fromMap(dict["MaintenanceAttributes"] as! [String: Any])
            self.maintenanceAttributes = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceMaintenanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceMaintenanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceMaintenanceAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceModificationPriceRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public var systemDisk: DescribeInstanceModificationPriceRequest.SystemDisk?

    public var dataDisk: [DescribeInstanceModificationPriceRequest.DataDisk]?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SystemDisk") {
            var model = DescribeInstanceModificationPriceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("DataDisk") {
            var tmp : [DescribeInstanceModificationPriceRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = DescribeInstanceModificationPriceRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceModificationPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var description_: String?

                public var ruleId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int64
                    }
                }
            }
            public var rule: [DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Rule") {
                    var tmp : [DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule] = []
                    for v in dict["Rule"] as! [Any] {
                        var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules.Rule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rule = tmp
                }
            }
        }
        public var price: DescribeInstanceModificationPriceResponseBody.PriceInfo.Price?

        public var rules: DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("Rules") {
                var model = DescribeInstanceModificationPriceResponseBody.PriceInfo.Rules()
                model.fromMap(dict["Rules"] as! [String: Any])
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribeInstanceModificationPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeInstanceModificationPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceModificationPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceModificationPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceModificationPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceMonitorDataRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeInstanceMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class InstanceMonitorData : Tea.TeaModel {
            public var BPSRead: Int32?

            public var BPSWrite: Int32?

            public var CPU: Int32?

            public var CPUAdvanceCreditBalance: Double?

            public var CPUCreditBalance: Double?

            public var CPUCreditUsage: Double?

            public var CPUNotpaidSurplusCreditUsage: Double?

            public var IOPSRead: Int32?

            public var IOPSWrite: Int32?

            public var instanceId: String?

            public var internetBandwidth: Int32?

            public var internetRX: Int32?

            public var internetTX: Int32?

            public var intranetBandwidth: Int32?

            public var intranetRX: Int32?

            public var intranetTX: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.BPSRead != nil {
                    map["BPSRead"] = self.BPSRead!
                }
                if self.BPSWrite != nil {
                    map["BPSWrite"] = self.BPSWrite!
                }
                if self.CPU != nil {
                    map["CPU"] = self.CPU!
                }
                if self.CPUAdvanceCreditBalance != nil {
                    map["CPUAdvanceCreditBalance"] = self.CPUAdvanceCreditBalance!
                }
                if self.CPUCreditBalance != nil {
                    map["CPUCreditBalance"] = self.CPUCreditBalance!
                }
                if self.CPUCreditUsage != nil {
                    map["CPUCreditUsage"] = self.CPUCreditUsage!
                }
                if self.CPUNotpaidSurplusCreditUsage != nil {
                    map["CPUNotpaidSurplusCreditUsage"] = self.CPUNotpaidSurplusCreditUsage!
                }
                if self.IOPSRead != nil {
                    map["IOPSRead"] = self.IOPSRead!
                }
                if self.IOPSWrite != nil {
                    map["IOPSWrite"] = self.IOPSWrite!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.internetBandwidth != nil {
                    map["InternetBandwidth"] = self.internetBandwidth!
                }
                if self.internetRX != nil {
                    map["InternetRX"] = self.internetRX!
                }
                if self.internetTX != nil {
                    map["InternetTX"] = self.internetTX!
                }
                if self.intranetBandwidth != nil {
                    map["IntranetBandwidth"] = self.intranetBandwidth!
                }
                if self.intranetRX != nil {
                    map["IntranetRX"] = self.intranetRX!
                }
                if self.intranetTX != nil {
                    map["IntranetTX"] = self.intranetTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BPSRead") {
                    self.BPSRead = dict["BPSRead"] as! Int32
                }
                if dict.keys.contains("BPSWrite") {
                    self.BPSWrite = dict["BPSWrite"] as! Int32
                }
                if dict.keys.contains("CPU") {
                    self.CPU = dict["CPU"] as! Int32
                }
                if dict.keys.contains("CPUAdvanceCreditBalance") {
                    self.CPUAdvanceCreditBalance = dict["CPUAdvanceCreditBalance"] as! Double
                }
                if dict.keys.contains("CPUCreditBalance") {
                    self.CPUCreditBalance = dict["CPUCreditBalance"] as! Double
                }
                if dict.keys.contains("CPUCreditUsage") {
                    self.CPUCreditUsage = dict["CPUCreditUsage"] as! Double
                }
                if dict.keys.contains("CPUNotpaidSurplusCreditUsage") {
                    self.CPUNotpaidSurplusCreditUsage = dict["CPUNotpaidSurplusCreditUsage"] as! Double
                }
                if dict.keys.contains("IOPSRead") {
                    self.IOPSRead = dict["IOPSRead"] as! Int32
                }
                if dict.keys.contains("IOPSWrite") {
                    self.IOPSWrite = dict["IOPSWrite"] as! Int32
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InternetBandwidth") {
                    self.internetBandwidth = dict["InternetBandwidth"] as! Int32
                }
                if dict.keys.contains("InternetRX") {
                    self.internetRX = dict["InternetRX"] as! Int32
                }
                if dict.keys.contains("InternetTX") {
                    self.internetTX = dict["InternetTX"] as! Int32
                }
                if dict.keys.contains("IntranetBandwidth") {
                    self.intranetBandwidth = dict["IntranetBandwidth"] as! Int32
                }
                if dict.keys.contains("IntranetRX") {
                    self.intranetRX = dict["IntranetRX"] as! Int32
                }
                if dict.keys.contains("IntranetTX") {
                    self.intranetTX = dict["IntranetTX"] as! Int32
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var instanceMonitorData: [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceMonitorData != nil {
                var tmp : [Any] = []
                for k in self.instanceMonitorData! {
                    tmp.append(k.toMap())
                }
                map["InstanceMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceMonitorData") {
                var tmp : [DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData] = []
                for v in dict["InstanceMonitorData"] as! [Any] {
                    var model = DescribeInstanceMonitorDataResponseBody.MonitorData.InstanceMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceMonitorData = tmp
            }
        }
    }
    public var monitorData: DescribeInstanceMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorData") {
            var model = DescribeInstanceMonitorDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceRamRoleRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceRamRoleResponseBody : Tea.TeaModel {
    public class InstanceRamRoleSets : Tea.TeaModel {
        public class InstanceRamRoleSet : Tea.TeaModel {
            public var instanceId: String?

            public var ramRoleName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ramRoleName != nil {
                    map["RamRoleName"] = self.ramRoleName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("RamRoleName") {
                    self.ramRoleName = dict["RamRoleName"] as! String
                }
            }
        }
        public var instanceRamRoleSet: [DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets.InstanceRamRoleSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceRamRoleSet != nil {
                var tmp : [Any] = []
                for k in self.instanceRamRoleSet! {
                    tmp.append(k.toMap())
                }
                map["InstanceRamRoleSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceRamRoleSet") {
                var tmp : [DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets.InstanceRamRoleSet] = []
                for v in dict["InstanceRamRoleSet"] as! [Any] {
                    var model = DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets.InstanceRamRoleSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceRamRoleSet = tmp
            }
        }
    }
    public var instanceRamRoleSets: DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets?

    public var regionId: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceRamRoleSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceRamRoleSets != nil {
            map["InstanceRamRoleSets"] = self.instanceRamRoleSets?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceRamRoleSets") {
            var model = DescribeInstanceRamRoleResponseBody.InstanceRamRoleSets()
            model.fromMap(dict["InstanceRamRoleSets"] as! [String: Any])
            self.instanceRamRoleSets = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceRamRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceRamRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceRamRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceStatusRequest : Tea.TeaModel {
    public var clusterId: String?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clusterId != nil {
            map["ClusterId"] = self.clusterId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClusterId") {
            self.clusterId = dict["ClusterId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeInstanceStatusResponseBody : Tea.TeaModel {
    public class InstanceStatuses : Tea.TeaModel {
        public class InstanceStatus : Tea.TeaModel {
            public var instanceId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var instanceStatus: [DescribeInstanceStatusResponseBody.InstanceStatuses.InstanceStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceStatus != nil {
                var tmp : [Any] = []
                for k in self.instanceStatus! {
                    tmp.append(k.toMap())
                }
                map["InstanceStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceStatus") {
                var tmp : [DescribeInstanceStatusResponseBody.InstanceStatuses.InstanceStatus] = []
                for v in dict["InstanceStatus"] as! [Any] {
                    var model = DescribeInstanceStatusResponseBody.InstanceStatuses.InstanceStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceStatus = tmp
            }
        }
    }
    public var instanceStatuses: DescribeInstanceStatusResponseBody.InstanceStatuses?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceStatuses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceStatuses != nil {
            map["InstanceStatuses"] = self.instanceStatuses?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceStatuses") {
            var model = DescribeInstanceStatusResponseBody.InstanceStatuses()
            model.fromMap(dict["InstanceStatuses"] as! [String: Any])
            self.instanceStatuses = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstanceStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTopologyRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceTopologyResponseBody : Tea.TeaModel {
    public class Topologys : Tea.TeaModel {
        public class Topology : Tea.TeaModel {
            public var hostId: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.hostId != nil {
                    map["HostId"] = self.hostId!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HostId") {
                    self.hostId = dict["HostId"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var topology: [DescribeInstanceTopologyResponseBody.Topologys.Topology]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.topology != nil {
                var tmp : [Any] = []
                for k in self.topology! {
                    tmp.append(k.toMap())
                }
                map["Topology"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Topology") {
                var tmp : [DescribeInstanceTopologyResponseBody.Topologys.Topology] = []
                for v in dict["Topology"] as! [Any] {
                    var model = DescribeInstanceTopologyResponseBody.Topologys.Topology()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.topology = tmp
            }
        }
    }
    public var requestId: String?

    public var topologys: DescribeInstanceTopologyResponseBody.Topologys?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.topologys?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.topologys != nil {
            map["Topologys"] = self.topologys?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Topologys") {
            var model = DescribeInstanceTopologyResponseBody.Topologys()
            model.fromMap(dict["Topologys"] as! [String: Any])
            self.topologys = model
        }
    }
}

public class DescribeInstanceTopologyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTopologyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTopologyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTypeFamiliesRequest : Tea.TeaModel {
    public var generation: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.generation != nil {
            map["Generation"] = self.generation!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Generation") {
            self.generation = dict["Generation"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceTypeFamiliesResponseBody : Tea.TeaModel {
    public class InstanceTypeFamilies : Tea.TeaModel {
        public class InstanceTypeFamily : Tea.TeaModel {
            public var generation: String?

            public var instanceTypeFamilyId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.generation != nil {
                    map["Generation"] = self.generation!
                }
                if self.instanceTypeFamilyId != nil {
                    map["InstanceTypeFamilyId"] = self.instanceTypeFamilyId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Generation") {
                    self.generation = dict["Generation"] as! String
                }
                if dict.keys.contains("InstanceTypeFamilyId") {
                    self.instanceTypeFamilyId = dict["InstanceTypeFamilyId"] as! String
                }
            }
        }
        public var instanceTypeFamily: [DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceTypeFamily != nil {
                var tmp : [Any] = []
                for k in self.instanceTypeFamily! {
                    tmp.append(k.toMap())
                }
                map["InstanceTypeFamily"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceTypeFamily") {
                var tmp : [DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily] = []
                for v in dict["InstanceTypeFamily"] as! [Any] {
                    var model = DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies.InstanceTypeFamily()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceTypeFamily = tmp
            }
        }
    }
    public var instanceTypeFamilies: DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypeFamilies?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTypeFamilies") {
            var model = DescribeInstanceTypeFamiliesResponseBody.InstanceTypeFamilies()
            model.fromMap(dict["InstanceTypeFamilies"] as! [String: Any])
            self.instanceTypeFamilies = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceTypeFamiliesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTypeFamiliesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTypeFamiliesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceTypesRequest : Tea.TeaModel {
    public var cpuArchitecture: String?

    public var cpuArchitectures: [String]?

    public var GPUSpec: String?

    public var gpuSpecs: [String]?

    public var instanceCategories: [String]?

    public var instanceCategory: String?

    public var instanceFamilyLevel: String?

    public var instanceTypeFamilies: [String]?

    public var instanceTypeFamily: String?

    public var instanceTypes: [String]?

    public var localStorageCategories: [String]?

    public var localStorageCategory: String?

    public var maxResults: Int64?

    public var maximumCpuCoreCount: Int32?

    public var maximumCpuSpeedFrequency: Double?

    public var maximumCpuTurboFrequency: Double?

    public var maximumGPUAmount: Int32?

    public var maximumMemorySize: Double?

    public var minimumBaselineCredit: Int32?

    public var minimumCpuCoreCount: Int32?

    public var minimumCpuSpeedFrequency: Double?

    public var minimumCpuTurboFrequency: Double?

    public var minimumDiskQuantity: Int32?

    public var minimumEniIpv6AddressQuantity: Int32?

    public var minimumEniPrivateIpAddressQuantity: Int32?

    public var minimumEniQuantity: Int32?

    public var minimumEriQuantity: Int32?

    public var minimumGPUAmount: Int32?

    public var minimumInitialCredit: Int32?

    public var minimumInstanceBandwidthRx: Int32?

    public var minimumInstanceBandwidthTx: Int32?

    public var minimumInstancePpsRx: Int64?

    public var minimumInstancePpsTx: Int64?

    public var minimumLocalStorageAmount: Int32?

    public var minimumLocalStorageCapacity: Int64?

    public var minimumMemorySize: Double?

    public var minimumPrimaryEniQueueNumber: Int32?

    public var minimumQueuePairNumber: Int32?

    public var minimumSecondaryEniQueueNumber: Int32?

    public var nextToken: String?

    public var nvmeSupport: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalProcessorModel: String?

    public var physicalProcessorModels: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuArchitecture != nil {
            map["CpuArchitecture"] = self.cpuArchitecture!
        }
        if self.cpuArchitectures != nil {
            map["CpuArchitectures"] = self.cpuArchitectures!
        }
        if self.GPUSpec != nil {
            map["GPUSpec"] = self.GPUSpec!
        }
        if self.gpuSpecs != nil {
            map["GpuSpecs"] = self.gpuSpecs!
        }
        if self.instanceCategories != nil {
            map["InstanceCategories"] = self.instanceCategories!
        }
        if self.instanceCategory != nil {
            map["InstanceCategory"] = self.instanceCategory!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeFamilies != nil {
            map["InstanceTypeFamilies"] = self.instanceTypeFamilies!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.localStorageCategories != nil {
            map["LocalStorageCategories"] = self.localStorageCategories!
        }
        if self.localStorageCategory != nil {
            map["LocalStorageCategory"] = self.localStorageCategory!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.maximumCpuCoreCount != nil {
            map["MaximumCpuCoreCount"] = self.maximumCpuCoreCount!
        }
        if self.maximumCpuSpeedFrequency != nil {
            map["MaximumCpuSpeedFrequency"] = self.maximumCpuSpeedFrequency!
        }
        if self.maximumCpuTurboFrequency != nil {
            map["MaximumCpuTurboFrequency"] = self.maximumCpuTurboFrequency!
        }
        if self.maximumGPUAmount != nil {
            map["MaximumGPUAmount"] = self.maximumGPUAmount!
        }
        if self.maximumMemorySize != nil {
            map["MaximumMemorySize"] = self.maximumMemorySize!
        }
        if self.minimumBaselineCredit != nil {
            map["MinimumBaselineCredit"] = self.minimumBaselineCredit!
        }
        if self.minimumCpuCoreCount != nil {
            map["MinimumCpuCoreCount"] = self.minimumCpuCoreCount!
        }
        if self.minimumCpuSpeedFrequency != nil {
            map["MinimumCpuSpeedFrequency"] = self.minimumCpuSpeedFrequency!
        }
        if self.minimumCpuTurboFrequency != nil {
            map["MinimumCpuTurboFrequency"] = self.minimumCpuTurboFrequency!
        }
        if self.minimumDiskQuantity != nil {
            map["MinimumDiskQuantity"] = self.minimumDiskQuantity!
        }
        if self.minimumEniIpv6AddressQuantity != nil {
            map["MinimumEniIpv6AddressQuantity"] = self.minimumEniIpv6AddressQuantity!
        }
        if self.minimumEniPrivateIpAddressQuantity != nil {
            map["MinimumEniPrivateIpAddressQuantity"] = self.minimumEniPrivateIpAddressQuantity!
        }
        if self.minimumEniQuantity != nil {
            map["MinimumEniQuantity"] = self.minimumEniQuantity!
        }
        if self.minimumEriQuantity != nil {
            map["MinimumEriQuantity"] = self.minimumEriQuantity!
        }
        if self.minimumGPUAmount != nil {
            map["MinimumGPUAmount"] = self.minimumGPUAmount!
        }
        if self.minimumInitialCredit != nil {
            map["MinimumInitialCredit"] = self.minimumInitialCredit!
        }
        if self.minimumInstanceBandwidthRx != nil {
            map["MinimumInstanceBandwidthRx"] = self.minimumInstanceBandwidthRx!
        }
        if self.minimumInstanceBandwidthTx != nil {
            map["MinimumInstanceBandwidthTx"] = self.minimumInstanceBandwidthTx!
        }
        if self.minimumInstancePpsRx != nil {
            map["MinimumInstancePpsRx"] = self.minimumInstancePpsRx!
        }
        if self.minimumInstancePpsTx != nil {
            map["MinimumInstancePpsTx"] = self.minimumInstancePpsTx!
        }
        if self.minimumLocalStorageAmount != nil {
            map["MinimumLocalStorageAmount"] = self.minimumLocalStorageAmount!
        }
        if self.minimumLocalStorageCapacity != nil {
            map["MinimumLocalStorageCapacity"] = self.minimumLocalStorageCapacity!
        }
        if self.minimumMemorySize != nil {
            map["MinimumMemorySize"] = self.minimumMemorySize!
        }
        if self.minimumPrimaryEniQueueNumber != nil {
            map["MinimumPrimaryEniQueueNumber"] = self.minimumPrimaryEniQueueNumber!
        }
        if self.minimumQueuePairNumber != nil {
            map["MinimumQueuePairNumber"] = self.minimumQueuePairNumber!
        }
        if self.minimumSecondaryEniQueueNumber != nil {
            map["MinimumSecondaryEniQueueNumber"] = self.minimumSecondaryEniQueueNumber!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nvmeSupport != nil {
            map["NvmeSupport"] = self.nvmeSupport!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalProcessorModel != nil {
            map["PhysicalProcessorModel"] = self.physicalProcessorModel!
        }
        if self.physicalProcessorModels != nil {
            map["PhysicalProcessorModels"] = self.physicalProcessorModels!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuArchitecture") {
            self.cpuArchitecture = dict["CpuArchitecture"] as! String
        }
        if dict.keys.contains("CpuArchitectures") {
            self.cpuArchitectures = dict["CpuArchitectures"] as! [String]
        }
        if dict.keys.contains("GPUSpec") {
            self.GPUSpec = dict["GPUSpec"] as! String
        }
        if dict.keys.contains("GpuSpecs") {
            self.gpuSpecs = dict["GpuSpecs"] as! [String]
        }
        if dict.keys.contains("InstanceCategories") {
            self.instanceCategories = dict["InstanceCategories"] as! [String]
        }
        if dict.keys.contains("InstanceCategory") {
            self.instanceCategory = dict["InstanceCategory"] as! String
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypeFamilies") {
            self.instanceTypeFamilies = dict["InstanceTypeFamilies"] as! [String]
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("LocalStorageCategories") {
            self.localStorageCategories = dict["LocalStorageCategories"] as! [String]
        }
        if dict.keys.contains("LocalStorageCategory") {
            self.localStorageCategory = dict["LocalStorageCategory"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int64
        }
        if dict.keys.contains("MaximumCpuCoreCount") {
            self.maximumCpuCoreCount = dict["MaximumCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("MaximumCpuSpeedFrequency") {
            self.maximumCpuSpeedFrequency = dict["MaximumCpuSpeedFrequency"] as! Double
        }
        if dict.keys.contains("MaximumCpuTurboFrequency") {
            self.maximumCpuTurboFrequency = dict["MaximumCpuTurboFrequency"] as! Double
        }
        if dict.keys.contains("MaximumGPUAmount") {
            self.maximumGPUAmount = dict["MaximumGPUAmount"] as! Int32
        }
        if dict.keys.contains("MaximumMemorySize") {
            self.maximumMemorySize = dict["MaximumMemorySize"] as! Double
        }
        if dict.keys.contains("MinimumBaselineCredit") {
            self.minimumBaselineCredit = dict["MinimumBaselineCredit"] as! Int32
        }
        if dict.keys.contains("MinimumCpuCoreCount") {
            self.minimumCpuCoreCount = dict["MinimumCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("MinimumCpuSpeedFrequency") {
            self.minimumCpuSpeedFrequency = dict["MinimumCpuSpeedFrequency"] as! Double
        }
        if dict.keys.contains("MinimumCpuTurboFrequency") {
            self.minimumCpuTurboFrequency = dict["MinimumCpuTurboFrequency"] as! Double
        }
        if dict.keys.contains("MinimumDiskQuantity") {
            self.minimumDiskQuantity = dict["MinimumDiskQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumEniIpv6AddressQuantity") {
            self.minimumEniIpv6AddressQuantity = dict["MinimumEniIpv6AddressQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumEniPrivateIpAddressQuantity") {
            self.minimumEniPrivateIpAddressQuantity = dict["MinimumEniPrivateIpAddressQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumEniQuantity") {
            self.minimumEniQuantity = dict["MinimumEniQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumEriQuantity") {
            self.minimumEriQuantity = dict["MinimumEriQuantity"] as! Int32
        }
        if dict.keys.contains("MinimumGPUAmount") {
            self.minimumGPUAmount = dict["MinimumGPUAmount"] as! Int32
        }
        if dict.keys.contains("MinimumInitialCredit") {
            self.minimumInitialCredit = dict["MinimumInitialCredit"] as! Int32
        }
        if dict.keys.contains("MinimumInstanceBandwidthRx") {
            self.minimumInstanceBandwidthRx = dict["MinimumInstanceBandwidthRx"] as! Int32
        }
        if dict.keys.contains("MinimumInstanceBandwidthTx") {
            self.minimumInstanceBandwidthTx = dict["MinimumInstanceBandwidthTx"] as! Int32
        }
        if dict.keys.contains("MinimumInstancePpsRx") {
            self.minimumInstancePpsRx = dict["MinimumInstancePpsRx"] as! Int64
        }
        if dict.keys.contains("MinimumInstancePpsTx") {
            self.minimumInstancePpsTx = dict["MinimumInstancePpsTx"] as! Int64
        }
        if dict.keys.contains("MinimumLocalStorageAmount") {
            self.minimumLocalStorageAmount = dict["MinimumLocalStorageAmount"] as! Int32
        }
        if dict.keys.contains("MinimumLocalStorageCapacity") {
            self.minimumLocalStorageCapacity = dict["MinimumLocalStorageCapacity"] as! Int64
        }
        if dict.keys.contains("MinimumMemorySize") {
            self.minimumMemorySize = dict["MinimumMemorySize"] as! Double
        }
        if dict.keys.contains("MinimumPrimaryEniQueueNumber") {
            self.minimumPrimaryEniQueueNumber = dict["MinimumPrimaryEniQueueNumber"] as! Int32
        }
        if dict.keys.contains("MinimumQueuePairNumber") {
            self.minimumQueuePairNumber = dict["MinimumQueuePairNumber"] as! Int32
        }
        if dict.keys.contains("MinimumSecondaryEniQueueNumber") {
            self.minimumSecondaryEniQueueNumber = dict["MinimumSecondaryEniQueueNumber"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NvmeSupport") {
            self.nvmeSupport = dict["NvmeSupport"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalProcessorModel") {
            self.physicalProcessorModel = dict["PhysicalProcessorModel"] as! String
        }
        if dict.keys.contains("PhysicalProcessorModels") {
            self.physicalProcessorModels = dict["PhysicalProcessorModels"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceTypesResponseBody : Tea.TeaModel {
    public class InstanceTypes : Tea.TeaModel {
        public class InstanceType : Tea.TeaModel {
            public class CpuOptions : Tea.TeaModel {
                public class SupportedTopologyTypes : Tea.TeaModel {
                    public var supportedTopologyType: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.supportedTopologyType != nil {
                            map["SupportedTopologyType"] = self.supportedTopologyType!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SupportedTopologyType") {
                            self.supportedTopologyType = dict["SupportedTopologyType"] as! [String]
                        }
                    }
                }
                public var supportedTopologyTypes: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions.SupportedTopologyTypes?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.supportedTopologyTypes?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedTopologyTypes != nil {
                        map["SupportedTopologyTypes"] = self.supportedTopologyTypes?.toMap()
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedTopologyTypes") {
                        var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions.SupportedTopologyTypes()
                        model.fromMap(dict["SupportedTopologyTypes"] as! [String: Any])
                        self.supportedTopologyTypes = model
                    }
                }
            }
            public class EnhancedNetwork : Tea.TeaModel {
                public var sriovSupport: Bool?

                public var vfQueueNumberPerEni: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.sriovSupport != nil {
                        map["SriovSupport"] = self.sriovSupport!
                    }
                    if self.vfQueueNumberPerEni != nil {
                        map["VfQueueNumberPerEni"] = self.vfQueueNumberPerEni!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SriovSupport") {
                        self.sriovSupport = dict["SriovSupport"] as! Bool
                    }
                    if dict.keys.contains("VfQueueNumberPerEni") {
                        self.vfQueueNumberPerEni = dict["VfQueueNumberPerEni"] as! Int32
                    }
                }
            }
            public class NetworkCards : Tea.TeaModel {
                public class NetworkCardInfo : Tea.TeaModel {
                    public var networkCardIndex: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.networkCardIndex != nil {
                            map["NetworkCardIndex"] = self.networkCardIndex!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NetworkCardIndex") {
                            self.networkCardIndex = dict["NetworkCardIndex"] as! Int32
                        }
                    }
                }
                public var networkCardInfo: [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards.NetworkCardInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkCardInfo != nil {
                        var tmp : [Any] = []
                        for k in self.networkCardInfo! {
                            tmp.append(k.toMap())
                        }
                        map["NetworkCardInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkCardInfo") {
                        var tmp : [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards.NetworkCardInfo] = []
                        for v in dict["NetworkCardInfo"] as! [Any] {
                            var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards.NetworkCardInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.networkCardInfo = tmp
                    }
                }
            }
            public class SupportedBootModes : Tea.TeaModel {
                public var supportedBootMode: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.supportedBootMode != nil {
                        map["SupportedBootMode"] = self.supportedBootMode!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SupportedBootMode") {
                        self.supportedBootMode = dict["SupportedBootMode"] as! [String]
                    }
                }
            }
            public var baselineCredit: Int32?

            public var cpuArchitecture: String?

            public var cpuCoreCount: Int32?

            public var cpuOptions: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions?

            public var cpuSpeedFrequency: Double?

            public var cpuTurboFrequency: Double?

            public var diskQuantity: Int32?

            public var enhancedNetwork: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.EnhancedNetwork?

            public var eniIpv6AddressQuantity: Int32?

            public var eniPrivateIpAddressQuantity: Int32?

            public var eniQuantity: Int32?

            public var eniTotalQuantity: Int32?

            public var eniTrunkSupported: Bool?

            public var eriQuantity: Int32?

            public var GPUAmount: Int32?

            public var GPUMemorySize: Double?

            public var GPUSpec: String?

            public var initialCredit: Int32?

            public var instanceBandwidthRx: Int32?

            public var instanceBandwidthTx: Int32?

            public var instanceCategory: String?

            public var instanceFamilyLevel: String?

            public var instancePpsRx: Int64?

            public var instancePpsTx: Int64?

            public var instanceTypeFamily: String?

            public var instanceTypeId: String?

            public var localStorageAmount: Int32?

            public var localStorageCapacity: Int64?

            public var localStorageCategory: String?

            public var maximumQueueNumberPerEni: Int32?

            public var memorySize: Double?

            public var networkCardQuantity: Int32?

            public var networkCards: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards?

            public var networkEncryptionSupport: Bool?

            public var nvmeSupport: String?

            public var physicalProcessorModel: String?

            public var primaryEniQueueNumber: Int32?

            public var queuePairNumber: Int32?

            public var secondaryEniQueueNumber: Int32?

            public var supportedBootModes: DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.SupportedBootModes?

            public var totalEniQueueQuantity: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cpuOptions?.validate()
                try self.enhancedNetwork?.validate()
                try self.networkCards?.validate()
                try self.supportedBootModes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.baselineCredit != nil {
                    map["BaselineCredit"] = self.baselineCredit!
                }
                if self.cpuArchitecture != nil {
                    map["CpuArchitecture"] = self.cpuArchitecture!
                }
                if self.cpuCoreCount != nil {
                    map["CpuCoreCount"] = self.cpuCoreCount!
                }
                if self.cpuOptions != nil {
                    map["CpuOptions"] = self.cpuOptions?.toMap()
                }
                if self.cpuSpeedFrequency != nil {
                    map["CpuSpeedFrequency"] = self.cpuSpeedFrequency!
                }
                if self.cpuTurboFrequency != nil {
                    map["CpuTurboFrequency"] = self.cpuTurboFrequency!
                }
                if self.diskQuantity != nil {
                    map["DiskQuantity"] = self.diskQuantity!
                }
                if self.enhancedNetwork != nil {
                    map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
                }
                if self.eniIpv6AddressQuantity != nil {
                    map["EniIpv6AddressQuantity"] = self.eniIpv6AddressQuantity!
                }
                if self.eniPrivateIpAddressQuantity != nil {
                    map["EniPrivateIpAddressQuantity"] = self.eniPrivateIpAddressQuantity!
                }
                if self.eniQuantity != nil {
                    map["EniQuantity"] = self.eniQuantity!
                }
                if self.eniTotalQuantity != nil {
                    map["EniTotalQuantity"] = self.eniTotalQuantity!
                }
                if self.eniTrunkSupported != nil {
                    map["EniTrunkSupported"] = self.eniTrunkSupported!
                }
                if self.eriQuantity != nil {
                    map["EriQuantity"] = self.eriQuantity!
                }
                if self.GPUAmount != nil {
                    map["GPUAmount"] = self.GPUAmount!
                }
                if self.GPUMemorySize != nil {
                    map["GPUMemorySize"] = self.GPUMemorySize!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.initialCredit != nil {
                    map["InitialCredit"] = self.initialCredit!
                }
                if self.instanceBandwidthRx != nil {
                    map["InstanceBandwidthRx"] = self.instanceBandwidthRx!
                }
                if self.instanceBandwidthTx != nil {
                    map["InstanceBandwidthTx"] = self.instanceBandwidthTx!
                }
                if self.instanceCategory != nil {
                    map["InstanceCategory"] = self.instanceCategory!
                }
                if self.instanceFamilyLevel != nil {
                    map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
                }
                if self.instancePpsRx != nil {
                    map["InstancePpsRx"] = self.instancePpsRx!
                }
                if self.instancePpsTx != nil {
                    map["InstancePpsTx"] = self.instancePpsTx!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.instanceTypeId != nil {
                    map["InstanceTypeId"] = self.instanceTypeId!
                }
                if self.localStorageAmount != nil {
                    map["LocalStorageAmount"] = self.localStorageAmount!
                }
                if self.localStorageCapacity != nil {
                    map["LocalStorageCapacity"] = self.localStorageCapacity!
                }
                if self.localStorageCategory != nil {
                    map["LocalStorageCategory"] = self.localStorageCategory!
                }
                if self.maximumQueueNumberPerEni != nil {
                    map["MaximumQueueNumberPerEni"] = self.maximumQueueNumberPerEni!
                }
                if self.memorySize != nil {
                    map["MemorySize"] = self.memorySize!
                }
                if self.networkCardQuantity != nil {
                    map["NetworkCardQuantity"] = self.networkCardQuantity!
                }
                if self.networkCards != nil {
                    map["NetworkCards"] = self.networkCards?.toMap()
                }
                if self.networkEncryptionSupport != nil {
                    map["NetworkEncryptionSupport"] = self.networkEncryptionSupport!
                }
                if self.nvmeSupport != nil {
                    map["NvmeSupport"] = self.nvmeSupport!
                }
                if self.physicalProcessorModel != nil {
                    map["PhysicalProcessorModel"] = self.physicalProcessorModel!
                }
                if self.primaryEniQueueNumber != nil {
                    map["PrimaryEniQueueNumber"] = self.primaryEniQueueNumber!
                }
                if self.queuePairNumber != nil {
                    map["QueuePairNumber"] = self.queuePairNumber!
                }
                if self.secondaryEniQueueNumber != nil {
                    map["SecondaryEniQueueNumber"] = self.secondaryEniQueueNumber!
                }
                if self.supportedBootModes != nil {
                    map["SupportedBootModes"] = self.supportedBootModes?.toMap()
                }
                if self.totalEniQueueQuantity != nil {
                    map["TotalEniQueueQuantity"] = self.totalEniQueueQuantity!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BaselineCredit") {
                    self.baselineCredit = dict["BaselineCredit"] as! Int32
                }
                if dict.keys.contains("CpuArchitecture") {
                    self.cpuArchitecture = dict["CpuArchitecture"] as! String
                }
                if dict.keys.contains("CpuCoreCount") {
                    self.cpuCoreCount = dict["CpuCoreCount"] as! Int32
                }
                if dict.keys.contains("CpuOptions") {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.CpuOptions()
                    model.fromMap(dict["CpuOptions"] as! [String: Any])
                    self.cpuOptions = model
                }
                if dict.keys.contains("CpuSpeedFrequency") {
                    self.cpuSpeedFrequency = dict["CpuSpeedFrequency"] as! Double
                }
                if dict.keys.contains("CpuTurboFrequency") {
                    self.cpuTurboFrequency = dict["CpuTurboFrequency"] as! Double
                }
                if dict.keys.contains("DiskQuantity") {
                    self.diskQuantity = dict["DiskQuantity"] as! Int32
                }
                if dict.keys.contains("EnhancedNetwork") {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.EnhancedNetwork()
                    model.fromMap(dict["EnhancedNetwork"] as! [String: Any])
                    self.enhancedNetwork = model
                }
                if dict.keys.contains("EniIpv6AddressQuantity") {
                    self.eniIpv6AddressQuantity = dict["EniIpv6AddressQuantity"] as! Int32
                }
                if dict.keys.contains("EniPrivateIpAddressQuantity") {
                    self.eniPrivateIpAddressQuantity = dict["EniPrivateIpAddressQuantity"] as! Int32
                }
                if dict.keys.contains("EniQuantity") {
                    self.eniQuantity = dict["EniQuantity"] as! Int32
                }
                if dict.keys.contains("EniTotalQuantity") {
                    self.eniTotalQuantity = dict["EniTotalQuantity"] as! Int32
                }
                if dict.keys.contains("EniTrunkSupported") {
                    self.eniTrunkSupported = dict["EniTrunkSupported"] as! Bool
                }
                if dict.keys.contains("EriQuantity") {
                    self.eriQuantity = dict["EriQuantity"] as! Int32
                }
                if dict.keys.contains("GPUAmount") {
                    self.GPUAmount = dict["GPUAmount"] as! Int32
                }
                if dict.keys.contains("GPUMemorySize") {
                    self.GPUMemorySize = dict["GPUMemorySize"] as! Double
                }
                if dict.keys.contains("GPUSpec") {
                    self.GPUSpec = dict["GPUSpec"] as! String
                }
                if dict.keys.contains("InitialCredit") {
                    self.initialCredit = dict["InitialCredit"] as! Int32
                }
                if dict.keys.contains("InstanceBandwidthRx") {
                    self.instanceBandwidthRx = dict["InstanceBandwidthRx"] as! Int32
                }
                if dict.keys.contains("InstanceBandwidthTx") {
                    self.instanceBandwidthTx = dict["InstanceBandwidthTx"] as! Int32
                }
                if dict.keys.contains("InstanceCategory") {
                    self.instanceCategory = dict["InstanceCategory"] as! String
                }
                if dict.keys.contains("InstanceFamilyLevel") {
                    self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
                }
                if dict.keys.contains("InstancePpsRx") {
                    self.instancePpsRx = dict["InstancePpsRx"] as! Int64
                }
                if dict.keys.contains("InstancePpsTx") {
                    self.instancePpsTx = dict["InstancePpsTx"] as! Int64
                }
                if dict.keys.contains("InstanceTypeFamily") {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("InstanceTypeId") {
                    self.instanceTypeId = dict["InstanceTypeId"] as! String
                }
                if dict.keys.contains("LocalStorageAmount") {
                    self.localStorageAmount = dict["LocalStorageAmount"] as! Int32
                }
                if dict.keys.contains("LocalStorageCapacity") {
                    self.localStorageCapacity = dict["LocalStorageCapacity"] as! Int64
                }
                if dict.keys.contains("LocalStorageCategory") {
                    self.localStorageCategory = dict["LocalStorageCategory"] as! String
                }
                if dict.keys.contains("MaximumQueueNumberPerEni") {
                    self.maximumQueueNumberPerEni = dict["MaximumQueueNumberPerEni"] as! Int32
                }
                if dict.keys.contains("MemorySize") {
                    self.memorySize = dict["MemorySize"] as! Double
                }
                if dict.keys.contains("NetworkCardQuantity") {
                    self.networkCardQuantity = dict["NetworkCardQuantity"] as! Int32
                }
                if dict.keys.contains("NetworkCards") {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.NetworkCards()
                    model.fromMap(dict["NetworkCards"] as! [String: Any])
                    self.networkCards = model
                }
                if dict.keys.contains("NetworkEncryptionSupport") {
                    self.networkEncryptionSupport = dict["NetworkEncryptionSupport"] as! Bool
                }
                if dict.keys.contains("NvmeSupport") {
                    self.nvmeSupport = dict["NvmeSupport"] as! String
                }
                if dict.keys.contains("PhysicalProcessorModel") {
                    self.physicalProcessorModel = dict["PhysicalProcessorModel"] as! String
                }
                if dict.keys.contains("PrimaryEniQueueNumber") {
                    self.primaryEniQueueNumber = dict["PrimaryEniQueueNumber"] as! Int32
                }
                if dict.keys.contains("QueuePairNumber") {
                    self.queuePairNumber = dict["QueuePairNumber"] as! Int32
                }
                if dict.keys.contains("SecondaryEniQueueNumber") {
                    self.secondaryEniQueueNumber = dict["SecondaryEniQueueNumber"] as! Int32
                }
                if dict.keys.contains("SupportedBootModes") {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType.SupportedBootModes()
                    model.fromMap(dict["SupportedBootModes"] as! [String: Any])
                    self.supportedBootModes = model
                }
                if dict.keys.contains("TotalEniQueueQuantity") {
                    self.totalEniQueueQuantity = dict["TotalEniQueueQuantity"] as! Int32
                }
            }
        }
        public var instanceType: [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                var tmp : [Any] = []
                for k in self.instanceType! {
                    tmp.append(k.toMap())
                }
                map["InstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                var tmp : [DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType] = []
                for v in dict["InstanceType"] as! [Any] {
                    var model = DescribeInstanceTypesResponseBody.InstanceTypes.InstanceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceType = tmp
            }
        }
    }
    public var instanceTypes: DescribeInstanceTypesResponseBody.InstanceTypes?

    public var nextToken: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceTypes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceTypes") {
            var model = DescribeInstanceTypesResponseBody.InstanceTypes()
            model.fromMap(dict["InstanceTypes"] as! [String: Any])
            self.instanceTypes = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInstanceTypesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceTypesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceTypesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstanceVncUrlRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeInstanceVncUrlResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var vncUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.vncUrl != nil {
            map["VncUrl"] = self.vncUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("VncUrl") {
            self.vncUrl = dict["VncUrl"] as! String
        }
    }
}

public class DescribeInstanceVncUrlResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstanceVncUrlResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstanceVncUrlResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeInstancesRequest.Filter]?

    public var additionalAttributes: [String]?

    public var deviceAvailable: Bool?

    public var dryRun: Bool?

    public var eipAddresses: String?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageId: String?

    public var innerIpAddresses: String?

    public var instanceChargeType: String?

    public var instanceIds: String?

    public var instanceName: String?

    public var instanceNetworkType: String?

    public var instanceType: String?

    public var instanceTypeFamily: String?

    public var internetChargeType: String?

    public var ioOptimized: Bool?

    public var ipv6Address: [String]?

    public var keyPairName: String?

    public var lockReason: String?

    public var maxResults: Int32?

    public var needSaleCycle: Bool?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var privateIpAddresses: String?

    public var publicIpAddresses: String?

    public var rdmaIpAddresses: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var status: String?

    public var tag: [DescribeInstancesRequest.Tag]?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.additionalAttributes != nil {
            map["AdditionalAttributes"] = self.additionalAttributes!
        }
        if self.deviceAvailable != nil {
            map["DeviceAvailable"] = self.deviceAvailable!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.eipAddresses != nil {
            map["EipAddresses"] = self.eipAddresses!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.innerIpAddresses != nil {
            map["InnerIpAddresses"] = self.innerIpAddresses!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.needSaleCycle != nil {
            map["NeedSaleCycle"] = self.needSaleCycle!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.privateIpAddresses != nil {
            map["PrivateIpAddresses"] = self.privateIpAddresses!
        }
        if self.publicIpAddresses != nil {
            map["PublicIpAddresses"] = self.publicIpAddresses!
        }
        if self.rdmaIpAddresses != nil {
            map["RdmaIpAddresses"] = self.rdmaIpAddresses!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeInstancesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeInstancesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("AdditionalAttributes") {
            self.additionalAttributes = dict["AdditionalAttributes"] as! [String]
        }
        if dict.keys.contains("DeviceAvailable") {
            self.deviceAvailable = dict["DeviceAvailable"] as! Bool
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("EipAddresses") {
            self.eipAddresses = dict["EipAddresses"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InnerIpAddresses") {
            self.innerIpAddresses = dict["InnerIpAddresses"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceNetworkType") {
            self.instanceNetworkType = dict["InstanceNetworkType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! Bool
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NeedSaleCycle") {
            self.needSaleCycle = dict["NeedSaleCycle"] as! Bool
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrivateIpAddresses") {
            self.privateIpAddresses = dict["PrivateIpAddresses"] as! String
        }
        if dict.keys.contains("PublicIpAddresses") {
            self.publicIpAddresses = dict["PublicIpAddresses"] as! String
        }
        if dict.keys.contains("RdmaIpAddresses") {
            self.rdmaIpAddresses = dict["RdmaIpAddresses"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeInstancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeInstancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Instance : Tea.TeaModel {
            public class CpuOptions : Tea.TeaModel {
                public var coreCount: Int32?

                public var numa: String?

                public var threadsPerCore: Int32?

                public var topologyType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.coreCount != nil {
                        map["CoreCount"] = self.coreCount!
                    }
                    if self.numa != nil {
                        map["Numa"] = self.numa!
                    }
                    if self.threadsPerCore != nil {
                        map["ThreadsPerCore"] = self.threadsPerCore!
                    }
                    if self.topologyType != nil {
                        map["TopologyType"] = self.topologyType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CoreCount") {
                        self.coreCount = dict["CoreCount"] as! Int32
                    }
                    if dict.keys.contains("Numa") {
                        self.numa = dict["Numa"] as! String
                    }
                    if dict.keys.contains("ThreadsPerCore") {
                        self.threadsPerCore = dict["ThreadsPerCore"] as! Int32
                    }
                    if dict.keys.contains("TopologyType") {
                        self.topologyType = dict["TopologyType"] as! String
                    }
                }
            }
            public class DedicatedHostAttribute : Tea.TeaModel {
                public var dedicatedHostClusterId: String?

                public var dedicatedHostId: String?

                public var dedicatedHostName: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostClusterId != nil {
                        map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
                    }
                    if self.dedicatedHostId != nil {
                        map["DedicatedHostId"] = self.dedicatedHostId!
                    }
                    if self.dedicatedHostName != nil {
                        map["DedicatedHostName"] = self.dedicatedHostName!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DedicatedHostClusterId") {
                        self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
                    }
                    if dict.keys.contains("DedicatedHostId") {
                        self.dedicatedHostId = dict["DedicatedHostId"] as! String
                    }
                    if dict.keys.contains("DedicatedHostName") {
                        self.dedicatedHostName = dict["DedicatedHostName"] as! String
                    }
                }
            }
            public class DedicatedInstanceAttribute : Tea.TeaModel {
                public var affinity: String?

                public var tenancy: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.affinity != nil {
                        map["Affinity"] = self.affinity!
                    }
                    if self.tenancy != nil {
                        map["Tenancy"] = self.tenancy!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Affinity") {
                        self.affinity = dict["Affinity"] as! String
                    }
                    if dict.keys.contains("Tenancy") {
                        self.tenancy = dict["Tenancy"] as! String
                    }
                }
            }
            public class EcsCapacityReservationAttr : Tea.TeaModel {
                public var capacityReservationId: String?

                public var capacityReservationPreference: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.capacityReservationId != nil {
                        map["CapacityReservationId"] = self.capacityReservationId!
                    }
                    if self.capacityReservationPreference != nil {
                        map["CapacityReservationPreference"] = self.capacityReservationPreference!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CapacityReservationId") {
                        self.capacityReservationId = dict["CapacityReservationId"] as! String
                    }
                    if dict.keys.contains("CapacityReservationPreference") {
                        self.capacityReservationPreference = dict["CapacityReservationPreference"] as! String
                    }
                }
            }
            public class EipAddress : Tea.TeaModel {
                public var allocationId: String?

                public var bandwidth: Int32?

                public var internetChargeType: String?

                public var ipAddress: String?

                public var isSupportUnassociate: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationId != nil {
                        map["AllocationId"] = self.allocationId!
                    }
                    if self.bandwidth != nil {
                        map["Bandwidth"] = self.bandwidth!
                    }
                    if self.internetChargeType != nil {
                        map["InternetChargeType"] = self.internetChargeType!
                    }
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    if self.isSupportUnassociate != nil {
                        map["IsSupportUnassociate"] = self.isSupportUnassociate!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocationId") {
                        self.allocationId = dict["AllocationId"] as! String
                    }
                    if dict.keys.contains("Bandwidth") {
                        self.bandwidth = dict["Bandwidth"] as! Int32
                    }
                    if dict.keys.contains("InternetChargeType") {
                        self.internetChargeType = dict["InternetChargeType"] as! String
                    }
                    if dict.keys.contains("IpAddress") {
                        self.ipAddress = dict["IpAddress"] as! String
                    }
                    if dict.keys.contains("IsSupportUnassociate") {
                        self.isSupportUnassociate = dict["IsSupportUnassociate"] as! Bool
                    }
                }
            }
            public class HibernationOptions : Tea.TeaModel {
                public var configured: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.configured != nil {
                        map["Configured"] = self.configured!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Configured") {
                        self.configured = dict["Configured"] as! Bool
                    }
                }
            }
            public class ImageOptions : Tea.TeaModel {
                public var currentOSNVMeSupported: Bool?

                public var loginAsNonRoot: Bool?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currentOSNVMeSupported != nil {
                        map["CurrentOSNVMeSupported"] = self.currentOSNVMeSupported!
                    }
                    if self.loginAsNonRoot != nil {
                        map["LoginAsNonRoot"] = self.loginAsNonRoot!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CurrentOSNVMeSupported") {
                        self.currentOSNVMeSupported = dict["CurrentOSNVMeSupported"] as! Bool
                    }
                    if dict.keys.contains("LoginAsNonRoot") {
                        self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
                    }
                }
            }
            public class InnerIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") {
                        self.ipAddress = dict["IpAddress"] as! [String]
                    }
                }
            }
            public class MetadataOptions : Tea.TeaModel {
                public var httpEndpoint: String?

                public var httpPutResponseHopLimit: Int32?

                public var httpTokens: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.httpEndpoint != nil {
                        map["HttpEndpoint"] = self.httpEndpoint!
                    }
                    if self.httpPutResponseHopLimit != nil {
                        map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
                    }
                    if self.httpTokens != nil {
                        map["HttpTokens"] = self.httpTokens!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("HttpEndpoint") {
                        self.httpEndpoint = dict["HttpEndpoint"] as! String
                    }
                    if dict.keys.contains("HttpPutResponseHopLimit") {
                        self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
                    }
                    if dict.keys.contains("HttpTokens") {
                        self.httpTokens = dict["HttpTokens"] as! String
                    }
                }
            }
            public class NetworkInterfaces : Tea.TeaModel {
                public class NetworkInterface : Tea.TeaModel {
                    public class Ipv4PrefixSets : Tea.TeaModel {
                        public class Ipv4PrefixSet : Tea.TeaModel {
                            public var ipv4Prefix: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ipv4Prefix != nil {
                                    map["Ipv4Prefix"] = self.ipv4Prefix!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Ipv4Prefix") {
                                    self.ipv4Prefix = dict["Ipv4Prefix"] as! String
                                }
                            }
                        }
                        public var ipv4PrefixSet: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets.Ipv4PrefixSet]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipv4PrefixSet != nil {
                                var tmp : [Any] = []
                                for k in self.ipv4PrefixSet! {
                                    tmp.append(k.toMap())
                                }
                                map["Ipv4PrefixSet"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Ipv4PrefixSet") {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets.Ipv4PrefixSet] = []
                                for v in dict["Ipv4PrefixSet"] as! [Any] {
                                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets.Ipv4PrefixSet()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.ipv4PrefixSet = tmp
                            }
                        }
                    }
                    public class Ipv6PrefixSets : Tea.TeaModel {
                        public class Ipv6PrefixSet : Tea.TeaModel {
                            public var ipv6Prefix: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ipv6Prefix != nil {
                                    map["Ipv6Prefix"] = self.ipv6Prefix!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Ipv6Prefix") {
                                    self.ipv6Prefix = dict["Ipv6Prefix"] as! String
                                }
                            }
                        }
                        public var ipv6PrefixSet: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets.Ipv6PrefixSet]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipv6PrefixSet != nil {
                                var tmp : [Any] = []
                                for k in self.ipv6PrefixSet! {
                                    tmp.append(k.toMap())
                                }
                                map["Ipv6PrefixSet"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Ipv6PrefixSet") {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets.Ipv6PrefixSet] = []
                                for v in dict["Ipv6PrefixSet"] as! [Any] {
                                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets.Ipv6PrefixSet()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.ipv6PrefixSet = tmp
                            }
                        }
                    }
                    public class Ipv6Sets : Tea.TeaModel {
                        public class Ipv6Set : Tea.TeaModel {
                            public var ipv6Address: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.ipv6Address != nil {
                                    map["Ipv6Address"] = self.ipv6Address!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Ipv6Address") {
                                    self.ipv6Address = dict["Ipv6Address"] as! String
                                }
                            }
                        }
                        public var ipv6Set: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets.Ipv6Set]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.ipv6Set != nil {
                                var tmp : [Any] = []
                                for k in self.ipv6Set! {
                                    tmp.append(k.toMap())
                                }
                                map["Ipv6Set"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Ipv6Set") {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets.Ipv6Set] = []
                                for v in dict["Ipv6Set"] as! [Any] {
                                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets.Ipv6Set()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.ipv6Set = tmp
                            }
                        }
                    }
                    public class PrivateIpSets : Tea.TeaModel {
                        public class PrivateIpSet : Tea.TeaModel {
                            public var primary: Bool?

                            public var privateDnsName: String?

                            public var privateIpAddress: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.primary != nil {
                                    map["Primary"] = self.primary!
                                }
                                if self.privateDnsName != nil {
                                    map["PrivateDnsName"] = self.privateDnsName!
                                }
                                if self.privateIpAddress != nil {
                                    map["PrivateIpAddress"] = self.privateIpAddress!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Primary") {
                                    self.primary = dict["Primary"] as! Bool
                                }
                                if dict.keys.contains("PrivateDnsName") {
                                    self.privateDnsName = dict["PrivateDnsName"] as! String
                                }
                                if dict.keys.contains("PrivateIpAddress") {
                                    self.privateIpAddress = dict["PrivateIpAddress"] as! String
                                }
                            }
                        }
                        public var privateIpSet: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets.PrivateIpSet]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.privateIpSet != nil {
                                var tmp : [Any] = []
                                for k in self.privateIpSet! {
                                    tmp.append(k.toMap())
                                }
                                map["PrivateIpSet"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("PrivateIpSet") {
                                var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets.PrivateIpSet] = []
                                for v in dict["PrivateIpSet"] as! [Any] {
                                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets.PrivateIpSet()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.privateIpSet = tmp
                            }
                        }
                    }
                    public var ipv4PrefixSets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets?

                    public var ipv6PrefixSets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets?

                    public var ipv6Sets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets?

                    public var macAddress: String?

                    public var networkInterfaceId: String?

                    public var primaryIpAddress: String?

                    public var privateIpSets: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.ipv4PrefixSets?.validate()
                        try self.ipv6PrefixSets?.validate()
                        try self.ipv6Sets?.validate()
                        try self.privateIpSets?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv4PrefixSets != nil {
                            map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
                        }
                        if self.ipv6PrefixSets != nil {
                            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
                        }
                        if self.ipv6Sets != nil {
                            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
                        }
                        if self.macAddress != nil {
                            map["MacAddress"] = self.macAddress!
                        }
                        if self.networkInterfaceId != nil {
                            map["NetworkInterfaceId"] = self.networkInterfaceId!
                        }
                        if self.primaryIpAddress != nil {
                            map["PrimaryIpAddress"] = self.primaryIpAddress!
                        }
                        if self.privateIpSets != nil {
                            map["PrivateIpSets"] = self.privateIpSets?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv4PrefixSets") {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv4PrefixSets()
                            model.fromMap(dict["Ipv4PrefixSets"] as! [String: Any])
                            self.ipv4PrefixSets = model
                        }
                        if dict.keys.contains("Ipv6PrefixSets") {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6PrefixSets()
                            model.fromMap(dict["Ipv6PrefixSets"] as! [String: Any])
                            self.ipv6PrefixSets = model
                        }
                        if dict.keys.contains("Ipv6Sets") {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.Ipv6Sets()
                            model.fromMap(dict["Ipv6Sets"] as! [String: Any])
                            self.ipv6Sets = model
                        }
                        if dict.keys.contains("MacAddress") {
                            self.macAddress = dict["MacAddress"] as! String
                        }
                        if dict.keys.contains("NetworkInterfaceId") {
                            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                        }
                        if dict.keys.contains("PrimaryIpAddress") {
                            self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
                        }
                        if dict.keys.contains("PrivateIpSets") {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface.PrivateIpSets()
                            model.fromMap(dict["PrivateIpSets"] as! [String: Any])
                            self.privateIpSets = model
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var networkInterface: [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.networkInterface != nil {
                        var tmp : [Any] = []
                        for k in self.networkInterface! {
                            tmp.append(k.toMap())
                        }
                        map["NetworkInterface"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NetworkInterface") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface] = []
                        for v in dict["NetworkInterface"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces.NetworkInterface()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.networkInterface = tmp
                    }
                }
            }
            public class OperationLocks : Tea.TeaModel {
                public class LockReason : Tea.TeaModel {
                    public var lockMsg: String?

                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockMsg != nil {
                            map["LockMsg"] = self.lockMsg!
                        }
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockMsg") {
                            self.lockMsg = dict["LockMsg"] as! String
                        }
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var lockReason: [DescribeInstancesResponseBody.Instances.Instance.OperationLocks.LockReason]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.lockReason != nil {
                        var tmp : [Any] = []
                        for k in self.lockReason! {
                            tmp.append(k.toMap())
                        }
                        map["LockReason"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("LockReason") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.OperationLocks.LockReason] = []
                        for v in dict["LockReason"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.OperationLocks.LockReason()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.lockReason = tmp
                    }
                }
            }
            public class PrivateDnsNameOptions : Tea.TeaModel {
                public var enableInstanceIdDnsAAAARecord: Bool?

                public var enableInstanceIdDnsARecord: Bool?

                public var enableIpDnsARecord: Bool?

                public var enableIpDnsPtrRecord: Bool?

                public var hostnameType: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.enableInstanceIdDnsAAAARecord != nil {
                        map["EnableInstanceIdDnsAAAARecord"] = self.enableInstanceIdDnsAAAARecord!
                    }
                    if self.enableInstanceIdDnsARecord != nil {
                        map["EnableInstanceIdDnsARecord"] = self.enableInstanceIdDnsARecord!
                    }
                    if self.enableIpDnsARecord != nil {
                        map["EnableIpDnsARecord"] = self.enableIpDnsARecord!
                    }
                    if self.enableIpDnsPtrRecord != nil {
                        map["EnableIpDnsPtrRecord"] = self.enableIpDnsPtrRecord!
                    }
                    if self.hostnameType != nil {
                        map["HostnameType"] = self.hostnameType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("EnableInstanceIdDnsAAAARecord") {
                        self.enableInstanceIdDnsAAAARecord = dict["EnableInstanceIdDnsAAAARecord"] as! Bool
                    }
                    if dict.keys.contains("EnableInstanceIdDnsARecord") {
                        self.enableInstanceIdDnsARecord = dict["EnableInstanceIdDnsARecord"] as! Bool
                    }
                    if dict.keys.contains("EnableIpDnsARecord") {
                        self.enableIpDnsARecord = dict["EnableIpDnsARecord"] as! Bool
                    }
                    if dict.keys.contains("EnableIpDnsPtrRecord") {
                        self.enableIpDnsPtrRecord = dict["EnableIpDnsPtrRecord"] as! Bool
                    }
                    if dict.keys.contains("HostnameType") {
                        self.hostnameType = dict["HostnameType"] as! String
                    }
                }
            }
            public class PublicIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") {
                        self.ipAddress = dict["IpAddress"] as! [String]
                    }
                }
            }
            public class RdmaIpAddress : Tea.TeaModel {
                public var ipAddress: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipAddress != nil {
                        map["IpAddress"] = self.ipAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("IpAddress") {
                        self.ipAddress = dict["IpAddress"] as! [String]
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeInstancesResponseBody.Instances.Instance.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeInstancesResponseBody.Instances.Instance.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeInstancesResponseBody.Instances.Instance.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public class VpcAttributes : Tea.TeaModel {
                public class PrivateIpAddress : Tea.TeaModel {
                    public var ipAddress: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipAddress != nil {
                            map["IpAddress"] = self.ipAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("IpAddress") {
                            self.ipAddress = dict["IpAddress"] as! [String]
                        }
                    }
                }
                public var natIpAddress: String?

                public var privateIpAddress: DescribeInstancesResponseBody.Instances.Instance.VpcAttributes.PrivateIpAddress?

                public var vSwitchId: String?

                public var vpcId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.privateIpAddress?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.natIpAddress != nil {
                        map["NatIpAddress"] = self.natIpAddress!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress?.toMap()
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("NatIpAddress") {
                        self.natIpAddress = dict["NatIpAddress"] as! String
                    }
                    if dict.keys.contains("PrivateIpAddress") {
                        var model = DescribeInstancesResponseBody.Instances.Instance.VpcAttributes.PrivateIpAddress()
                        model.fromMap(dict["PrivateIpAddress"] as! [String: Any])
                        self.privateIpAddress = model
                    }
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                }
            }
            public var autoReleaseTime: String?

            public var clusterId: String?

            public var cpu: Int32?

            public var cpuOptions: DescribeInstancesResponseBody.Instances.Instance.CpuOptions?

            public var creationTime: String?

            public var creditSpecification: String?

            public var dedicatedHostAttribute: DescribeInstancesResponseBody.Instances.Instance.DedicatedHostAttribute?

            public var dedicatedInstanceAttribute: DescribeInstancesResponseBody.Instances.Instance.DedicatedInstanceAttribute?

            public var deletionProtection: Bool?

            public var deploymentSetGroupNo: Int32?

            public var deploymentSetId: String?

            public var description_: String?

            public var deviceAvailable: Bool?

            public var ecsCapacityReservationAttr: DescribeInstancesResponseBody.Instances.Instance.EcsCapacityReservationAttr?

            public var eipAddress: DescribeInstancesResponseBody.Instances.Instance.EipAddress?

            public var expiredTime: String?

            public var GPUAmount: Int32?

            public var GPUSpec: String?

            public var hibernationOptions: DescribeInstancesResponseBody.Instances.Instance.HibernationOptions?

            public var hostName: String?

            public var hpcClusterId: String?

            public var ISP: String?

            public var imageId: String?

            public var imageOptions: DescribeInstancesResponseBody.Instances.Instance.ImageOptions?

            public var innerIpAddress: DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress?

            public var instanceChargeType: String?

            public var instanceId: String?

            public var instanceName: String?

            public var instanceNetworkType: String?

            public var instanceType: String?

            public var instanceTypeFamily: String?

            public var internetChargeType: String?

            public var internetMaxBandwidthIn: Int32?

            public var internetMaxBandwidthOut: Int32?

            public var ioOptimized: Bool?

            public var keyPairName: String?

            public var localStorageAmount: Int32?

            public var localStorageCapacity: Int64?

            public var memory: Int32?

            public var metadataOptions: DescribeInstancesResponseBody.Instances.Instance.MetadataOptions?

            public var networkInterfaces: DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces?

            public var OSName: String?

            public var OSNameEn: String?

            public var OSType: String?

            public var operationLocks: DescribeInstancesResponseBody.Instances.Instance.OperationLocks?

            public var privateDnsNameOptions: DescribeInstancesResponseBody.Instances.Instance.PrivateDnsNameOptions?

            public var publicIpAddress: DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress?

            public var rdmaIpAddress: DescribeInstancesResponseBody.Instances.Instance.RdmaIpAddress?

            public var recyclable: Bool?

            public var regionId: String?

            public var resourceGroupId: String?

            public var saleCycle: String?

            public var securityGroupIds: DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds?

            public var serialNumber: String?

            public var spotDuration: Int32?

            public var spotInterruptionBehavior: String?

            public var spotPriceLimit: Double?

            public var spotStrategy: String?

            public var startTime: String?

            public var status: String?

            public var stoppedMode: String?

            public var tags: DescribeInstancesResponseBody.Instances.Instance.Tags?

            public var vlanId: String?

            public var vpcAttributes: DescribeInstancesResponseBody.Instances.Instance.VpcAttributes?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.cpuOptions?.validate()
                try self.dedicatedHostAttribute?.validate()
                try self.dedicatedInstanceAttribute?.validate()
                try self.ecsCapacityReservationAttr?.validate()
                try self.eipAddress?.validate()
                try self.hibernationOptions?.validate()
                try self.imageOptions?.validate()
                try self.innerIpAddress?.validate()
                try self.metadataOptions?.validate()
                try self.networkInterfaces?.validate()
                try self.operationLocks?.validate()
                try self.privateDnsNameOptions?.validate()
                try self.publicIpAddress?.validate()
                try self.rdmaIpAddress?.validate()
                try self.securityGroupIds?.validate()
                try self.tags?.validate()
                try self.vpcAttributes?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.autoReleaseTime != nil {
                    map["AutoReleaseTime"] = self.autoReleaseTime!
                }
                if self.clusterId != nil {
                    map["ClusterId"] = self.clusterId!
                }
                if self.cpu != nil {
                    map["Cpu"] = self.cpu!
                }
                if self.cpuOptions != nil {
                    map["CpuOptions"] = self.cpuOptions?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.creditSpecification != nil {
                    map["CreditSpecification"] = self.creditSpecification!
                }
                if self.dedicatedHostAttribute != nil {
                    map["DedicatedHostAttribute"] = self.dedicatedHostAttribute?.toMap()
                }
                if self.dedicatedInstanceAttribute != nil {
                    map["DedicatedInstanceAttribute"] = self.dedicatedInstanceAttribute?.toMap()
                }
                if self.deletionProtection != nil {
                    map["DeletionProtection"] = self.deletionProtection!
                }
                if self.deploymentSetGroupNo != nil {
                    map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
                }
                if self.deploymentSetId != nil {
                    map["DeploymentSetId"] = self.deploymentSetId!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.deviceAvailable != nil {
                    map["DeviceAvailable"] = self.deviceAvailable!
                }
                if self.ecsCapacityReservationAttr != nil {
                    map["EcsCapacityReservationAttr"] = self.ecsCapacityReservationAttr?.toMap()
                }
                if self.eipAddress != nil {
                    map["EipAddress"] = self.eipAddress?.toMap()
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.GPUAmount != nil {
                    map["GPUAmount"] = self.GPUAmount!
                }
                if self.GPUSpec != nil {
                    map["GPUSpec"] = self.GPUSpec!
                }
                if self.hibernationOptions != nil {
                    map["HibernationOptions"] = self.hibernationOptions?.toMap()
                }
                if self.hostName != nil {
                    map["HostName"] = self.hostName!
                }
                if self.hpcClusterId != nil {
                    map["HpcClusterId"] = self.hpcClusterId!
                }
                if self.ISP != nil {
                    map["ISP"] = self.ISP!
                }
                if self.imageId != nil {
                    map["ImageId"] = self.imageId!
                }
                if self.imageOptions != nil {
                    map["ImageOptions"] = self.imageOptions?.toMap()
                }
                if self.innerIpAddress != nil {
                    map["InnerIpAddress"] = self.innerIpAddress?.toMap()
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instanceNetworkType != nil {
                    map["InstanceNetworkType"] = self.instanceNetworkType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.instanceTypeFamily != nil {
                    map["InstanceTypeFamily"] = self.instanceTypeFamily!
                }
                if self.internetChargeType != nil {
                    map["InternetChargeType"] = self.internetChargeType!
                }
                if self.internetMaxBandwidthIn != nil {
                    map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
                }
                if self.internetMaxBandwidthOut != nil {
                    map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                }
                if self.ioOptimized != nil {
                    map["IoOptimized"] = self.ioOptimized!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                if self.localStorageAmount != nil {
                    map["LocalStorageAmount"] = self.localStorageAmount!
                }
                if self.localStorageCapacity != nil {
                    map["LocalStorageCapacity"] = self.localStorageCapacity!
                }
                if self.memory != nil {
                    map["Memory"] = self.memory!
                }
                if self.metadataOptions != nil {
                    map["MetadataOptions"] = self.metadataOptions?.toMap()
                }
                if self.networkInterfaces != nil {
                    map["NetworkInterfaces"] = self.networkInterfaces?.toMap()
                }
                if self.OSName != nil {
                    map["OSName"] = self.OSName!
                }
                if self.OSNameEn != nil {
                    map["OSNameEn"] = self.OSNameEn!
                }
                if self.OSType != nil {
                    map["OSType"] = self.OSType!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.privateDnsNameOptions != nil {
                    map["PrivateDnsNameOptions"] = self.privateDnsNameOptions?.toMap()
                }
                if self.publicIpAddress != nil {
                    map["PublicIpAddress"] = self.publicIpAddress?.toMap()
                }
                if self.rdmaIpAddress != nil {
                    map["RdmaIpAddress"] = self.rdmaIpAddress?.toMap()
                }
                if self.recyclable != nil {
                    map["Recyclable"] = self.recyclable!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.saleCycle != nil {
                    map["SaleCycle"] = self.saleCycle!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.serialNumber != nil {
                    map["SerialNumber"] = self.serialNumber!
                }
                if self.spotDuration != nil {
                    map["SpotDuration"] = self.spotDuration!
                }
                if self.spotInterruptionBehavior != nil {
                    map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
                }
                if self.spotPriceLimit != nil {
                    map["SpotPriceLimit"] = self.spotPriceLimit!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.stoppedMode != nil {
                    map["StoppedMode"] = self.stoppedMode!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vpcAttributes != nil {
                    map["VpcAttributes"] = self.vpcAttributes?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AutoReleaseTime") {
                    self.autoReleaseTime = dict["AutoReleaseTime"] as! String
                }
                if dict.keys.contains("ClusterId") {
                    self.clusterId = dict["ClusterId"] as! String
                }
                if dict.keys.contains("Cpu") {
                    self.cpu = dict["Cpu"] as! Int32
                }
                if dict.keys.contains("CpuOptions") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.CpuOptions()
                    model.fromMap(dict["CpuOptions"] as! [String: Any])
                    self.cpuOptions = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("CreditSpecification") {
                    self.creditSpecification = dict["CreditSpecification"] as! String
                }
                if dict.keys.contains("DedicatedHostAttribute") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.DedicatedHostAttribute()
                    model.fromMap(dict["DedicatedHostAttribute"] as! [String: Any])
                    self.dedicatedHostAttribute = model
                }
                if dict.keys.contains("DedicatedInstanceAttribute") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.DedicatedInstanceAttribute()
                    model.fromMap(dict["DedicatedInstanceAttribute"] as! [String: Any])
                    self.dedicatedInstanceAttribute = model
                }
                if dict.keys.contains("DeletionProtection") {
                    self.deletionProtection = dict["DeletionProtection"] as! Bool
                }
                if dict.keys.contains("DeploymentSetGroupNo") {
                    self.deploymentSetGroupNo = dict["DeploymentSetGroupNo"] as! Int32
                }
                if dict.keys.contains("DeploymentSetId") {
                    self.deploymentSetId = dict["DeploymentSetId"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DeviceAvailable") {
                    self.deviceAvailable = dict["DeviceAvailable"] as! Bool
                }
                if dict.keys.contains("EcsCapacityReservationAttr") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.EcsCapacityReservationAttr()
                    model.fromMap(dict["EcsCapacityReservationAttr"] as! [String: Any])
                    self.ecsCapacityReservationAttr = model
                }
                if dict.keys.contains("EipAddress") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.EipAddress()
                    model.fromMap(dict["EipAddress"] as! [String: Any])
                    self.eipAddress = model
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("GPUAmount") {
                    self.GPUAmount = dict["GPUAmount"] as! Int32
                }
                if dict.keys.contains("GPUSpec") {
                    self.GPUSpec = dict["GPUSpec"] as! String
                }
                if dict.keys.contains("HibernationOptions") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.HibernationOptions()
                    model.fromMap(dict["HibernationOptions"] as! [String: Any])
                    self.hibernationOptions = model
                }
                if dict.keys.contains("HostName") {
                    self.hostName = dict["HostName"] as! String
                }
                if dict.keys.contains("HpcClusterId") {
                    self.hpcClusterId = dict["HpcClusterId"] as! String
                }
                if dict.keys.contains("ISP") {
                    self.ISP = dict["ISP"] as! String
                }
                if dict.keys.contains("ImageId") {
                    self.imageId = dict["ImageId"] as! String
                }
                if dict.keys.contains("ImageOptions") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.ImageOptions()
                    model.fromMap(dict["ImageOptions"] as! [String: Any])
                    self.imageOptions = model
                }
                if dict.keys.contains("InnerIpAddress") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.InnerIpAddress()
                    model.fromMap(dict["InnerIpAddress"] as! [String: Any])
                    self.innerIpAddress = model
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstanceNetworkType") {
                    self.instanceNetworkType = dict["InstanceNetworkType"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("InstanceTypeFamily") {
                    self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                }
                if dict.keys.contains("InternetChargeType") {
                    self.internetChargeType = dict["InternetChargeType"] as! String
                }
                if dict.keys.contains("InternetMaxBandwidthIn") {
                    self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
                }
                if dict.keys.contains("InternetMaxBandwidthOut") {
                    self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
                }
                if dict.keys.contains("IoOptimized") {
                    self.ioOptimized = dict["IoOptimized"] as! Bool
                }
                if dict.keys.contains("KeyPairName") {
                    self.keyPairName = dict["KeyPairName"] as! String
                }
                if dict.keys.contains("LocalStorageAmount") {
                    self.localStorageAmount = dict["LocalStorageAmount"] as! Int32
                }
                if dict.keys.contains("LocalStorageCapacity") {
                    self.localStorageCapacity = dict["LocalStorageCapacity"] as! Int64
                }
                if dict.keys.contains("Memory") {
                    self.memory = dict["Memory"] as! Int32
                }
                if dict.keys.contains("MetadataOptions") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.MetadataOptions()
                    model.fromMap(dict["MetadataOptions"] as! [String: Any])
                    self.metadataOptions = model
                }
                if dict.keys.contains("NetworkInterfaces") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.NetworkInterfaces()
                    model.fromMap(dict["NetworkInterfaces"] as! [String: Any])
                    self.networkInterfaces = model
                }
                if dict.keys.contains("OSName") {
                    self.OSName = dict["OSName"] as! String
                }
                if dict.keys.contains("OSNameEn") {
                    self.OSNameEn = dict["OSNameEn"] as! String
                }
                if dict.keys.contains("OSType") {
                    self.OSType = dict["OSType"] as! String
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("PrivateDnsNameOptions") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PrivateDnsNameOptions()
                    model.fromMap(dict["PrivateDnsNameOptions"] as! [String: Any])
                    self.privateDnsNameOptions = model
                }
                if dict.keys.contains("PublicIpAddress") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.PublicIpAddress()
                    model.fromMap(dict["PublicIpAddress"] as! [String: Any])
                    self.publicIpAddress = model
                }
                if dict.keys.contains("RdmaIpAddress") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.RdmaIpAddress()
                    model.fromMap(dict["RdmaIpAddress"] as! [String: Any])
                    self.rdmaIpAddress = model
                }
                if dict.keys.contains("Recyclable") {
                    self.recyclable = dict["Recyclable"] as! Bool
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SaleCycle") {
                    self.saleCycle = dict["SaleCycle"] as! String
                }
                if dict.keys.contains("SecurityGroupIds") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.SecurityGroupIds()
                    model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                    self.securityGroupIds = model
                }
                if dict.keys.contains("SerialNumber") {
                    self.serialNumber = dict["SerialNumber"] as! String
                }
                if dict.keys.contains("SpotDuration") {
                    self.spotDuration = dict["SpotDuration"] as! Int32
                }
                if dict.keys.contains("SpotInterruptionBehavior") {
                    self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
                }
                if dict.keys.contains("SpotPriceLimit") {
                    self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
                }
                if dict.keys.contains("SpotStrategy") {
                    self.spotStrategy = dict["SpotStrategy"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StoppedMode") {
                    self.stoppedMode = dict["StoppedMode"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VlanId") {
                    self.vlanId = dict["VlanId"] as! String
                }
                if dict.keys.contains("VpcAttributes") {
                    var model = DescribeInstancesResponseBody.Instances.Instance.VpcAttributes()
                    model.fromMap(dict["VpcAttributes"] as! [String: Any])
                    self.vpcAttributes = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var instance: [DescribeInstancesResponseBody.Instances.Instance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instance != nil {
                var tmp : [Any] = []
                for k in self.instance! {
                    tmp.append(k.toMap())
                }
                map["Instance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Instance") {
                var tmp : [DescribeInstancesResponseBody.Instances.Instance] = []
                for v in dict["Instance"] as! [Any] {
                    var model = DescribeInstancesResponseBody.Instances.Instance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instance = tmp
            }
        }
    }
    public var instances: DescribeInstancesResponseBody.Instances?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            map["Instances"] = self.instances?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var model = DescribeInstancesResponseBody.Instances()
            model.fromMap(dict["Instances"] as! [String: Any])
            self.instances = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInstancesFullStatusRequest : Tea.TeaModel {
    public class EventPublishTime : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("End") {
                self.end = dict["End"] as! String
            }
            if dict.keys.contains("Start") {
                self.start = dict["Start"] as! String
            }
        }
    }
    public class NotBefore : Tea.TeaModel {
        public var end: String?

        public var start: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.end != nil {
                map["End"] = self.end!
            }
            if self.start != nil {
                map["Start"] = self.start!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("End") {
                self.end = dict["End"] as! String
            }
            if dict.keys.contains("Start") {
                self.start = dict["Start"] as! String
            }
        }
    }
    public var eventPublishTime: DescribeInstancesFullStatusRequest.EventPublishTime?

    public var notBefore: DescribeInstancesFullStatusRequest.NotBefore?

    public var eventId: [String]?

    public var eventType: String?

    public var healthStatus: String?

    public var instanceEventType: [String]?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eventPublishTime?.validate()
        try self.notBefore?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eventPublishTime != nil {
            map["EventPublishTime"] = self.eventPublishTime?.toMap()
        }
        if self.notBefore != nil {
            map["NotBefore"] = self.notBefore?.toMap()
        }
        if self.eventId != nil {
            map["EventId"] = self.eventId!
        }
        if self.eventType != nil {
            map["EventType"] = self.eventType!
        }
        if self.healthStatus != nil {
            map["HealthStatus"] = self.healthStatus!
        }
        if self.instanceEventType != nil {
            map["InstanceEventType"] = self.instanceEventType!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EventPublishTime") {
            var model = DescribeInstancesFullStatusRequest.EventPublishTime()
            model.fromMap(dict["EventPublishTime"] as! [String: Any])
            self.eventPublishTime = model
        }
        if dict.keys.contains("NotBefore") {
            var model = DescribeInstancesFullStatusRequest.NotBefore()
            model.fromMap(dict["NotBefore"] as! [String: Any])
            self.notBefore = model
        }
        if dict.keys.contains("EventId") {
            self.eventId = dict["EventId"] as! [String]
        }
        if dict.keys.contains("EventType") {
            self.eventType = dict["EventType"] as! String
        }
        if dict.keys.contains("HealthStatus") {
            self.healthStatus = dict["HealthStatus"] as! String
        }
        if dict.keys.contains("InstanceEventType") {
            self.instanceEventType = dict["InstanceEventType"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class DescribeInstancesFullStatusResponseBody : Tea.TeaModel {
    public class InstanceFullStatusSet : Tea.TeaModel {
        public class InstanceFullStatusType : Tea.TeaModel {
            public class HealthStatus : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public class ScheduledSystemEventSet : Tea.TeaModel {
                public class ScheduledSystemEventType : Tea.TeaModel {
                    public class EventCycleStatus : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Code") {
                                self.code = dict["Code"] as! Int32
                            }
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                        }
                    }
                    public class EventType : Tea.TeaModel {
                        public var code: Int32?

                        public var name: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.code != nil {
                                map["Code"] = self.code!
                            }
                            if self.name != nil {
                                map["Name"] = self.name!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Code") {
                                self.code = dict["Code"] as! Int32
                            }
                            if dict.keys.contains("Name") {
                                self.name = dict["Name"] as! String
                            }
                        }
                    }
                    public class ExtendedAttribute : Tea.TeaModel {
                        public class InactiveDisks : Tea.TeaModel {
                            public class InactiveDisk : Tea.TeaModel {
                                public var creationTime: String?

                                public var deviceCategory: String?

                                public var deviceSize: String?

                                public var deviceType: String?

                                public var releaseTime: String?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.creationTime != nil {
                                        map["CreationTime"] = self.creationTime!
                                    }
                                    if self.deviceCategory != nil {
                                        map["DeviceCategory"] = self.deviceCategory!
                                    }
                                    if self.deviceSize != nil {
                                        map["DeviceSize"] = self.deviceSize!
                                    }
                                    if self.deviceType != nil {
                                        map["DeviceType"] = self.deviceType!
                                    }
                                    if self.releaseTime != nil {
                                        map["ReleaseTime"] = self.releaseTime!
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("CreationTime") {
                                        self.creationTime = dict["CreationTime"] as! String
                                    }
                                    if dict.keys.contains("DeviceCategory") {
                                        self.deviceCategory = dict["DeviceCategory"] as! String
                                    }
                                    if dict.keys.contains("DeviceSize") {
                                        self.deviceSize = dict["DeviceSize"] as! String
                                    }
                                    if dict.keys.contains("DeviceType") {
                                        self.deviceType = dict["DeviceType"] as! String
                                    }
                                    if dict.keys.contains("ReleaseTime") {
                                        self.releaseTime = dict["ReleaseTime"] as! String
                                    }
                                }
                            }
                            public var inactiveDisk: [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.inactiveDisk != nil {
                                    var tmp : [Any] = []
                                    for k in self.inactiveDisk! {
                                        tmp.append(k.toMap())
                                    }
                                    map["InactiveDisk"] = tmp
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("InactiveDisk") {
                                    var tmp : [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk] = []
                                    for v in dict["InactiveDisk"] as! [Any] {
                                        var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks.InactiveDisk()
                                        if v != nil {
                                            model.fromMap(v as! [String: Any])
                                        }
                                        tmp.append(model)
                                    }
                                    self.inactiveDisk = tmp
                                }
                            }
                        }
                        public var device: String?

                        public var diskId: String?

                        public var inactiveDisks: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.inactiveDisks?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.device != nil {
                                map["Device"] = self.device!
                            }
                            if self.diskId != nil {
                                map["DiskId"] = self.diskId!
                            }
                            if self.inactiveDisks != nil {
                                map["InactiveDisks"] = self.inactiveDisks?.toMap()
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Device") {
                                self.device = dict["Device"] as! String
                            }
                            if dict.keys.contains("DiskId") {
                                self.diskId = dict["DiskId"] as! String
                            }
                            if dict.keys.contains("InactiveDisks") {
                                var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute.InactiveDisks()
                                model.fromMap(dict["InactiveDisks"] as! [String: Any])
                                self.inactiveDisks = model
                            }
                        }
                    }
                    public var eventCycleStatus: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventCycleStatus?

                    public var eventId: String?

                    public var eventPublishTime: String?

                    public var eventType: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventType?

                    public var extendedAttribute: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute?

                    public var impactLevel: String?

                    public var notBefore: String?

                    public var reason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.eventCycleStatus?.validate()
                        try self.eventType?.validate()
                        try self.extendedAttribute?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.eventCycleStatus != nil {
                            map["EventCycleStatus"] = self.eventCycleStatus?.toMap()
                        }
                        if self.eventId != nil {
                            map["EventId"] = self.eventId!
                        }
                        if self.eventPublishTime != nil {
                            map["EventPublishTime"] = self.eventPublishTime!
                        }
                        if self.eventType != nil {
                            map["EventType"] = self.eventType?.toMap()
                        }
                        if self.extendedAttribute != nil {
                            map["ExtendedAttribute"] = self.extendedAttribute?.toMap()
                        }
                        if self.impactLevel != nil {
                            map["ImpactLevel"] = self.impactLevel!
                        }
                        if self.notBefore != nil {
                            map["NotBefore"] = self.notBefore!
                        }
                        if self.reason != nil {
                            map["Reason"] = self.reason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("EventCycleStatus") {
                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventCycleStatus()
                            model.fromMap(dict["EventCycleStatus"] as! [String: Any])
                            self.eventCycleStatus = model
                        }
                        if dict.keys.contains("EventId") {
                            self.eventId = dict["EventId"] as! String
                        }
                        if dict.keys.contains("EventPublishTime") {
                            self.eventPublishTime = dict["EventPublishTime"] as! String
                        }
                        if dict.keys.contains("EventType") {
                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.EventType()
                            model.fromMap(dict["EventType"] as! [String: Any])
                            self.eventType = model
                        }
                        if dict.keys.contains("ExtendedAttribute") {
                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType.ExtendedAttribute()
                            model.fromMap(dict["ExtendedAttribute"] as! [String: Any])
                            self.extendedAttribute = model
                        }
                        if dict.keys.contains("ImpactLevel") {
                            self.impactLevel = dict["ImpactLevel"] as! String
                        }
                        if dict.keys.contains("NotBefore") {
                            self.notBefore = dict["NotBefore"] as! String
                        }
                        if dict.keys.contains("Reason") {
                            self.reason = dict["Reason"] as! String
                        }
                    }
                }
                public var scheduledSystemEventType: [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.scheduledSystemEventType != nil {
                        var tmp : [Any] = []
                        for k in self.scheduledSystemEventType! {
                            tmp.append(k.toMap())
                        }
                        map["ScheduledSystemEventType"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ScheduledSystemEventType") {
                        var tmp : [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType] = []
                        for v in dict["ScheduledSystemEventType"] as! [Any] {
                            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet.ScheduledSystemEventType()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.scheduledSystemEventType = tmp
                    }
                }
            }
            public class Status : Tea.TeaModel {
                public var code: Int32?

                public var name: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.code != nil {
                        map["Code"] = self.code!
                    }
                    if self.name != nil {
                        map["Name"] = self.name!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Code") {
                        self.code = dict["Code"] as! Int32
                    }
                    if dict.keys.contains("Name") {
                        self.name = dict["Name"] as! String
                    }
                }
            }
            public var healthStatus: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.HealthStatus?

            public var instanceId: String?

            public var scheduledSystemEventSet: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet?

            public var status: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.Status?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.healthStatus?.validate()
                try self.scheduledSystemEventSet?.validate()
                try self.status?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.healthStatus != nil {
                    map["HealthStatus"] = self.healthStatus?.toMap()
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.scheduledSystemEventSet != nil {
                    map["ScheduledSystemEventSet"] = self.scheduledSystemEventSet?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("HealthStatus") {
                    var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.HealthStatus()
                    model.fromMap(dict["HealthStatus"] as! [String: Any])
                    self.healthStatus = model
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("ScheduledSystemEventSet") {
                    var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.ScheduledSystemEventSet()
                    model.fromMap(dict["ScheduledSystemEventSet"] as! [String: Any])
                    self.scheduledSystemEventSet = model
                }
                if dict.keys.contains("Status") {
                    var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType.Status()
                    model.fromMap(dict["Status"] as! [String: Any])
                    self.status = model
                }
            }
        }
        public var instanceFullStatusType: [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceFullStatusType != nil {
                var tmp : [Any] = []
                for k in self.instanceFullStatusType! {
                    tmp.append(k.toMap())
                }
                map["InstanceFullStatusType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceFullStatusType") {
                var tmp : [DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType] = []
                for v in dict["InstanceFullStatusType"] as! [Any] {
                    var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet.InstanceFullStatusType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceFullStatusType = tmp
            }
        }
    }
    public var instanceFullStatusSet: DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceFullStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceFullStatusSet != nil {
            map["InstanceFullStatusSet"] = self.instanceFullStatusSet?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceFullStatusSet") {
            var model = DescribeInstancesFullStatusResponseBody.InstanceFullStatusSet()
            model.fromMap(dict["InstanceFullStatusSet"] as! [String: Any])
            self.instanceFullStatusSet = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeInstancesFullStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInstancesFullStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInstancesFullStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInvocationResultsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var commandId: String?

    public var contentEncoding: String?

    public var includeHistory: Bool?

    public var instanceId: String?

    public var invokeId: String?

    public var invokeRecordStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeInvocationResultsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.includeHistory != nil {
            map["IncludeHistory"] = self.includeHistory!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.invokeRecordStatus != nil {
            map["InvokeRecordStatus"] = self.invokeRecordStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("IncludeHistory") {
            self.includeHistory = dict["IncludeHistory"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("InvokeRecordStatus") {
            self.invokeRecordStatus = dict["InvokeRecordStatus"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeInvocationResultsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeInvocationResultsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeInvocationResultsResponseBody : Tea.TeaModel {
    public class Invocation : Tea.TeaModel {
        public class InvocationResults : Tea.TeaModel {
            public class InvocationResult : Tea.TeaModel {
                public class Tags : Tea.TeaModel {
                    public class Tag : Tea.TeaModel {
                        public var tagKey: String?

                        public var tagValue: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.tagKey != nil {
                                map["TagKey"] = self.tagKey!
                            }
                            if self.tagValue != nil {
                                map["TagValue"] = self.tagValue!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("TagKey") {
                                self.tagKey = dict["TagKey"] as! String
                            }
                            if dict.keys.contains("TagValue") {
                                self.tagValue = dict["TagValue"] as! String
                            }
                        }
                    }
                    public var tag: [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags.Tag]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tag != nil {
                            var tmp : [Any] = []
                            for k in self.tag! {
                                tmp.append(k.toMap())
                            }
                            map["Tag"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Tag") {
                            var tmp : [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags.Tag] = []
                            for v in dict["Tag"] as! [Any] {
                                var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags.Tag()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.tag = tmp
                        }
                    }
                }
                public var commandId: String?

                public var containerId: String?

                public var containerName: String?

                public var dropped: Int32?

                public var errorCode: String?

                public var errorInfo: String?

                public var exitCode: Int64?

                public var finishedTime: String?

                public var instanceId: String?

                public var invocationStatus: String?

                public var invokeId: String?

                public var invokeRecordStatus: String?

                public var launcher: String?

                public var output: String?

                public var repeats: Int32?

                public var startTime: String?

                public var stopTime: String?

                public var tags: DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags?

                public var terminationMode: String?

                public var username: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.tags?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.commandId != nil {
                        map["CommandId"] = self.commandId!
                    }
                    if self.containerId != nil {
                        map["ContainerId"] = self.containerId!
                    }
                    if self.containerName != nil {
                        map["ContainerName"] = self.containerName!
                    }
                    if self.dropped != nil {
                        map["Dropped"] = self.dropped!
                    }
                    if self.errorCode != nil {
                        map["ErrorCode"] = self.errorCode!
                    }
                    if self.errorInfo != nil {
                        map["ErrorInfo"] = self.errorInfo!
                    }
                    if self.exitCode != nil {
                        map["ExitCode"] = self.exitCode!
                    }
                    if self.finishedTime != nil {
                        map["FinishedTime"] = self.finishedTime!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.invocationStatus != nil {
                        map["InvocationStatus"] = self.invocationStatus!
                    }
                    if self.invokeId != nil {
                        map["InvokeId"] = self.invokeId!
                    }
                    if self.invokeRecordStatus != nil {
                        map["InvokeRecordStatus"] = self.invokeRecordStatus!
                    }
                    if self.launcher != nil {
                        map["Launcher"] = self.launcher!
                    }
                    if self.output != nil {
                        map["Output"] = self.output!
                    }
                    if self.repeats != nil {
                        map["Repeats"] = self.repeats!
                    }
                    if self.startTime != nil {
                        map["StartTime"] = self.startTime!
                    }
                    if self.stopTime != nil {
                        map["StopTime"] = self.stopTime!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags?.toMap()
                    }
                    if self.terminationMode != nil {
                        map["TerminationMode"] = self.terminationMode!
                    }
                    if self.username != nil {
                        map["Username"] = self.username!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("CommandId") {
                        self.commandId = dict["CommandId"] as! String
                    }
                    if dict.keys.contains("ContainerId") {
                        self.containerId = dict["ContainerId"] as! String
                    }
                    if dict.keys.contains("ContainerName") {
                        self.containerName = dict["ContainerName"] as! String
                    }
                    if dict.keys.contains("Dropped") {
                        self.dropped = dict["Dropped"] as! Int32
                    }
                    if dict.keys.contains("ErrorCode") {
                        self.errorCode = dict["ErrorCode"] as! String
                    }
                    if dict.keys.contains("ErrorInfo") {
                        self.errorInfo = dict["ErrorInfo"] as! String
                    }
                    if dict.keys.contains("ExitCode") {
                        self.exitCode = dict["ExitCode"] as! Int64
                    }
                    if dict.keys.contains("FinishedTime") {
                        self.finishedTime = dict["FinishedTime"] as! String
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("InvocationStatus") {
                        self.invocationStatus = dict["InvocationStatus"] as! String
                    }
                    if dict.keys.contains("InvokeId") {
                        self.invokeId = dict["InvokeId"] as! String
                    }
                    if dict.keys.contains("InvokeRecordStatus") {
                        self.invokeRecordStatus = dict["InvokeRecordStatus"] as! String
                    }
                    if dict.keys.contains("Launcher") {
                        self.launcher = dict["Launcher"] as! String
                    }
                    if dict.keys.contains("Output") {
                        self.output = dict["Output"] as! String
                    }
                    if dict.keys.contains("Repeats") {
                        self.repeats = dict["Repeats"] as! Int32
                    }
                    if dict.keys.contains("StartTime") {
                        self.startTime = dict["StartTime"] as! String
                    }
                    if dict.keys.contains("StopTime") {
                        self.stopTime = dict["StopTime"] as! String
                    }
                    if dict.keys.contains("Tags") {
                        var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult.Tags()
                        model.fromMap(dict["Tags"] as! [String: Any])
                        self.tags = model
                    }
                    if dict.keys.contains("TerminationMode") {
                        self.terminationMode = dict["TerminationMode"] as! String
                    }
                    if dict.keys.contains("Username") {
                        self.username = dict["Username"] as! String
                    }
                }
            }
            public var invocationResult: [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.invocationResult != nil {
                    var tmp : [Any] = []
                    for k in self.invocationResult! {
                        tmp.append(k.toMap())
                    }
                    map["InvocationResult"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InvocationResult") {
                    var tmp : [DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult] = []
                    for v in dict["InvocationResult"] as! [Any] {
                        var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults.InvocationResult()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.invocationResult = tmp
                }
            }
        }
        public var invocationResults: DescribeInvocationResultsResponseBody.Invocation.InvocationResults?

        public var nextToken: String?

        public var pageNumber: Int64?

        public var pageSize: Int64?

        public var totalCount: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.invocationResults?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invocationResults != nil {
                map["InvocationResults"] = self.invocationResults?.toMap()
            }
            if self.nextToken != nil {
                map["NextToken"] = self.nextToken!
            }
            if self.pageNumber != nil {
                map["PageNumber"] = self.pageNumber!
            }
            if self.pageSize != nil {
                map["PageSize"] = self.pageSize!
            }
            if self.totalCount != nil {
                map["TotalCount"] = self.totalCount!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InvocationResults") {
                var model = DescribeInvocationResultsResponseBody.Invocation.InvocationResults()
                model.fromMap(dict["InvocationResults"] as! [String: Any])
                self.invocationResults = model
            }
            if dict.keys.contains("NextToken") {
                self.nextToken = dict["NextToken"] as! String
            }
            if dict.keys.contains("PageNumber") {
                self.pageNumber = dict["PageNumber"] as! Int64
            }
            if dict.keys.contains("PageSize") {
                self.pageSize = dict["PageSize"] as! Int64
            }
            if dict.keys.contains("TotalCount") {
                self.totalCount = dict["TotalCount"] as! Int64
            }
        }
    }
    public var invocation: DescribeInvocationResultsResponseBody.Invocation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.invocation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invocation != nil {
            map["Invocation"] = self.invocation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Invocation") {
            var model = DescribeInvocationResultsResponseBody.Invocation()
            model.fromMap(dict["Invocation"] as! [String: Any])
            self.invocation = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeInvocationResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInvocationResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInvocationResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeInvocationsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var commandId: String?

    public var commandName: String?

    public var commandType: String?

    public var contentEncoding: String?

    public var includeOutput: Bool?

    public var instanceId: String?

    public var invokeId: String?

    public var invokeStatus: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeInvocationsRequest.Tag]?

    public var timed: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.commandName != nil {
            map["CommandName"] = self.commandName!
        }
        if self.commandType != nil {
            map["CommandType"] = self.commandType!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.includeOutput != nil {
            map["IncludeOutput"] = self.includeOutput!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.invokeStatus != nil {
            map["InvokeStatus"] = self.invokeStatus!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("CommandName") {
            self.commandName = dict["CommandName"] as! String
        }
        if dict.keys.contains("CommandType") {
            self.commandType = dict["CommandType"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("IncludeOutput") {
            self.includeOutput = dict["IncludeOutput"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("InvokeStatus") {
            self.invokeStatus = dict["InvokeStatus"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepeatMode") {
            self.repeatMode = dict["RepeatMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeInvocationsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeInvocationsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Timed") {
            self.timed = dict["Timed"] as! Bool
        }
    }
}

public class DescribeInvocationsResponseBody : Tea.TeaModel {
    public class Invocations : Tea.TeaModel {
        public class Invocation : Tea.TeaModel {
            public class InvokeInstances : Tea.TeaModel {
                public class InvokeInstance : Tea.TeaModel {
                    public var creationTime: String?

                    public var dropped: Int32?

                    public var errorCode: String?

                    public var errorInfo: String?

                    public var exitCode: Int64?

                    public var finishTime: String?

                    public var instanceId: String?

                    public var instanceInvokeStatus: String?

                    public var invocationStatus: String?

                    public var output: String?

                    public var repeats: Int32?

                    public var startTime: String?

                    public var stopTime: String?

                    public var timed: Bool?

                    public var updateTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.creationTime != nil {
                            map["CreationTime"] = self.creationTime!
                        }
                        if self.dropped != nil {
                            map["Dropped"] = self.dropped!
                        }
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorInfo != nil {
                            map["ErrorInfo"] = self.errorInfo!
                        }
                        if self.exitCode != nil {
                            map["ExitCode"] = self.exitCode!
                        }
                        if self.finishTime != nil {
                            map["FinishTime"] = self.finishTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.instanceInvokeStatus != nil {
                            map["InstanceInvokeStatus"] = self.instanceInvokeStatus!
                        }
                        if self.invocationStatus != nil {
                            map["InvocationStatus"] = self.invocationStatus!
                        }
                        if self.output != nil {
                            map["Output"] = self.output!
                        }
                        if self.repeats != nil {
                            map["Repeats"] = self.repeats!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.stopTime != nil {
                            map["StopTime"] = self.stopTime!
                        }
                        if self.timed != nil {
                            map["Timed"] = self.timed!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreationTime") {
                            self.creationTime = dict["CreationTime"] as! String
                        }
                        if dict.keys.contains("Dropped") {
                            self.dropped = dict["Dropped"] as! Int32
                        }
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorInfo") {
                            self.errorInfo = dict["ErrorInfo"] as! String
                        }
                        if dict.keys.contains("ExitCode") {
                            self.exitCode = dict["ExitCode"] as! Int64
                        }
                        if dict.keys.contains("FinishTime") {
                            self.finishTime = dict["FinishTime"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("InstanceInvokeStatus") {
                            self.instanceInvokeStatus = dict["InstanceInvokeStatus"] as! String
                        }
                        if dict.keys.contains("InvocationStatus") {
                            self.invocationStatus = dict["InvocationStatus"] as! String
                        }
                        if dict.keys.contains("Output") {
                            self.output = dict["Output"] as! String
                        }
                        if dict.keys.contains("Repeats") {
                            self.repeats = dict["Repeats"] as! Int32
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("StopTime") {
                            self.stopTime = dict["StopTime"] as! String
                        }
                        if dict.keys.contains("Timed") {
                            self.timed = dict["Timed"] as! Bool
                        }
                        if dict.keys.contains("UpdateTime") {
                            self.updateTime = dict["UpdateTime"] as! String
                        }
                    }
                }
                public var invokeInstance: [DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.invokeInstance != nil {
                        var tmp : [Any] = []
                        for k in self.invokeInstance! {
                            tmp.append(k.toMap())
                        }
                        map["InvokeInstance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InvokeInstance") {
                        var tmp : [DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance] = []
                        for v in dict["InvokeInstance"] as! [Any] {
                            var model = DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.invokeInstance = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeInvocationsResponseBody.Invocations.Invocation.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeInvocationsResponseBody.Invocations.Invocation.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeInvocationsResponseBody.Invocations.Invocation.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var commandContent: String?

            public var commandDescription: String?

            public var commandId: String?

            public var commandName: String?

            public var commandType: String?

            public var containerId: String?

            public var containerName: String?

            public var creationTime: String?

            public var frequency: String?

            public var invocationStatus: String?

            public var invokeId: String?

            public var invokeInstances: DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances?

            public var invokeStatus: String?

            public var launcher: String?

            public var parameters: String?

            public var repeatMode: String?

            public var tags: DescribeInvocationsResponseBody.Invocations.Invocation.Tags?

            public var terminationMode: String?

            public var timed: Bool?

            public var timeout: Int64?

            public var username: String?

            public var workingDir: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.invokeInstances?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commandContent != nil {
                    map["CommandContent"] = self.commandContent!
                }
                if self.commandDescription != nil {
                    map["CommandDescription"] = self.commandDescription!
                }
                if self.commandId != nil {
                    map["CommandId"] = self.commandId!
                }
                if self.commandName != nil {
                    map["CommandName"] = self.commandName!
                }
                if self.commandType != nil {
                    map["CommandType"] = self.commandType!
                }
                if self.containerId != nil {
                    map["ContainerId"] = self.containerId!
                }
                if self.containerName != nil {
                    map["ContainerName"] = self.containerName!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.frequency != nil {
                    map["Frequency"] = self.frequency!
                }
                if self.invocationStatus != nil {
                    map["InvocationStatus"] = self.invocationStatus!
                }
                if self.invokeId != nil {
                    map["InvokeId"] = self.invokeId!
                }
                if self.invokeInstances != nil {
                    map["InvokeInstances"] = self.invokeInstances?.toMap()
                }
                if self.invokeStatus != nil {
                    map["InvokeStatus"] = self.invokeStatus!
                }
                if self.launcher != nil {
                    map["Launcher"] = self.launcher!
                }
                if self.parameters != nil {
                    map["Parameters"] = self.parameters!
                }
                if self.repeatMode != nil {
                    map["RepeatMode"] = self.repeatMode!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.terminationMode != nil {
                    map["TerminationMode"] = self.terminationMode!
                }
                if self.timed != nil {
                    map["Timed"] = self.timed!
                }
                if self.timeout != nil {
                    map["Timeout"] = self.timeout!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                if self.workingDir != nil {
                    map["WorkingDir"] = self.workingDir!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommandContent") {
                    self.commandContent = dict["CommandContent"] as! String
                }
                if dict.keys.contains("CommandDescription") {
                    self.commandDescription = dict["CommandDescription"] as! String
                }
                if dict.keys.contains("CommandId") {
                    self.commandId = dict["CommandId"] as! String
                }
                if dict.keys.contains("CommandName") {
                    self.commandName = dict["CommandName"] as! String
                }
                if dict.keys.contains("CommandType") {
                    self.commandType = dict["CommandType"] as! String
                }
                if dict.keys.contains("ContainerId") {
                    self.containerId = dict["ContainerId"] as! String
                }
                if dict.keys.contains("ContainerName") {
                    self.containerName = dict["ContainerName"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Frequency") {
                    self.frequency = dict["Frequency"] as! String
                }
                if dict.keys.contains("InvocationStatus") {
                    self.invocationStatus = dict["InvocationStatus"] as! String
                }
                if dict.keys.contains("InvokeId") {
                    self.invokeId = dict["InvokeId"] as! String
                }
                if dict.keys.contains("InvokeInstances") {
                    var model = DescribeInvocationsResponseBody.Invocations.Invocation.InvokeInstances()
                    model.fromMap(dict["InvokeInstances"] as! [String: Any])
                    self.invokeInstances = model
                }
                if dict.keys.contains("InvokeStatus") {
                    self.invokeStatus = dict["InvokeStatus"] as! String
                }
                if dict.keys.contains("Launcher") {
                    self.launcher = dict["Launcher"] as! String
                }
                if dict.keys.contains("Parameters") {
                    self.parameters = dict["Parameters"] as! String
                }
                if dict.keys.contains("RepeatMode") {
                    self.repeatMode = dict["RepeatMode"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeInvocationsResponseBody.Invocations.Invocation.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TerminationMode") {
                    self.terminationMode = dict["TerminationMode"] as! String
                }
                if dict.keys.contains("Timed") {
                    self.timed = dict["Timed"] as! Bool
                }
                if dict.keys.contains("Timeout") {
                    self.timeout = dict["Timeout"] as! Int64
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
                if dict.keys.contains("WorkingDir") {
                    self.workingDir = dict["WorkingDir"] as! String
                }
            }
        }
        public var invocation: [DescribeInvocationsResponseBody.Invocations.Invocation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invocation != nil {
                var tmp : [Any] = []
                for k in self.invocation! {
                    tmp.append(k.toMap())
                }
                map["Invocation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Invocation") {
                var tmp : [DescribeInvocationsResponseBody.Invocations.Invocation] = []
                for v in dict["Invocation"] as! [Any] {
                    var model = DescribeInvocationsResponseBody.Invocations.Invocation()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.invocation = tmp
            }
        }
    }
    public var invocations: DescribeInvocationsResponseBody.Invocations?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.invocations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invocations != nil {
            map["Invocations"] = self.invocations?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Invocations") {
            var model = DescribeInvocationsResponseBody.Invocations()
            model.fromMap(dict["Invocations"] as! [String: Any])
            self.invocations = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeInvocationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeInvocationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeInvocationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeKeyPairsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var includePublicKey: Bool?

    public var keyPairFingerPrint: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeKeyPairsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.includePublicKey != nil {
            map["IncludePublicKey"] = self.includePublicKey!
        }
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IncludePublicKey") {
            self.includePublicKey = dict["IncludePublicKey"] as! Bool
        }
        if dict.keys.contains("KeyPairFingerPrint") {
            self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeKeyPairsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeKeyPairsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeKeyPairsResponseBody : Tea.TeaModel {
    public class KeyPairs : Tea.TeaModel {
        public class KeyPair : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var keyPairFingerPrint: String?

            public var keyPairName: String?

            public var publicKey: String?

            public var resourceGroupId: String?

            public var tags: DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.keyPairFingerPrint != nil {
                    map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
                }
                if self.keyPairName != nil {
                    map["KeyPairName"] = self.keyPairName!
                }
                if self.publicKey != nil {
                    map["PublicKey"] = self.publicKey!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("KeyPairFingerPrint") {
                    self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
                }
                if dict.keys.contains("KeyPairName") {
                    self.keyPairName = dict["KeyPairName"] as! String
                }
                if dict.keys.contains("PublicKey") {
                    self.publicKey = dict["PublicKey"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var keyPair: [DescribeKeyPairsResponseBody.KeyPairs.KeyPair]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.keyPair != nil {
                var tmp : [Any] = []
                for k in self.keyPair! {
                    tmp.append(k.toMap())
                }
                map["KeyPair"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("KeyPair") {
                var tmp : [DescribeKeyPairsResponseBody.KeyPairs.KeyPair] = []
                for v in dict["KeyPair"] as! [Any] {
                    var model = DescribeKeyPairsResponseBody.KeyPairs.KeyPair()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.keyPair = tmp
            }
        }
    }
    public var keyPairs: DescribeKeyPairsResponseBody.KeyPairs?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.keyPairs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairs != nil {
            map["KeyPairs"] = self.keyPairs?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairs") {
            var model = DescribeKeyPairsResponseBody.KeyPairs()
            model.fromMap(dict["KeyPairs"] as! [String: Any])
            self.keyPairs = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeKeyPairsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeKeyPairsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeKeyPairsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLaunchTemplateVersionsRequest : Tea.TeaModel {
    public var defaultVersion: Bool?

    public var detailFlag: Bool?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var launchTemplateVersion: [Int64]?

    public var maxVersion: Int64?

    public var minVersion: Int64?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultVersion != nil {
            map["DefaultVersion"] = self.defaultVersion!
        }
        if self.detailFlag != nil {
            map["DetailFlag"] = self.detailFlag!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.maxVersion != nil {
            map["MaxVersion"] = self.maxVersion!
        }
        if self.minVersion != nil {
            map["MinVersion"] = self.minVersion!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultVersion") {
            self.defaultVersion = dict["DefaultVersion"] as! Bool
        }
        if dict.keys.contains("DetailFlag") {
            self.detailFlag = dict["DetailFlag"] as! Bool
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! [Int64]
        }
        if dict.keys.contains("MaxVersion") {
            self.maxVersion = dict["MaxVersion"] as! Int64
        }
        if dict.keys.contains("MinVersion") {
            self.minVersion = dict["MinVersion"] as! Int64
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeLaunchTemplateVersionsResponseBody : Tea.TeaModel {
    public class LaunchTemplateVersionSets : Tea.TeaModel {
        public class LaunchTemplateVersionSet : Tea.TeaModel {
            public class LaunchTemplateData : Tea.TeaModel {
                public class SystemDisk : Tea.TeaModel {
                    public var autoSnapshotPolicyId: String?

                    public var burstingEnabled: Bool?

                    public var category: String?

                    public var deleteWithInstance: Bool?

                    public var description_: String?

                    public var diskName: String?

                    public var encrypted: String?

                    public var iops: Int32?

                    public var performanceLevel: String?

                    public var provisionedIops: Int64?

                    public var size: Int32?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.autoSnapshotPolicyId != nil {
                            map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                        }
                        if self.burstingEnabled != nil {
                            map["BurstingEnabled"] = self.burstingEnabled!
                        }
                        if self.category != nil {
                            map["Category"] = self.category!
                        }
                        if self.deleteWithInstance != nil {
                            map["DeleteWithInstance"] = self.deleteWithInstance!
                        }
                        if self.description_ != nil {
                            map["Description"] = self.description_!
                        }
                        if self.diskName != nil {
                            map["DiskName"] = self.diskName!
                        }
                        if self.encrypted != nil {
                            map["Encrypted"] = self.encrypted!
                        }
                        if self.iops != nil {
                            map["Iops"] = self.iops!
                        }
                        if self.performanceLevel != nil {
                            map["PerformanceLevel"] = self.performanceLevel!
                        }
                        if self.provisionedIops != nil {
                            map["ProvisionedIops"] = self.provisionedIops!
                        }
                        if self.size != nil {
                            map["Size"] = self.size!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AutoSnapshotPolicyId") {
                            self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
                        }
                        if dict.keys.contains("BurstingEnabled") {
                            self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                        }
                        if dict.keys.contains("Category") {
                            self.category = dict["Category"] as! String
                        }
                        if dict.keys.contains("DeleteWithInstance") {
                            self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                        }
                        if dict.keys.contains("Description") {
                            self.description_ = dict["Description"] as! String
                        }
                        if dict.keys.contains("DiskName") {
                            self.diskName = dict["DiskName"] as! String
                        }
                        if dict.keys.contains("Encrypted") {
                            self.encrypted = dict["Encrypted"] as! String
                        }
                        if dict.keys.contains("Iops") {
                            self.iops = dict["Iops"] as! Int32
                        }
                        if dict.keys.contains("PerformanceLevel") {
                            self.performanceLevel = dict["PerformanceLevel"] as! String
                        }
                        if dict.keys.contains("ProvisionedIops") {
                            self.provisionedIops = dict["ProvisionedIops"] as! Int64
                        }
                        if dict.keys.contains("Size") {
                            self.size = dict["Size"] as! Int32
                        }
                    }
                }
                public class DataDisks : Tea.TeaModel {
                    public class DataDisk : Tea.TeaModel {
                        public var autoSnapshotPolicyId: String?

                        public var burstingEnabled: Bool?

                        public var category: String?

                        public var deleteWithInstance: Bool?

                        public var description_: String?

                        public var device: String?

                        public var diskName: String?

                        public var encrypted: String?

                        public var performanceLevel: String?

                        public var provisionedIops: Int64?

                        public var size: Int32?

                        public var snapshotId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.autoSnapshotPolicyId != nil {
                                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
                            }
                            if self.burstingEnabled != nil {
                                map["BurstingEnabled"] = self.burstingEnabled!
                            }
                            if self.category != nil {
                                map["Category"] = self.category!
                            }
                            if self.deleteWithInstance != nil {
                                map["DeleteWithInstance"] = self.deleteWithInstance!
                            }
                            if self.description_ != nil {
                                map["Description"] = self.description_!
                            }
                            if self.device != nil {
                                map["Device"] = self.device!
                            }
                            if self.diskName != nil {
                                map["DiskName"] = self.diskName!
                            }
                            if self.encrypted != nil {
                                map["Encrypted"] = self.encrypted!
                            }
                            if self.performanceLevel != nil {
                                map["PerformanceLevel"] = self.performanceLevel!
                            }
                            if self.provisionedIops != nil {
                                map["ProvisionedIops"] = self.provisionedIops!
                            }
                            if self.size != nil {
                                map["Size"] = self.size!
                            }
                            if self.snapshotId != nil {
                                map["SnapshotId"] = self.snapshotId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AutoSnapshotPolicyId") {
                                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
                            }
                            if dict.keys.contains("BurstingEnabled") {
                                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
                            }
                            if dict.keys.contains("Category") {
                                self.category = dict["Category"] as! String
                            }
                            if dict.keys.contains("DeleteWithInstance") {
                                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
                            }
                            if dict.keys.contains("Description") {
                                self.description_ = dict["Description"] as! String
                            }
                            if dict.keys.contains("Device") {
                                self.device = dict["Device"] as! String
                            }
                            if dict.keys.contains("DiskName") {
                                self.diskName = dict["DiskName"] as! String
                            }
                            if dict.keys.contains("Encrypted") {
                                self.encrypted = dict["Encrypted"] as! String
                            }
                            if dict.keys.contains("PerformanceLevel") {
                                self.performanceLevel = dict["PerformanceLevel"] as! String
                            }
                            if dict.keys.contains("ProvisionedIops") {
                                self.provisionedIops = dict["ProvisionedIops"] as! Int64
                            }
                            if dict.keys.contains("Size") {
                                self.size = dict["Size"] as! Int32
                            }
                            if dict.keys.contains("SnapshotId") {
                                self.snapshotId = dict["SnapshotId"] as! String
                            }
                        }
                    }
                    public var dataDisk: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks.DataDisk]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dataDisk != nil {
                            var tmp : [Any] = []
                            for k in self.dataDisk! {
                                tmp.append(k.toMap())
                            }
                            map["DataDisk"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DataDisk") {
                            var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks.DataDisk] = []
                            for v in dict["DataDisk"] as! [Any] {
                                var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks.DataDisk()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.dataDisk = tmp
                        }
                    }
                }
                public class NetworkInterfaces : Tea.TeaModel {
                    public class NetworkInterface : Tea.TeaModel {
                        public class SecurityGroupIds : Tea.TeaModel {
                            public var securityGroupId: [String]?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.securityGroupId != nil {
                                    map["SecurityGroupId"] = self.securityGroupId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("SecurityGroupId") {
                                    self.securityGroupId = dict["SecurityGroupId"] as! [String]
                                }
                            }
                        }
                        public var description_: String?

                        public var instanceType: String?

                        public var networkInterfaceName: String?

                        public var networkInterfaceTrafficMode: String?

                        public var primaryIpAddress: String?

                        public var securityGroupId: String?

                        public var securityGroupIds: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface.SecurityGroupIds?

                        public var vSwitchId: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                            try self.securityGroupIds?.validate()
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.description_ != nil {
                                map["Description"] = self.description_!
                            }
                            if self.instanceType != nil {
                                map["InstanceType"] = self.instanceType!
                            }
                            if self.networkInterfaceName != nil {
                                map["NetworkInterfaceName"] = self.networkInterfaceName!
                            }
                            if self.networkInterfaceTrafficMode != nil {
                                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
                            }
                            if self.primaryIpAddress != nil {
                                map["PrimaryIpAddress"] = self.primaryIpAddress!
                            }
                            if self.securityGroupId != nil {
                                map["SecurityGroupId"] = self.securityGroupId!
                            }
                            if self.securityGroupIds != nil {
                                map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                            }
                            if self.vSwitchId != nil {
                                map["VSwitchId"] = self.vSwitchId!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Description") {
                                self.description_ = dict["Description"] as! String
                            }
                            if dict.keys.contains("InstanceType") {
                                self.instanceType = dict["InstanceType"] as! String
                            }
                            if dict.keys.contains("NetworkInterfaceName") {
                                self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
                            }
                            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
                            }
                            if dict.keys.contains("PrimaryIpAddress") {
                                self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
                            }
                            if dict.keys.contains("SecurityGroupId") {
                                self.securityGroupId = dict["SecurityGroupId"] as! String
                            }
                            if dict.keys.contains("SecurityGroupIds") {
                                var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface.SecurityGroupIds()
                                model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                                self.securityGroupIds = model
                            }
                            if dict.keys.contains("VSwitchId") {
                                self.vSwitchId = dict["VSwitchId"] as! String
                            }
                        }
                    }
                    public var networkInterface: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.networkInterface != nil {
                            var tmp : [Any] = []
                            for k in self.networkInterface! {
                                tmp.append(k.toMap())
                            }
                            map["NetworkInterface"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NetworkInterface") {
                            var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface] = []
                            for v in dict["NetworkInterface"] as! [Any] {
                                var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces.NetworkInterface()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.networkInterface = tmp
                        }
                    }
                }
                public class SecurityGroupIds : Tea.TeaModel {
                    public var securityGroupId: [String]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.securityGroupId != nil {
                            map["SecurityGroupId"] = self.securityGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("SecurityGroupId") {
                            self.securityGroupId = dict["SecurityGroupId"] as! [String]
                        }
                    }
                }
                public class Tags : Tea.TeaModel {
                    public class InstanceTag : Tea.TeaModel {
                        public var key: String?

                        public var value: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.key != nil {
                                map["Key"] = self.key!
                            }
                            if self.value != nil {
                                map["Value"] = self.value!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Key") {
                                self.key = dict["Key"] as! String
                            }
                            if dict.keys.contains("Value") {
                                self.value = dict["Value"] as! String
                            }
                        }
                    }
                    public var instanceTag: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags.InstanceTag]?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceTag != nil {
                            var tmp : [Any] = []
                            for k in self.instanceTag! {
                                tmp.append(k.toMap())
                            }
                            map["InstanceTag"] = tmp
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceTag") {
                            var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags.InstanceTag] = []
                            for v in dict["InstanceTag"] as! [Any] {
                                var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags.InstanceTag()
                                if v != nil {
                                    model.fromMap(v as! [String: Any])
                                }
                                tmp.append(model)
                            }
                            self.instanceTag = tmp
                        }
                    }
                }
                public var systemDisk: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SystemDisk?

                public var autoReleaseTime: String?

                public var autoRenew: Bool?

                public var autoRenewPeriod: Int32?

                public var creditSpecification: String?

                public var dataDisks: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks?

                public var deletionProtection: Bool?

                public var deploymentSetId: String?

                public var description_: String?

                public var enableVmOsConfig: Bool?

                public var hostName: String?

                public var httpEndpoint: String?

                public var httpPutResponseHopLimit: Int32?

                public var httpTokens: String?

                public var imageId: String?

                public var imageOwnerAlias: String?

                public var instanceChargeType: String?

                public var instanceName: String?

                public var instanceType: String?

                public var internetChargeType: String?

                public var internetMaxBandwidthIn: Int32?

                public var internetMaxBandwidthOut: Int32?

                public var ioOptimized: String?

                public var ipv6AddressCount: Int32?

                public var keyPairName: String?

                public var networkInterfaces: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces?

                public var networkType: String?

                public var passwordInherit: Bool?

                public var period: Int32?

                public var periodUnit: String?

                public var privateIpAddress: String?

                public var ramRoleName: String?

                public var resourceGroupId: String?

                public var securityEnhancementStrategy: String?

                public var securityGroupId: String?

                public var securityGroupIds: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SecurityGroupIds?

                public var spotDuration: Int32?

                public var spotPriceLimit: Double?

                public var spotStrategy: String?

                public var tags: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags?

                public var userData: String?

                public var vSwitchId: String?

                public var vpcId: String?

                public var zoneId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                    try self.systemDisk?.validate()
                    try self.dataDisks?.validate()
                    try self.networkInterfaces?.validate()
                    try self.securityGroupIds?.validate()
                    try self.tags?.validate()
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.systemDisk != nil {
                        map["SystemDisk"] = self.systemDisk?.toMap()
                    }
                    if self.autoReleaseTime != nil {
                        map["AutoReleaseTime"] = self.autoReleaseTime!
                    }
                    if self.autoRenew != nil {
                        map["AutoRenew"] = self.autoRenew!
                    }
                    if self.autoRenewPeriod != nil {
                        map["AutoRenewPeriod"] = self.autoRenewPeriod!
                    }
                    if self.creditSpecification != nil {
                        map["CreditSpecification"] = self.creditSpecification!
                    }
                    if self.dataDisks != nil {
                        map["DataDisks"] = self.dataDisks?.toMap()
                    }
                    if self.deletionProtection != nil {
                        map["DeletionProtection"] = self.deletionProtection!
                    }
                    if self.deploymentSetId != nil {
                        map["DeploymentSetId"] = self.deploymentSetId!
                    }
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.enableVmOsConfig != nil {
                        map["EnableVmOsConfig"] = self.enableVmOsConfig!
                    }
                    if self.hostName != nil {
                        map["HostName"] = self.hostName!
                    }
                    if self.httpEndpoint != nil {
                        map["HttpEndpoint"] = self.httpEndpoint!
                    }
                    if self.httpPutResponseHopLimit != nil {
                        map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
                    }
                    if self.httpTokens != nil {
                        map["HttpTokens"] = self.httpTokens!
                    }
                    if self.imageId != nil {
                        map["ImageId"] = self.imageId!
                    }
                    if self.imageOwnerAlias != nil {
                        map["ImageOwnerAlias"] = self.imageOwnerAlias!
                    }
                    if self.instanceChargeType != nil {
                        map["InstanceChargeType"] = self.instanceChargeType!
                    }
                    if self.instanceName != nil {
                        map["InstanceName"] = self.instanceName!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.internetChargeType != nil {
                        map["InternetChargeType"] = self.internetChargeType!
                    }
                    if self.internetMaxBandwidthIn != nil {
                        map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
                    }
                    if self.internetMaxBandwidthOut != nil {
                        map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
                    }
                    if self.ioOptimized != nil {
                        map["IoOptimized"] = self.ioOptimized!
                    }
                    if self.ipv6AddressCount != nil {
                        map["Ipv6AddressCount"] = self.ipv6AddressCount!
                    }
                    if self.keyPairName != nil {
                        map["KeyPairName"] = self.keyPairName!
                    }
                    if self.networkInterfaces != nil {
                        map["NetworkInterfaces"] = self.networkInterfaces?.toMap()
                    }
                    if self.networkType != nil {
                        map["NetworkType"] = self.networkType!
                    }
                    if self.passwordInherit != nil {
                        map["PasswordInherit"] = self.passwordInherit!
                    }
                    if self.period != nil {
                        map["Period"] = self.period!
                    }
                    if self.periodUnit != nil {
                        map["PeriodUnit"] = self.periodUnit!
                    }
                    if self.privateIpAddress != nil {
                        map["PrivateIpAddress"] = self.privateIpAddress!
                    }
                    if self.ramRoleName != nil {
                        map["RamRoleName"] = self.ramRoleName!
                    }
                    if self.resourceGroupId != nil {
                        map["ResourceGroupId"] = self.resourceGroupId!
                    }
                    if self.securityEnhancementStrategy != nil {
                        map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
                    }
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    if self.securityGroupIds != nil {
                        map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                    }
                    if self.spotDuration != nil {
                        map["SpotDuration"] = self.spotDuration!
                    }
                    if self.spotPriceLimit != nil {
                        map["SpotPriceLimit"] = self.spotPriceLimit!
                    }
                    if self.spotStrategy != nil {
                        map["SpotStrategy"] = self.spotStrategy!
                    }
                    if self.tags != nil {
                        map["Tags"] = self.tags?.toMap()
                    }
                    if self.userData != nil {
                        map["UserData"] = self.userData!
                    }
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    if self.vpcId != nil {
                        map["VpcId"] = self.vpcId!
                    }
                    if self.zoneId != nil {
                        map["ZoneId"] = self.zoneId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SystemDisk") {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SystemDisk()
                        model.fromMap(dict["SystemDisk"] as! [String: Any])
                        self.systemDisk = model
                    }
                    if dict.keys.contains("AutoReleaseTime") {
                        self.autoReleaseTime = dict["AutoReleaseTime"] as! String
                    }
                    if dict.keys.contains("AutoRenew") {
                        self.autoRenew = dict["AutoRenew"] as! Bool
                    }
                    if dict.keys.contains("AutoRenewPeriod") {
                        self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
                    }
                    if dict.keys.contains("CreditSpecification") {
                        self.creditSpecification = dict["CreditSpecification"] as! String
                    }
                    if dict.keys.contains("DataDisks") {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.DataDisks()
                        model.fromMap(dict["DataDisks"] as! [String: Any])
                        self.dataDisks = model
                    }
                    if dict.keys.contains("DeletionProtection") {
                        self.deletionProtection = dict["DeletionProtection"] as! Bool
                    }
                    if dict.keys.contains("DeploymentSetId") {
                        self.deploymentSetId = dict["DeploymentSetId"] as! String
                    }
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("EnableVmOsConfig") {
                        self.enableVmOsConfig = dict["EnableVmOsConfig"] as! Bool
                    }
                    if dict.keys.contains("HostName") {
                        self.hostName = dict["HostName"] as! String
                    }
                    if dict.keys.contains("HttpEndpoint") {
                        self.httpEndpoint = dict["HttpEndpoint"] as! String
                    }
                    if dict.keys.contains("HttpPutResponseHopLimit") {
                        self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
                    }
                    if dict.keys.contains("HttpTokens") {
                        self.httpTokens = dict["HttpTokens"] as! String
                    }
                    if dict.keys.contains("ImageId") {
                        self.imageId = dict["ImageId"] as! String
                    }
                    if dict.keys.contains("ImageOwnerAlias") {
                        self.imageOwnerAlias = dict["ImageOwnerAlias"] as! String
                    }
                    if dict.keys.contains("InstanceChargeType") {
                        self.instanceChargeType = dict["InstanceChargeType"] as! String
                    }
                    if dict.keys.contains("InstanceName") {
                        self.instanceName = dict["InstanceName"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("InternetChargeType") {
                        self.internetChargeType = dict["InternetChargeType"] as! String
                    }
                    if dict.keys.contains("InternetMaxBandwidthIn") {
                        self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
                    }
                    if dict.keys.contains("InternetMaxBandwidthOut") {
                        self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
                    }
                    if dict.keys.contains("IoOptimized") {
                        self.ioOptimized = dict["IoOptimized"] as! String
                    }
                    if dict.keys.contains("Ipv6AddressCount") {
                        self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
                    }
                    if dict.keys.contains("KeyPairName") {
                        self.keyPairName = dict["KeyPairName"] as! String
                    }
                    if dict.keys.contains("NetworkInterfaces") {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.NetworkInterfaces()
                        model.fromMap(dict["NetworkInterfaces"] as! [String: Any])
                        self.networkInterfaces = model
                    }
                    if dict.keys.contains("NetworkType") {
                        self.networkType = dict["NetworkType"] as! String
                    }
                    if dict.keys.contains("PasswordInherit") {
                        self.passwordInherit = dict["PasswordInherit"] as! Bool
                    }
                    if dict.keys.contains("Period") {
                        self.period = dict["Period"] as! Int32
                    }
                    if dict.keys.contains("PeriodUnit") {
                        self.periodUnit = dict["PeriodUnit"] as! String
                    }
                    if dict.keys.contains("PrivateIpAddress") {
                        self.privateIpAddress = dict["PrivateIpAddress"] as! String
                    }
                    if dict.keys.contains("RamRoleName") {
                        self.ramRoleName = dict["RamRoleName"] as! String
                    }
                    if dict.keys.contains("ResourceGroupId") {
                        self.resourceGroupId = dict["ResourceGroupId"] as! String
                    }
                    if dict.keys.contains("SecurityEnhancementStrategy") {
                        self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
                    }
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! String
                    }
                    if dict.keys.contains("SecurityGroupIds") {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.SecurityGroupIds()
                        model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                        self.securityGroupIds = model
                    }
                    if dict.keys.contains("SpotDuration") {
                        self.spotDuration = dict["SpotDuration"] as! Int32
                    }
                    if dict.keys.contains("SpotPriceLimit") {
                        self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
                    }
                    if dict.keys.contains("SpotStrategy") {
                        self.spotStrategy = dict["SpotStrategy"] as! String
                    }
                    if dict.keys.contains("Tags") {
                        var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData.Tags()
                        model.fromMap(dict["Tags"] as! [String: Any])
                        self.tags = model
                    }
                    if dict.keys.contains("UserData") {
                        self.userData = dict["UserData"] as! String
                    }
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! String
                    }
                    if dict.keys.contains("VpcId") {
                        self.vpcId = dict["VpcId"] as! String
                    }
                    if dict.keys.contains("ZoneId") {
                        self.zoneId = dict["ZoneId"] as! String
                    }
                }
            }
            public var createTime: String?

            public var createdBy: String?

            public var defaultVersion: Bool?

            public var launchTemplateData: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData?

            public var launchTemplateId: String?

            public var launchTemplateName: String?

            public var modifiedTime: String?

            public var versionDescription: String?

            public var versionNumber: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.launchTemplateData?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createdBy != nil {
                    map["CreatedBy"] = self.createdBy!
                }
                if self.defaultVersion != nil {
                    map["DefaultVersion"] = self.defaultVersion!
                }
                if self.launchTemplateData != nil {
                    map["LaunchTemplateData"] = self.launchTemplateData?.toMap()
                }
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateName != nil {
                    map["LaunchTemplateName"] = self.launchTemplateName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.versionDescription != nil {
                    map["VersionDescription"] = self.versionDescription!
                }
                if self.versionNumber != nil {
                    map["VersionNumber"] = self.versionNumber!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreatedBy") {
                    self.createdBy = dict["CreatedBy"] as! String
                }
                if dict.keys.contains("DefaultVersion") {
                    self.defaultVersion = dict["DefaultVersion"] as! Bool
                }
                if dict.keys.contains("LaunchTemplateData") {
                    var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet.LaunchTemplateData()
                    model.fromMap(dict["LaunchTemplateData"] as! [String: Any])
                    self.launchTemplateData = model
                }
                if dict.keys.contains("LaunchTemplateId") {
                    self.launchTemplateId = dict["LaunchTemplateId"] as! String
                }
                if dict.keys.contains("LaunchTemplateName") {
                    self.launchTemplateName = dict["LaunchTemplateName"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("VersionDescription") {
                    self.versionDescription = dict["VersionDescription"] as! String
                }
                if dict.keys.contains("VersionNumber") {
                    self.versionNumber = dict["VersionNumber"] as! Int64
                }
            }
        }
        public var launchTemplateVersionSet: [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchTemplateVersionSet != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateVersionSet! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateVersionSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LaunchTemplateVersionSet") {
                var tmp : [DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet] = []
                for v in dict["LaunchTemplateVersionSet"] as! [Any] {
                    var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets.LaunchTemplateVersionSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchTemplateVersionSet = tmp
            }
        }
    }
    public var launchTemplateVersionSets: DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateVersionSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateVersionSets != nil {
            map["LaunchTemplateVersionSets"] = self.launchTemplateVersionSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateVersionSets") {
            var model = DescribeLaunchTemplateVersionsResponseBody.LaunchTemplateVersionSets()
            model.fromMap(dict["LaunchTemplateVersionSets"] as! [String: Any])
            self.launchTemplateVersionSets = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLaunchTemplateVersionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLaunchTemplateVersionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLaunchTemplateVersionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLaunchTemplatesRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var launchTemplateId: [String]?

    public var launchTemplateName: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateResourceGroupId: String?

    public var templateTag: [DescribeLaunchTemplatesRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateResourceGroupId != nil {
            map["TemplateResourceGroupId"] = self.templateResourceGroupId!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! [String]
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateResourceGroupId") {
            self.templateResourceGroupId = dict["TemplateResourceGroupId"] as! String
        }
        if dict.keys.contains("TemplateTag") {
            var tmp : [DescribeLaunchTemplatesRequest.TemplateTag] = []
            for v in dict["TemplateTag"] as! [Any] {
                var model = DescribeLaunchTemplatesRequest.TemplateTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateTag = tmp
        }
    }
}

public class DescribeLaunchTemplatesResponseBody : Tea.TeaModel {
    public class LaunchTemplateSets : Tea.TeaModel {
        public class LaunchTemplateSet : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var createTime: String?

            public var createdBy: String?

            public var defaultVersionNumber: Int64?

            public var latestVersionNumber: Int64?

            public var launchTemplateId: String?

            public var launchTemplateName: String?

            public var modifiedTime: String?

            public var resourceGroupId: String?

            public var tags: DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.createdBy != nil {
                    map["CreatedBy"] = self.createdBy!
                }
                if self.defaultVersionNumber != nil {
                    map["DefaultVersionNumber"] = self.defaultVersionNumber!
                }
                if self.latestVersionNumber != nil {
                    map["LatestVersionNumber"] = self.latestVersionNumber!
                }
                if self.launchTemplateId != nil {
                    map["LaunchTemplateId"] = self.launchTemplateId!
                }
                if self.launchTemplateName != nil {
                    map["LaunchTemplateName"] = self.launchTemplateName!
                }
                if self.modifiedTime != nil {
                    map["ModifiedTime"] = self.modifiedTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("CreatedBy") {
                    self.createdBy = dict["CreatedBy"] as! String
                }
                if dict.keys.contains("DefaultVersionNumber") {
                    self.defaultVersionNumber = dict["DefaultVersionNumber"] as! Int64
                }
                if dict.keys.contains("LatestVersionNumber") {
                    self.latestVersionNumber = dict["LatestVersionNumber"] as! Int64
                }
                if dict.keys.contains("LaunchTemplateId") {
                    self.launchTemplateId = dict["LaunchTemplateId"] as! String
                }
                if dict.keys.contains("LaunchTemplateName") {
                    self.launchTemplateName = dict["LaunchTemplateName"] as! String
                }
                if dict.keys.contains("ModifiedTime") {
                    self.modifiedTime = dict["ModifiedTime"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var launchTemplateSet: [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.launchTemplateSet != nil {
                var tmp : [Any] = []
                for k in self.launchTemplateSet! {
                    tmp.append(k.toMap())
                }
                map["LaunchTemplateSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LaunchTemplateSet") {
                var tmp : [DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet] = []
                for v in dict["LaunchTemplateSet"] as! [Any] {
                    var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets.LaunchTemplateSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.launchTemplateSet = tmp
            }
        }
    }
    public var launchTemplateSets: DescribeLaunchTemplatesResponseBody.LaunchTemplateSets?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.launchTemplateSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateSets != nil {
            map["LaunchTemplateSets"] = self.launchTemplateSets?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateSets") {
            var model = DescribeLaunchTemplatesResponseBody.LaunchTemplateSets()
            model.fromMap(dict["LaunchTemplateSets"] as! [String: Any])
            self.launchTemplateSets = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeLaunchTemplatesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLaunchTemplatesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLaunchTemplatesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeLimitationRequest : Tea.TeaModel {
    public var limitation: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limitation != nil {
            map["Limitation"] = self.limitation!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Limitation") {
            self.limitation = dict["Limitation"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeLimitationResponseBody : Tea.TeaModel {
    public var limitation: String?

    public var requestId: String?

    public var value: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.limitation != nil {
            map["Limitation"] = self.limitation!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.value != nil {
            map["Value"] = self.value!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Limitation") {
            self.limitation = dict["Limitation"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Value") {
            self.value = dict["Value"] as! String
        }
    }
}

public class DescribeLimitationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeLimitationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeLimitationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeManagedInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var activationId: String?

    public var instanceId: [String]?

    public var instanceIp: String?

    public var instanceName: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var osType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeManagedInstancesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceIp != nil {
            map["InstanceIp"] = self.instanceIp!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.osType != nil {
            map["OsType"] = self.osType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivationId") {
            self.activationId = dict["ActivationId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("InstanceIp") {
            self.instanceIp = dict["InstanceIp"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OsType") {
            self.osType = dict["OsType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeManagedInstancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeManagedInstancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeManagedInstancesResponseBody : Tea.TeaModel {
    public class Instances : Tea.TeaModel {
        public class Tags : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var activationId: String?

        public var agentVersion: String?

        public var connected: Bool?

        public var hostname: String?

        public var instanceId: String?

        public var instanceName: String?

        public var internetIp: String?

        public var intranetIp: String?

        public var invocationCount: Int64?

        public var lastInvokedTime: String?

        public var machineId: String?

        public var osType: String?

        public var osVersion: String?

        public var registrationTime: String?

        public var resourceGroupId: String?

        public var tags: [DescribeManagedInstancesResponseBody.Instances.Tags]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.agentVersion != nil {
                map["AgentVersion"] = self.agentVersion!
            }
            if self.connected != nil {
                map["Connected"] = self.connected!
            }
            if self.hostname != nil {
                map["Hostname"] = self.hostname!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.internetIp != nil {
                map["InternetIp"] = self.internetIp!
            }
            if self.intranetIp != nil {
                map["IntranetIp"] = self.intranetIp!
            }
            if self.invocationCount != nil {
                map["InvocationCount"] = self.invocationCount!
            }
            if self.lastInvokedTime != nil {
                map["LastInvokedTime"] = self.lastInvokedTime!
            }
            if self.machineId != nil {
                map["MachineId"] = self.machineId!
            }
            if self.osType != nil {
                map["OsType"] = self.osType!
            }
            if self.osVersion != nil {
                map["OsVersion"] = self.osVersion!
            }
            if self.registrationTime != nil {
                map["RegistrationTime"] = self.registrationTime!
            }
            if self.resourceGroupId != nil {
                map["ResourceGroupId"] = self.resourceGroupId!
            }
            if self.tags != nil {
                var tmp : [Any] = []
                for k in self.tags! {
                    tmp.append(k.toMap())
                }
                map["Tags"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivationId") {
                self.activationId = dict["ActivationId"] as! String
            }
            if dict.keys.contains("AgentVersion") {
                self.agentVersion = dict["AgentVersion"] as! String
            }
            if dict.keys.contains("Connected") {
                self.connected = dict["Connected"] as! Bool
            }
            if dict.keys.contains("Hostname") {
                self.hostname = dict["Hostname"] as! String
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("InternetIp") {
                self.internetIp = dict["InternetIp"] as! String
            }
            if dict.keys.contains("IntranetIp") {
                self.intranetIp = dict["IntranetIp"] as! String
            }
            if dict.keys.contains("InvocationCount") {
                self.invocationCount = dict["InvocationCount"] as! Int64
            }
            if dict.keys.contains("LastInvokedTime") {
                self.lastInvokedTime = dict["LastInvokedTime"] as! String
            }
            if dict.keys.contains("MachineId") {
                self.machineId = dict["MachineId"] as! String
            }
            if dict.keys.contains("OsType") {
                self.osType = dict["OsType"] as! String
            }
            if dict.keys.contains("OsVersion") {
                self.osVersion = dict["OsVersion"] as! String
            }
            if dict.keys.contains("RegistrationTime") {
                self.registrationTime = dict["RegistrationTime"] as! String
            }
            if dict.keys.contains("ResourceGroupId") {
                self.resourceGroupId = dict["ResourceGroupId"] as! String
            }
            if dict.keys.contains("Tags") {
                var tmp : [DescribeManagedInstancesResponseBody.Instances.Tags] = []
                for v in dict["Tags"] as! [Any] {
                    var model = DescribeManagedInstancesResponseBody.Instances.Tags()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tags = tmp
            }
        }
    }
    public var instances: [DescribeManagedInstancesResponseBody.Instances]?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instances != nil {
            var tmp : [Any] = []
            for k in self.instances! {
                tmp.append(k.toMap())
            }
            map["Instances"] = tmp
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instances") {
            var tmp : [DescribeManagedInstancesResponseBody.Instances] = []
            for v in dict["Instances"] as! [Any] {
                var model = DescribeManagedInstancesResponseBody.Instances()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.instances = tmp
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeManagedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeManagedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeManagedInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNatGatewaysRequest : Tea.TeaModel {
    public var natGatewayId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGatewayId != nil {
            map["NatGatewayId"] = self.natGatewayId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGatewayId") {
            self.natGatewayId = dict["NatGatewayId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeNatGatewaysResponseBody : Tea.TeaModel {
    public class NatGateways : Tea.TeaModel {
        public class NatGateway : Tea.TeaModel {
            public class BandwidthPackageIds : Tea.TeaModel {
                public var bandwidthPackageId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bandwidthPackageId != nil {
                        map["BandwidthPackageId"] = self.bandwidthPackageId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BandwidthPackageId") {
                        self.bandwidthPackageId = dict["BandwidthPackageId"] as! [String]
                    }
                }
            }
            public class ForwardTableIds : Tea.TeaModel {
                public var forwardTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.forwardTableId != nil {
                        map["ForwardTableId"] = self.forwardTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ForwardTableId") {
                        self.forwardTableId = dict["ForwardTableId"] as! [String]
                    }
                }
            }
            public var bandwidthPackageIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.BandwidthPackageIds?

            public var businessStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var forwardTableIds: DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds?

            public var instanceChargeType: String?

            public var name: String?

            public var natGatewayId: String?

            public var regionId: String?

            public var spec: String?

            public var status: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.bandwidthPackageIds?.validate()
                try self.forwardTableIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.bandwidthPackageIds != nil {
                    map["BandwidthPackageIds"] = self.bandwidthPackageIds?.toMap()
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.forwardTableIds != nil {
                    map["ForwardTableIds"] = self.forwardTableIds?.toMap()
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.natGatewayId != nil {
                    map["NatGatewayId"] = self.natGatewayId!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("BandwidthPackageIds") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.BandwidthPackageIds()
                    model.fromMap(dict["BandwidthPackageIds"] as! [String: Any])
                    self.bandwidthPackageIds = model
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ForwardTableIds") {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway.ForwardTableIds()
                    model.fromMap(dict["ForwardTableIds"] as! [String: Any])
                    self.forwardTableIds = model
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("NatGatewayId") {
                    self.natGatewayId = dict["NatGatewayId"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var natGateway: [DescribeNatGatewaysResponseBody.NatGateways.NatGateway]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.natGateway != nil {
                var tmp : [Any] = []
                for k in self.natGateway! {
                    tmp.append(k.toMap())
                }
                map["NatGateway"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NatGateway") {
                var tmp : [DescribeNatGatewaysResponseBody.NatGateways.NatGateway] = []
                for v in dict["NatGateway"] as! [Any] {
                    var model = DescribeNatGatewaysResponseBody.NatGateways.NatGateway()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.natGateway = tmp
            }
        }
    }
    public var natGateways: DescribeNatGatewaysResponseBody.NatGateways?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.natGateways?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.natGateways != nil {
            map["NatGateways"] = self.natGateways?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NatGateways") {
            var model = DescribeNatGatewaysResponseBody.NatGateways()
            model.fromMap(dict["NatGateways"] as! [String: Any])
            self.natGateways = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNatGatewaysResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNatGatewaysResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNatGatewaysResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInterfaceAttributeRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var attribute: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeNetworkInterfaceAttributeRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.attribute != nil {
            map["Attribute"] = self.attribute!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Attribute") {
            self.attribute = dict["Attribute"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeNetworkInterfaceAttributeRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeNetworkInterfaceAttributeRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeNetworkInterfaceAttributeResponseBody : Tea.TeaModel {
    public class AssociatedPublicIp : Tea.TeaModel {
        public var allocationId: String?

        public var publicIpAddress: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allocationId != nil {
                map["AllocationId"] = self.allocationId!
            }
            if self.publicIpAddress != nil {
                map["PublicIpAddress"] = self.publicIpAddress!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllocationId") {
                self.allocationId = dict["AllocationId"] as! String
            }
            if dict.keys.contains("PublicIpAddress") {
                self.publicIpAddress = dict["PublicIpAddress"] as! String
            }
        }
    }
    public class Attachment : Tea.TeaModel {
        public class MemberNetworkInterfaceIds : Tea.TeaModel {
            public var memberNetworkInterfaceId: [String]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.memberNetworkInterfaceId != nil {
                    map["MemberNetworkInterfaceId"] = self.memberNetworkInterfaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MemberNetworkInterfaceId") {
                    self.memberNetworkInterfaceId = dict["MemberNetworkInterfaceId"] as! [String]
                }
            }
        }
        public var deviceIndex: Int32?

        public var instanceId: String?

        public var memberNetworkInterfaceIds: DescribeNetworkInterfaceAttributeResponseBody.Attachment.MemberNetworkInterfaceIds?

        public var networkCardIndex: Int32?

        public var trunkNetworkInterfaceId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.memberNetworkInterfaceIds?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deviceIndex != nil {
                map["DeviceIndex"] = self.deviceIndex!
            }
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.memberNetworkInterfaceIds != nil {
                map["MemberNetworkInterfaceIds"] = self.memberNetworkInterfaceIds?.toMap()
            }
            if self.networkCardIndex != nil {
                map["NetworkCardIndex"] = self.networkCardIndex!
            }
            if self.trunkNetworkInterfaceId != nil {
                map["TrunkNetworkInterfaceId"] = self.trunkNetworkInterfaceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeviceIndex") {
                self.deviceIndex = dict["DeviceIndex"] as! Int32
            }
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("MemberNetworkInterfaceIds") {
                var model = DescribeNetworkInterfaceAttributeResponseBody.Attachment.MemberNetworkInterfaceIds()
                model.fromMap(dict["MemberNetworkInterfaceIds"] as! [String: Any])
                self.memberNetworkInterfaceIds = model
            }
            if dict.keys.contains("NetworkCardIndex") {
                self.networkCardIndex = dict["NetworkCardIndex"] as! Int32
            }
            if dict.keys.contains("TrunkNetworkInterfaceId") {
                self.trunkNetworkInterfaceId = dict["TrunkNetworkInterfaceId"] as! String
            }
        }
    }
    public class BondInterfaceSpecification : Tea.TeaModel {
        public class SlaveInterfaceSpecification : Tea.TeaModel {
            public class SlaveInterfaceSpecificationSet : Tea.TeaModel {
                public var bondNetworkInterfaceId: String?

                public var slaveNetworkInterfaceId: String?

                public var workState: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.bondNetworkInterfaceId != nil {
                        map["BondNetworkInterfaceId"] = self.bondNetworkInterfaceId!
                    }
                    if self.slaveNetworkInterfaceId != nil {
                        map["SlaveNetworkInterfaceId"] = self.slaveNetworkInterfaceId!
                    }
                    if self.workState != nil {
                        map["WorkState"] = self.workState!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("BondNetworkInterfaceId") {
                        self.bondNetworkInterfaceId = dict["BondNetworkInterfaceId"] as! String
                    }
                    if dict.keys.contains("SlaveNetworkInterfaceId") {
                        self.slaveNetworkInterfaceId = dict["SlaveNetworkInterfaceId"] as! String
                    }
                    if dict.keys.contains("WorkState") {
                        self.workState = dict["WorkState"] as! String
                    }
                }
            }
            public var slaveInterfaceSpecificationSet: [DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification.SlaveInterfaceSpecificationSet]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.slaveInterfaceSpecificationSet != nil {
                    var tmp : [Any] = []
                    for k in self.slaveInterfaceSpecificationSet! {
                        tmp.append(k.toMap())
                    }
                    map["SlaveInterfaceSpecificationSet"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("SlaveInterfaceSpecificationSet") {
                    var tmp : [DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification.SlaveInterfaceSpecificationSet] = []
                    for v in dict["SlaveInterfaceSpecificationSet"] as! [Any] {
                        var model = DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification.SlaveInterfaceSpecificationSet()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.slaveInterfaceSpecificationSet = tmp
                }
            }
        }
        public var bondMode: String?

        public var slaveInterfaceSpecification: DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.slaveInterfaceSpecification?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bondMode != nil {
                map["BondMode"] = self.bondMode!
            }
            if self.slaveInterfaceSpecification != nil {
                map["SlaveInterfaceSpecification"] = self.slaveInterfaceSpecification?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BondMode") {
                self.bondMode = dict["BondMode"] as! String
            }
            if dict.keys.contains("SlaveInterfaceSpecification") {
                var model = DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification.SlaveInterfaceSpecification()
                model.fromMap(dict["SlaveInterfaceSpecification"] as! [String: Any])
                self.slaveInterfaceSpecification = model
            }
        }
    }
    public class ConnectionTrackingConfiguration : Tea.TeaModel {
        public var tcpClosedAndTimeWaitTimeout: Int32?

        public var tcpEstablishedTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tcpClosedAndTimeWaitTimeout != nil {
                map["TcpClosedAndTimeWaitTimeout"] = self.tcpClosedAndTimeWaitTimeout!
            }
            if self.tcpEstablishedTimeout != nil {
                map["TcpEstablishedTimeout"] = self.tcpEstablishedTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TcpClosedAndTimeWaitTimeout") {
                self.tcpClosedAndTimeWaitTimeout = dict["TcpClosedAndTimeWaitTimeout"] as! Int32
            }
            if dict.keys.contains("TcpEstablishedTimeout") {
                self.tcpEstablishedTimeout = dict["TcpEstablishedTimeout"] as! Int32
            }
            if dict.keys.contains("UdpTimeout") {
                self.udpTimeout = dict["UdpTimeout"] as! Int32
            }
        }
    }
    public class EnhancedNetwork : Tea.TeaModel {
        public var enableSriov: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableSriov != nil {
                map["EnableSriov"] = self.enableSriov!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableSriov") {
                self.enableSriov = dict["EnableSriov"] as! Bool
            }
        }
    }
    public class Ipv4PrefixSets : Tea.TeaModel {
        public class Ipv4PrefixSet : Tea.TeaModel {
            public var ipv4Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv4Prefix != nil {
                    map["Ipv4Prefix"] = self.ipv4Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv4Prefix") {
                    self.ipv4Prefix = dict["Ipv4Prefix"] as! String
                }
            }
        }
        public var ipv4PrefixSet: [DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets.Ipv4PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv4PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv4PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv4PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv4PrefixSet") {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets.Ipv4PrefixSet] = []
                for v in dict["Ipv4PrefixSet"] as! [Any] {
                    var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets.Ipv4PrefixSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv4PrefixSet = tmp
            }
        }
    }
    public class Ipv6PrefixSets : Tea.TeaModel {
        public class Ipv6PrefixSet : Tea.TeaModel {
            public var ipv6Prefix: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Prefix != nil {
                    map["Ipv6Prefix"] = self.ipv6Prefix!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv6Prefix") {
                    self.ipv6Prefix = dict["Ipv6Prefix"] as! String
                }
            }
        }
        public var ipv6PrefixSet: [DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets.Ipv6PrefixSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6PrefixSet != nil {
                var tmp : [Any] = []
                for k in self.ipv6PrefixSet! {
                    tmp.append(k.toMap())
                }
                map["Ipv6PrefixSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6PrefixSet") {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets.Ipv6PrefixSet] = []
                for v in dict["Ipv6PrefixSet"] as! [Any] {
                    var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets.Ipv6PrefixSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6PrefixSet = tmp
            }
        }
    }
    public class Ipv6Sets : Tea.TeaModel {
        public class Ipv6Set : Tea.TeaModel {
            public var ipv6Address: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.ipv6Address != nil {
                    map["Ipv6Address"] = self.ipv6Address!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Ipv6Address") {
                    self.ipv6Address = dict["Ipv6Address"] as! String
                }
            }
        }
        public var ipv6Set: [DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets.Ipv6Set]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.ipv6Set != nil {
                var tmp : [Any] = []
                for k in self.ipv6Set! {
                    tmp.append(k.toMap())
                }
                map["Ipv6Set"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Ipv6Set") {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets.Ipv6Set] = []
                for v in dict["Ipv6Set"] as! [Any] {
                    var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets.Ipv6Set()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.ipv6Set = tmp
            }
        }
    }
    public class NetworkInterfaceTrafficConfig : Tea.TeaModel {
        public var networkInterfaceTrafficMode: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("QueueNumber") {
                self.queueNumber = dict["QueueNumber"] as! Int32
            }
            if dict.keys.contains("QueuePairNumber") {
                self.queuePairNumber = dict["QueuePairNumber"] as! Int32
            }
        }
    }
    public class PrivateIpSets : Tea.TeaModel {
        public class PrivateIpSet : Tea.TeaModel {
            public class AssociatedPublicIp : Tea.TeaModel {
                public var allocationId: String?

                public var publicIpAddress: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationId != nil {
                        map["AllocationId"] = self.allocationId!
                    }
                    if self.publicIpAddress != nil {
                        map["PublicIpAddress"] = self.publicIpAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocationId") {
                        self.allocationId = dict["AllocationId"] as! String
                    }
                    if dict.keys.contains("PublicIpAddress") {
                        self.publicIpAddress = dict["PublicIpAddress"] as! String
                    }
                }
            }
            public var associatedPublicIp: DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet.AssociatedPublicIp?

            public var primary: Bool?

            public var privateIpAddress: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedPublicIp?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedPublicIp != nil {
                    map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                }
                if self.primary != nil {
                    map["Primary"] = self.primary!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociatedPublicIp") {
                    var model = DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet.AssociatedPublicIp()
                    model.fromMap(dict["AssociatedPublicIp"] as! [String: Any])
                    self.associatedPublicIp = model
                }
                if dict.keys.contains("Primary") {
                    self.primary = dict["Primary"] as! Bool
                }
                if dict.keys.contains("PrivateIpAddress") {
                    self.privateIpAddress = dict["PrivateIpAddress"] as! String
                }
            }
        }
        public var privateIpSet: [DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privateIpSet != nil {
                var tmp : [Any] = []
                for k in self.privateIpSet! {
                    tmp.append(k.toMap())
                }
                map["PrivateIpSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivateIpSet") {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet] = []
                for v in dict["PrivateIpSet"] as! [Any] {
                    var model = DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets.PrivateIpSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.privateIpSet = tmp
            }
        }
    }
    public class SecurityGroupIds : Tea.TeaModel {
        public var securityGroupId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! [String]
            }
        }
    }
    public class SlaveInterfaceSpecification : Tea.TeaModel {
        public var bondNetworkInterfaceId: String?

        public var slaveNetworkInterfaceId: String?

        public var workState: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bondNetworkInterfaceId != nil {
                map["BondNetworkInterfaceId"] = self.bondNetworkInterfaceId!
            }
            if self.slaveNetworkInterfaceId != nil {
                map["SlaveNetworkInterfaceId"] = self.slaveNetworkInterfaceId!
            }
            if self.workState != nil {
                map["WorkState"] = self.workState!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BondNetworkInterfaceId") {
                self.bondNetworkInterfaceId = dict["BondNetworkInterfaceId"] as! String
            }
            if dict.keys.contains("SlaveNetworkInterfaceId") {
                self.slaveNetworkInterfaceId = dict["SlaveNetworkInterfaceId"] as! String
            }
            if dict.keys.contains("WorkState") {
                self.workState = dict["WorkState"] as! String
            }
        }
    }
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tag: [DescribeNetworkInterfaceAttributeResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeNetworkInterfaceAttributeResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeNetworkInterfaceAttributeResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var associatedPublicIp: DescribeNetworkInterfaceAttributeResponseBody.AssociatedPublicIp?

    public var attachment: DescribeNetworkInterfaceAttributeResponseBody.Attachment?

    public var bondInterfaceSpecification: DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification?

    public var connectionTrackingConfiguration: DescribeNetworkInterfaceAttributeResponseBody.ConnectionTrackingConfiguration?

    public var creationTime: String?

    public var deleteOnRelease: Bool?

    public var description_: String?

    public var enhancedNetwork: DescribeNetworkInterfaceAttributeResponseBody.EnhancedNetwork?

    public var instanceId: String?

    public var ipv4PrefixSets: DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets?

    public var ipv6PrefixSets: DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets?

    public var ipv6Sets: DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets?

    public var macAddress: String?

    public var networkInterfaceId: String?

    public var networkInterfaceName: String?

    public var networkInterfaceTrafficConfig: DescribeNetworkInterfaceAttributeResponseBody.NetworkInterfaceTrafficConfig?

    public var networkInterfaceTrafficMode: String?

    public var ownerId: String?

    public var privateIpAddress: String?

    public var privateIpSets: DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets?

    public var queueNumber: Int32?

    public var queuePairNumber: Int32?

    public var requestId: String?

    public var resourceGroupId: String?

    public var securityGroupIds: DescribeNetworkInterfaceAttributeResponseBody.SecurityGroupIds?

    public var serviceID: Int64?

    public var serviceManaged: Bool?

    public var slaveInterfaceSpecification: DescribeNetworkInterfaceAttributeResponseBody.SlaveInterfaceSpecification?

    public var sourceDestCheck: Bool?

    public var status: String?

    public var tags: DescribeNetworkInterfaceAttributeResponseBody.Tags?

    public var tcpOptionAddressEnabled: String?

    public var type: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.associatedPublicIp?.validate()
        try self.attachment?.validate()
        try self.bondInterfaceSpecification?.validate()
        try self.connectionTrackingConfiguration?.validate()
        try self.enhancedNetwork?.validate()
        try self.ipv4PrefixSets?.validate()
        try self.ipv6PrefixSets?.validate()
        try self.ipv6Sets?.validate()
        try self.networkInterfaceTrafficConfig?.validate()
        try self.privateIpSets?.validate()
        try self.securityGroupIds?.validate()
        try self.slaveInterfaceSpecification?.validate()
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.associatedPublicIp != nil {
            map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
        }
        if self.attachment != nil {
            map["Attachment"] = self.attachment?.toMap()
        }
        if self.bondInterfaceSpecification != nil {
            map["BondInterfaceSpecification"] = self.bondInterfaceSpecification?.toMap()
        }
        if self.connectionTrackingConfiguration != nil {
            map["ConnectionTrackingConfiguration"] = self.connectionTrackingConfiguration?.toMap()
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.deleteOnRelease != nil {
            map["DeleteOnRelease"] = self.deleteOnRelease!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enhancedNetwork != nil {
            map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ipv4PrefixSets != nil {
            map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
        }
        if self.ipv6PrefixSets != nil {
            map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
        }
        if self.ipv6Sets != nil {
            map["Ipv6Sets"] = self.ipv6Sets?.toMap()
        }
        if self.macAddress != nil {
            map["MacAddress"] = self.macAddress!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.networkInterfaceTrafficConfig != nil {
            map["NetworkInterfaceTrafficConfig"] = self.networkInterfaceTrafficConfig?.toMap()
        }
        if self.networkInterfaceTrafficMode != nil {
            map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.privateIpSets != nil {
            map["PrivateIpSets"] = self.privateIpSets?.toMap()
        }
        if self.queueNumber != nil {
            map["QueueNumber"] = self.queueNumber!
        }
        if self.queuePairNumber != nil {
            map["QueuePairNumber"] = self.queuePairNumber!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
        }
        if self.serviceID != nil {
            map["ServiceID"] = self.serviceID!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.slaveInterfaceSpecification != nil {
            map["SlaveInterfaceSpecification"] = self.slaveInterfaceSpecification?.toMap()
        }
        if self.sourceDestCheck != nil {
            map["SourceDestCheck"] = self.sourceDestCheck!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.tcpOptionAddressEnabled != nil {
            map["TcpOptionAddressEnabled"] = self.tcpOptionAddressEnabled!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AssociatedPublicIp") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.AssociatedPublicIp()
            model.fromMap(dict["AssociatedPublicIp"] as! [String: Any])
            self.associatedPublicIp = model
        }
        if dict.keys.contains("Attachment") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Attachment()
            model.fromMap(dict["Attachment"] as! [String: Any])
            self.attachment = model
        }
        if dict.keys.contains("BondInterfaceSpecification") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.BondInterfaceSpecification()
            model.fromMap(dict["BondInterfaceSpecification"] as! [String: Any])
            self.bondInterfaceSpecification = model
        }
        if dict.keys.contains("ConnectionTrackingConfiguration") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.ConnectionTrackingConfiguration()
            model.fromMap(dict["ConnectionTrackingConfiguration"] as! [String: Any])
            self.connectionTrackingConfiguration = model
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("DeleteOnRelease") {
            self.deleteOnRelease = dict["DeleteOnRelease"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnhancedNetwork") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.EnhancedNetwork()
            model.fromMap(dict["EnhancedNetwork"] as! [String: Any])
            self.enhancedNetwork = model
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ipv4PrefixSets") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv4PrefixSets()
            model.fromMap(dict["Ipv4PrefixSets"] as! [String: Any])
            self.ipv4PrefixSets = model
        }
        if dict.keys.contains("Ipv6PrefixSets") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6PrefixSets()
            model.fromMap(dict["Ipv6PrefixSets"] as! [String: Any])
            self.ipv6PrefixSets = model
        }
        if dict.keys.contains("Ipv6Sets") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Ipv6Sets()
            model.fromMap(dict["Ipv6Sets"] as! [String: Any])
            self.ipv6Sets = model
        }
        if dict.keys.contains("MacAddress") {
            self.macAddress = dict["MacAddress"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceName") {
            self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
        }
        if dict.keys.contains("NetworkInterfaceTrafficConfig") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.NetworkInterfaceTrafficConfig()
            model.fromMap(dict["NetworkInterfaceTrafficConfig"] as! [String: Any])
            self.networkInterfaceTrafficConfig = model
        }
        if dict.keys.contains("NetworkInterfaceTrafficMode") {
            self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("PrivateIpSets") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.PrivateIpSets()
            model.fromMap(dict["PrivateIpSets"] as! [String: Any])
            self.privateIpSets = model
        }
        if dict.keys.contains("QueueNumber") {
            self.queueNumber = dict["QueueNumber"] as! Int32
        }
        if dict.keys.contains("QueuePairNumber") {
            self.queuePairNumber = dict["QueuePairNumber"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.SecurityGroupIds()
            model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
            self.securityGroupIds = model
        }
        if dict.keys.contains("ServiceID") {
            self.serviceID = dict["ServiceID"] as! Int64
        }
        if dict.keys.contains("ServiceManaged") {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("SlaveInterfaceSpecification") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.SlaveInterfaceSpecification()
            model.fromMap(dict["SlaveInterfaceSpecification"] as! [String: Any])
            self.slaveInterfaceSpecification = model
        }
        if dict.keys.contains("SourceDestCheck") {
            self.sourceDestCheck = dict["SourceDestCheck"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = DescribeNetworkInterfaceAttributeResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("TcpOptionAddressEnabled") {
            self.tcpOptionAddressEnabled = dict["TcpOptionAddressEnabled"] as! String
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeNetworkInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkInterfaceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInterfacePermissionsRequest : Tea.TeaModel {
    public var networkInterfaceId: String?

    public var networkInterfacePermissionId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfacePermissionId != nil {
            map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("NetworkInterfacePermissionId") {
            self.networkInterfacePermissionId = dict["NetworkInterfacePermissionId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeNetworkInterfacePermissionsResponseBody : Tea.TeaModel {
    public class NetworkInterfacePermissions : Tea.TeaModel {
        public class NetworkInterfacePermission : Tea.TeaModel {
            public var accountId: Int64?

            public var networkInterfaceId: String?

            public var networkInterfacePermissionId: String?

            public var permission: String?

            public var permissionState: String?

            public var serviceName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accountId != nil {
                    map["AccountId"] = self.accountId!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.networkInterfacePermissionId != nil {
                    map["NetworkInterfacePermissionId"] = self.networkInterfacePermissionId!
                }
                if self.permission != nil {
                    map["Permission"] = self.permission!
                }
                if self.permissionState != nil {
                    map["PermissionState"] = self.permissionState!
                }
                if self.serviceName != nil {
                    map["ServiceName"] = self.serviceName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccountId") {
                    self.accountId = dict["AccountId"] as! Int64
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("NetworkInterfacePermissionId") {
                    self.networkInterfacePermissionId = dict["NetworkInterfacePermissionId"] as! String
                }
                if dict.keys.contains("Permission") {
                    self.permission = dict["Permission"] as! String
                }
                if dict.keys.contains("PermissionState") {
                    self.permissionState = dict["PermissionState"] as! String
                }
                if dict.keys.contains("ServiceName") {
                    self.serviceName = dict["ServiceName"] as! String
                }
            }
        }
        public var networkInterfacePermission: [DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions.NetworkInterfacePermission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfacePermission != nil {
                var tmp : [Any] = []
                for k in self.networkInterfacePermission! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfacePermission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfacePermission") {
                var tmp : [DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions.NetworkInterfacePermission] = []
                for v in dict["NetworkInterfacePermission"] as! [Any] {
                    var model = DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions.NetworkInterfacePermission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.networkInterfacePermission = tmp
            }
        }
    }
    public var networkInterfacePermissions: DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfacePermissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfacePermissions != nil {
            map["NetworkInterfacePermissions"] = self.networkInterfacePermissions?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfacePermissions") {
            var model = DescribeNetworkInterfacePermissionsResponseBody.NetworkInterfacePermissions()
            model.fromMap(dict["NetworkInterfacePermissions"] as! [String: Any])
            self.networkInterfacePermissions = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNetworkInterfacePermissionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfacePermissionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkInterfacePermissionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNetworkInterfacesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var instanceId: String?

    public var ipv6Address: [String]?

    public var maxResults: Int32?

    public var networkInterfaceId: [String]?

    public var networkInterfaceName: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var primaryIpAddress: String?

    public var privateIpAddress: [String]?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var serviceManaged: Bool?

    public var status: String?

    public var tag: [DescribeNetworkInterfacesRequest.Tag]?

    public var type: String?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.primaryIpAddress != nil {
            map["PrimaryIpAddress"] = self.primaryIpAddress!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! [String]
        }
        if dict.keys.contains("NetworkInterfaceName") {
            self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PrimaryIpAddress") {
            self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("ServiceManaged") {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeNetworkInterfacesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeNetworkInterfacesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeNetworkInterfacesResponseBody : Tea.TeaModel {
    public class NetworkInterfaceSets : Tea.TeaModel {
        public class NetworkInterfaceSet : Tea.TeaModel {
            public class AssociatedPublicIp : Tea.TeaModel {
                public var allocationId: String?

                public var publicIpAddress: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.allocationId != nil {
                        map["AllocationId"] = self.allocationId!
                    }
                    if self.publicIpAddress != nil {
                        map["PublicIpAddress"] = self.publicIpAddress!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AllocationId") {
                        self.allocationId = dict["AllocationId"] as! String
                    }
                    if dict.keys.contains("PublicIpAddress") {
                        self.publicIpAddress = dict["PublicIpAddress"] as! String
                    }
                }
            }
            public class Attachment : Tea.TeaModel {
                public var deviceIndex: Int32?

                public var instanceId: String?

                public var networkCardIndex: Int32?

                public var trunkNetworkInterfaceId: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.deviceIndex != nil {
                        map["DeviceIndex"] = self.deviceIndex!
                    }
                    if self.instanceId != nil {
                        map["InstanceId"] = self.instanceId!
                    }
                    if self.networkCardIndex != nil {
                        map["NetworkCardIndex"] = self.networkCardIndex!
                    }
                    if self.trunkNetworkInterfaceId != nil {
                        map["TrunkNetworkInterfaceId"] = self.trunkNetworkInterfaceId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DeviceIndex") {
                        self.deviceIndex = dict["DeviceIndex"] as! Int32
                    }
                    if dict.keys.contains("InstanceId") {
                        self.instanceId = dict["InstanceId"] as! String
                    }
                    if dict.keys.contains("NetworkCardIndex") {
                        self.networkCardIndex = dict["NetworkCardIndex"] as! Int32
                    }
                    if dict.keys.contains("TrunkNetworkInterfaceId") {
                        self.trunkNetworkInterfaceId = dict["TrunkNetworkInterfaceId"] as! String
                    }
                }
            }
            public class Ipv4PrefixSets : Tea.TeaModel {
                public class Ipv4PrefixSet : Tea.TeaModel {
                    public var ipv4Prefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv4Prefix != nil {
                            map["Ipv4Prefix"] = self.ipv4Prefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv4Prefix") {
                            self.ipv4Prefix = dict["Ipv4Prefix"] as! String
                        }
                    }
                }
                public var ipv4PrefixSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets.Ipv4PrefixSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv4PrefixSet != nil {
                        var tmp : [Any] = []
                        for k in self.ipv4PrefixSet! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv4PrefixSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ipv4PrefixSet") {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets.Ipv4PrefixSet] = []
                        for v in dict["Ipv4PrefixSet"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets.Ipv4PrefixSet()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ipv4PrefixSet = tmp
                    }
                }
            }
            public class Ipv6PrefixSets : Tea.TeaModel {
                public class Ipv6PrefixSet : Tea.TeaModel {
                    public var ipv6Prefix: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6Prefix != nil {
                            map["Ipv6Prefix"] = self.ipv6Prefix!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv6Prefix") {
                            self.ipv6Prefix = dict["Ipv6Prefix"] as! String
                        }
                    }
                }
                public var ipv6PrefixSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets.Ipv6PrefixSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6PrefixSet != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6PrefixSet! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6PrefixSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ipv6PrefixSet") {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets.Ipv6PrefixSet] = []
                        for v in dict["Ipv6PrefixSet"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets.Ipv6PrefixSet()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ipv6PrefixSet = tmp
                    }
                }
            }
            public class Ipv6Sets : Tea.TeaModel {
                public class Ipv6Set : Tea.TeaModel {
                    public var ipv6Address: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.ipv6Address != nil {
                            map["Ipv6Address"] = self.ipv6Address!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Ipv6Address") {
                            self.ipv6Address = dict["Ipv6Address"] as! String
                        }
                    }
                }
                public var ipv6Set: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ipv6Set != nil {
                        var tmp : [Any] = []
                        for k in self.ipv6Set! {
                            tmp.append(k.toMap())
                        }
                        map["Ipv6Set"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ipv6Set") {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set] = []
                        for v in dict["Ipv6Set"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets.Ipv6Set()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.ipv6Set = tmp
                    }
                }
            }
            public class PrivateIpSets : Tea.TeaModel {
                public class PrivateIpSet : Tea.TeaModel {
                    public class AssociatedPublicIp : Tea.TeaModel {
                        public var allocationId: String?

                        public var publicIpAddress: String?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.allocationId != nil {
                                map["AllocationId"] = self.allocationId!
                            }
                            if self.publicIpAddress != nil {
                                map["PublicIpAddress"] = self.publicIpAddress!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("AllocationId") {
                                self.allocationId = dict["AllocationId"] as! String
                            }
                            if dict.keys.contains("PublicIpAddress") {
                                self.publicIpAddress = dict["PublicIpAddress"] as! String
                            }
                        }
                    }
                    public var associatedPublicIp: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet.AssociatedPublicIp?

                    public var primary: Bool?

                    public var privateDnsName: String?

                    public var privateIpAddress: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.associatedPublicIp?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.associatedPublicIp != nil {
                            map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                        }
                        if self.primary != nil {
                            map["Primary"] = self.primary!
                        }
                        if self.privateDnsName != nil {
                            map["PrivateDnsName"] = self.privateDnsName!
                        }
                        if self.privateIpAddress != nil {
                            map["PrivateIpAddress"] = self.privateIpAddress!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AssociatedPublicIp") {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet.AssociatedPublicIp()
                            model.fromMap(dict["AssociatedPublicIp"] as! [String: Any])
                            self.associatedPublicIp = model
                        }
                        if dict.keys.contains("Primary") {
                            self.primary = dict["Primary"] as! Bool
                        }
                        if dict.keys.contains("PrivateDnsName") {
                            self.privateDnsName = dict["PrivateDnsName"] as! String
                        }
                        if dict.keys.contains("PrivateIpAddress") {
                            self.privateIpAddress = dict["PrivateIpAddress"] as! String
                        }
                    }
                }
                public var privateIpSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.privateIpSet != nil {
                        var tmp : [Any] = []
                        for k in self.privateIpSet! {
                            tmp.append(k.toMap())
                        }
                        map["PrivateIpSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PrivateIpSet") {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet] = []
                        for v in dict["PrivateIpSet"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets.PrivateIpSet()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.privateIpSet = tmp
                    }
                }
            }
            public class SecurityGroupIds : Tea.TeaModel {
                public var securityGroupId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.securityGroupId != nil {
                        map["SecurityGroupId"] = self.securityGroupId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("SecurityGroupId") {
                        self.securityGroupId = dict["SecurityGroupId"] as! [String]
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var associatedPublicIp: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.AssociatedPublicIp?

            public var attachment: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Attachment?

            public var creationTime: String?

            public var deleteOnRelease: Bool?

            public var description_: String?

            public var instanceId: String?

            public var ipv4PrefixSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets?

            public var ipv6PrefixSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets?

            public var ipv6Sets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets?

            public var macAddress: String?

            public var networkInterfaceId: String?

            public var networkInterfaceName: String?

            public var networkInterfaceTrafficMode: String?

            public var ownerId: String?

            public var privateIpAddress: String?

            public var privateIpSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets?

            public var queueNumber: Int32?

            public var queuePairNumber: Int32?

            public var resourceGroupId: String?

            public var securityGroupIds: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds?

            public var serviceID: Int64?

            public var serviceManaged: Bool?

            public var sourceDestCheck: Bool?

            public var status: String?

            public var tags: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags?

            public var type: String?

            public var vSwitchId: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.associatedPublicIp?.validate()
                try self.attachment?.validate()
                try self.ipv4PrefixSets?.validate()
                try self.ipv6PrefixSets?.validate()
                try self.ipv6Sets?.validate()
                try self.privateIpSets?.validate()
                try self.securityGroupIds?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.associatedPublicIp != nil {
                    map["AssociatedPublicIp"] = self.associatedPublicIp?.toMap()
                }
                if self.attachment != nil {
                    map["Attachment"] = self.attachment?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.deleteOnRelease != nil {
                    map["DeleteOnRelease"] = self.deleteOnRelease!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.ipv4PrefixSets != nil {
                    map["Ipv4PrefixSets"] = self.ipv4PrefixSets?.toMap()
                }
                if self.ipv6PrefixSets != nil {
                    map["Ipv6PrefixSets"] = self.ipv6PrefixSets?.toMap()
                }
                if self.ipv6Sets != nil {
                    map["Ipv6Sets"] = self.ipv6Sets?.toMap()
                }
                if self.macAddress != nil {
                    map["MacAddress"] = self.macAddress!
                }
                if self.networkInterfaceId != nil {
                    map["NetworkInterfaceId"] = self.networkInterfaceId!
                }
                if self.networkInterfaceName != nil {
                    map["NetworkInterfaceName"] = self.networkInterfaceName!
                }
                if self.networkInterfaceTrafficMode != nil {
                    map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
                }
                if self.ownerId != nil {
                    map["OwnerId"] = self.ownerId!
                }
                if self.privateIpAddress != nil {
                    map["PrivateIpAddress"] = self.privateIpAddress!
                }
                if self.privateIpSets != nil {
                    map["PrivateIpSets"] = self.privateIpSets?.toMap()
                }
                if self.queueNumber != nil {
                    map["QueueNumber"] = self.queueNumber!
                }
                if self.queuePairNumber != nil {
                    map["QueuePairNumber"] = self.queuePairNumber!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.securityGroupIds != nil {
                    map["SecurityGroupIds"] = self.securityGroupIds?.toMap()
                }
                if self.serviceID != nil {
                    map["ServiceID"] = self.serviceID!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.sourceDestCheck != nil {
                    map["SourceDestCheck"] = self.sourceDestCheck!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssociatedPublicIp") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.AssociatedPublicIp()
                    model.fromMap(dict["AssociatedPublicIp"] as! [String: Any])
                    self.associatedPublicIp = model
                }
                if dict.keys.contains("Attachment") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Attachment()
                    model.fromMap(dict["Attachment"] as! [String: Any])
                    self.attachment = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DeleteOnRelease") {
                    self.deleteOnRelease = dict["DeleteOnRelease"] as! Bool
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Ipv4PrefixSets") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv4PrefixSets()
                    model.fromMap(dict["Ipv4PrefixSets"] as! [String: Any])
                    self.ipv4PrefixSets = model
                }
                if dict.keys.contains("Ipv6PrefixSets") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6PrefixSets()
                    model.fromMap(dict["Ipv6PrefixSets"] as! [String: Any])
                    self.ipv6PrefixSets = model
                }
                if dict.keys.contains("Ipv6Sets") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Ipv6Sets()
                    model.fromMap(dict["Ipv6Sets"] as! [String: Any])
                    self.ipv6Sets = model
                }
                if dict.keys.contains("MacAddress") {
                    self.macAddress = dict["MacAddress"] as! String
                }
                if dict.keys.contains("NetworkInterfaceId") {
                    self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
                }
                if dict.keys.contains("NetworkInterfaceName") {
                    self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
                }
                if dict.keys.contains("NetworkInterfaceTrafficMode") {
                    self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
                }
                if dict.keys.contains("OwnerId") {
                    self.ownerId = dict["OwnerId"] as! String
                }
                if dict.keys.contains("PrivateIpAddress") {
                    self.privateIpAddress = dict["PrivateIpAddress"] as! String
                }
                if dict.keys.contains("PrivateIpSets") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.PrivateIpSets()
                    model.fromMap(dict["PrivateIpSets"] as! [String: Any])
                    self.privateIpSets = model
                }
                if dict.keys.contains("QueueNumber") {
                    self.queueNumber = dict["QueueNumber"] as! Int32
                }
                if dict.keys.contains("QueuePairNumber") {
                    self.queuePairNumber = dict["QueuePairNumber"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupIds") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.SecurityGroupIds()
                    model.fromMap(dict["SecurityGroupIds"] as! [String: Any])
                    self.securityGroupIds = model
                }
                if dict.keys.contains("ServiceID") {
                    self.serviceID = dict["ServiceID"] as! Int64
                }
                if dict.keys.contains("ServiceManaged") {
                    self.serviceManaged = dict["ServiceManaged"] as! Bool
                }
                if dict.keys.contains("SourceDestCheck") {
                    self.sourceDestCheck = dict["SourceDestCheck"] as! Bool
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var networkInterfaceSet: [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceSet != nil {
                var tmp : [Any] = []
                for k in self.networkInterfaceSet! {
                    tmp.append(k.toMap())
                }
                map["NetworkInterfaceSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceSet") {
                var tmp : [DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet] = []
                for v in dict["NetworkInterfaceSet"] as! [Any] {
                    var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets.NetworkInterfaceSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.networkInterfaceSet = tmp
            }
        }
    }
    public var networkInterfaceSets: DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets?

    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkInterfaceSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkInterfaceSets != nil {
            map["NetworkInterfaceSets"] = self.networkInterfaceSets?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkInterfaceSets") {
            var model = DescribeNetworkInterfacesResponseBody.NetworkInterfaceSets()
            model.fromMap(dict["NetworkInterfaceSets"] as! [String: Any])
            self.networkInterfaceSets = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeNetworkInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNetworkInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNetworkInterfacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeNewProjectEipMonitorDataRequest : Tea.TeaModel {
    public var allocationId: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeNewProjectEipMonitorDataResponseBody : Tea.TeaModel {
    public class EipMonitorDatas : Tea.TeaModel {
        public class EipMonitorData : Tea.TeaModel {
            public var eipBandwidth: Int32?

            public var eipFlow: Int32?

            public var eipPackets: Int32?

            public var eipRX: Int32?

            public var eipTX: Int32?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.eipBandwidth != nil {
                    map["EipBandwidth"] = self.eipBandwidth!
                }
                if self.eipFlow != nil {
                    map["EipFlow"] = self.eipFlow!
                }
                if self.eipPackets != nil {
                    map["EipPackets"] = self.eipPackets!
                }
                if self.eipRX != nil {
                    map["EipRX"] = self.eipRX!
                }
                if self.eipTX != nil {
                    map["EipTX"] = self.eipTX!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("EipBandwidth") {
                    self.eipBandwidth = dict["EipBandwidth"] as! Int32
                }
                if dict.keys.contains("EipFlow") {
                    self.eipFlow = dict["EipFlow"] as! Int32
                }
                if dict.keys.contains("EipPackets") {
                    self.eipPackets = dict["EipPackets"] as! Int32
                }
                if dict.keys.contains("EipRX") {
                    self.eipRX = dict["EipRX"] as! Int32
                }
                if dict.keys.contains("EipTX") {
                    self.eipTX = dict["EipTX"] as! Int32
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var eipMonitorData: [DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.eipMonitorData != nil {
                var tmp : [Any] = []
                for k in self.eipMonitorData! {
                    tmp.append(k.toMap())
                }
                map["EipMonitorData"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EipMonitorData") {
                var tmp : [DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData] = []
                for v in dict["EipMonitorData"] as! [Any] {
                    var model = DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas.EipMonitorData()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.eipMonitorData = tmp
            }
        }
    }
    public var eipMonitorDatas: DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.eipMonitorDatas?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.eipMonitorDatas != nil {
            map["EipMonitorDatas"] = self.eipMonitorDatas?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EipMonitorDatas") {
            var model = DescribeNewProjectEipMonitorDataResponseBody.EipMonitorDatas()
            model.fromMap(dict["EipMonitorDatas"] as! [String: Any])
            self.eipMonitorDatas = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeNewProjectEipMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeNewProjectEipMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeNewProjectEipMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePhysicalConnectionsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var clientToken: String?

    public var filter: [DescribePhysicalConnectionsRequest.Filter]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Filter") {
            var tmp : [DescribePhysicalConnectionsRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribePhysicalConnectionsRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
    }
}

public class DescribePhysicalConnectionsResponseBody : Tea.TeaModel {
    public class PhysicalConnectionSet : Tea.TeaModel {
        public class PhysicalConnectionType : Tea.TeaModel {
            public var accessPointId: String?

            public var adLocation: String?

            public var bandwidth: Int64?

            public var businessStatus: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var description_: String?

            public var enabledTime: String?

            public var lineOperator: String?

            public var name: String?

            public var peerLocation: String?

            public var physicalConnectionId: String?

            public var portNumber: String?

            public var portType: String?

            public var redundantPhysicalConnectionId: String?

            public var spec: String?

            public var status: String?

            public var type: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.adLocation != nil {
                    map["AdLocation"] = self.adLocation!
                }
                if self.bandwidth != nil {
                    map["Bandwidth"] = self.bandwidth!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.enabledTime != nil {
                    map["EnabledTime"] = self.enabledTime!
                }
                if self.lineOperator != nil {
                    map["LineOperator"] = self.lineOperator!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerLocation != nil {
                    map["PeerLocation"] = self.peerLocation!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.portNumber != nil {
                    map["PortNumber"] = self.portNumber!
                }
                if self.portType != nil {
                    map["PortType"] = self.portType!
                }
                if self.redundantPhysicalConnectionId != nil {
                    map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.type != nil {
                    map["Type"] = self.type!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("AdLocation") {
                    self.adLocation = dict["AdLocation"] as! String
                }
                if dict.keys.contains("Bandwidth") {
                    self.bandwidth = dict["Bandwidth"] as! Int64
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("CircuitCode") {
                    self.circuitCode = dict["CircuitCode"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EnabledTime") {
                    self.enabledTime = dict["EnabledTime"] as! String
                }
                if dict.keys.contains("LineOperator") {
                    self.lineOperator = dict["LineOperator"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PeerLocation") {
                    self.peerLocation = dict["PeerLocation"] as! String
                }
                if dict.keys.contains("PhysicalConnectionId") {
                    self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
                }
                if dict.keys.contains("PortNumber") {
                    self.portNumber = dict["PortNumber"] as! String
                }
                if dict.keys.contains("PortType") {
                    self.portType = dict["PortType"] as! String
                }
                if dict.keys.contains("RedundantPhysicalConnectionId") {
                    self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Type") {
                    self.type = dict["Type"] as! String
                }
            }
        }
        public var physicalConnectionType: [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.physicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.physicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["PhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PhysicalConnectionType") {
                var tmp : [DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType] = []
                for v in dict["PhysicalConnectionType"] as! [Any] {
                    var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet.PhysicalConnectionType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.physicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionSet: DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.physicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionSet != nil {
            map["PhysicalConnectionSet"] = self.physicalConnectionSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PhysicalConnectionSet") {
            var model = DescribePhysicalConnectionsResponseBody.PhysicalConnectionSet()
            model.fromMap(dict["PhysicalConnectionSet"] as! [String: Any])
            self.physicalConnectionSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribePhysicalConnectionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePhysicalConnectionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePhysicalConnectionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrefixListAssociationsRequest : Tea.TeaModel {
    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribePrefixListAssociationsResponseBody : Tea.TeaModel {
    public class PrefixListAssociations : Tea.TeaModel {
        public class PrefixListAssociation : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
            }
        }
        public var prefixListAssociation: [DescribePrefixListAssociationsResponseBody.PrefixListAssociations.PrefixListAssociation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.prefixListAssociation != nil {
                var tmp : [Any] = []
                for k in self.prefixListAssociation! {
                    tmp.append(k.toMap())
                }
                map["PrefixListAssociation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrefixListAssociation") {
                var tmp : [DescribePrefixListAssociationsResponseBody.PrefixListAssociations.PrefixListAssociation] = []
                for v in dict["PrefixListAssociation"] as! [Any] {
                    var model = DescribePrefixListAssociationsResponseBody.PrefixListAssociations.PrefixListAssociation()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.prefixListAssociation = tmp
            }
        }
    }
    public var nextToken: String?

    public var prefixListAssociations: DescribePrefixListAssociationsResponseBody.PrefixListAssociations?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prefixListAssociations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixListAssociations != nil {
            map["PrefixListAssociations"] = self.prefixListAssociations?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PrefixListAssociations") {
            var model = DescribePrefixListAssociationsResponseBody.PrefixListAssociations()
            model.fromMap(dict["PrefixListAssociations"] as! [String: Any])
            self.prefixListAssociations = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePrefixListAssociationsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrefixListAssociationsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrefixListAssociationsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrefixListAttributesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribePrefixListAttributesResponseBody : Tea.TeaModel {
    public class Entries : Tea.TeaModel {
        public class Entry : Tea.TeaModel {
            public var cidr: String?

            public var description_: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidr != nil {
                    map["Cidr"] = self.cidr!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Cidr") {
                    self.cidr = dict["Cidr"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
            }
        }
        public var entry: [DescribePrefixListAttributesResponseBody.Entries.Entry]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.entry != nil {
                var tmp : [Any] = []
                for k in self.entry! {
                    tmp.append(k.toMap())
                }
                map["Entry"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Entry") {
                var tmp : [DescribePrefixListAttributesResponseBody.Entries.Entry] = []
                for v in dict["Entry"] as! [Any] {
                    var model = DescribePrefixListAttributesResponseBody.Entries.Entry()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.entry = tmp
            }
        }
    }
    public var addressFamily: String?

    public var creationTime: String?

    public var description_: String?

    public var entries: DescribePrefixListAttributesResponseBody.Entries?

    public var maxEntries: Int32?

    public var prefixListId: String?

    public var prefixListName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.entries?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressFamily != nil {
            map["AddressFamily"] = self.addressFamily!
        }
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.entries != nil {
            map["Entries"] = self.entries?.toMap()
        }
        if self.maxEntries != nil {
            map["MaxEntries"] = self.maxEntries!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressFamily") {
            self.addressFamily = dict["AddressFamily"] as! String
        }
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Entries") {
            var model = DescribePrefixListAttributesResponseBody.Entries()
            model.fromMap(dict["Entries"] as! [String: Any])
            self.entries = model
        }
        if dict.keys.contains("MaxEntries") {
            self.maxEntries = dict["MaxEntries"] as! Int32
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("PrefixListName") {
            self.prefixListName = dict["PrefixListName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePrefixListAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrefixListAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrefixListAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePrefixListsRequest : Tea.TeaModel {
    public var addressFamily: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: [String]?

    public var prefixListName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addressFamily != nil {
            map["AddressFamily"] = self.addressFamily!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddressFamily") {
            self.addressFamily = dict["AddressFamily"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! [String]
        }
        if dict.keys.contains("PrefixListName") {
            self.prefixListName = dict["PrefixListName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribePrefixListsResponseBody : Tea.TeaModel {
    public class PrefixLists : Tea.TeaModel {
        public class PrefixList : Tea.TeaModel {
            public var addressFamily: String?

            public var associationCount: Int32?

            public var creationTime: String?

            public var description_: String?

            public var maxEntries: Int32?

            public var prefixListId: String?

            public var prefixListName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.addressFamily != nil {
                    map["AddressFamily"] = self.addressFamily!
                }
                if self.associationCount != nil {
                    map["AssociationCount"] = self.associationCount!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.maxEntries != nil {
                    map["MaxEntries"] = self.maxEntries!
                }
                if self.prefixListId != nil {
                    map["PrefixListId"] = self.prefixListId!
                }
                if self.prefixListName != nil {
                    map["PrefixListName"] = self.prefixListName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AddressFamily") {
                    self.addressFamily = dict["AddressFamily"] as! String
                }
                if dict.keys.contains("AssociationCount") {
                    self.associationCount = dict["AssociationCount"] as! Int32
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("MaxEntries") {
                    self.maxEntries = dict["MaxEntries"] as! Int32
                }
                if dict.keys.contains("PrefixListId") {
                    self.prefixListId = dict["PrefixListId"] as! String
                }
                if dict.keys.contains("PrefixListName") {
                    self.prefixListName = dict["PrefixListName"] as! String
                }
            }
        }
        public var prefixList: [DescribePrefixListsResponseBody.PrefixLists.PrefixList]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.prefixList != nil {
                var tmp : [Any] = []
                for k in self.prefixList! {
                    tmp.append(k.toMap())
                }
                map["PrefixList"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrefixList") {
                var tmp : [DescribePrefixListsResponseBody.PrefixLists.PrefixList] = []
                for v in dict["PrefixList"] as! [Any] {
                    var model = DescribePrefixListsResponseBody.PrefixLists.PrefixList()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.prefixList = tmp
            }
        }
    }
    public var nextToken: String?

    public var prefixLists: DescribePrefixListsResponseBody.PrefixLists?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.prefixLists?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.prefixLists != nil {
            map["PrefixLists"] = self.prefixLists?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PrefixLists") {
            var model = DescribePrefixListsResponseBody.PrefixLists()
            model.fromMap(dict["PrefixLists"] as! [String: Any])
            self.prefixLists = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePrefixListsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePrefixListsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePrefixListsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribePriceRequest : Tea.TeaModel {
    public class DataDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int64
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var dedicatedHostId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostId != nil {
                map["DedicatedHostId"] = self.dedicatedHostId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostId") {
                self.dedicatedHostId = dict["DedicatedHostId"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public var performanceLevel: String?

        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public var dataDisk: [DescribePriceRequest.DataDisk]?

    public var schedulerOptions: DescribePriceRequest.SchedulerOptions?

    public var systemDisk: DescribePriceRequest.SystemDisk?

    public var amount: Int32?

    public var assuranceTimes: String?

    public var capacity: Int32?

    public var dedicatedHostType: String?

    public var imageId: String?

    public var instanceAmount: Int32?

    public var instanceCpuCoreCount: Int32?

    public var instanceNetworkType: String?

    public var instanceType: String?

    public var instanceTypeList: [String]?

    public var internetChargeType: String?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var isp: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var platform: String?

    public var priceUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var scope: String?

    public var spotDuration: Int32?

    public var spotStrategy: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.schedulerOptions?.validate()
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.assuranceTimes != nil {
            map["AssuranceTimes"] = self.assuranceTimes!
        }
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.dedicatedHostType != nil {
            map["DedicatedHostType"] = self.dedicatedHostType!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceCpuCoreCount != nil {
            map["InstanceCpuCoreCount"] = self.instanceCpuCoreCount!
        }
        if self.instanceNetworkType != nil {
            map["InstanceNetworkType"] = self.instanceNetworkType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeList != nil {
            map["InstanceTypeList"] = self.instanceTypeList!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.priceUnit != nil {
            map["PriceUnit"] = self.priceUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDisk") {
            var tmp : [DescribePriceRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = DescribePriceRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("SchedulerOptions") {
            var model = DescribePriceRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = DescribePriceRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("AssuranceTimes") {
            self.assuranceTimes = dict["AssuranceTimes"] as! String
        }
        if dict.keys.contains("Capacity") {
            self.capacity = dict["Capacity"] as! Int32
        }
        if dict.keys.contains("DedicatedHostType") {
            self.dedicatedHostType = dict["DedicatedHostType"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceCpuCoreCount") {
            self.instanceCpuCoreCount = dict["InstanceCpuCoreCount"] as! Int32
        }
        if dict.keys.contains("InstanceNetworkType") {
            self.instanceNetworkType = dict["InstanceNetworkType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeList") {
            self.instanceTypeList = dict["InstanceTypeList"] as! [String]
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("PriceUnit") {
            self.priceUnit = dict["PriceUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribePriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class DetailInfos : Tea.TeaModel {
                public class DetailInfo : Tea.TeaModel {
                    public class SubRules : Tea.TeaModel {
                        public class Rule : Tea.TeaModel {
                            public var description_: String?

                            public var ruleId: Int64?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.description_ != nil {
                                    map["Description"] = self.description_!
                                }
                                if self.ruleId != nil {
                                    map["RuleId"] = self.ruleId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Description") {
                                    self.description_ = dict["Description"] as! String
                                }
                                if dict.keys.contains("RuleId") {
                                    self.ruleId = dict["RuleId"] as! Int64
                                }
                            }
                        }
                        public var rule: [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.rule != nil {
                                var tmp : [Any] = []
                                for k in self.rule! {
                                    tmp.append(k.toMap())
                                }
                                map["Rule"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Rule") {
                                var tmp : [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule] = []
                                for v in dict["Rule"] as! [Any] {
                                    var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules.Rule()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.rule = tmp
                            }
                        }
                    }
                    public var discountPrice: Double?

                    public var originalPrice: Double?

                    public var resource: String?

                    public var subRules: DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules?

                    public var tradePrice: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.subRules?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.originalPrice != nil {
                            map["OriginalPrice"] = self.originalPrice!
                        }
                        if self.resource != nil {
                            map["Resource"] = self.resource!
                        }
                        if self.subRules != nil {
                            map["SubRules"] = self.subRules?.toMap()
                        }
                        if self.tradePrice != nil {
                            map["TradePrice"] = self.tradePrice!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DiscountPrice") {
                            self.discountPrice = dict["DiscountPrice"] as! Double
                        }
                        if dict.keys.contains("OriginalPrice") {
                            self.originalPrice = dict["OriginalPrice"] as! Double
                        }
                        if dict.keys.contains("Resource") {
                            self.resource = dict["Resource"] as! String
                        }
                        if dict.keys.contains("SubRules") {
                            var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo.SubRules()
                            model.fromMap(dict["SubRules"] as! [String: Any])
                            self.subRules = model
                        }
                        if dict.keys.contains("TradePrice") {
                            self.tradePrice = dict["TradePrice"] as! Double
                        }
                    }
                }
                public var detailInfo: [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.detailInfo != nil {
                        var tmp : [Any] = []
                        for k in self.detailInfo! {
                            tmp.append(k.toMap())
                        }
                        map["DetailInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DetailInfo") {
                        var tmp : [DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo] = []
                        for v in dict["DetailInfo"] as! [Any] {
                            var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos.DetailInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.detailInfo = tmp
                    }
                }
            }
            public var currency: String?

            public var detailInfos: DescribePriceResponseBody.PriceInfo.Price.DetailInfos?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var reservedInstanceHourPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detailInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.detailInfos != nil {
                    map["DetailInfos"] = self.detailInfos?.toMap()
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.reservedInstanceHourPrice != nil {
                    map["ReservedInstanceHourPrice"] = self.reservedInstanceHourPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DetailInfos") {
                    var model = DescribePriceResponseBody.PriceInfo.Price.DetailInfos()
                    model.fromMap(dict["DetailInfos"] as! [String: Any])
                    self.detailInfos = model
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("ReservedInstanceHourPrice") {
                    self.reservedInstanceHourPrice = dict["ReservedInstanceHourPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class RelatedPrice : Tea.TeaModel {
            public class MarketplaceImagePrice : Tea.TeaModel {
                public var currency: String?

                public var discountPrice: Double?

                public var originalPrice: Double?

                public var tradePrice: Double?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.currency != nil {
                        map["Currency"] = self.currency!
                    }
                    if self.discountPrice != nil {
                        map["DiscountPrice"] = self.discountPrice!
                    }
                    if self.originalPrice != nil {
                        map["OriginalPrice"] = self.originalPrice!
                    }
                    if self.tradePrice != nil {
                        map["TradePrice"] = self.tradePrice!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Currency") {
                        self.currency = dict["Currency"] as! String
                    }
                    if dict.keys.contains("DiscountPrice") {
                        self.discountPrice = dict["DiscountPrice"] as! Double
                    }
                    if dict.keys.contains("OriginalPrice") {
                        self.originalPrice = dict["OriginalPrice"] as! Double
                    }
                    if dict.keys.contains("TradePrice") {
                        self.tradePrice = dict["TradePrice"] as! Double
                    }
                }
            }
            public var marketplaceImagePrice: DescribePriceResponseBody.PriceInfo.RelatedPrice.MarketplaceImagePrice?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.marketplaceImagePrice?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.marketplaceImagePrice != nil {
                    map["MarketplaceImagePrice"] = self.marketplaceImagePrice?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("MarketplaceImagePrice") {
                    var model = DescribePriceResponseBody.PriceInfo.RelatedPrice.MarketplaceImagePrice()
                    model.fromMap(dict["MarketplaceImagePrice"] as! [String: Any])
                    self.marketplaceImagePrice = model
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var description_: String?

                public var ruleId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int64
                    }
                }
            }
            public var rule: [DescribePriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Rule") {
                    var tmp : [DescribePriceResponseBody.PriceInfo.Rules.Rule] = []
                    for v in dict["Rule"] as! [Any] {
                        var model = DescribePriceResponseBody.PriceInfo.Rules.Rule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rule = tmp
                }
            }
        }
        public var price: DescribePriceResponseBody.PriceInfo.Price?

        public var relatedPrice: DescribePriceResponseBody.PriceInfo.RelatedPrice?

        public var rules: DescribePriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
            try self.relatedPrice?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.relatedPrice != nil {
                map["RelatedPrice"] = self.relatedPrice?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribePriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("RelatedPrice") {
                var model = DescribePriceResponseBody.PriceInfo.RelatedPrice()
                model.fromMap(dict["RelatedPrice"] as! [String: Any])
                self.relatedPrice = model
            }
            if dict.keys.contains("Rules") {
                var model = DescribePriceResponseBody.PriceInfo.Rules()
                model.fromMap(dict["Rules"] as! [String: Any])
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribePriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribePriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribePriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribePriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribePriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRecommendInstanceTypeRequest : Tea.TeaModel {
    public var cores: Int32?

    public var instanceChargeType: String?

    public var instanceFamilyLevel: String?

    public var instanceType: String?

    public var instanceTypeFamily: [String]?

    public var ioOptimized: String?

    public var maxPrice: Double?

    public var memory: Double?

    public var networkType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var priorityStrategy: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scene: String?

    public var spotStrategy: String?

    public var systemDiskCategory: String?

    public var zoneId: String?

    public var zoneMatchMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.maxPrice != nil {
            map["MaxPrice"] = self.maxPrice!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.priorityStrategy != nil {
            map["PriorityStrategy"] = self.priorityStrategy!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scene != nil {
            map["Scene"] = self.scene!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.systemDiskCategory != nil {
            map["SystemDiskCategory"] = self.systemDiskCategory!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        if self.zoneMatchMode != nil {
            map["ZoneMatchMode"] = self.zoneMatchMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! [String]
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("MaxPrice") {
            self.maxPrice = dict["MaxPrice"] as! Double
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PriorityStrategy") {
            self.priorityStrategy = dict["PriorityStrategy"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scene") {
            self.scene = dict["Scene"] as! String
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("SystemDiskCategory") {
            self.systemDiskCategory = dict["SystemDiskCategory"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
        if dict.keys.contains("ZoneMatchMode") {
            self.zoneMatchMode = dict["ZoneMatchMode"] as! String
        }
    }
}

public class DescribeRecommendInstanceTypeResponseBody : Tea.TeaModel {
    public class Data : Tea.TeaModel {
        public class RecommendInstanceType : Tea.TeaModel {
            public class InstanceType : Tea.TeaModel {
                public var cores: Int32?

                public var generation: String?

                public var instanceType: String?

                public var instanceTypeFamily: String?

                public var memory: Int32?

                public var supportIoOptimized: String?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.cores != nil {
                        map["Cores"] = self.cores!
                    }
                    if self.generation != nil {
                        map["Generation"] = self.generation!
                    }
                    if self.instanceType != nil {
                        map["InstanceType"] = self.instanceType!
                    }
                    if self.instanceTypeFamily != nil {
                        map["InstanceTypeFamily"] = self.instanceTypeFamily!
                    }
                    if self.memory != nil {
                        map["Memory"] = self.memory!
                    }
                    if self.supportIoOptimized != nil {
                        map["SupportIoOptimized"] = self.supportIoOptimized!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Cores") {
                        self.cores = dict["Cores"] as! Int32
                    }
                    if dict.keys.contains("Generation") {
                        self.generation = dict["Generation"] as! String
                    }
                    if dict.keys.contains("InstanceType") {
                        self.instanceType = dict["InstanceType"] as! String
                    }
                    if dict.keys.contains("InstanceTypeFamily") {
                        self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
                    }
                    if dict.keys.contains("Memory") {
                        self.memory = dict["Memory"] as! Int32
                    }
                    if dict.keys.contains("SupportIoOptimized") {
                        self.supportIoOptimized = dict["SupportIoOptimized"] as! String
                    }
                }
            }
            public class Zones : Tea.TeaModel {
                public class Zone : Tea.TeaModel {
                    public class NetworkTypes : Tea.TeaModel {
                        public var networkType: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.networkType != nil {
                                map["NetworkType"] = self.networkType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("NetworkType") {
                                self.networkType = dict["NetworkType"] as! [String]
                            }
                        }
                    }
                    public var networkTypes: DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone.NetworkTypes?

                    public var zoneNo: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.networkTypes?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.networkTypes != nil {
                            map["NetworkTypes"] = self.networkTypes?.toMap()
                        }
                        if self.zoneNo != nil {
                            map["ZoneNo"] = self.zoneNo!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("NetworkTypes") {
                            var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone.NetworkTypes()
                            model.fromMap(dict["NetworkTypes"] as! [String: Any])
                            self.networkTypes = model
                        }
                        if dict.keys.contains("ZoneNo") {
                            self.zoneNo = dict["ZoneNo"] as! String
                        }
                    }
                }
                public var zone: [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.zone != nil {
                        var tmp : [Any] = []
                        for k in self.zone! {
                            tmp.append(k.toMap())
                        }
                        map["zone"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("zone") {
                        var tmp : [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone] = []
                        for v in dict["zone"] as! [Any] {
                            var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones.Zone()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.zone = tmp
                    }
                }
            }
            public var commodityCode: String?

            public var instanceChargeType: String?

            public var instanceType: DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.InstanceType?

            public var networkType: String?

            public var priority: Int32?

            public var regionId: String?

            public var scene: String?

            public var spotStrategy: String?

            public var zoneId: String?

            public var zones: DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceType?.validate()
                try self.zones?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.commodityCode != nil {
                    map["CommodityCode"] = self.commodityCode!
                }
                if self.instanceChargeType != nil {
                    map["InstanceChargeType"] = self.instanceChargeType!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType?.toMap()
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.scene != nil {
                    map["Scene"] = self.scene!
                }
                if self.spotStrategy != nil {
                    map["SpotStrategy"] = self.spotStrategy!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zones != nil {
                    map["Zones"] = self.zones?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CommodityCode") {
                    self.commodityCode = dict["CommodityCode"] as! String
                }
                if dict.keys.contains("InstanceChargeType") {
                    self.instanceChargeType = dict["InstanceChargeType"] as! String
                }
                if dict.keys.contains("InstanceType") {
                    var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.InstanceType()
                    model.fromMap(dict["InstanceType"] as! [String: Any])
                    self.instanceType = model
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! Int32
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Scene") {
                    self.scene = dict["Scene"] as! String
                }
                if dict.keys.contains("SpotStrategy") {
                    self.spotStrategy = dict["SpotStrategy"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
                if dict.keys.contains("Zones") {
                    var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType.Zones()
                    model.fromMap(dict["Zones"] as! [String: Any])
                    self.zones = model
                }
            }
        }
        public var recommendInstanceType: [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.recommendInstanceType != nil {
                var tmp : [Any] = []
                for k in self.recommendInstanceType! {
                    tmp.append(k.toMap())
                }
                map["RecommendInstanceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RecommendInstanceType") {
                var tmp : [DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType] = []
                for v in dict["RecommendInstanceType"] as! [Any] {
                    var model = DescribeRecommendInstanceTypeResponseBody.Data.RecommendInstanceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.recommendInstanceType = tmp
            }
        }
    }
    public var data: DescribeRecommendInstanceTypeResponseBody.Data?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.data?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.data != nil {
            map["Data"] = self.data?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Data") {
            var model = DescribeRecommendInstanceTypeResponseBody.Data()
            model.fromMap(dict["Data"] as! [String: Any])
            self.data = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRecommendInstanceTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRecommendInstanceTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRecommendInstanceTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRegionsRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeRegionsResponseBody : Tea.TeaModel {
    public class Regions : Tea.TeaModel {
        public class Region : Tea.TeaModel {
            public var localName: String?

            public var regionEndpoint: String?

            public var regionId: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.regionEndpoint != nil {
                    map["RegionEndpoint"] = self.regionEndpoint!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("LocalName") {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("RegionEndpoint") {
                    self.regionEndpoint = dict["RegionEndpoint"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var region: [DescribeRegionsResponseBody.Regions.Region]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.region != nil {
                var tmp : [Any] = []
                for k in self.region! {
                    tmp.append(k.toMap())
                }
                map["Region"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Region") {
                var tmp : [DescribeRegionsResponseBody.Regions.Region] = []
                for v in dict["Region"] as! [Any] {
                    var model = DescribeRegionsResponseBody.Regions.Region()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.region = tmp
            }
        }
    }
    public var regions: DescribeRegionsResponseBody.Regions?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.regions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regions != nil {
            map["Regions"] = self.regions?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Regions") {
            var model = DescribeRegionsResponseBody.Regions()
            model.fromMap(dict["Regions"] as! [String: Any])
            self.regions = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRegionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRegionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRegionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRenewalPriceRequest : Tea.TeaModel {
    public var expectedRenewDay: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var priceUnit: String?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.expectedRenewDay != nil {
            map["ExpectedRenewDay"] = self.expectedRenewDay!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.priceUnit != nil {
            map["PriceUnit"] = self.priceUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExpectedRenewDay") {
            self.expectedRenewDay = dict["ExpectedRenewDay"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PriceUnit") {
            self.priceUnit = dict["PriceUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class DescribeRenewalPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public class DetailInfos : Tea.TeaModel {
                public class ResourcePriceModel : Tea.TeaModel {
                    public class SubRules : Tea.TeaModel {
                        public class Rule : Tea.TeaModel {
                            public var description_: String?

                            public var ruleId: Int64?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.description_ != nil {
                                    map["Description"] = self.description_!
                                }
                                if self.ruleId != nil {
                                    map["RuleId"] = self.ruleId!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Description") {
                                    self.description_ = dict["Description"] as! String
                                }
                                if dict.keys.contains("RuleId") {
                                    self.ruleId = dict["RuleId"] as! Int64
                                }
                            }
                        }
                        public var rule: [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel.SubRules.Rule]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.rule != nil {
                                var tmp : [Any] = []
                                for k in self.rule! {
                                    tmp.append(k.toMap())
                                }
                                map["Rule"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Rule") {
                                var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel.SubRules.Rule] = []
                                for v in dict["Rule"] as! [Any] {
                                    var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel.SubRules.Rule()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.rule = tmp
                            }
                        }
                    }
                    public var discountPrice: Double?

                    public var originalPrice: Double?

                    public var resource: String?

                    public var subRules: DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel.SubRules?

                    public var tradePrice: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.subRules?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.discountPrice != nil {
                            map["DiscountPrice"] = self.discountPrice!
                        }
                        if self.originalPrice != nil {
                            map["OriginalPrice"] = self.originalPrice!
                        }
                        if self.resource != nil {
                            map["Resource"] = self.resource!
                        }
                        if self.subRules != nil {
                            map["SubRules"] = self.subRules?.toMap()
                        }
                        if self.tradePrice != nil {
                            map["TradePrice"] = self.tradePrice!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DiscountPrice") {
                            self.discountPrice = dict["DiscountPrice"] as! Double
                        }
                        if dict.keys.contains("OriginalPrice") {
                            self.originalPrice = dict["OriginalPrice"] as! Double
                        }
                        if dict.keys.contains("Resource") {
                            self.resource = dict["Resource"] as! String
                        }
                        if dict.keys.contains("SubRules") {
                            var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel.SubRules()
                            model.fromMap(dict["SubRules"] as! [String: Any])
                            self.subRules = model
                        }
                        if dict.keys.contains("TradePrice") {
                            self.tradePrice = dict["TradePrice"] as! Double
                        }
                    }
                }
                public var resourcePriceModel: [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourcePriceModel != nil {
                        var tmp : [Any] = []
                        for k in self.resourcePriceModel! {
                            tmp.append(k.toMap())
                        }
                        map["ResourcePriceModel"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourcePriceModel") {
                        var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel] = []
                        for v in dict["ResourcePriceModel"] as! [Any] {
                            var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos.ResourcePriceModel()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resourcePriceModel = tmp
                    }
                }
            }
            public var currency: String?

            public var detailInfos: DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.detailInfos?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.detailInfos != nil {
                    map["DetailInfos"] = self.detailInfos?.toMap()
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DetailInfos") {
                    var model = DescribeRenewalPriceResponseBody.PriceInfo.Price.DetailInfos()
                    model.fromMap(dict["DetailInfos"] as! [String: Any])
                    self.detailInfos = model
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public class Rule : Tea.TeaModel {
                public var description_: String?

                public var ruleId: Int64?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.description_ != nil {
                        map["Description"] = self.description_!
                    }
                    if self.ruleId != nil {
                        map["RuleId"] = self.ruleId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Description") {
                        self.description_ = dict["Description"] as! String
                    }
                    if dict.keys.contains("RuleId") {
                        self.ruleId = dict["RuleId"] as! Int64
                    }
                }
            }
            public var rule: [DescribeRenewalPriceResponseBody.PriceInfo.Rules.Rule]?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.rule != nil {
                    var tmp : [Any] = []
                    for k in self.rule! {
                        tmp.append(k.toMap())
                    }
                    map["Rule"] = tmp
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Rule") {
                    var tmp : [DescribeRenewalPriceResponseBody.PriceInfo.Rules.Rule] = []
                    for v in dict["Rule"] as! [Any] {
                        var model = DescribeRenewalPriceResponseBody.PriceInfo.Rules.Rule()
                        if v != nil {
                            model.fromMap(v as! [String: Any])
                        }
                        tmp.append(model)
                    }
                    self.rule = tmp
                }
            }
        }
        public var price: DescribeRenewalPriceResponseBody.PriceInfo.Price?

        public var rules: DescribeRenewalPriceResponseBody.PriceInfo.Rules?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
            try self.rules?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                map["Rules"] = self.rules?.toMap()
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("Rules") {
                var model = DescribeRenewalPriceResponseBody.PriceInfo.Rules()
                model.fromMap(dict["Rules"] as! [String: Any])
                self.rules = model
            }
        }
    }
    public var priceInfo: DescribeRenewalPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeRenewalPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeRenewalPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRenewalPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRenewalPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeReservedInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public class ReservedInstanceRenewAttributes : Tea.TeaModel {
        public class ReservedInstanceRenewAttribute : Tea.TeaModel {
            public var duration: Int32?

            public var periodUnit: String?

            public var renewalStatus: String?

            public var reservedInstanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.duration != nil {
                    map["Duration"] = self.duration!
                }
                if self.periodUnit != nil {
                    map["PeriodUnit"] = self.periodUnit!
                }
                if self.renewalStatus != nil {
                    map["RenewalStatus"] = self.renewalStatus!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Duration") {
                    self.duration = dict["Duration"] as! Int32
                }
                if dict.keys.contains("PeriodUnit") {
                    self.periodUnit = dict["PeriodUnit"] as! String
                }
                if dict.keys.contains("RenewalStatus") {
                    self.renewalStatus = dict["RenewalStatus"] as! String
                }
                if dict.keys.contains("ReservedInstanceId") {
                    self.reservedInstanceId = dict["ReservedInstanceId"] as! String
                }
            }
        }
        public var reservedInstanceRenewAttribute: [DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes.ReservedInstanceRenewAttribute]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceRenewAttribute != nil {
                var tmp : [Any] = []
                for k in self.reservedInstanceRenewAttribute! {
                    tmp.append(k.toMap())
                }
                map["ReservedInstanceRenewAttribute"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstanceRenewAttribute") {
                var tmp : [DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes.ReservedInstanceRenewAttribute] = []
                for v in dict["ReservedInstanceRenewAttribute"] as! [Any] {
                    var model = DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes.ReservedInstanceRenewAttribute()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reservedInstanceRenewAttribute = tmp
            }
        }
    }
    public var requestId: String?

    public var reservedInstanceRenewAttributes: DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceRenewAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceRenewAttributes != nil {
            map["ReservedInstanceRenewAttributes"] = self.reservedInstanceRenewAttributes?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstanceRenewAttributes") {
            var model = DescribeReservedInstanceAutoRenewAttributeResponseBody.ReservedInstanceRenewAttributes()
            model.fromMap(dict["ReservedInstanceRenewAttributes"] as! [String: Any])
            self.reservedInstanceRenewAttributes = model
        }
    }
}

public class DescribeReservedInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservedInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeReservedInstancesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var allocationType: String?

    public var instanceType: String?

    public var instanceTypeFamily: String?

    public var lockReason: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var reservedInstanceName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public var status: [String]?

    public var tag: [DescribeReservedInstancesRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationType != nil {
            map["AllocationType"] = self.allocationType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.lockReason != nil {
            map["LockReason"] = self.lockReason!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationType") {
            self.allocationType = dict["AllocationType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("LockReason") {
            self.lockReason = dict["LockReason"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! [String]
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeReservedInstancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeReservedInstancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstances : Tea.TeaModel {
        public class ReservedInstance : Tea.TeaModel {
            public class OperationLocks : Tea.TeaModel {
                public class OperationLock : Tea.TeaModel {
                    public var lockReason: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.lockReason != nil {
                            map["LockReason"] = self.lockReason!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("LockReason") {
                            self.lockReason = dict["LockReason"] as! String
                        }
                    }
                }
                public var operationLock: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.operationLock != nil {
                        var tmp : [Any] = []
                        for k in self.operationLock! {
                            tmp.append(k.toMap())
                        }
                        map["OperationLock"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("OperationLock") {
                        var tmp : [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock] = []
                        for v in dict["OperationLock"] as! [Any] {
                            var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks.OperationLock()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.operationLock = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocationStatus: String?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var instanceAmount: Int32?

            public var instanceType: String?

            public var offeringType: String?

            public var operationLocks: DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks?

            public var platform: String?

            public var regionId: String?

            public var reservedInstanceId: String?

            public var reservedInstanceName: String?

            public var resourceGroupId: String?

            public var scope: String?

            public var startTime: String?

            public var status: String?

            public var tags: DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.operationLocks?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationStatus != nil {
                    map["AllocationStatus"] = self.allocationStatus!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.instanceAmount != nil {
                    map["InstanceAmount"] = self.instanceAmount!
                }
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.offeringType != nil {
                    map["OfferingType"] = self.offeringType!
                }
                if self.operationLocks != nil {
                    map["OperationLocks"] = self.operationLocks?.toMap()
                }
                if self.platform != nil {
                    map["Platform"] = self.platform!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.reservedInstanceId != nil {
                    map["ReservedInstanceId"] = self.reservedInstanceId!
                }
                if self.reservedInstanceName != nil {
                    map["ReservedInstanceName"] = self.reservedInstanceName!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.scope != nil {
                    map["Scope"] = self.scope!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationStatus") {
                    self.allocationStatus = dict["AllocationStatus"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("InstanceAmount") {
                    self.instanceAmount = dict["InstanceAmount"] as! Int32
                }
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("OfferingType") {
                    self.offeringType = dict["OfferingType"] as! String
                }
                if dict.keys.contains("OperationLocks") {
                    var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.OperationLocks()
                    model.fromMap(dict["OperationLocks"] as! [String: Any])
                    self.operationLocks = model
                }
                if dict.keys.contains("Platform") {
                    self.platform = dict["Platform"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ReservedInstanceId") {
                    self.reservedInstanceId = dict["ReservedInstanceId"] as! String
                }
                if dict.keys.contains("ReservedInstanceName") {
                    self.reservedInstanceName = dict["ReservedInstanceName"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Scope") {
                    self.scope = dict["Scope"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var reservedInstance: [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstance != nil {
                var tmp : [Any] = []
                for k in self.reservedInstance! {
                    tmp.append(k.toMap())
                }
                map["ReservedInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstance") {
                var tmp : [DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance] = []
                for v in dict["ReservedInstance"] as! [Any] {
                    var model = DescribeReservedInstancesResponseBody.ReservedInstances.ReservedInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.reservedInstance = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var reservedInstances: DescribeReservedInstancesResponseBody.ReservedInstances?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstances != nil {
            map["ReservedInstances"] = self.reservedInstances?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstances") {
            var model = DescribeReservedInstancesResponseBody.ReservedInstances()
            model.fromMap(dict["ReservedInstances"] as! [String: Any])
            self.reservedInstances = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeReservedInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourceByTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeResourceByTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeResourceByTagsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeResourceByTagsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeResourceByTagsResponseBody : Tea.TeaModel {
    public class Resources : Tea.TeaModel {
        public class Resource : Tea.TeaModel {
            public var regionId: String?

            public var resourceId: String?

            public var resourceType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
            }
        }
        public var resource: [DescribeResourceByTagsResponseBody.Resources.Resource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.resource != nil {
                var tmp : [Any] = []
                for k in self.resource! {
                    tmp.append(k.toMap())
                }
                map["Resource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Resource") {
                var tmp : [DescribeResourceByTagsResponseBody.Resources.Resource] = []
                for v in dict["Resource"] as! [Any] {
                    var model = DescribeResourceByTagsResponseBody.Resources.Resource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.resource = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var resources: DescribeResourceByTagsResponseBody.Resources?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.resources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resources != nil {
            map["Resources"] = self.resources?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Resources") {
            var model = DescribeResourceByTagsResponseBody.Resources()
            model.fromMap(dict["Resources"] as! [String: Any])
            self.resources = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeResourceByTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourceByTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourceByTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeResourcesModificationRequest : Tea.TeaModel {
    public var conditions: [String]?

    public var cores: Int32?

    public var destinationResource: String?

    public var instanceType: String?

    public var memory: Double?

    public var migrateAcrossZone: Bool?

    public var operationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.conditions != nil {
            map["Conditions"] = self.conditions!
        }
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.destinationResource != nil {
            map["DestinationResource"] = self.destinationResource!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.migrateAcrossZone != nil {
            map["MigrateAcrossZone"] = self.migrateAcrossZone!
        }
        if self.operationType != nil {
            map["OperationType"] = self.operationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Conditions") {
            self.conditions = dict["Conditions"] as! [String]
        }
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("DestinationResource") {
            self.destinationResource = dict["DestinationResource"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("MigrateAcrossZone") {
            self.migrateAcrossZone = dict["MigrateAcrossZone"] as! Bool
        }
        if dict.keys.contains("OperationType") {
            self.operationType = dict["OperationType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeResourcesModificationResponseBody : Tea.TeaModel {
    public class AvailableZones : Tea.TeaModel {
        public class AvailableZone : Tea.TeaModel {
            public class AvailableResources : Tea.TeaModel {
                public class AvailableResource : Tea.TeaModel {
                    public class ConditionSupportedResources : Tea.TeaModel {
                        public class ConditionSupportedResource : Tea.TeaModel {
                            public class Conditions : Tea.TeaModel {
                                public class Condition : Tea.TeaModel {
                                    public var key: String?

                                    public override init() {
                                        super.init()
                                    }

                                    public init(_ dict: [String: Any]) {
                                        super.init()
                                        self.fromMap(dict)
                                    }

                                    public override func validate() throws -> Void {
                                    }

                                    public override func toMap() -> [String : Any] {
                                        var map = super.toMap()
                                        if self.key != nil {
                                            map["Key"] = self.key!
                                        }
                                        return map
                                    }

                                    public override func fromMap(_ dict: [String: Any]) -> Void {
                                        if dict.keys.contains("Key") {
                                            self.key = dict["Key"] as! String
                                        }
                                    }
                                }
                                public var condition: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions.Condition]?

                                public override init() {
                                    super.init()
                                }

                                public init(_ dict: [String: Any]) {
                                    super.init()
                                    self.fromMap(dict)
                                }

                                public override func validate() throws -> Void {
                                }

                                public override func toMap() -> [String : Any] {
                                    var map = super.toMap()
                                    if self.condition != nil {
                                        var tmp : [Any] = []
                                        for k in self.condition! {
                                            tmp.append(k.toMap())
                                        }
                                        map["Condition"] = tmp
                                    }
                                    return map
                                }

                                public override func fromMap(_ dict: [String: Any]) -> Void {
                                    if dict.keys.contains("Condition") {
                                        var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions.Condition] = []
                                        for v in dict["Condition"] as! [Any] {
                                            var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions.Condition()
                                            if v != nil {
                                                model.fromMap(v as! [String: Any])
                                            }
                                            tmp.append(model)
                                        }
                                        self.condition = tmp
                                    }
                                }
                            }
                            public var conditions: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions?

                            public var max: Int32?

                            public var min: Int32?

                            public var status: String?

                            public var statusCategory: String?

                            public var unit: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                                try self.conditions?.validate()
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.conditions != nil {
                                    map["Conditions"] = self.conditions?.toMap()
                                }
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                if self.status != nil {
                                    map["Status"] = self.status!
                                }
                                if self.statusCategory != nil {
                                    map["StatusCategory"] = self.statusCategory!
                                }
                                if self.unit != nil {
                                    map["Unit"] = self.unit!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Conditions") {
                                    var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource.Conditions()
                                    model.fromMap(dict["Conditions"] as! [String: Any])
                                    self.conditions = model
                                }
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! Int32
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! Int32
                                }
                                if dict.keys.contains("Status") {
                                    self.status = dict["Status"] as! String
                                }
                                if dict.keys.contains("StatusCategory") {
                                    self.statusCategory = dict["StatusCategory"] as! String
                                }
                                if dict.keys.contains("Unit") {
                                    self.unit = dict["Unit"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var conditionSupportedResource: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.conditionSupportedResource != nil {
                                var tmp : [Any] = []
                                for k in self.conditionSupportedResource! {
                                    tmp.append(k.toMap())
                                }
                                map["ConditionSupportedResource"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("ConditionSupportedResource") {
                                var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource] = []
                                for v in dict["ConditionSupportedResource"] as! [Any] {
                                    var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources.ConditionSupportedResource()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.conditionSupportedResource = tmp
                            }
                        }
                    }
                    public class SupportedResources : Tea.TeaModel {
                        public class SupportedResource : Tea.TeaModel {
                            public var max: Int32?

                            public var min: Int32?

                            public var status: String?

                            public var statusCategory: String?

                            public var unit: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.max != nil {
                                    map["Max"] = self.max!
                                }
                                if self.min != nil {
                                    map["Min"] = self.min!
                                }
                                if self.status != nil {
                                    map["Status"] = self.status!
                                }
                                if self.statusCategory != nil {
                                    map["StatusCategory"] = self.statusCategory!
                                }
                                if self.unit != nil {
                                    map["Unit"] = self.unit!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Max") {
                                    self.max = dict["Max"] as! Int32
                                }
                                if dict.keys.contains("Min") {
                                    self.min = dict["Min"] as! Int32
                                }
                                if dict.keys.contains("Status") {
                                    self.status = dict["Status"] as! String
                                }
                                if dict.keys.contains("StatusCategory") {
                                    self.statusCategory = dict["StatusCategory"] as! String
                                }
                                if dict.keys.contains("Unit") {
                                    self.unit = dict["Unit"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var supportedResource: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedResource != nil {
                                var tmp : [Any] = []
                                for k in self.supportedResource! {
                                    tmp.append(k.toMap())
                                }
                                map["SupportedResource"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("SupportedResource") {
                                var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource] = []
                                for v in dict["SupportedResource"] as! [Any] {
                                    var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources.SupportedResource()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.supportedResource = tmp
                            }
                        }
                    }
                    public var conditionSupportedResources: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources?

                    public var supportedResources: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.conditionSupportedResources?.validate()
                        try self.supportedResources?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.conditionSupportedResources != nil {
                            map["ConditionSupportedResources"] = self.conditionSupportedResources?.toMap()
                        }
                        if self.supportedResources != nil {
                            map["SupportedResources"] = self.supportedResources?.toMap()
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ConditionSupportedResources") {
                            var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.ConditionSupportedResources()
                            model.fromMap(dict["ConditionSupportedResources"] as! [String: Any])
                            self.conditionSupportedResources = model
                        }
                        if dict.keys.contains("SupportedResources") {
                            var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource.SupportedResources()
                            model.fromMap(dict["SupportedResources"] as! [String: Any])
                            self.supportedResources = model
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var availableResource: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableResource != nil {
                        var tmp : [Any] = []
                        for k in self.availableResource! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableResource") {
                        var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource] = []
                        for v in dict["AvailableResource"] as! [Any] {
                            var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources.AvailableResource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.availableResource = tmp
                    }
                }
            }
            public var availableResources: DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources?

            public var regionId: String?

            public var status: String?

            public var statusCategory: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableResources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableResources != nil {
                    map["AvailableResources"] = self.availableResources?.toMap()
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.statusCategory != nil {
                    map["StatusCategory"] = self.statusCategory!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableResources") {
                    var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone.AvailableResources()
                    model.fromMap(dict["AvailableResources"] as! [String: Any])
                    self.availableResources = model
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StatusCategory") {
                    self.statusCategory = dict["StatusCategory"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var availableZone: [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableZone != nil {
                var tmp : [Any] = []
                for k in self.availableZone! {
                    tmp.append(k.toMap())
                }
                map["AvailableZone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableZone") {
                var tmp : [DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone] = []
                for v in dict["AvailableZone"] as! [Any] {
                    var model = DescribeResourcesModificationResponseBody.AvailableZones.AvailableZone()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableZone = tmp
            }
        }
    }
    public var availableZones: DescribeResourcesModificationResponseBody.AvailableZones?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableZones != nil {
            map["AvailableZones"] = self.availableZones?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableZones") {
            var model = DescribeResourcesModificationResponseBody.AvailableZones()
            model.fromMap(dict["AvailableZones"] as! [String: Any])
            self.availableZones = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeResourcesModificationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeResourcesModificationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeResourcesModificationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRouteTablesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routeTableId: String?

    public var routeTableName: String?

    public var routerId: String?

    public var routerType: String?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routeTableId != nil {
            map["RouteTableId"] = self.routeTableId!
        }
        if self.routeTableName != nil {
            map["RouteTableName"] = self.routeTableName!
        }
        if self.routerId != nil {
            map["RouterId"] = self.routerId!
        }
        if self.routerType != nil {
            map["RouterType"] = self.routerType!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouteTableId") {
            self.routeTableId = dict["RouteTableId"] as! String
        }
        if dict.keys.contains("RouteTableName") {
            self.routeTableName = dict["RouteTableName"] as! String
        }
        if dict.keys.contains("RouterId") {
            self.routerId = dict["RouterId"] as! String
        }
        if dict.keys.contains("RouterType") {
            self.routerType = dict["RouterType"] as! String
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
    }
}

public class DescribeRouteTablesResponseBody : Tea.TeaModel {
    public class RouteTables : Tea.TeaModel {
        public class RouteTable : Tea.TeaModel {
            public class RouteEntrys : Tea.TeaModel {
                public class RouteEntry : Tea.TeaModel {
                    public class NextHops : Tea.TeaModel {
                        public class NextHop : Tea.TeaModel {
                            public var enabled: Int32?

                            public var nextHopId: String?

                            public var nextHopType: String?

                            public var weight: Int32?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.enabled != nil {
                                    map["Enabled"] = self.enabled!
                                }
                                if self.nextHopId != nil {
                                    map["NextHopId"] = self.nextHopId!
                                }
                                if self.nextHopType != nil {
                                    map["NextHopType"] = self.nextHopType!
                                }
                                if self.weight != nil {
                                    map["Weight"] = self.weight!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Enabled") {
                                    self.enabled = dict["Enabled"] as! Int32
                                }
                                if dict.keys.contains("NextHopId") {
                                    self.nextHopId = dict["NextHopId"] as! String
                                }
                                if dict.keys.contains("NextHopType") {
                                    self.nextHopType = dict["NextHopType"] as! String
                                }
                                if dict.keys.contains("Weight") {
                                    self.weight = dict["Weight"] as! Int32
                                }
                            }
                        }
                        public var nextHop: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.nextHop != nil {
                                var tmp : [Any] = []
                                for k in self.nextHop! {
                                    tmp.append(k.toMap())
                                }
                                map["NextHop"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("NextHop") {
                                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop] = []
                                for v in dict["NextHop"] as! [Any] {
                                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops.NextHop()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.nextHop = tmp
                            }
                        }
                    }
                    public var destinationCidrBlock: String?

                    public var instanceId: String?

                    public var nextHopType: String?

                    public var nextHops: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops?

                    public var routeTableId: String?

                    public var status: String?

                    public var type: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.nextHops?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.destinationCidrBlock != nil {
                            map["DestinationCidrBlock"] = self.destinationCidrBlock!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.nextHopType != nil {
                            map["NextHopType"] = self.nextHopType!
                        }
                        if self.nextHops != nil {
                            map["NextHops"] = self.nextHops?.toMap()
                        }
                        if self.routeTableId != nil {
                            map["RouteTableId"] = self.routeTableId!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        if self.type != nil {
                            map["Type"] = self.type!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DestinationCidrBlock") {
                            self.destinationCidrBlock = dict["DestinationCidrBlock"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("NextHopType") {
                            self.nextHopType = dict["NextHopType"] as! String
                        }
                        if dict.keys.contains("NextHops") {
                            var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry.NextHops()
                            model.fromMap(dict["NextHops"] as! [String: Any])
                            self.nextHops = model
                        }
                        if dict.keys.contains("RouteTableId") {
                            self.routeTableId = dict["RouteTableId"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                        if dict.keys.contains("Type") {
                            self.type = dict["Type"] as! String
                        }
                    }
                }
                public var routeEntry: [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeEntry != nil {
                        var tmp : [Any] = []
                        for k in self.routeEntry! {
                            tmp.append(k.toMap())
                        }
                        map["RouteEntry"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RouteEntry") {
                        var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry] = []
                        for v in dict["RouteEntry"] as! [Any] {
                            var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys.RouteEntry()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.routeEntry = tmp
                    }
                }
            }
            public var creationTime: String?

            public var resourceGroupId: String?

            public var routeEntrys: DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys?

            public var routeTableId: String?

            public var routeTableType: String?

            public var VRouterId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeEntrys?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.routeEntrys != nil {
                    map["RouteEntrys"] = self.routeEntrys?.toMap()
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.routeTableType != nil {
                    map["RouteTableType"] = self.routeTableType!
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RouteEntrys") {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable.RouteEntrys()
                    model.fromMap(dict["RouteEntrys"] as! [String: Any])
                    self.routeEntrys = model
                }
                if dict.keys.contains("RouteTableId") {
                    self.routeTableId = dict["RouteTableId"] as! String
                }
                if dict.keys.contains("RouteTableType") {
                    self.routeTableType = dict["RouteTableType"] as! String
                }
                if dict.keys.contains("VRouterId") {
                    self.VRouterId = dict["VRouterId"] as! String
                }
            }
        }
        public var routeTable: [DescribeRouteTablesResponseBody.RouteTables.RouteTable]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routeTable != nil {
                var tmp : [Any] = []
                for k in self.routeTable! {
                    tmp.append(k.toMap())
                }
                map["RouteTable"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouteTable") {
                var tmp : [DescribeRouteTablesResponseBody.RouteTables.RouteTable] = []
                for v in dict["RouteTable"] as! [Any] {
                    var model = DescribeRouteTablesResponseBody.RouteTables.RouteTable()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routeTable = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routeTables: DescribeRouteTablesResponseBody.RouteTables?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routeTables?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routeTables != nil {
            map["RouteTables"] = self.routeTables?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouteTables") {
            var model = DescribeRouteTablesResponseBody.RouteTables()
            model.fromMap(dict["RouteTables"] as! [String: Any])
            self.routeTables = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeRouteTablesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouteTablesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRouteTablesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeRouterInterfacesRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var filter: [DescribeRouterInterfacesRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeRouterInterfacesRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeRouterInterfacesRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeRouterInterfacesResponseBody : Tea.TeaModel {
    public class RouterInterfaceSet : Tea.TeaModel {
        public class RouterInterfaceType : Tea.TeaModel {
            public var accessPointId: String?

            public var businessStatus: String?

            public var chargeType: String?

            public var connectedTime: String?

            public var creationTime: String?

            public var description_: String?

            public var endTime: String?

            public var healthCheckSourceIp: String?

            public var healthCheckTargetIp: String?

            public var name: String?

            public var oppositeAccessPointId: String?

            public var oppositeInterfaceBusinessStatus: String?

            public var oppositeInterfaceId: String?

            public var oppositeInterfaceOwnerId: String?

            public var oppositeInterfaceSpec: String?

            public var oppositeInterfaceStatus: String?

            public var oppositeRegionId: String?

            public var oppositeRouterId: String?

            public var oppositeRouterType: String?

            public var role: String?

            public var routerId: String?

            public var routerInterfaceId: String?

            public var routerType: String?

            public var spec: String?

            public var status: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.businessStatus != nil {
                    map["BusinessStatus"] = self.businessStatus!
                }
                if self.chargeType != nil {
                    map["ChargeType"] = self.chargeType!
                }
                if self.connectedTime != nil {
                    map["ConnectedTime"] = self.connectedTime!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.healthCheckSourceIp != nil {
                    map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
                }
                if self.healthCheckTargetIp != nil {
                    map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.oppositeAccessPointId != nil {
                    map["OppositeAccessPointId"] = self.oppositeAccessPointId!
                }
                if self.oppositeInterfaceBusinessStatus != nil {
                    map["OppositeInterfaceBusinessStatus"] = self.oppositeInterfaceBusinessStatus!
                }
                if self.oppositeInterfaceId != nil {
                    map["OppositeInterfaceId"] = self.oppositeInterfaceId!
                }
                if self.oppositeInterfaceOwnerId != nil {
                    map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
                }
                if self.oppositeInterfaceSpec != nil {
                    map["OppositeInterfaceSpec"] = self.oppositeInterfaceSpec!
                }
                if self.oppositeInterfaceStatus != nil {
                    map["OppositeInterfaceStatus"] = self.oppositeInterfaceStatus!
                }
                if self.oppositeRegionId != nil {
                    map["OppositeRegionId"] = self.oppositeRegionId!
                }
                if self.oppositeRouterId != nil {
                    map["OppositeRouterId"] = self.oppositeRouterId!
                }
                if self.oppositeRouterType != nil {
                    map["OppositeRouterType"] = self.oppositeRouterType!
                }
                if self.role != nil {
                    map["Role"] = self.role!
                }
                if self.routerId != nil {
                    map["RouterId"] = self.routerId!
                }
                if self.routerInterfaceId != nil {
                    map["RouterInterfaceId"] = self.routerInterfaceId!
                }
                if self.routerType != nil {
                    map["RouterType"] = self.routerType!
                }
                if self.spec != nil {
                    map["Spec"] = self.spec!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("BusinessStatus") {
                    self.businessStatus = dict["BusinessStatus"] as! String
                }
                if dict.keys.contains("ChargeType") {
                    self.chargeType = dict["ChargeType"] as! String
                }
                if dict.keys.contains("ConnectedTime") {
                    self.connectedTime = dict["ConnectedTime"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("HealthCheckSourceIp") {
                    self.healthCheckSourceIp = dict["HealthCheckSourceIp"] as! String
                }
                if dict.keys.contains("HealthCheckTargetIp") {
                    self.healthCheckTargetIp = dict["HealthCheckTargetIp"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("OppositeAccessPointId") {
                    self.oppositeAccessPointId = dict["OppositeAccessPointId"] as! String
                }
                if dict.keys.contains("OppositeInterfaceBusinessStatus") {
                    self.oppositeInterfaceBusinessStatus = dict["OppositeInterfaceBusinessStatus"] as! String
                }
                if dict.keys.contains("OppositeInterfaceId") {
                    self.oppositeInterfaceId = dict["OppositeInterfaceId"] as! String
                }
                if dict.keys.contains("OppositeInterfaceOwnerId") {
                    self.oppositeInterfaceOwnerId = dict["OppositeInterfaceOwnerId"] as! String
                }
                if dict.keys.contains("OppositeInterfaceSpec") {
                    self.oppositeInterfaceSpec = dict["OppositeInterfaceSpec"] as! String
                }
                if dict.keys.contains("OppositeInterfaceStatus") {
                    self.oppositeInterfaceStatus = dict["OppositeInterfaceStatus"] as! String
                }
                if dict.keys.contains("OppositeRegionId") {
                    self.oppositeRegionId = dict["OppositeRegionId"] as! String
                }
                if dict.keys.contains("OppositeRouterId") {
                    self.oppositeRouterId = dict["OppositeRouterId"] as! String
                }
                if dict.keys.contains("OppositeRouterType") {
                    self.oppositeRouterType = dict["OppositeRouterType"] as! String
                }
                if dict.keys.contains("Role") {
                    self.role = dict["Role"] as! String
                }
                if dict.keys.contains("RouterId") {
                    self.routerId = dict["RouterId"] as! String
                }
                if dict.keys.contains("RouterInterfaceId") {
                    self.routerInterfaceId = dict["RouterInterfaceId"] as! String
                }
                if dict.keys.contains("RouterType") {
                    self.routerType = dict["RouterType"] as! String
                }
                if dict.keys.contains("Spec") {
                    self.spec = dict["Spec"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
            }
        }
        public var routerInterfaceType: [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.routerInterfaceType != nil {
                var tmp : [Any] = []
                for k in self.routerInterfaceType! {
                    tmp.append(k.toMap())
                }
                map["RouterInterfaceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("RouterInterfaceType") {
                var tmp : [DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType] = []
                for v in dict["RouterInterfaceType"] as! [Any] {
                    var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet.RouterInterfaceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.routerInterfaceType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var routerInterfaceSet: DescribeRouterInterfacesResponseBody.RouterInterfaceSet?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.routerInterfaceSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.routerInterfaceSet != nil {
            map["RouterInterfaceSet"] = self.routerInterfaceSet?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("RouterInterfaceSet") {
            var model = DescribeRouterInterfacesResponseBody.RouterInterfaceSet()
            model.fromMap(dict["RouterInterfaceSet"] as! [String: Any])
            self.routerInterfaceSet = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeRouterInterfacesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeRouterInterfacesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeRouterInterfacesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSavingsPlanEstimationRequest : Tea.TeaModel {
    public var offeringType: String?

    public var period: String?

    public var periodUnit: String?

    public var planType: String?

    public var regionId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! String
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PlanType") {
            self.planType = dict["PlanType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DescribeSavingsPlanEstimationResponseBody : Tea.TeaModel {
    public var committedAmount: String?

    public var currency: String?

    public var instanceTypeFamily: String?

    public var offeringType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var planType: String?

    public var requestId: String?

    public var resourceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.committedAmount != nil {
            map["CommittedAmount"] = self.committedAmount!
        }
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommittedAmount") {
            self.committedAmount = dict["CommittedAmount"] as! String
        }
        if dict.keys.contains("Currency") {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PlanType") {
            self.planType = dict["PlanType"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
    }
}

public class DescribeSavingsPlanEstimationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSavingsPlanEstimationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSavingsPlanEstimationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSavingsPlanPriceRequest : Tea.TeaModel {
    public var committedAmount: String?

    public var instanceTypeFamily: String?

    public var offeringType: String?

    public var period: Int32?

    public var periodUnit: String?

    public var planType: String?

    public var regionId: String?

    public var resourceId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.committedAmount != nil {
            map["CommittedAmount"] = self.committedAmount!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.planType != nil {
            map["PlanType"] = self.planType!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommittedAmount") {
            self.committedAmount = dict["CommittedAmount"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PlanType") {
            self.planType = dict["PlanType"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
    }
}

public class DescribeSavingsPlanPriceResponseBody : Tea.TeaModel {
    public class PriceInfo : Tea.TeaModel {
        public class Price : Tea.TeaModel {
            public var currency: String?

            public var discountPrice: Double?

            public var originalPrice: Double?

            public var tradePrice: Double?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.discountPrice != nil {
                    map["DiscountPrice"] = self.discountPrice!
                }
                if self.originalPrice != nil {
                    map["OriginalPrice"] = self.originalPrice!
                }
                if self.tradePrice != nil {
                    map["TradePrice"] = self.tradePrice!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("DiscountPrice") {
                    self.discountPrice = dict["DiscountPrice"] as! Double
                }
                if dict.keys.contains("OriginalPrice") {
                    self.originalPrice = dict["OriginalPrice"] as! Double
                }
                if dict.keys.contains("TradePrice") {
                    self.tradePrice = dict["TradePrice"] as! Double
                }
            }
        }
        public class Rules : Tea.TeaModel {
            public var description_: String?

            public var ruleId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ruleId != nil {
                    map["RuleId"] = self.ruleId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RuleId") {
                    self.ruleId = dict["RuleId"] as! String
                }
            }
        }
        public var price: DescribeSavingsPlanPriceResponseBody.PriceInfo.Price?

        public var rules: [DescribeSavingsPlanPriceResponseBody.PriceInfo.Rules]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
            try self.price?.validate()
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.price != nil {
                map["Price"] = self.price?.toMap()
            }
            if self.rules != nil {
                var tmp : [Any] = []
                for k in self.rules! {
                    tmp.append(k.toMap())
                }
                map["Rules"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Price") {
                var model = DescribeSavingsPlanPriceResponseBody.PriceInfo.Price()
                model.fromMap(dict["Price"] as! [String: Any])
                self.price = model
            }
            if dict.keys.contains("Rules") {
                var tmp : [DescribeSavingsPlanPriceResponseBody.PriceInfo.Rules] = []
                for v in dict["Rules"] as! [Any] {
                    var model = DescribeSavingsPlanPriceResponseBody.PriceInfo.Rules()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.rules = tmp
            }
        }
    }
    public var priceInfo: DescribeSavingsPlanPriceResponseBody.PriceInfo?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.priceInfo?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.priceInfo != nil {
            map["PriceInfo"] = self.priceInfo?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PriceInfo") {
            var model = DescribeSavingsPlanPriceResponseBody.PriceInfo()
            model.fromMap(dict["PriceInfo"] as! [String: Any])
            self.priceInfo = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSavingsPlanPriceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSavingsPlanPriceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSavingsPlanPriceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityGroupAttributeRequest : Tea.TeaModel {
    public var direction: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.direction != nil {
            map["Direction"] = self.direction!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Direction") {
            self.direction = dict["Direction"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class DescribeSecurityGroupAttributeResponseBody : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public class Permission : Tea.TeaModel {
            public var createTime: String?

            public var description_: String?

            public var destCidrIp: String?

            public var destGroupId: String?

            public var destGroupName: String?

            public var destGroupOwnerAccount: String?

            public var destPrefixListId: String?

            public var destPrefixListName: String?

            public var direction: String?

            public var ipProtocol: String?

            public var ipv6DestCidrIp: String?

            public var ipv6SourceCidrIp: String?

            public var nicType: String?

            public var policy: String?

            public var portRange: String?

            public var priority: String?

            public var securityGroupRuleId: String?

            public var sourceCidrIp: String?

            public var sourceGroupId: String?

            public var sourceGroupName: String?

            public var sourceGroupOwnerAccount: String?

            public var sourcePortRange: String?

            public var sourcePrefixListId: String?

            public var sourcePrefixListName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.createTime != nil {
                    map["CreateTime"] = self.createTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.destCidrIp != nil {
                    map["DestCidrIp"] = self.destCidrIp!
                }
                if self.destGroupId != nil {
                    map["DestGroupId"] = self.destGroupId!
                }
                if self.destGroupName != nil {
                    map["DestGroupName"] = self.destGroupName!
                }
                if self.destGroupOwnerAccount != nil {
                    map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
                }
                if self.destPrefixListId != nil {
                    map["DestPrefixListId"] = self.destPrefixListId!
                }
                if self.destPrefixListName != nil {
                    map["DestPrefixListName"] = self.destPrefixListName!
                }
                if self.direction != nil {
                    map["Direction"] = self.direction!
                }
                if self.ipProtocol != nil {
                    map["IpProtocol"] = self.ipProtocol!
                }
                if self.ipv6DestCidrIp != nil {
                    map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
                }
                if self.ipv6SourceCidrIp != nil {
                    map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
                }
                if self.nicType != nil {
                    map["NicType"] = self.nicType!
                }
                if self.policy != nil {
                    map["Policy"] = self.policy!
                }
                if self.portRange != nil {
                    map["PortRange"] = self.portRange!
                }
                if self.priority != nil {
                    map["Priority"] = self.priority!
                }
                if self.securityGroupRuleId != nil {
                    map["SecurityGroupRuleId"] = self.securityGroupRuleId!
                }
                if self.sourceCidrIp != nil {
                    map["SourceCidrIp"] = self.sourceCidrIp!
                }
                if self.sourceGroupId != nil {
                    map["SourceGroupId"] = self.sourceGroupId!
                }
                if self.sourceGroupName != nil {
                    map["SourceGroupName"] = self.sourceGroupName!
                }
                if self.sourceGroupOwnerAccount != nil {
                    map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
                }
                if self.sourcePortRange != nil {
                    map["SourcePortRange"] = self.sourcePortRange!
                }
                if self.sourcePrefixListId != nil {
                    map["SourcePrefixListId"] = self.sourcePrefixListId!
                }
                if self.sourcePrefixListName != nil {
                    map["SourcePrefixListName"] = self.sourcePrefixListName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreateTime") {
                    self.createTime = dict["CreateTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("DestCidrIp") {
                    self.destCidrIp = dict["DestCidrIp"] as! String
                }
                if dict.keys.contains("DestGroupId") {
                    self.destGroupId = dict["DestGroupId"] as! String
                }
                if dict.keys.contains("DestGroupName") {
                    self.destGroupName = dict["DestGroupName"] as! String
                }
                if dict.keys.contains("DestGroupOwnerAccount") {
                    self.destGroupOwnerAccount = dict["DestGroupOwnerAccount"] as! String
                }
                if dict.keys.contains("DestPrefixListId") {
                    self.destPrefixListId = dict["DestPrefixListId"] as! String
                }
                if dict.keys.contains("DestPrefixListName") {
                    self.destPrefixListName = dict["DestPrefixListName"] as! String
                }
                if dict.keys.contains("Direction") {
                    self.direction = dict["Direction"] as! String
                }
                if dict.keys.contains("IpProtocol") {
                    self.ipProtocol = dict["IpProtocol"] as! String
                }
                if dict.keys.contains("Ipv6DestCidrIp") {
                    self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
                }
                if dict.keys.contains("Ipv6SourceCidrIp") {
                    self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
                }
                if dict.keys.contains("NicType") {
                    self.nicType = dict["NicType"] as! String
                }
                if dict.keys.contains("Policy") {
                    self.policy = dict["Policy"] as! String
                }
                if dict.keys.contains("PortRange") {
                    self.portRange = dict["PortRange"] as! String
                }
                if dict.keys.contains("Priority") {
                    self.priority = dict["Priority"] as! String
                }
                if dict.keys.contains("SecurityGroupRuleId") {
                    self.securityGroupRuleId = dict["SecurityGroupRuleId"] as! String
                }
                if dict.keys.contains("SourceCidrIp") {
                    self.sourceCidrIp = dict["SourceCidrIp"] as! String
                }
                if dict.keys.contains("SourceGroupId") {
                    self.sourceGroupId = dict["SourceGroupId"] as! String
                }
                if dict.keys.contains("SourceGroupName") {
                    self.sourceGroupName = dict["SourceGroupName"] as! String
                }
                if dict.keys.contains("SourceGroupOwnerAccount") {
                    self.sourceGroupOwnerAccount = dict["SourceGroupOwnerAccount"] as! String
                }
                if dict.keys.contains("SourcePortRange") {
                    self.sourcePortRange = dict["SourcePortRange"] as! String
                }
                if dict.keys.contains("SourcePrefixListId") {
                    self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
                }
                if dict.keys.contains("SourcePrefixListName") {
                    self.sourcePrefixListName = dict["SourcePrefixListName"] as! String
                }
            }
        }
        public var permission: [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.permission != nil {
                var tmp : [Any] = []
                for k in self.permission! {
                    tmp.append(k.toMap())
                }
                map["Permission"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Permission") {
                var tmp : [DescribeSecurityGroupAttributeResponseBody.Permissions.Permission] = []
                for v in dict["Permission"] as! [Any] {
                    var model = DescribeSecurityGroupAttributeResponseBody.Permissions.Permission()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.permission = tmp
            }
        }
    }
    public var description_: String?

    public var innerAccessPolicy: String?

    public var nextToken: String?

    public var permissions: DescribeSecurityGroupAttributeResponseBody.Permissions?

    public var regionId: String?

    public var requestId: String?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.permissions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.innerAccessPolicy != nil {
            map["InnerAccessPolicy"] = self.innerAccessPolicy!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.permissions != nil {
            map["Permissions"] = self.permissions?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InnerAccessPolicy") {
            self.innerAccessPolicy = dict["InnerAccessPolicy"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("Permissions") {
            var model = DescribeSecurityGroupAttributeResponseBody.Permissions()
            model.fromMap(dict["Permissions"] as! [String: Any])
            self.permissions = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeSecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecurityGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityGroupReferencesRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! [String]
        }
    }
}

public class DescribeSecurityGroupReferencesResponseBody : Tea.TeaModel {
    public class SecurityGroupReferences : Tea.TeaModel {
        public class SecurityGroupReference : Tea.TeaModel {
            public class ReferencingSecurityGroups : Tea.TeaModel {
                public class ReferencingSecurityGroup : Tea.TeaModel {
                    public var aliUid: String?

                    public var securityGroupId: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.aliUid != nil {
                            map["AliUid"] = self.aliUid!
                        }
                        if self.securityGroupId != nil {
                            map["SecurityGroupId"] = self.securityGroupId!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AliUid") {
                            self.aliUid = dict["AliUid"] as! String
                        }
                        if dict.keys.contains("SecurityGroupId") {
                            self.securityGroupId = dict["SecurityGroupId"] as! String
                        }
                    }
                }
                public var referencingSecurityGroup: [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups.ReferencingSecurityGroup]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.referencingSecurityGroup != nil {
                        var tmp : [Any] = []
                        for k in self.referencingSecurityGroup! {
                            tmp.append(k.toMap())
                        }
                        map["ReferencingSecurityGroup"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ReferencingSecurityGroup") {
                        var tmp : [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups.ReferencingSecurityGroup] = []
                        for v in dict["ReferencingSecurityGroup"] as! [Any] {
                            var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups.ReferencingSecurityGroup()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.referencingSecurityGroup = tmp
                    }
                }
            }
            public var referencingSecurityGroups: DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups?

            public var securityGroupId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.referencingSecurityGroups?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.referencingSecurityGroups != nil {
                    map["ReferencingSecurityGroups"] = self.referencingSecurityGroups?.toMap()
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ReferencingSecurityGroups") {
                    var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference.ReferencingSecurityGroups()
                    model.fromMap(dict["ReferencingSecurityGroups"] as! [String: Any])
                    self.referencingSecurityGroups = model
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
            }
        }
        public var securityGroupReference: [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroupReference != nil {
                var tmp : [Any] = []
                for k in self.securityGroupReference! {
                    tmp.append(k.toMap())
                }
                map["SecurityGroupReference"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroupReference") {
                var tmp : [DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference] = []
                for v in dict["SecurityGroupReference"] as! [Any] {
                    var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences.SecurityGroupReference()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityGroupReference = tmp
            }
        }
    }
    public var requestId: String?

    public var securityGroupReferences: DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityGroupReferences?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroupReferences != nil {
            map["SecurityGroupReferences"] = self.securityGroupReferences?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroupReferences") {
            var model = DescribeSecurityGroupReferencesResponseBody.SecurityGroupReferences()
            model.fromMap(dict["SecurityGroupReferences"] as! [String: Any])
            self.securityGroupReferences = model
        }
    }
}

public class DescribeSecurityGroupReferencesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupReferencesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecurityGroupReferencesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSecurityGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var dryRun: Bool?

    public var fuzzyQuery: Bool?

    public var isQueryEcsCount: Bool?

    public var maxResults: Int32?

    public var networkType: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupIds: String?

    public var securityGroupName: String?

    public var securityGroupType: String?

    public var serviceManaged: Bool?

    public var tag: [DescribeSecurityGroupsRequest.Tag]?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.fuzzyQuery != nil {
            map["FuzzyQuery"] = self.fuzzyQuery!
        }
        if self.isQueryEcsCount != nil {
            map["IsQueryEcsCount"] = self.isQueryEcsCount!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        if self.securityGroupType != nil {
            map["SecurityGroupType"] = self.securityGroupType!
        }
        if self.serviceManaged != nil {
            map["ServiceManaged"] = self.serviceManaged!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("FuzzyQuery") {
            self.fuzzyQuery = dict["FuzzyQuery"] as! Bool
        }
        if dict.keys.contains("IsQueryEcsCount") {
            self.isQueryEcsCount = dict["IsQueryEcsCount"] as! Bool
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
        if dict.keys.contains("SecurityGroupType") {
            self.securityGroupType = dict["SecurityGroupType"] as! String
        }
        if dict.keys.contains("ServiceManaged") {
            self.serviceManaged = dict["ServiceManaged"] as! Bool
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeSecurityGroupsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeSecurityGroupsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeSecurityGroupsResponseBody : Tea.TeaModel {
    public class SecurityGroups : Tea.TeaModel {
        public class SecurityGroup : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var availableInstanceAmount: Int32?

            public var creationTime: String?

            public var description_: String?

            public var ecsCount: Int32?

            public var groupToGroupRuleCount: Int32?

            public var resourceGroupId: String?

            public var ruleCount: Int32?

            public var securityGroupId: String?

            public var securityGroupName: String?

            public var securityGroupType: String?

            public var serviceID: Int64?

            public var serviceManaged: Bool?

            public var tags: DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableInstanceAmount != nil {
                    map["AvailableInstanceAmount"] = self.availableInstanceAmount!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.ecsCount != nil {
                    map["EcsCount"] = self.ecsCount!
                }
                if self.groupToGroupRuleCount != nil {
                    map["GroupToGroupRuleCount"] = self.groupToGroupRuleCount!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.ruleCount != nil {
                    map["RuleCount"] = self.ruleCount!
                }
                if self.securityGroupId != nil {
                    map["SecurityGroupId"] = self.securityGroupId!
                }
                if self.securityGroupName != nil {
                    map["SecurityGroupName"] = self.securityGroupName!
                }
                if self.securityGroupType != nil {
                    map["SecurityGroupType"] = self.securityGroupType!
                }
                if self.serviceID != nil {
                    map["ServiceID"] = self.serviceID!
                }
                if self.serviceManaged != nil {
                    map["ServiceManaged"] = self.serviceManaged!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableInstanceAmount") {
                    self.availableInstanceAmount = dict["AvailableInstanceAmount"] as! Int32
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("EcsCount") {
                    self.ecsCount = dict["EcsCount"] as! Int32
                }
                if dict.keys.contains("GroupToGroupRuleCount") {
                    self.groupToGroupRuleCount = dict["GroupToGroupRuleCount"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RuleCount") {
                    self.ruleCount = dict["RuleCount"] as! Int32
                }
                if dict.keys.contains("SecurityGroupId") {
                    self.securityGroupId = dict["SecurityGroupId"] as! String
                }
                if dict.keys.contains("SecurityGroupName") {
                    self.securityGroupName = dict["SecurityGroupName"] as! String
                }
                if dict.keys.contains("SecurityGroupType") {
                    self.securityGroupType = dict["SecurityGroupType"] as! String
                }
                if dict.keys.contains("ServiceID") {
                    self.serviceID = dict["ServiceID"] as! Int64
                }
                if dict.keys.contains("ServiceManaged") {
                    self.serviceManaged = dict["ServiceManaged"] as! Bool
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var securityGroup: [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.securityGroup != nil {
                var tmp : [Any] = []
                for k in self.securityGroup! {
                    tmp.append(k.toMap())
                }
                map["SecurityGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SecurityGroup") {
                var tmp : [DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup] = []
                for v in dict["SecurityGroup"] as! [Any] {
                    var model = DescribeSecurityGroupsResponseBody.SecurityGroups.SecurityGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.securityGroup = tmp
            }
        }
    }
    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var securityGroups: DescribeSecurityGroupsResponseBody.SecurityGroups?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.securityGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityGroups != nil {
            map["SecurityGroups"] = self.securityGroups?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityGroups") {
            var model = DescribeSecurityGroupsResponseBody.SecurityGroups()
            model.fromMap(dict["SecurityGroups"] as! [String: Any])
            self.securityGroups = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSecurityGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSecurityGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSecurityGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSendFileResultsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var instanceId: String?

    public var invocationStatus: String?

    public var invokeId: String?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [DescribeSendFileResultsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invocationStatus != nil {
            map["InvocationStatus"] = self.invocationStatus!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InvocationStatus") {
            self.invocationStatus = dict["InvocationStatus"] as! String
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeSendFileResultsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeSendFileResultsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeSendFileResultsResponseBody : Tea.TeaModel {
    public class Invocations : Tea.TeaModel {
        public class Invocation : Tea.TeaModel {
            public class InvokeInstances : Tea.TeaModel {
                public class InvokeInstance : Tea.TeaModel {
                    public var creationTime: String?

                    public var errorCode: String?

                    public var errorInfo: String?

                    public var finishTime: String?

                    public var instanceId: String?

                    public var invocationStatus: String?

                    public var startTime: String?

                    public var updateTime: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.creationTime != nil {
                            map["CreationTime"] = self.creationTime!
                        }
                        if self.errorCode != nil {
                            map["ErrorCode"] = self.errorCode!
                        }
                        if self.errorInfo != nil {
                            map["ErrorInfo"] = self.errorInfo!
                        }
                        if self.finishTime != nil {
                            map["FinishTime"] = self.finishTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.invocationStatus != nil {
                            map["InvocationStatus"] = self.invocationStatus!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.updateTime != nil {
                            map["UpdateTime"] = self.updateTime!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("CreationTime") {
                            self.creationTime = dict["CreationTime"] as! String
                        }
                        if dict.keys.contains("ErrorCode") {
                            self.errorCode = dict["ErrorCode"] as! String
                        }
                        if dict.keys.contains("ErrorInfo") {
                            self.errorInfo = dict["ErrorInfo"] as! String
                        }
                        if dict.keys.contains("FinishTime") {
                            self.finishTime = dict["FinishTime"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("InvocationStatus") {
                            self.invocationStatus = dict["InvocationStatus"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("UpdateTime") {
                            self.updateTime = dict["UpdateTime"] as! String
                        }
                    }
                }
                public var invokeInstance: [DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.invokeInstance != nil {
                        var tmp : [Any] = []
                        for k in self.invokeInstance! {
                            tmp.append(k.toMap())
                        }
                        map["InvokeInstance"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InvokeInstance") {
                        var tmp : [DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance] = []
                        for v in dict["InvokeInstance"] as! [Any] {
                            var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances.InvokeInstance()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.invokeInstance = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var content: String?

            public var contentType: String?

            public var creationTime: String?

            public var description_: String?

            public var fileGroup: String?

            public var fileMode: String?

            public var fileOwner: String?

            public var invocationStatus: String?

            public var invokeId: String?

            public var invokeInstances: DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances?

            public var name: String?

            public var overwrite: String?

            public var tags: DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags?

            public var targetDir: String?

            public var vmCount: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.invokeInstances?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.content != nil {
                    map["Content"] = self.content!
                }
                if self.contentType != nil {
                    map["ContentType"] = self.contentType!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.fileGroup != nil {
                    map["FileGroup"] = self.fileGroup!
                }
                if self.fileMode != nil {
                    map["FileMode"] = self.fileMode!
                }
                if self.fileOwner != nil {
                    map["FileOwner"] = self.fileOwner!
                }
                if self.invocationStatus != nil {
                    map["InvocationStatus"] = self.invocationStatus!
                }
                if self.invokeId != nil {
                    map["InvokeId"] = self.invokeId!
                }
                if self.invokeInstances != nil {
                    map["InvokeInstances"] = self.invokeInstances?.toMap()
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.overwrite != nil {
                    map["Overwrite"] = self.overwrite!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.targetDir != nil {
                    map["TargetDir"] = self.targetDir!
                }
                if self.vmCount != nil {
                    map["VmCount"] = self.vmCount!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Content") {
                    self.content = dict["Content"] as! String
                }
                if dict.keys.contains("ContentType") {
                    self.contentType = dict["ContentType"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("FileGroup") {
                    self.fileGroup = dict["FileGroup"] as! String
                }
                if dict.keys.contains("FileMode") {
                    self.fileMode = dict["FileMode"] as! String
                }
                if dict.keys.contains("FileOwner") {
                    self.fileOwner = dict["FileOwner"] as! String
                }
                if dict.keys.contains("InvocationStatus") {
                    self.invocationStatus = dict["InvocationStatus"] as! String
                }
                if dict.keys.contains("InvokeId") {
                    self.invokeId = dict["InvokeId"] as! String
                }
                if dict.keys.contains("InvokeInstances") {
                    var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.InvokeInstances()
                    model.fromMap(dict["InvokeInstances"] as! [String: Any])
                    self.invokeInstances = model
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("Overwrite") {
                    self.overwrite = dict["Overwrite"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeSendFileResultsResponseBody.Invocations.Invocation.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("TargetDir") {
                    self.targetDir = dict["TargetDir"] as! String
                }
                if dict.keys.contains("VmCount") {
                    self.vmCount = dict["VmCount"] as! Int32
                }
            }
        }
        public var invocation: [DescribeSendFileResultsResponseBody.Invocations.Invocation]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.invocation != nil {
                var tmp : [Any] = []
                for k in self.invocation! {
                    tmp.append(k.toMap())
                }
                map["Invocation"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Invocation") {
                var tmp : [DescribeSendFileResultsResponseBody.Invocations.Invocation] = []
                for v in dict["Invocation"] as! [Any] {
                    var model = DescribeSendFileResultsResponseBody.Invocations.Invocation()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.invocation = tmp
            }
        }
    }
    public var invocations: DescribeSendFileResultsResponseBody.Invocations?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.invocations?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invocations != nil {
            map["Invocations"] = self.invocations?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Invocations") {
            var model = DescribeSendFileResultsResponseBody.Invocations()
            model.fromMap(dict["Invocations"] as! [String: Any])
            self.invocations = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class DescribeSendFileResultsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSendFileResultsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSendFileResultsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotGroupsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var additionalAttributes: [String]?

    public var instanceId: String?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotGroupId: [String]?

    public var status: [String]?

    public var tag: [DescribeSnapshotGroupsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.additionalAttributes != nil {
            map["AdditionalAttributes"] = self.additionalAttributes!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AdditionalAttributes") {
            self.additionalAttributes = dict["AdditionalAttributes"] as! [String]
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotGroupId") {
            self.snapshotGroupId = dict["SnapshotGroupId"] as! [String]
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! [String]
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeSnapshotGroupsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeSnapshotGroupsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeSnapshotGroupsResponseBody : Tea.TeaModel {
    public class SnapshotGroups : Tea.TeaModel {
        public class SnapshotGroup : Tea.TeaModel {
            public class Snapshots : Tea.TeaModel {
                public class Snapshot : Tea.TeaModel {
                    public class Tags : Tea.TeaModel {
                        public class Tag : Tea.TeaModel {
                            public var key: String?

                            public var value: String?

                            public override init() {
                                super.init()
                            }

                            public init(_ dict: [String: Any]) {
                                super.init()
                                self.fromMap(dict)
                            }

                            public override func validate() throws -> Void {
                            }

                            public override func toMap() -> [String : Any] {
                                var map = super.toMap()
                                if self.key != nil {
                                    map["Key"] = self.key!
                                }
                                if self.value != nil {
                                    map["Value"] = self.value!
                                }
                                return map
                            }

                            public override func fromMap(_ dict: [String: Any]) -> Void {
                                if dict.keys.contains("Key") {
                                    self.key = dict["Key"] as! String
                                }
                                if dict.keys.contains("Value") {
                                    self.value = dict["Value"] as! String
                                }
                            }
                        }
                        public var tag: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags.Tag]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.tag != nil {
                                var tmp : [Any] = []
                                for k in self.tag! {
                                    tmp.append(k.toMap())
                                }
                                map["Tag"] = tmp
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("Tag") {
                                var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags.Tag] = []
                                for v in dict["Tag"] as! [Any] {
                                    var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags.Tag()
                                    if v != nil {
                                        model.fromMap(v as! [String: Any])
                                    }
                                    tmp.append(model)
                                }
                                self.tag = tmp
                            }
                        }
                    }
                    public var available: Bool?

                    public var instantAccess: Bool?

                    public var instantAccessRetentionDays: Int32?

                    public var progress: String?

                    public var snapshotId: String?

                    public var sourceDiskId: String?

                    public var sourceDiskType: String?

                    public var tags: DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.tags?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.available != nil {
                            map["Available"] = self.available!
                        }
                        if self.instantAccess != nil {
                            map["InstantAccess"] = self.instantAccess!
                        }
                        if self.instantAccessRetentionDays != nil {
                            map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
                        }
                        if self.progress != nil {
                            map["Progress"] = self.progress!
                        }
                        if self.snapshotId != nil {
                            map["SnapshotId"] = self.snapshotId!
                        }
                        if self.sourceDiskId != nil {
                            map["SourceDiskId"] = self.sourceDiskId!
                        }
                        if self.sourceDiskType != nil {
                            map["SourceDiskType"] = self.sourceDiskType!
                        }
                        if self.tags != nil {
                            map["Tags"] = self.tags?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Available") {
                            self.available = dict["Available"] as! Bool
                        }
                        if dict.keys.contains("InstantAccess") {
                            self.instantAccess = dict["InstantAccess"] as! Bool
                        }
                        if dict.keys.contains("InstantAccessRetentionDays") {
                            self.instantAccessRetentionDays = dict["InstantAccessRetentionDays"] as! Int32
                        }
                        if dict.keys.contains("Progress") {
                            self.progress = dict["Progress"] as! String
                        }
                        if dict.keys.contains("SnapshotId") {
                            self.snapshotId = dict["SnapshotId"] as! String
                        }
                        if dict.keys.contains("SourceDiskId") {
                            self.sourceDiskId = dict["SourceDiskId"] as! String
                        }
                        if dict.keys.contains("SourceDiskType") {
                            self.sourceDiskType = dict["SourceDiskType"] as! String
                        }
                        if dict.keys.contains("Tags") {
                            var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot.Tags()
                            model.fromMap(dict["Tags"] as! [String: Any])
                            self.tags = model
                        }
                    }
                }
                public var snapshot: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.snapshot != nil {
                        var tmp : [Any] = []
                        for k in self.snapshot! {
                            tmp.append(k.toMap())
                        }
                        map["Snapshot"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Snapshot") {
                        var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot] = []
                        for v in dict["Snapshot"] as! [Any] {
                            var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots.Snapshot()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.snapshot = tmp
                    }
                }
            }
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var key: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.key != nil {
                            map["Key"] = self.key!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Key") {
                            self.key = dict["Key"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var tag: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var instanceId: String?

            public var name: String?

            public var progressStatus: String?

            public var resourceGroupId: String?

            public var snapshotGroupId: String?

            public var snapshots: DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots?

            public var status: String?

            public var tags: DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.snapshots?.validate()
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.progressStatus != nil {
                    map["ProgressStatus"] = self.progressStatus!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.snapshotGroupId != nil {
                    map["SnapshotGroupId"] = self.snapshotGroupId!
                }
                if self.snapshots != nil {
                    map["Snapshots"] = self.snapshots?.toMap()
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("ProgressStatus") {
                    self.progressStatus = dict["ProgressStatus"] as! String
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("SnapshotGroupId") {
                    self.snapshotGroupId = dict["SnapshotGroupId"] as! String
                }
                if dict.keys.contains("Snapshots") {
                    var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Snapshots()
                    model.fromMap(dict["Snapshots"] as! [String: Any])
                    self.snapshots = model
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var snapshotGroup: [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotGroup != nil {
                var tmp : [Any] = []
                for k in self.snapshotGroup! {
                    tmp.append(k.toMap())
                }
                map["SnapshotGroup"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnapshotGroup") {
                var tmp : [DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup] = []
                for v in dict["SnapshotGroup"] as! [Any] {
                    var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups.SnapshotGroup()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.snapshotGroup = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var snapshotGroups: DescribeSnapshotGroupsResponseBody.SnapshotGroups?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotGroups?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotGroups != nil {
            map["SnapshotGroups"] = self.snapshotGroups?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotGroups") {
            var model = DescribeSnapshotGroupsResponseBody.SnapshotGroups()
            model.fromMap(dict["SnapshotGroups"] as! [String: Any])
            self.snapshotGroups = model
        }
    }
}

public class DescribeSnapshotGroupsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotGroupsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotGroupsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotLinksRequest : Tea.TeaModel {
    public var diskIds: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotLinkIds: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotLinkIds != nil {
            map["SnapshotLinkIds"] = self.snapshotLinkIds!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskIds") {
            self.diskIds = dict["DiskIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotLinkIds") {
            self.snapshotLinkIds = dict["SnapshotLinkIds"] as! String
        }
    }
}

public class DescribeSnapshotLinksResponseBody : Tea.TeaModel {
    public class SnapshotLinks : Tea.TeaModel {
        public class SnapshotLink : Tea.TeaModel {
            public var category: String?

            public var instanceId: String?

            public var instanceName: String?

            public var instantAccess: Bool?

            public var regionId: String?

            public var snapshotLinkId: String?

            public var sourceDiskId: String?

            public var sourceDiskName: String?

            public var sourceDiskSize: Int32?

            public var sourceDiskType: String?

            public var totalCount: Int32?

            public var totalSize: Int64?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceName != nil {
                    map["InstanceName"] = self.instanceName!
                }
                if self.instantAccess != nil {
                    map["InstantAccess"] = self.instantAccess!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.snapshotLinkId != nil {
                    map["SnapshotLinkId"] = self.snapshotLinkId!
                }
                if self.sourceDiskId != nil {
                    map["SourceDiskId"] = self.sourceDiskId!
                }
                if self.sourceDiskName != nil {
                    map["SourceDiskName"] = self.sourceDiskName!
                }
                if self.sourceDiskSize != nil {
                    map["SourceDiskSize"] = self.sourceDiskSize!
                }
                if self.sourceDiskType != nil {
                    map["SourceDiskType"] = self.sourceDiskType!
                }
                if self.totalCount != nil {
                    map["TotalCount"] = self.totalCount!
                }
                if self.totalSize != nil {
                    map["TotalSize"] = self.totalSize!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceName") {
                    self.instanceName = dict["InstanceName"] as! String
                }
                if dict.keys.contains("InstantAccess") {
                    self.instantAccess = dict["InstantAccess"] as! Bool
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("SnapshotLinkId") {
                    self.snapshotLinkId = dict["SnapshotLinkId"] as! String
                }
                if dict.keys.contains("SourceDiskId") {
                    self.sourceDiskId = dict["SourceDiskId"] as! String
                }
                if dict.keys.contains("SourceDiskName") {
                    self.sourceDiskName = dict["SourceDiskName"] as! String
                }
                if dict.keys.contains("SourceDiskSize") {
                    self.sourceDiskSize = dict["SourceDiskSize"] as! Int32
                }
                if dict.keys.contains("SourceDiskType") {
                    self.sourceDiskType = dict["SourceDiskType"] as! String
                }
                if dict.keys.contains("TotalCount") {
                    self.totalCount = dict["TotalCount"] as! Int32
                }
                if dict.keys.contains("TotalSize") {
                    self.totalSize = dict["TotalSize"] as! Int64
                }
            }
        }
        public var snapshotLink: [DescribeSnapshotLinksResponseBody.SnapshotLinks.SnapshotLink]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotLink != nil {
                var tmp : [Any] = []
                for k in self.snapshotLink! {
                    tmp.append(k.toMap())
                }
                map["SnapshotLink"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnapshotLink") {
                var tmp : [DescribeSnapshotLinksResponseBody.SnapshotLinks.SnapshotLink] = []
                for v in dict["SnapshotLink"] as! [Any] {
                    var model = DescribeSnapshotLinksResponseBody.SnapshotLinks.SnapshotLink()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.snapshotLink = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snapshotLinks: DescribeSnapshotLinksResponseBody.SnapshotLinks?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotLinks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotLinks != nil {
            map["SnapshotLinks"] = self.snapshotLinks?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotLinks") {
            var model = DescribeSnapshotLinksResponseBody.SnapshotLinks()
            model.fromMap(dict["SnapshotLinks"] as! [String: Any])
            self.snapshotLinks = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSnapshotLinksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotLinksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotLinksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotMonitorDataRequest : Tea.TeaModel {
    public var category: String?

    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class DescribeSnapshotMonitorDataResponseBody : Tea.TeaModel {
    public class MonitorData : Tea.TeaModel {
        public class DataPoint : Tea.TeaModel {
            public var size: Int64?

            public var timeStamp: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.size != nil {
                    map["Size"] = self.size!
                }
                if self.timeStamp != nil {
                    map["TimeStamp"] = self.timeStamp!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Size") {
                    self.size = dict["Size"] as! Int64
                }
                if dict.keys.contains("TimeStamp") {
                    self.timeStamp = dict["TimeStamp"] as! String
                }
            }
        }
        public var dataPoint: [DescribeSnapshotMonitorDataResponseBody.MonitorData.DataPoint]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dataPoint != nil {
                var tmp : [Any] = []
                for k in self.dataPoint! {
                    tmp.append(k.toMap())
                }
                map["DataPoint"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DataPoint") {
                var tmp : [DescribeSnapshotMonitorDataResponseBody.MonitorData.DataPoint] = []
                for v in dict["DataPoint"] as! [Any] {
                    var model = DescribeSnapshotMonitorDataResponseBody.MonitorData.DataPoint()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.dataPoint = tmp
            }
        }
    }
    public var monitorData: DescribeSnapshotMonitorDataResponseBody.MonitorData?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.monitorData?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.monitorData != nil {
            map["MonitorData"] = self.monitorData?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("MonitorData") {
            var model = DescribeSnapshotMonitorDataResponseBody.MonitorData()
            model.fromMap(dict["MonitorData"] as! [String: Any])
            self.monitorData = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSnapshotMonitorDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotMonitorDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotMonitorDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotPackageRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeSnapshotPackageResponseBody : Tea.TeaModel {
    public class SnapshotPackages : Tea.TeaModel {
        public class SnapshotPackage : Tea.TeaModel {
            public var displayName: String?

            public var endTime: String?

            public var initCapacity: Int64?

            public var startTime: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.displayName != nil {
                    map["DisplayName"] = self.displayName!
                }
                if self.endTime != nil {
                    map["EndTime"] = self.endTime!
                }
                if self.initCapacity != nil {
                    map["InitCapacity"] = self.initCapacity!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("DisplayName") {
                    self.displayName = dict["DisplayName"] as! String
                }
                if dict.keys.contains("EndTime") {
                    self.endTime = dict["EndTime"] as! String
                }
                if dict.keys.contains("InitCapacity") {
                    self.initCapacity = dict["InitCapacity"] as! Int64
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
            }
        }
        public var snapshotPackage: [DescribeSnapshotPackageResponseBody.SnapshotPackages.SnapshotPackage]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshotPackage != nil {
                var tmp : [Any] = []
                for k in self.snapshotPackage! {
                    tmp.append(k.toMap())
                }
                map["SnapshotPackage"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SnapshotPackage") {
                var tmp : [DescribeSnapshotPackageResponseBody.SnapshotPackages.SnapshotPackage] = []
                for v in dict["SnapshotPackage"] as! [Any] {
                    var model = DescribeSnapshotPackageResponseBody.SnapshotPackages.SnapshotPackage()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.snapshotPackage = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snapshotPackages: DescribeSnapshotPackageResponseBody.SnapshotPackages?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshotPackages?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotPackages != nil {
            map["SnapshotPackages"] = self.snapshotPackages?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotPackages") {
            var model = DescribeSnapshotPackageResponseBody.SnapshotPackages()
            model.fromMap(dict["SnapshotPackages"] as! [String: Any])
            self.snapshotPackages = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSnapshotPackageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotPackageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotPackageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotsRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var filter: [DescribeSnapshotsRequest.Filter]?

    public var category: String?

    public var diskId: String?

    public var dryRun: Bool?

    public var encrypted: Bool?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotIds: String?

    public var snapshotLinkId: String?

    public var snapshotName: String?

    public var snapshotType: String?

    public var sourceDiskType: String?

    public var status: String?

    public var tag: [DescribeSnapshotsRequest.Tag]?

    public var usage: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotIds != nil {
            map["SnapshotIds"] = self.snapshotIds!
        }
        if self.snapshotLinkId != nil {
            map["SnapshotLinkId"] = self.snapshotLinkId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        if self.snapshotType != nil {
            map["SnapshotType"] = self.snapshotType!
        }
        if self.sourceDiskType != nil {
            map["SourceDiskType"] = self.sourceDiskType!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.usage != nil {
            map["Usage"] = self.usage!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeSnapshotsRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeSnapshotsRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotIds") {
            self.snapshotIds = dict["SnapshotIds"] as! String
        }
        if dict.keys.contains("SnapshotLinkId") {
            self.snapshotLinkId = dict["SnapshotLinkId"] as! String
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
        if dict.keys.contains("SnapshotType") {
            self.snapshotType = dict["SnapshotType"] as! String
        }
        if dict.keys.contains("SourceDiskType") {
            self.sourceDiskType = dict["SourceDiskType"] as! String
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeSnapshotsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeSnapshotsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Usage") {
            self.usage = dict["Usage"] as! String
        }
    }
}

public class DescribeSnapshotsResponseBody : Tea.TeaModel {
    public class Snapshots : Tea.TeaModel {
        public class Snapshot : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var available: Bool?

            public var category: String?

            public var creationTime: String?

            public var description_: String?

            public var encrypted: Bool?

            public var instantAccess: Bool?

            public var instantAccessRetentionDays: Int32?

            public var KMSKeyId: String?

            public var lastModifiedTime: String?

            public var productCode: String?

            public var progress: String?

            public var regionId: String?

            public var remainTime: Int32?

            public var resourceGroupId: String?

            public var retentionDays: Int32?

            public var snapshotId: String?

            public var snapshotLinkId: String?

            public var snapshotName: String?

            public var snapshotSN: String?

            public var snapshotType: String?

            public var sourceDiskId: String?

            public var sourceDiskSize: String?

            public var sourceDiskType: String?

            public var sourceRegionId: String?

            public var sourceSnapshotId: String?

            public var sourceStorageType: String?

            public var status: String?

            public var tags: DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags?

            public var usage: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.available != nil {
                    map["Available"] = self.available!
                }
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.encrypted != nil {
                    map["Encrypted"] = self.encrypted!
                }
                if self.instantAccess != nil {
                    map["InstantAccess"] = self.instantAccess!
                }
                if self.instantAccessRetentionDays != nil {
                    map["InstantAccessRetentionDays"] = self.instantAccessRetentionDays!
                }
                if self.KMSKeyId != nil {
                    map["KMSKeyId"] = self.KMSKeyId!
                }
                if self.lastModifiedTime != nil {
                    map["LastModifiedTime"] = self.lastModifiedTime!
                }
                if self.productCode != nil {
                    map["ProductCode"] = self.productCode!
                }
                if self.progress != nil {
                    map["Progress"] = self.progress!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.remainTime != nil {
                    map["RemainTime"] = self.remainTime!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.retentionDays != nil {
                    map["RetentionDays"] = self.retentionDays!
                }
                if self.snapshotId != nil {
                    map["SnapshotId"] = self.snapshotId!
                }
                if self.snapshotLinkId != nil {
                    map["SnapshotLinkId"] = self.snapshotLinkId!
                }
                if self.snapshotName != nil {
                    map["SnapshotName"] = self.snapshotName!
                }
                if self.snapshotSN != nil {
                    map["SnapshotSN"] = self.snapshotSN!
                }
                if self.snapshotType != nil {
                    map["SnapshotType"] = self.snapshotType!
                }
                if self.sourceDiskId != nil {
                    map["SourceDiskId"] = self.sourceDiskId!
                }
                if self.sourceDiskSize != nil {
                    map["SourceDiskSize"] = self.sourceDiskSize!
                }
                if self.sourceDiskType != nil {
                    map["SourceDiskType"] = self.sourceDiskType!
                }
                if self.sourceRegionId != nil {
                    map["SourceRegionId"] = self.sourceRegionId!
                }
                if self.sourceSnapshotId != nil {
                    map["SourceSnapshotId"] = self.sourceSnapshotId!
                }
                if self.sourceStorageType != nil {
                    map["SourceStorageType"] = self.sourceStorageType!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                if self.usage != nil {
                    map["Usage"] = self.usage!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Available") {
                    self.available = dict["Available"] as! Bool
                }
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("Encrypted") {
                    self.encrypted = dict["Encrypted"] as! Bool
                }
                if dict.keys.contains("InstantAccess") {
                    self.instantAccess = dict["InstantAccess"] as! Bool
                }
                if dict.keys.contains("InstantAccessRetentionDays") {
                    self.instantAccessRetentionDays = dict["InstantAccessRetentionDays"] as! Int32
                }
                if dict.keys.contains("KMSKeyId") {
                    self.KMSKeyId = dict["KMSKeyId"] as! String
                }
                if dict.keys.contains("LastModifiedTime") {
                    self.lastModifiedTime = dict["LastModifiedTime"] as! String
                }
                if dict.keys.contains("ProductCode") {
                    self.productCode = dict["ProductCode"] as! String
                }
                if dict.keys.contains("Progress") {
                    self.progress = dict["Progress"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RemainTime") {
                    self.remainTime = dict["RemainTime"] as! Int32
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("RetentionDays") {
                    self.retentionDays = dict["RetentionDays"] as! Int32
                }
                if dict.keys.contains("SnapshotId") {
                    self.snapshotId = dict["SnapshotId"] as! String
                }
                if dict.keys.contains("SnapshotLinkId") {
                    self.snapshotLinkId = dict["SnapshotLinkId"] as! String
                }
                if dict.keys.contains("SnapshotName") {
                    self.snapshotName = dict["SnapshotName"] as! String
                }
                if dict.keys.contains("SnapshotSN") {
                    self.snapshotSN = dict["SnapshotSN"] as! String
                }
                if dict.keys.contains("SnapshotType") {
                    self.snapshotType = dict["SnapshotType"] as! String
                }
                if dict.keys.contains("SourceDiskId") {
                    self.sourceDiskId = dict["SourceDiskId"] as! String
                }
                if dict.keys.contains("SourceDiskSize") {
                    self.sourceDiskSize = dict["SourceDiskSize"] as! String
                }
                if dict.keys.contains("SourceDiskType") {
                    self.sourceDiskType = dict["SourceDiskType"] as! String
                }
                if dict.keys.contains("SourceRegionId") {
                    self.sourceRegionId = dict["SourceRegionId"] as! String
                }
                if dict.keys.contains("SourceSnapshotId") {
                    self.sourceSnapshotId = dict["SourceSnapshotId"] as! String
                }
                if dict.keys.contains("SourceStorageType") {
                    self.sourceStorageType = dict["SourceStorageType"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeSnapshotsResponseBody.Snapshots.Snapshot.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
                if dict.keys.contains("Usage") {
                    self.usage = dict["Usage"] as! String
                }
            }
        }
        public var snapshot: [DescribeSnapshotsResponseBody.Snapshots.Snapshot]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.snapshot != nil {
                var tmp : [Any] = []
                for k in self.snapshot! {
                    tmp.append(k.toMap())
                }
                map["Snapshot"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Snapshot") {
                var tmp : [DescribeSnapshotsResponseBody.Snapshots.Snapshot] = []
                for v in dict["Snapshot"] as! [Any] {
                    var model = DescribeSnapshotsResponseBody.Snapshots.Snapshot()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.snapshot = tmp
            }
        }
    }
    public var nextToken: String?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var snapshots: DescribeSnapshotsResponseBody.Snapshots?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.snapshots?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshots != nil {
            map["Snapshots"] = self.snapshots?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Snapshots") {
            var model = DescribeSnapshotsResponseBody.Snapshots()
            model.fromMap(dict["Snapshots"] as! [String: Any])
            self.snapshots = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeSnapshotsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSnapshotsUsageRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeSnapshotsUsageResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var snapshotCount: Int32?

    public var snapshotSize: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.snapshotCount != nil {
            map["SnapshotCount"] = self.snapshotCount!
        }
        if self.snapshotSize != nil {
            map["SnapshotSize"] = self.snapshotSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SnapshotCount") {
            self.snapshotCount = dict["SnapshotCount"] as! Int32
        }
        if dict.keys.contains("SnapshotSize") {
            self.snapshotSize = dict["SnapshotSize"] as! Int64
        }
    }
}

public class DescribeSnapshotsUsageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSnapshotsUsageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSnapshotsUsageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSpotAdviceRequest : Tea.TeaModel {
    public var cores: Int32?

    public var gpuAmount: Int32?

    public var gpuSpec: String?

    public var instanceFamilyLevel: String?

    public var instanceTypeFamily: String?

    public var instanceTypes: [String]?

    public var memory: Double?

    public var minCores: Int32?

    public var minMemory: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cores != nil {
            map["Cores"] = self.cores!
        }
        if self.gpuAmount != nil {
            map["GpuAmount"] = self.gpuAmount!
        }
        if self.gpuSpec != nil {
            map["GpuSpec"] = self.gpuSpec!
        }
        if self.instanceFamilyLevel != nil {
            map["InstanceFamilyLevel"] = self.instanceFamilyLevel!
        }
        if self.instanceTypeFamily != nil {
            map["InstanceTypeFamily"] = self.instanceTypeFamily!
        }
        if self.instanceTypes != nil {
            map["InstanceTypes"] = self.instanceTypes!
        }
        if self.memory != nil {
            map["Memory"] = self.memory!
        }
        if self.minCores != nil {
            map["MinCores"] = self.minCores!
        }
        if self.minMemory != nil {
            map["MinMemory"] = self.minMemory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Cores") {
            self.cores = dict["Cores"] as! Int32
        }
        if dict.keys.contains("GpuAmount") {
            self.gpuAmount = dict["GpuAmount"] as! Int32
        }
        if dict.keys.contains("GpuSpec") {
            self.gpuSpec = dict["GpuSpec"] as! String
        }
        if dict.keys.contains("InstanceFamilyLevel") {
            self.instanceFamilyLevel = dict["InstanceFamilyLevel"] as! String
        }
        if dict.keys.contains("InstanceTypeFamily") {
            self.instanceTypeFamily = dict["InstanceTypeFamily"] as! String
        }
        if dict.keys.contains("InstanceTypes") {
            self.instanceTypes = dict["InstanceTypes"] as! [String]
        }
        if dict.keys.contains("Memory") {
            self.memory = dict["Memory"] as! Double
        }
        if dict.keys.contains("MinCores") {
            self.minCores = dict["MinCores"] as! Int32
        }
        if dict.keys.contains("MinMemory") {
            self.minMemory = dict["MinMemory"] as! Double
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeSpotAdviceResponseBody : Tea.TeaModel {
    public class AvailableSpotZones : Tea.TeaModel {
        public class AvailableSpotZone : Tea.TeaModel {
            public class AvailableSpotResources : Tea.TeaModel {
                public class AvailableSpotResource : Tea.TeaModel {
                    public var averageSpotDiscount: Int32?

                    public var instanceType: String?

                    public var interruptRateDesc: String?

                    public var interruptionRate: Double?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.averageSpotDiscount != nil {
                            map["AverageSpotDiscount"] = self.averageSpotDiscount!
                        }
                        if self.instanceType != nil {
                            map["InstanceType"] = self.instanceType!
                        }
                        if self.interruptRateDesc != nil {
                            map["InterruptRateDesc"] = self.interruptRateDesc!
                        }
                        if self.interruptionRate != nil {
                            map["InterruptionRate"] = self.interruptionRate!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("AverageSpotDiscount") {
                            self.averageSpotDiscount = dict["AverageSpotDiscount"] as! Int32
                        }
                        if dict.keys.contains("InstanceType") {
                            self.instanceType = dict["InstanceType"] as! String
                        }
                        if dict.keys.contains("InterruptRateDesc") {
                            self.interruptRateDesc = dict["InterruptRateDesc"] as! String
                        }
                        if dict.keys.contains("InterruptionRate") {
                            self.interruptionRate = dict["InterruptionRate"] as! Double
                        }
                    }
                }
                public var availableSpotResource: [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources.AvailableSpotResource]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.availableSpotResource != nil {
                        var tmp : [Any] = []
                        for k in self.availableSpotResource! {
                            tmp.append(k.toMap())
                        }
                        map["AvailableSpotResource"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("AvailableSpotResource") {
                        var tmp : [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources.AvailableSpotResource] = []
                        for v in dict["AvailableSpotResource"] as! [Any] {
                            var model = DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources.AvailableSpotResource()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.availableSpotResource = tmp
                    }
                }
            }
            public var availableSpotResources: DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableSpotResources?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableSpotResources != nil {
                    map["AvailableSpotResources"] = self.availableSpotResources?.toMap()
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableSpotResources") {
                    var model = DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone.AvailableSpotResources()
                    model.fromMap(dict["AvailableSpotResources"] as! [String: Any])
                    self.availableSpotResources = model
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var availableSpotZone: [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.availableSpotZone != nil {
                var tmp : [Any] = []
                for k in self.availableSpotZone! {
                    tmp.append(k.toMap())
                }
                map["AvailableSpotZone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AvailableSpotZone") {
                var tmp : [DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone] = []
                for v in dict["AvailableSpotZone"] as! [Any] {
                    var model = DescribeSpotAdviceResponseBody.AvailableSpotZones.AvailableSpotZone()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.availableSpotZone = tmp
            }
        }
    }
    public var availableSpotZones: DescribeSpotAdviceResponseBody.AvailableSpotZones?

    public var regionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.availableSpotZones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.availableSpotZones != nil {
            map["AvailableSpotZones"] = self.availableSpotZones?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AvailableSpotZones") {
            var model = DescribeSpotAdviceResponseBody.AvailableSpotZones()
            model.fromMap(dict["AvailableSpotZones"] as! [String: Any])
            self.availableSpotZones = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DescribeSpotAdviceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSpotAdviceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSpotAdviceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeSpotPriceHistoryRequest : Tea.TeaModel {
    public var endTime: String?

    public var instanceType: String?

    public var ioOptimized: String?

    public var networkType: String?

    public var OSType: String?

    public var offset: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotDuration: Int32?

    public var startTime: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.networkType != nil {
            map["NetworkType"] = self.networkType!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.offset != nil {
            map["Offset"] = self.offset!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("NetworkType") {
            self.networkType = dict["NetworkType"] as! String
        }
        if dict.keys.contains("OSType") {
            self.OSType = dict["OSType"] as! String
        }
        if dict.keys.contains("Offset") {
            self.offset = dict["Offset"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeSpotPriceHistoryResponseBody : Tea.TeaModel {
    public class SpotPrices : Tea.TeaModel {
        public class SpotPriceType : Tea.TeaModel {
            public var instanceType: String?

            public var ioOptimized: String?

            public var networkType: String?

            public var originPrice: Double?

            public var spotPrice: Double?

            public var timestamp: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceType != nil {
                    map["InstanceType"] = self.instanceType!
                }
                if self.ioOptimized != nil {
                    map["IoOptimized"] = self.ioOptimized!
                }
                if self.networkType != nil {
                    map["NetworkType"] = self.networkType!
                }
                if self.originPrice != nil {
                    map["OriginPrice"] = self.originPrice!
                }
                if self.spotPrice != nil {
                    map["SpotPrice"] = self.spotPrice!
                }
                if self.timestamp != nil {
                    map["Timestamp"] = self.timestamp!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceType") {
                    self.instanceType = dict["InstanceType"] as! String
                }
                if dict.keys.contains("IoOptimized") {
                    self.ioOptimized = dict["IoOptimized"] as! String
                }
                if dict.keys.contains("NetworkType") {
                    self.networkType = dict["NetworkType"] as! String
                }
                if dict.keys.contains("OriginPrice") {
                    self.originPrice = dict["OriginPrice"] as! Double
                }
                if dict.keys.contains("SpotPrice") {
                    self.spotPrice = dict["SpotPrice"] as! Double
                }
                if dict.keys.contains("Timestamp") {
                    self.timestamp = dict["Timestamp"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var spotPriceType: [DescribeSpotPriceHistoryResponseBody.SpotPrices.SpotPriceType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.spotPriceType != nil {
                var tmp : [Any] = []
                for k in self.spotPriceType! {
                    tmp.append(k.toMap())
                }
                map["SpotPriceType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SpotPriceType") {
                var tmp : [DescribeSpotPriceHistoryResponseBody.SpotPrices.SpotPriceType] = []
                for v in dict["SpotPriceType"] as! [Any] {
                    var model = DescribeSpotPriceHistoryResponseBody.SpotPrices.SpotPriceType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.spotPriceType = tmp
            }
        }
    }
    public var currency: String?

    public var nextOffset: Int32?

    public var requestId: String?

    public var spotPrices: DescribeSpotPriceHistoryResponseBody.SpotPrices?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.spotPrices?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.currency != nil {
            map["Currency"] = self.currency!
        }
        if self.nextOffset != nil {
            map["NextOffset"] = self.nextOffset!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spotPrices != nil {
            map["SpotPrices"] = self.spotPrices?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Currency") {
            self.currency = dict["Currency"] as! String
        }
        if dict.keys.contains("NextOffset") {
            self.nextOffset = dict["NextOffset"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SpotPrices") {
            var model = DescribeSpotPriceHistoryResponseBody.SpotPrices()
            model.fromMap(dict["SpotPrices"] as! [String: Any])
            self.spotPrices = model
        }
    }
}

public class DescribeSpotPriceHistoryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeSpotPriceHistoryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeSpotPriceHistoryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageCapacityUnitsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var allocationType: String?

    public var capacity: Int32?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: [String]?

    public var storageCapacityUnitId: [String]?

    public var tag: [DescribeStorageCapacityUnitsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationType != nil {
            map["AllocationType"] = self.allocationType!
        }
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        if self.storageCapacityUnitId != nil {
            map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationType") {
            self.allocationType = dict["AllocationType"] as! String
        }
        if dict.keys.contains("Capacity") {
            self.capacity = dict["Capacity"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! [String]
        }
        if dict.keys.contains("StorageCapacityUnitId") {
            self.storageCapacityUnitId = dict["StorageCapacityUnitId"] as! [String]
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeStorageCapacityUnitsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeStorageCapacityUnitsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeStorageCapacityUnitsResponseBody : Tea.TeaModel {
    public class StorageCapacityUnits : Tea.TeaModel {
        public class StorageCapacityUnit : Tea.TeaModel {
            public class Tags : Tea.TeaModel {
                public class Tag : Tea.TeaModel {
                    public var tagKey: String?

                    public var tagValue: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.tagKey != nil {
                            map["TagKey"] = self.tagKey!
                        }
                        if self.tagValue != nil {
                            map["TagValue"] = self.tagValue!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("TagKey") {
                            self.tagKey = dict["TagKey"] as! String
                        }
                        if dict.keys.contains("TagValue") {
                            self.tagValue = dict["TagValue"] as! String
                        }
                    }
                }
                public var tag: [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags.Tag]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.tag != nil {
                        var tmp : [Any] = []
                        for k in self.tag! {
                            tmp.append(k.toMap())
                        }
                        map["Tag"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Tag") {
                        var tmp : [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags.Tag] = []
                        for v in dict["Tag"] as! [Any] {
                            var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags.Tag()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.tag = tmp
                    }
                }
            }
            public var allocationStatus: String?

            public var capacity: Int32?

            public var creationTime: String?

            public var description_: String?

            public var expiredTime: String?

            public var name: String?

            public var regionId: String?

            public var startTime: String?

            public var status: String?

            public var storageCapacityUnitId: String?

            public var tags: DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.tags?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.allocationStatus != nil {
                    map["AllocationStatus"] = self.allocationStatus!
                }
                if self.capacity != nil {
                    map["Capacity"] = self.capacity!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.expiredTime != nil {
                    map["ExpiredTime"] = self.expiredTime!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.startTime != nil {
                    map["StartTime"] = self.startTime!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.storageCapacityUnitId != nil {
                    map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
                }
                if self.tags != nil {
                    map["Tags"] = self.tags?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AllocationStatus") {
                    self.allocationStatus = dict["AllocationStatus"] as! String
                }
                if dict.keys.contains("Capacity") {
                    self.capacity = dict["Capacity"] as! Int32
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("ExpiredTime") {
                    self.expiredTime = dict["ExpiredTime"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StartTime") {
                    self.startTime = dict["StartTime"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("StorageCapacityUnitId") {
                    self.storageCapacityUnitId = dict["StorageCapacityUnitId"] as! String
                }
                if dict.keys.contains("Tags") {
                    var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit.Tags()
                    model.fromMap(dict["Tags"] as! [String: Any])
                    self.tags = model
                }
            }
        }
        public var storageCapacityUnit: [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageCapacityUnit != nil {
                var tmp : [Any] = []
                for k in self.storageCapacityUnit! {
                    tmp.append(k.toMap())
                }
                map["StorageCapacityUnit"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageCapacityUnit") {
                var tmp : [DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit] = []
                for v in dict["StorageCapacityUnit"] as! [Any] {
                    var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits.StorageCapacityUnit()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.storageCapacityUnit = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var storageCapacityUnits: DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageCapacityUnits?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageCapacityUnits != nil {
            map["StorageCapacityUnits"] = self.storageCapacityUnits?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageCapacityUnits") {
            var model = DescribeStorageCapacityUnitsResponseBody.StorageCapacityUnits()
            model.fromMap(dict["StorageCapacityUnits"] as! [String: Any])
            self.storageCapacityUnits = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeStorageCapacityUnitsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageCapacityUnitsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageCapacityUnitsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageSetDetailsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diskIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DiskIds") {
            self.diskIds = dict["DiskIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
    }
}

public class DescribeStorageSetDetailsResponseBody : Tea.TeaModel {
    public class Disks : Tea.TeaModel {
        public class Disk : Tea.TeaModel {
            public var category: String?

            public var creationTime: String?

            public var diskId: String?

            public var diskName: String?

            public var regionId: String?

            public var storageSetId: String?

            public var storageSetPartitionNumber: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.category != nil {
                    map["Category"] = self.category!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.diskId != nil {
                    map["DiskId"] = self.diskId!
                }
                if self.diskName != nil {
                    map["DiskName"] = self.diskName!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Category") {
                    self.category = dict["Category"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("DiskId") {
                    self.diskId = dict["DiskId"] as! String
                }
                if dict.keys.contains("DiskName") {
                    self.diskName = dict["DiskName"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StorageSetId") {
                    self.storageSetId = dict["StorageSetId"] as! String
                }
                if dict.keys.contains("StorageSetPartitionNumber") {
                    self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var disk: [DescribeStorageSetDetailsResponseBody.Disks.Disk]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.disk != nil {
                var tmp : [Any] = []
                for k in self.disk! {
                    tmp.append(k.toMap())
                }
                map["Disk"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Disk") {
                var tmp : [DescribeStorageSetDetailsResponseBody.Disks.Disk] = []
                for v in dict["Disk"] as! [Any] {
                    var model = DescribeStorageSetDetailsResponseBody.Disks.Disk()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.disk = tmp
            }
        }
    }
    public var disks: DescribeStorageSetDetailsResponseBody.Disks?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.disks?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disks != nil {
            map["Disks"] = self.disks?.toMap()
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Disks") {
            var model = DescribeStorageSetDetailsResponseBody.Disks()
            model.fromMap(dict["Disks"] as! [String: Any])
            self.disks = model
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeStorageSetDetailsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageSetDetailsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageSetDetailsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeStorageSetsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetIds: String?

    public var storageSetName: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetIds != nil {
            map["StorageSetIds"] = self.storageSetIds!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetIds") {
            self.storageSetIds = dict["StorageSetIds"] as! String
        }
        if dict.keys.contains("StorageSetName") {
            self.storageSetName = dict["StorageSetName"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeStorageSetsResponseBody : Tea.TeaModel {
    public class StorageSets : Tea.TeaModel {
        public class StorageSet : Tea.TeaModel {
            public var creationTime: String?

            public var description_: String?

            public var regionId: String?

            public var storageSetId: String?

            public var storageSetName: String?

            public var storageSetPartitionNumber: Int32?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.storageSetId != nil {
                    map["StorageSetId"] = self.storageSetId!
                }
                if self.storageSetName != nil {
                    map["StorageSetName"] = self.storageSetName!
                }
                if self.storageSetPartitionNumber != nil {
                    map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("StorageSetId") {
                    self.storageSetId = dict["StorageSetId"] as! String
                }
                if dict.keys.contains("StorageSetName") {
                    self.storageSetName = dict["StorageSetName"] as! String
                }
                if dict.keys.contains("StorageSetPartitionNumber") {
                    self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var storageSet: [DescribeStorageSetsResponseBody.StorageSets.StorageSet]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageSet != nil {
                var tmp : [Any] = []
                for k in self.storageSet! {
                    tmp.append(k.toMap())
                }
                map["StorageSet"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageSet") {
                var tmp : [DescribeStorageSetsResponseBody.StorageSets.StorageSet] = []
                for v in dict["StorageSet"] as! [Any] {
                    var model = DescribeStorageSetsResponseBody.StorageSets.StorageSet()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.storageSet = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var storageSets: DescribeStorageSetsResponseBody.StorageSets?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageSets != nil {
            map["StorageSets"] = self.storageSets?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageSets") {
            var model = DescribeStorageSetsResponseBody.StorageSets()
            model.fromMap(dict["StorageSets"] as! [String: Any])
            self.storageSets = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeStorageSetsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeStorageSetsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeStorageSetsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var category: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [DescribeTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.category != nil {
            map["Category"] = self.category!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Category") {
            self.category = dict["Category"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [DescribeTagsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = DescribeTagsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class DescribeTagsResponseBody : Tea.TeaModel {
    public class Tags : Tea.TeaModel {
        public class Tag : Tea.TeaModel {
            public class ResourceTypeCount : Tea.TeaModel {
                public var ddh: Int32?

                public var disk: Int32?

                public var eni: Int32?

                public var image: Int32?

                public var instance: Int32?

                public var keyPair: Int32?

                public var launchTemplate: Int32?

                public var reservedInstance: Int32?

                public var securitygroup: Int32?

                public var snapshot: Int32?

                public var snapshotPolicy: Int32?

                public var volume: Int32?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.ddh != nil {
                        map["Ddh"] = self.ddh!
                    }
                    if self.disk != nil {
                        map["Disk"] = self.disk!
                    }
                    if self.eni != nil {
                        map["Eni"] = self.eni!
                    }
                    if self.image != nil {
                        map["Image"] = self.image!
                    }
                    if self.instance != nil {
                        map["Instance"] = self.instance!
                    }
                    if self.keyPair != nil {
                        map["KeyPair"] = self.keyPair!
                    }
                    if self.launchTemplate != nil {
                        map["LaunchTemplate"] = self.launchTemplate!
                    }
                    if self.reservedInstance != nil {
                        map["ReservedInstance"] = self.reservedInstance!
                    }
                    if self.securitygroup != nil {
                        map["Securitygroup"] = self.securitygroup!
                    }
                    if self.snapshot != nil {
                        map["Snapshot"] = self.snapshot!
                    }
                    if self.snapshotPolicy != nil {
                        map["SnapshotPolicy"] = self.snapshotPolicy!
                    }
                    if self.volume != nil {
                        map["Volume"] = self.volume!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Ddh") {
                        self.ddh = dict["Ddh"] as! Int32
                    }
                    if dict.keys.contains("Disk") {
                        self.disk = dict["Disk"] as! Int32
                    }
                    if dict.keys.contains("Eni") {
                        self.eni = dict["Eni"] as! Int32
                    }
                    if dict.keys.contains("Image") {
                        self.image = dict["Image"] as! Int32
                    }
                    if dict.keys.contains("Instance") {
                        self.instance = dict["Instance"] as! Int32
                    }
                    if dict.keys.contains("KeyPair") {
                        self.keyPair = dict["KeyPair"] as! Int32
                    }
                    if dict.keys.contains("LaunchTemplate") {
                        self.launchTemplate = dict["LaunchTemplate"] as! Int32
                    }
                    if dict.keys.contains("ReservedInstance") {
                        self.reservedInstance = dict["ReservedInstance"] as! Int32
                    }
                    if dict.keys.contains("Securitygroup") {
                        self.securitygroup = dict["Securitygroup"] as! Int32
                    }
                    if dict.keys.contains("Snapshot") {
                        self.snapshot = dict["Snapshot"] as! Int32
                    }
                    if dict.keys.contains("SnapshotPolicy") {
                        self.snapshotPolicy = dict["SnapshotPolicy"] as! Int32
                    }
                    if dict.keys.contains("Volume") {
                        self.volume = dict["Volume"] as! Int32
                    }
                }
            }
            public var resourceTypeCount: DescribeTagsResponseBody.Tags.Tag.ResourceTypeCount?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.resourceTypeCount?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceTypeCount != nil {
                    map["ResourceTypeCount"] = self.resourceTypeCount?.toMap()
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceTypeCount") {
                    var model = DescribeTagsResponseBody.Tags.Tag.ResourceTypeCount()
                    model.fromMap(dict["ResourceTypeCount"] as! [String: Any])
                    self.resourceTypeCount = model
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tag: [DescribeTagsResponseBody.Tags.Tag]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tag != nil {
                var tmp : [Any] = []
                for k in self.tag! {
                    tmp.append(k.toMap())
                }
                map["Tag"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Tag") {
                var tmp : [DescribeTagsResponseBody.Tags.Tag] = []
                for v in dict["Tag"] as! [Any] {
                    var model = DescribeTagsResponseBody.Tags.Tag()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tag = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var tags: DescribeTagsResponseBody.Tags?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tags?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tags != nil {
            map["Tags"] = self.tags?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Tags") {
            var model = DescribeTagsResponseBody.Tags()
            model.fromMap(dict["Tags"] as! [String: Any])
            self.tags = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTaskAttributeRequest : Tea.TeaModel {
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class DescribeTaskAttributeResponseBody : Tea.TeaModel {
    public class OperationProgressSet : Tea.TeaModel {
        public class OperationProgress : Tea.TeaModel {
            public class RelatedItemSet : Tea.TeaModel {
                public class RelatedItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var relatedItem: [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relatedItem != nil {
                        var tmp : [Any] = []
                        for k in self.relatedItem! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RelatedItem") {
                        var tmp : [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem] = []
                        for v in dict["RelatedItem"] as! [Any] {
                            var model = DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.relatedItem = tmp
                    }
                }
            }
            public var errorCode: String?

            public var errorMsg: String?

            public var operationStatus: String?

            public var relatedItemSet: DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.relatedItemSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.operationStatus != nil {
                    map["OperationStatus"] = self.operationStatus!
                }
                if self.relatedItemSet != nil {
                    map["RelatedItemSet"] = self.relatedItemSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("OperationStatus") {
                    self.operationStatus = dict["OperationStatus"] as! String
                }
                if dict.keys.contains("RelatedItemSet") {
                    var model = DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet()
                    model.fromMap(dict["RelatedItemSet"] as! [String: Any])
                    self.relatedItemSet = model
                }
            }
        }
        public var operationProgress: [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationProgress != nil {
                var tmp : [Any] = []
                for k in self.operationProgress! {
                    tmp.append(k.toMap())
                }
                map["OperationProgress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OperationProgress") {
                var tmp : [DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress] = []
                for v in dict["OperationProgress"] as! [Any] {
                    var model = DescribeTaskAttributeResponseBody.OperationProgressSet.OperationProgress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operationProgress = tmp
            }
        }
    }
    public var creationTime: String?

    public var failedCount: Int32?

    public var finishedTime: String?

    public var operationProgressSet: DescribeTaskAttributeResponseBody.OperationProgressSet?

    public var regionId: String?

    public var requestId: String?

    public var successCount: Int32?

    public var supportCancel: String?

    public var taskAction: String?

    public var taskId: String?

    public var taskProcess: String?

    public var taskStatus: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operationProgressSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.creationTime != nil {
            map["CreationTime"] = self.creationTime!
        }
        if self.failedCount != nil {
            map["FailedCount"] = self.failedCount!
        }
        if self.finishedTime != nil {
            map["FinishedTime"] = self.finishedTime!
        }
        if self.operationProgressSet != nil {
            map["OperationProgressSet"] = self.operationProgressSet?.toMap()
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.successCount != nil {
            map["SuccessCount"] = self.successCount!
        }
        if self.supportCancel != nil {
            map["SupportCancel"] = self.supportCancel!
        }
        if self.taskAction != nil {
            map["TaskAction"] = self.taskAction!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        if self.taskProcess != nil {
            map["TaskProcess"] = self.taskProcess!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CreationTime") {
            self.creationTime = dict["CreationTime"] as! String
        }
        if dict.keys.contains("FailedCount") {
            self.failedCount = dict["FailedCount"] as! Int32
        }
        if dict.keys.contains("FinishedTime") {
            self.finishedTime = dict["FinishedTime"] as! String
        }
        if dict.keys.contains("OperationProgressSet") {
            var model = DescribeTaskAttributeResponseBody.OperationProgressSet()
            model.fromMap(dict["OperationProgressSet"] as! [String: Any])
            self.operationProgressSet = model
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SuccessCount") {
            self.successCount = dict["SuccessCount"] as! Int32
        }
        if dict.keys.contains("SupportCancel") {
            self.supportCancel = dict["SupportCancel"] as! String
        }
        if dict.keys.contains("TaskAction") {
            self.taskAction = dict["TaskAction"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
        if dict.keys.contains("TaskProcess") {
            self.taskProcess = dict["TaskProcess"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTaskAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTaskAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTaskAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTasksRequest : Tea.TeaModel {
    public var endTime: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceIds: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var taskAction: String?

    public var taskIds: String?

    public var taskStatus: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceIds != nil {
            map["ResourceIds"] = self.resourceIds!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.taskAction != nil {
            map["TaskAction"] = self.taskAction!
        }
        if self.taskIds != nil {
            map["TaskIds"] = self.taskIds!
        }
        if self.taskStatus != nil {
            map["TaskStatus"] = self.taskStatus!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceIds") {
            self.resourceIds = dict["ResourceIds"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("TaskAction") {
            self.taskAction = dict["TaskAction"] as! String
        }
        if dict.keys.contains("TaskIds") {
            self.taskIds = dict["TaskIds"] as! String
        }
        if dict.keys.contains("TaskStatus") {
            self.taskStatus = dict["TaskStatus"] as! String
        }
    }
}

public class DescribeTasksResponseBody : Tea.TeaModel {
    public class TaskSet : Tea.TeaModel {
        public class Task : Tea.TeaModel {
            public var creationTime: String?

            public var finishedTime: String?

            public var resourceId: String?

            public var supportCancel: String?

            public var taskAction: String?

            public var taskId: String?

            public var taskStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.finishedTime != nil {
                    map["FinishedTime"] = self.finishedTime!
                }
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.supportCancel != nil {
                    map["SupportCancel"] = self.supportCancel!
                }
                if self.taskAction != nil {
                    map["TaskAction"] = self.taskAction!
                }
                if self.taskId != nil {
                    map["TaskId"] = self.taskId!
                }
                if self.taskStatus != nil {
                    map["TaskStatus"] = self.taskStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("FinishedTime") {
                    self.finishedTime = dict["FinishedTime"] as! String
                }
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("SupportCancel") {
                    self.supportCancel = dict["SupportCancel"] as! String
                }
                if dict.keys.contains("TaskAction") {
                    self.taskAction = dict["TaskAction"] as! String
                }
                if dict.keys.contains("TaskId") {
                    self.taskId = dict["TaskId"] as! String
                }
                if dict.keys.contains("TaskStatus") {
                    self.taskStatus = dict["TaskStatus"] as! String
                }
            }
        }
        public var task: [DescribeTasksResponseBody.TaskSet.Task]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.task != nil {
                var tmp : [Any] = []
                for k in self.task! {
                    tmp.append(k.toMap())
                }
                map["Task"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Task") {
                var tmp : [DescribeTasksResponseBody.TaskSet.Task] = []
                for v in dict["Task"] as! [Any] {
                    var model = DescribeTasksResponseBody.TaskSet.Task()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.task = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var requestId: String?

    public var taskSet: DescribeTasksResponseBody.TaskSet?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.taskSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskSet != nil {
            map["TaskSet"] = self.taskSet?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskSet") {
            var model = DescribeTasksResponseBody.TaskSet()
            model.fromMap(dict["TaskSet"] as! [String: Any])
            self.taskSet = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DescribeTasksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTasksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTasksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeTerminalSessionsRequest : Tea.TeaModel {
    public var instanceId: String?

    public var maxResults: Int32?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var sessionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
    }
}

public class DescribeTerminalSessionsResponseBody : Tea.TeaModel {
    public class Sessions : Tea.TeaModel {
        public class Session : Tea.TeaModel {
            public class Connections : Tea.TeaModel {
                public class Connection : Tea.TeaModel {
                    public var closedReason: String?

                    public var endTime: String?

                    public var instanceId: String?

                    public var startTime: String?

                    public var status: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.closedReason != nil {
                            map["ClosedReason"] = self.closedReason!
                        }
                        if self.endTime != nil {
                            map["EndTime"] = self.endTime!
                        }
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.startTime != nil {
                            map["StartTime"] = self.startTime!
                        }
                        if self.status != nil {
                            map["Status"] = self.status!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("ClosedReason") {
                            self.closedReason = dict["ClosedReason"] as! String
                        }
                        if dict.keys.contains("EndTime") {
                            self.endTime = dict["EndTime"] as! String
                        }
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("StartTime") {
                            self.startTime = dict["StartTime"] as! String
                        }
                        if dict.keys.contains("Status") {
                            self.status = dict["Status"] as! String
                        }
                    }
                }
                public var connection: [DescribeTerminalSessionsResponseBody.Sessions.Session.Connections.Connection]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.connection != nil {
                        var tmp : [Any] = []
                        for k in self.connection! {
                            tmp.append(k.toMap())
                        }
                        map["Connection"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("Connection") {
                        var tmp : [DescribeTerminalSessionsResponseBody.Sessions.Session.Connections.Connection] = []
                        for v in dict["Connection"] as! [Any] {
                            var model = DescribeTerminalSessionsResponseBody.Sessions.Session.Connections.Connection()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.connection = tmp
                    }
                }
            }
            public var clientIP: String?

            public var connections: DescribeTerminalSessionsResponseBody.Sessions.Session.Connections?

            public var creationTime: String?

            public var identityType: String?

            public var portNumber: Int32?

            public var principalId: String?

            public var sessionId: String?

            public var targetServer: String?

            public var username: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.connections?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.clientIP != nil {
                    map["ClientIP"] = self.clientIP!
                }
                if self.connections != nil {
                    map["Connections"] = self.connections?.toMap()
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.identityType != nil {
                    map["IdentityType"] = self.identityType!
                }
                if self.portNumber != nil {
                    map["PortNumber"] = self.portNumber!
                }
                if self.principalId != nil {
                    map["PrincipalId"] = self.principalId!
                }
                if self.sessionId != nil {
                    map["SessionId"] = self.sessionId!
                }
                if self.targetServer != nil {
                    map["TargetServer"] = self.targetServer!
                }
                if self.username != nil {
                    map["Username"] = self.username!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ClientIP") {
                    self.clientIP = dict["ClientIP"] as! String
                }
                if dict.keys.contains("Connections") {
                    var model = DescribeTerminalSessionsResponseBody.Sessions.Session.Connections()
                    model.fromMap(dict["Connections"] as! [String: Any])
                    self.connections = model
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("IdentityType") {
                    self.identityType = dict["IdentityType"] as! String
                }
                if dict.keys.contains("PortNumber") {
                    self.portNumber = dict["PortNumber"] as! Int32
                }
                if dict.keys.contains("PrincipalId") {
                    self.principalId = dict["PrincipalId"] as! String
                }
                if dict.keys.contains("SessionId") {
                    self.sessionId = dict["SessionId"] as! String
                }
                if dict.keys.contains("TargetServer") {
                    self.targetServer = dict["TargetServer"] as! String
                }
                if dict.keys.contains("Username") {
                    self.username = dict["Username"] as! String
                }
            }
        }
        public var session: [DescribeTerminalSessionsResponseBody.Sessions.Session]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.session != nil {
                var tmp : [Any] = []
                for k in self.session! {
                    tmp.append(k.toMap())
                }
                map["Session"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Session") {
                var tmp : [DescribeTerminalSessionsResponseBody.Sessions.Session] = []
                for v in dict["Session"] as! [Any] {
                    var model = DescribeTerminalSessionsResponseBody.Sessions.Session()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.session = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var sessions: DescribeTerminalSessionsResponseBody.Sessions?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.sessions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.sessions != nil {
            map["Sessions"] = self.sessions?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Sessions") {
            var model = DescribeTerminalSessionsResponseBody.Sessions()
            model.fromMap(dict["Sessions"] as! [String: Any])
            self.sessions = model
        }
    }
}

public class DescribeTerminalSessionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeTerminalSessionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeTerminalSessionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserBusinessBehaviorRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var statusKey: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.statusKey != nil {
            map["statusKey"] = self.statusKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("statusKey") {
            self.statusKey = dict["statusKey"] as! String
        }
    }
}

public class DescribeUserBusinessBehaviorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var statusValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.statusValue != nil {
            map["StatusValue"] = self.statusValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StatusValue") {
            self.statusValue = dict["StatusValue"] as! String
        }
    }
}

public class DescribeUserBusinessBehaviorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserBusinessBehaviorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserBusinessBehaviorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeUserDataRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeUserDataResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var regionId: String?

    public var requestId: String?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class DescribeUserDataResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeUserDataResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeUserDataResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVRoutersRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
    }
}

public class DescribeVRoutersResponseBody : Tea.TeaModel {
    public class VRouters : Tea.TeaModel {
        public class VRouter : Tea.TeaModel {
            public class RouteTableIds : Tea.TeaModel {
                public var routeTableId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.routeTableId != nil {
                        map["RouteTableId"] = self.routeTableId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RouteTableId") {
                        self.routeTableId = dict["RouteTableId"] as! [String]
                    }
                }
            }
            public var creationTime: String?

            public var description_: String?

            public var regionId: String?

            public var routeTableIds: DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds?

            public var VRouterId: String?

            public var VRouterName: String?

            public var vpcId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.routeTableIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.routeTableIds != nil {
                    map["RouteTableIds"] = self.routeTableIds?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.VRouterName != nil {
                    map["VRouterName"] = self.VRouterName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("RouteTableIds") {
                    var model = DescribeVRoutersResponseBody.VRouters.VRouter.RouteTableIds()
                    model.fromMap(dict["RouteTableIds"] as! [String: Any])
                    self.routeTableIds = model
                }
                if dict.keys.contains("VRouterId") {
                    self.VRouterId = dict["VRouterId"] as! String
                }
                if dict.keys.contains("VRouterName") {
                    self.VRouterName = dict["VRouterName"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
            }
        }
        public var VRouter: [DescribeVRoutersResponseBody.VRouters.VRouter]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.VRouter != nil {
                var tmp : [Any] = []
                for k in self.VRouter! {
                    tmp.append(k.toMap())
                }
                map["VRouter"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VRouter") {
                var tmp : [DescribeVRoutersResponseBody.VRouters.VRouter] = []
                for v in dict["VRouter"] as! [Any] {
                    var model = DescribeVRoutersResponseBody.VRouters.VRouter()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.VRouter = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var VRouters: DescribeVRoutersResponseBody.VRouters?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.VRouters?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.VRouters != nil {
            map["VRouters"] = self.VRouters?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VRouters") {
            var model = DescribeVRoutersResponseBody.VRouters()
            model.fromMap(dict["VRouters"] as! [String: Any])
            self.VRouters = model
        }
    }
}

public class DescribeVRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVRoutersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVSwitchesRequest : Tea.TeaModel {
    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vpcId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class DescribeVSwitchesResponseBody : Tea.TeaModel {
    public class VSwitches : Tea.TeaModel {
        public class VSwitch : Tea.TeaModel {
            public var availableIpAddressCount: Int64?

            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var isDefault: Bool?

            public var resourceGroupId: String?

            public var status: String?

            public var vSwitchId: String?

            public var vSwitchName: String?

            public var vpcId: String?

            public var zoneId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableIpAddressCount != nil {
                    map["AvailableIpAddressCount"] = self.availableIpAddressCount!
                }
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.resourceGroupId != nil {
                    map["ResourceGroupId"] = self.resourceGroupId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.vSwitchId != nil {
                    map["VSwitchId"] = self.vSwitchId!
                }
                if self.vSwitchName != nil {
                    map["VSwitchName"] = self.vSwitchName!
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableIpAddressCount") {
                    self.availableIpAddressCount = dict["AvailableIpAddressCount"] as! Int64
                }
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("ResourceGroupId") {
                    self.resourceGroupId = dict["ResourceGroupId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("VSwitchId") {
                    self.vSwitchId = dict["VSwitchId"] as! String
                }
                if dict.keys.contains("VSwitchName") {
                    self.vSwitchName = dict["VSwitchName"] as! String
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
            }
        }
        public var vSwitch: [DescribeVSwitchesResponseBody.VSwitches.VSwitch]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vSwitch != nil {
                var tmp : [Any] = []
                for k in self.vSwitch! {
                    tmp.append(k.toMap())
                }
                map["VSwitch"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VSwitch") {
                var tmp : [DescribeVSwitchesResponseBody.VSwitches.VSwitch] = []
                for v in dict["VSwitch"] as! [Any] {
                    var model = DescribeVSwitchesResponseBody.VSwitches.VSwitch()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vSwitch = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vSwitches: DescribeVSwitchesResponseBody.VSwitches?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vSwitches?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vSwitches != nil {
            map["VSwitches"] = self.vSwitches?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VSwitches") {
            var model = DescribeVSwitchesResponseBody.VSwitches()
            model.fromMap(dict["VSwitches"] as! [String: Any])
            self.vSwitches = model
        }
    }
}

public class DescribeVSwitchesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVSwitchesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVSwitchesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeVirtualBorderRoutersRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeVirtualBorderRoutersRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeVirtualBorderRoutersResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterSet : Tea.TeaModel {
        public class VirtualBorderRouterType : Tea.TeaModel {
            public var accessPointId: String?

            public var activationTime: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var description_: String?

            public var localGatewayIp: String?

            public var name: String?

            public var peerGatewayIp: String?

            public var peeringSubnetMask: String?

            public var physicalConnectionBusinessStatus: String?

            public var physicalConnectionId: String?

            public var physicalConnectionOwnerUid: String?

            public var physicalConnectionStatus: String?

            public var recoveryTime: String?

            public var routeTableId: String?

            public var status: String?

            public var terminationTime: String?

            public var vbrId: String?

            public var vlanId: Int32?

            public var vlanInterfaceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.accessPointId != nil {
                    map["AccessPointId"] = self.accessPointId!
                }
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.localGatewayIp != nil {
                    map["LocalGatewayIp"] = self.localGatewayIp!
                }
                if self.name != nil {
                    map["Name"] = self.name!
                }
                if self.peerGatewayIp != nil {
                    map["PeerGatewayIp"] = self.peerGatewayIp!
                }
                if self.peeringSubnetMask != nil {
                    map["PeeringSubnetMask"] = self.peeringSubnetMask!
                }
                if self.physicalConnectionBusinessStatus != nil {
                    map["PhysicalConnectionBusinessStatus"] = self.physicalConnectionBusinessStatus!
                }
                if self.physicalConnectionId != nil {
                    map["PhysicalConnectionId"] = self.physicalConnectionId!
                }
                if self.physicalConnectionOwnerUid != nil {
                    map["PhysicalConnectionOwnerUid"] = self.physicalConnectionOwnerUid!
                }
                if self.physicalConnectionStatus != nil {
                    map["PhysicalConnectionStatus"] = self.physicalConnectionStatus!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.routeTableId != nil {
                    map["RouteTableId"] = self.routeTableId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                if self.vlanInterfaceId != nil {
                    map["VlanInterfaceId"] = self.vlanInterfaceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AccessPointId") {
                    self.accessPointId = dict["AccessPointId"] as! String
                }
                if dict.keys.contains("ActivationTime") {
                    self.activationTime = dict["ActivationTime"] as! String
                }
                if dict.keys.contains("CircuitCode") {
                    self.circuitCode = dict["CircuitCode"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("LocalGatewayIp") {
                    self.localGatewayIp = dict["LocalGatewayIp"] as! String
                }
                if dict.keys.contains("Name") {
                    self.name = dict["Name"] as! String
                }
                if dict.keys.contains("PeerGatewayIp") {
                    self.peerGatewayIp = dict["PeerGatewayIp"] as! String
                }
                if dict.keys.contains("PeeringSubnetMask") {
                    self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
                }
                if dict.keys.contains("PhysicalConnectionBusinessStatus") {
                    self.physicalConnectionBusinessStatus = dict["PhysicalConnectionBusinessStatus"] as! String
                }
                if dict.keys.contains("PhysicalConnectionId") {
                    self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
                }
                if dict.keys.contains("PhysicalConnectionOwnerUid") {
                    self.physicalConnectionOwnerUid = dict["PhysicalConnectionOwnerUid"] as! String
                }
                if dict.keys.contains("PhysicalConnectionStatus") {
                    self.physicalConnectionStatus = dict["PhysicalConnectionStatus"] as! String
                }
                if dict.keys.contains("RecoveryTime") {
                    self.recoveryTime = dict["RecoveryTime"] as! String
                }
                if dict.keys.contains("RouteTableId") {
                    self.routeTableId = dict["RouteTableId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("TerminationTime") {
                    self.terminationTime = dict["TerminationTime"] as! String
                }
                if dict.keys.contains("VbrId") {
                    self.vbrId = dict["VbrId"] as! String
                }
                if dict.keys.contains("VlanId") {
                    self.vlanId = dict["VlanId"] as! Int32
                }
                if dict.keys.contains("VlanInterfaceId") {
                    self.vlanInterfaceId = dict["VlanInterfaceId"] as! String
                }
            }
        }
        public var virtualBorderRouterType: [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VirtualBorderRouterType") {
                var tmp : [DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType] = []
                for v in dict["VirtualBorderRouterType"] as! [Any] {
                    var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet.VirtualBorderRouterType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.virtualBorderRouterType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterSet: DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterSet != nil {
            map["VirtualBorderRouterSet"] = self.virtualBorderRouterSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VirtualBorderRouterSet") {
            var model = DescribeVirtualBorderRoutersResponseBody.VirtualBorderRouterSet()
            model.fromMap(dict["VirtualBorderRouterSet"] as! [String: Any])
            self.virtualBorderRouterSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVirtualBorderRoutersResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionRequest : Tea.TeaModel {
    public class Filter : Tea.TeaModel {
        public var key: String?

        public var value: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! [String]
            }
        }
    }
    public var filter: [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter]?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.filter != nil {
            var tmp : [Any] = []
            for k in self.filter! {
                tmp.append(k.toMap())
            }
            map["Filter"] = tmp
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Filter") {
            var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter] = []
            for v in dict["Filter"] as! [Any] {
                var model = DescribeVirtualBorderRoutersForPhysicalConnectionRequest.Filter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.filter = tmp
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody : Tea.TeaModel {
    public class VirtualBorderRouterForPhysicalConnectionSet : Tea.TeaModel {
        public class VirtualBorderRouterForPhysicalConnectionType : Tea.TeaModel {
            public var activationTime: String?

            public var circuitCode: String?

            public var creationTime: String?

            public var recoveryTime: String?

            public var terminationTime: String?

            public var vbrId: String?

            public var vbrOwnerUid: Int64?

            public var vlanId: Int32?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.activationTime != nil {
                    map["ActivationTime"] = self.activationTime!
                }
                if self.circuitCode != nil {
                    map["CircuitCode"] = self.circuitCode!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.recoveryTime != nil {
                    map["RecoveryTime"] = self.recoveryTime!
                }
                if self.terminationTime != nil {
                    map["TerminationTime"] = self.terminationTime!
                }
                if self.vbrId != nil {
                    map["VbrId"] = self.vbrId!
                }
                if self.vbrOwnerUid != nil {
                    map["VbrOwnerUid"] = self.vbrOwnerUid!
                }
                if self.vlanId != nil {
                    map["VlanId"] = self.vlanId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ActivationTime") {
                    self.activationTime = dict["ActivationTime"] as! String
                }
                if dict.keys.contains("CircuitCode") {
                    self.circuitCode = dict["CircuitCode"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("RecoveryTime") {
                    self.recoveryTime = dict["RecoveryTime"] as! String
                }
                if dict.keys.contains("TerminationTime") {
                    self.terminationTime = dict["TerminationTime"] as! String
                }
                if dict.keys.contains("VbrId") {
                    self.vbrId = dict["VbrId"] as! String
                }
                if dict.keys.contains("VbrOwnerUid") {
                    self.vbrOwnerUid = dict["VbrOwnerUid"] as! Int64
                }
                if dict.keys.contains("VlanId") {
                    self.vlanId = dict["VlanId"] as! Int32
                }
            }
        }
        public var virtualBorderRouterForPhysicalConnectionType: [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.virtualBorderRouterForPhysicalConnectionType != nil {
                var tmp : [Any] = []
                for k in self.virtualBorderRouterForPhysicalConnectionType! {
                    tmp.append(k.toMap())
                }
                map["VirtualBorderRouterForPhysicalConnectionType"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("VirtualBorderRouterForPhysicalConnectionType") {
                var tmp : [DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType] = []
                for v in dict["VirtualBorderRouterForPhysicalConnectionType"] as! [Any] {
                    var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet.VirtualBorderRouterForPhysicalConnectionType()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.virtualBorderRouterForPhysicalConnectionType = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var virtualBorderRouterForPhysicalConnectionSet: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.virtualBorderRouterForPhysicalConnectionSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.virtualBorderRouterForPhysicalConnectionSet != nil {
            map["VirtualBorderRouterForPhysicalConnectionSet"] = self.virtualBorderRouterForPhysicalConnectionSet?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("VirtualBorderRouterForPhysicalConnectionSet") {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody.VirtualBorderRouterForPhysicalConnectionSet()
            model.fromMap(dict["VirtualBorderRouterForPhysicalConnectionSet"] as! [String: Any])
            self.virtualBorderRouterForPhysicalConnectionSet = model
        }
    }
}

public class DescribeVirtualBorderRoutersForPhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVirtualBorderRoutersForPhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeVpcsRequest : Tea.TeaModel {
    public var isDefault: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.isDefault != nil {
            map["IsDefault"] = self.isDefault!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("IsDefault") {
            self.isDefault = dict["IsDefault"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DescribeVpcsResponseBody : Tea.TeaModel {
    public class Vpcs : Tea.TeaModel {
        public class Vpc : Tea.TeaModel {
            public class UserCidrs : Tea.TeaModel {
                public var userCidr: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.userCidr != nil {
                        map["UserCidr"] = self.userCidr!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("UserCidr") {
                        self.userCidr = dict["UserCidr"] as! [String]
                    }
                }
            }
            public class VSwitchIds : Tea.TeaModel {
                public var vSwitchId: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.vSwitchId != nil {
                        map["VSwitchId"] = self.vSwitchId!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VSwitchId") {
                        self.vSwitchId = dict["VSwitchId"] as! [String]
                    }
                }
            }
            public var cidrBlock: String?

            public var creationTime: String?

            public var description_: String?

            public var isDefault: Bool?

            public var regionId: String?

            public var status: String?

            public var userCidrs: DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs?

            public var VRouterId: String?

            public var vSwitchIds: DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds?

            public var vpcId: String?

            public var vpcName: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.userCidrs?.validate()
                try self.vSwitchIds?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.cidrBlock != nil {
                    map["CidrBlock"] = self.cidrBlock!
                }
                if self.creationTime != nil {
                    map["CreationTime"] = self.creationTime!
                }
                if self.description_ != nil {
                    map["Description"] = self.description_!
                }
                if self.isDefault != nil {
                    map["IsDefault"] = self.isDefault!
                }
                if self.regionId != nil {
                    map["RegionId"] = self.regionId!
                }
                if self.status != nil {
                    map["Status"] = self.status!
                }
                if self.userCidrs != nil {
                    map["UserCidrs"] = self.userCidrs?.toMap()
                }
                if self.VRouterId != nil {
                    map["VRouterId"] = self.VRouterId!
                }
                if self.vSwitchIds != nil {
                    map["VSwitchIds"] = self.vSwitchIds?.toMap()
                }
                if self.vpcId != nil {
                    map["VpcId"] = self.vpcId!
                }
                if self.vpcName != nil {
                    map["VpcName"] = self.vpcName!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("CidrBlock") {
                    self.cidrBlock = dict["CidrBlock"] as! String
                }
                if dict.keys.contains("CreationTime") {
                    self.creationTime = dict["CreationTime"] as! String
                }
                if dict.keys.contains("Description") {
                    self.description_ = dict["Description"] as! String
                }
                if dict.keys.contains("IsDefault") {
                    self.isDefault = dict["IsDefault"] as! Bool
                }
                if dict.keys.contains("RegionId") {
                    self.regionId = dict["RegionId"] as! String
                }
                if dict.keys.contains("Status") {
                    self.status = dict["Status"] as! String
                }
                if dict.keys.contains("UserCidrs") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.UserCidrs()
                    model.fromMap(dict["UserCidrs"] as! [String: Any])
                    self.userCidrs = model
                }
                if dict.keys.contains("VRouterId") {
                    self.VRouterId = dict["VRouterId"] as! String
                }
                if dict.keys.contains("VSwitchIds") {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc.VSwitchIds()
                    model.fromMap(dict["VSwitchIds"] as! [String: Any])
                    self.vSwitchIds = model
                }
                if dict.keys.contains("VpcId") {
                    self.vpcId = dict["VpcId"] as! String
                }
                if dict.keys.contains("VpcName") {
                    self.vpcName = dict["VpcName"] as! String
                }
            }
        }
        public var vpc: [DescribeVpcsResponseBody.Vpcs.Vpc]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.vpc != nil {
                var tmp : [Any] = []
                for k in self.vpc! {
                    tmp.append(k.toMap())
                }
                map["Vpc"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Vpc") {
                var tmp : [DescribeVpcsResponseBody.Vpcs.Vpc] = []
                for v in dict["Vpc"] as! [Any] {
                    var model = DescribeVpcsResponseBody.Vpcs.Vpc()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.vpc = tmp
            }
        }
    }
    public var pageNumber: Int32?

    public var pageSize: Int32?

    public var requestId: String?

    public var totalCount: Int32?

    public var vpcs: DescribeVpcsResponseBody.Vpcs?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.vpcs?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        if self.vpcs != nil {
            map["Vpcs"] = self.vpcs?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int32
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int32
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
        if dict.keys.contains("Vpcs") {
            var model = DescribeVpcsResponseBody.Vpcs()
            model.fromMap(dict["Vpcs"] as! [String: Any])
            self.vpcs = model
        }
    }
}

public class DescribeVpcsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeVpcsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeVpcsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DescribeZonesRequest : Tea.TeaModel {
    public var acceptLanguage: String?

    public var instanceChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotStrategy: String?

    public var verbose: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.acceptLanguage != nil {
            map["AcceptLanguage"] = self.acceptLanguage!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.verbose != nil {
            map["Verbose"] = self.verbose!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AcceptLanguage") {
            self.acceptLanguage = dict["AcceptLanguage"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("Verbose") {
            self.verbose = dict["Verbose"] as! Bool
        }
    }
}

public class DescribeZonesResponseBody : Tea.TeaModel {
    public class Zones : Tea.TeaModel {
        public class Zone : Tea.TeaModel {
            public class AvailableDedicatedHostTypes : Tea.TeaModel {
                public var dedicatedHostType: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostType != nil {
                        map["DedicatedHostType"] = self.dedicatedHostType!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DedicatedHostType") {
                        self.dedicatedHostType = dict["DedicatedHostType"] as! [String]
                    }
                }
            }
            public class AvailableDiskCategories : Tea.TeaModel {
                public var diskCategories: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.diskCategories != nil {
                        map["DiskCategories"] = self.diskCategories!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DiskCategories") {
                        self.diskCategories = dict["DiskCategories"] as! [String]
                    }
                }
            }
            public class AvailableInstanceTypes : Tea.TeaModel {
                public var instanceTypes: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceTypes != nil {
                        map["InstanceTypes"] = self.instanceTypes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceTypes") {
                        self.instanceTypes = dict["InstanceTypes"] as! [String]
                    }
                }
            }
            public class AvailableResourceCreation : Tea.TeaModel {
                public var resourceTypes: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourceTypes != nil {
                        map["ResourceTypes"] = self.resourceTypes!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourceTypes") {
                        self.resourceTypes = dict["ResourceTypes"] as! [String]
                    }
                }
            }
            public class AvailableResources : Tea.TeaModel {
                public class ResourcesInfo : Tea.TeaModel {
                    public class DataDiskCategories : Tea.TeaModel {
                        public var supportedDataDiskCategory: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedDataDiskCategory != nil {
                                map["supportedDataDiskCategory"] = self.supportedDataDiskCategory!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("supportedDataDiskCategory") {
                                self.supportedDataDiskCategory = dict["supportedDataDiskCategory"] as! [String]
                            }
                        }
                    }
                    public class InstanceGenerations : Tea.TeaModel {
                        public var supportedInstanceGeneration: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedInstanceGeneration != nil {
                                map["supportedInstanceGeneration"] = self.supportedInstanceGeneration!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("supportedInstanceGeneration") {
                                self.supportedInstanceGeneration = dict["supportedInstanceGeneration"] as! [String]
                            }
                        }
                    }
                    public class InstanceTypeFamilies : Tea.TeaModel {
                        public var supportedInstanceTypeFamily: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedInstanceTypeFamily != nil {
                                map["supportedInstanceTypeFamily"] = self.supportedInstanceTypeFamily!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("supportedInstanceTypeFamily") {
                                self.supportedInstanceTypeFamily = dict["supportedInstanceTypeFamily"] as! [String]
                            }
                        }
                    }
                    public class InstanceTypes : Tea.TeaModel {
                        public var supportedInstanceType: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedInstanceType != nil {
                                map["supportedInstanceType"] = self.supportedInstanceType!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("supportedInstanceType") {
                                self.supportedInstanceType = dict["supportedInstanceType"] as! [String]
                            }
                        }
                    }
                    public class NetworkTypes : Tea.TeaModel {
                        public var supportedNetworkCategory: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedNetworkCategory != nil {
                                map["supportedNetworkCategory"] = self.supportedNetworkCategory!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("supportedNetworkCategory") {
                                self.supportedNetworkCategory = dict["supportedNetworkCategory"] as! [String]
                            }
                        }
                    }
                    public class SystemDiskCategories : Tea.TeaModel {
                        public var supportedSystemDiskCategory: [String]?

                        public override init() {
                            super.init()
                        }

                        public init(_ dict: [String: Any]) {
                            super.init()
                            self.fromMap(dict)
                        }

                        public override func validate() throws -> Void {
                        }

                        public override func toMap() -> [String : Any] {
                            var map = super.toMap()
                            if self.supportedSystemDiskCategory != nil {
                                map["supportedSystemDiskCategory"] = self.supportedSystemDiskCategory!
                            }
                            return map
                        }

                        public override func fromMap(_ dict: [String: Any]) -> Void {
                            if dict.keys.contains("supportedSystemDiskCategory") {
                                self.supportedSystemDiskCategory = dict["supportedSystemDiskCategory"] as! [String]
                            }
                        }
                    }
                    public var dataDiskCategories: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.DataDiskCategories?

                    public var instanceGenerations: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceGenerations?

                    public var instanceTypeFamilies: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypeFamilies?

                    public var instanceTypes: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypes?

                    public var ioOptimized: Bool?

                    public var networkTypes: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.NetworkTypes?

                    public var systemDiskCategories: DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.SystemDiskCategories?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                        try self.dataDiskCategories?.validate()
                        try self.instanceGenerations?.validate()
                        try self.instanceTypeFamilies?.validate()
                        try self.instanceTypes?.validate()
                        try self.networkTypes?.validate()
                        try self.systemDiskCategories?.validate()
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.dataDiskCategories != nil {
                            map["DataDiskCategories"] = self.dataDiskCategories?.toMap()
                        }
                        if self.instanceGenerations != nil {
                            map["InstanceGenerations"] = self.instanceGenerations?.toMap()
                        }
                        if self.instanceTypeFamilies != nil {
                            map["InstanceTypeFamilies"] = self.instanceTypeFamilies?.toMap()
                        }
                        if self.instanceTypes != nil {
                            map["InstanceTypes"] = self.instanceTypes?.toMap()
                        }
                        if self.ioOptimized != nil {
                            map["IoOptimized"] = self.ioOptimized!
                        }
                        if self.networkTypes != nil {
                            map["NetworkTypes"] = self.networkTypes?.toMap()
                        }
                        if self.systemDiskCategories != nil {
                            map["SystemDiskCategories"] = self.systemDiskCategories?.toMap()
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("DataDiskCategories") {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.DataDiskCategories()
                            model.fromMap(dict["DataDiskCategories"] as! [String: Any])
                            self.dataDiskCategories = model
                        }
                        if dict.keys.contains("InstanceGenerations") {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceGenerations()
                            model.fromMap(dict["InstanceGenerations"] as! [String: Any])
                            self.instanceGenerations = model
                        }
                        if dict.keys.contains("InstanceTypeFamilies") {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypeFamilies()
                            model.fromMap(dict["InstanceTypeFamilies"] as! [String: Any])
                            self.instanceTypeFamilies = model
                        }
                        if dict.keys.contains("InstanceTypes") {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.InstanceTypes()
                            model.fromMap(dict["InstanceTypes"] as! [String: Any])
                            self.instanceTypes = model
                        }
                        if dict.keys.contains("IoOptimized") {
                            self.ioOptimized = dict["IoOptimized"] as! Bool
                        }
                        if dict.keys.contains("NetworkTypes") {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.NetworkTypes()
                            model.fromMap(dict["NetworkTypes"] as! [String: Any])
                            self.networkTypes = model
                        }
                        if dict.keys.contains("SystemDiskCategories") {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo.SystemDiskCategories()
                            model.fromMap(dict["SystemDiskCategories"] as! [String: Any])
                            self.systemDiskCategories = model
                        }
                    }
                }
                public var resourcesInfo: [DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.resourcesInfo != nil {
                        var tmp : [Any] = []
                        for k in self.resourcesInfo! {
                            tmp.append(k.toMap())
                        }
                        map["ResourcesInfo"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("ResourcesInfo") {
                        var tmp : [DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo] = []
                        for v in dict["ResourcesInfo"] as! [Any] {
                            var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources.ResourcesInfo()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.resourcesInfo = tmp
                    }
                }
            }
            public class AvailableVolumeCategories : Tea.TeaModel {
                public var volumeCategories: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.volumeCategories != nil {
                        map["VolumeCategories"] = self.volumeCategories!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("VolumeCategories") {
                        self.volumeCategories = dict["VolumeCategories"] as! [String]
                    }
                }
            }
            public class DedicatedHostGenerations : Tea.TeaModel {
                public var dedicatedHostGeneration: [String]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.dedicatedHostGeneration != nil {
                        map["DedicatedHostGeneration"] = self.dedicatedHostGeneration!
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("DedicatedHostGeneration") {
                        self.dedicatedHostGeneration = dict["DedicatedHostGeneration"] as! [String]
                    }
                }
            }
            public var availableDedicatedHostTypes: DescribeZonesResponseBody.Zones.Zone.AvailableDedicatedHostTypes?

            public var availableDiskCategories: DescribeZonesResponseBody.Zones.Zone.AvailableDiskCategories?

            public var availableInstanceTypes: DescribeZonesResponseBody.Zones.Zone.AvailableInstanceTypes?

            public var availableResourceCreation: DescribeZonesResponseBody.Zones.Zone.AvailableResourceCreation?

            public var availableResources: DescribeZonesResponseBody.Zones.Zone.AvailableResources?

            public var availableVolumeCategories: DescribeZonesResponseBody.Zones.Zone.AvailableVolumeCategories?

            public var dedicatedHostGenerations: DescribeZonesResponseBody.Zones.Zone.DedicatedHostGenerations?

            public var localName: String?

            public var zoneId: String?

            public var zoneType: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.availableDedicatedHostTypes?.validate()
                try self.availableDiskCategories?.validate()
                try self.availableInstanceTypes?.validate()
                try self.availableResourceCreation?.validate()
                try self.availableResources?.validate()
                try self.availableVolumeCategories?.validate()
                try self.dedicatedHostGenerations?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.availableDedicatedHostTypes != nil {
                    map["AvailableDedicatedHostTypes"] = self.availableDedicatedHostTypes?.toMap()
                }
                if self.availableDiskCategories != nil {
                    map["AvailableDiskCategories"] = self.availableDiskCategories?.toMap()
                }
                if self.availableInstanceTypes != nil {
                    map["AvailableInstanceTypes"] = self.availableInstanceTypes?.toMap()
                }
                if self.availableResourceCreation != nil {
                    map["AvailableResourceCreation"] = self.availableResourceCreation?.toMap()
                }
                if self.availableResources != nil {
                    map["AvailableResources"] = self.availableResources?.toMap()
                }
                if self.availableVolumeCategories != nil {
                    map["AvailableVolumeCategories"] = self.availableVolumeCategories?.toMap()
                }
                if self.dedicatedHostGenerations != nil {
                    map["DedicatedHostGenerations"] = self.dedicatedHostGenerations?.toMap()
                }
                if self.localName != nil {
                    map["LocalName"] = self.localName!
                }
                if self.zoneId != nil {
                    map["ZoneId"] = self.zoneId!
                }
                if self.zoneType != nil {
                    map["ZoneType"] = self.zoneType!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AvailableDedicatedHostTypes") {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableDedicatedHostTypes()
                    model.fromMap(dict["AvailableDedicatedHostTypes"] as! [String: Any])
                    self.availableDedicatedHostTypes = model
                }
                if dict.keys.contains("AvailableDiskCategories") {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableDiskCategories()
                    model.fromMap(dict["AvailableDiskCategories"] as! [String: Any])
                    self.availableDiskCategories = model
                }
                if dict.keys.contains("AvailableInstanceTypes") {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableInstanceTypes()
                    model.fromMap(dict["AvailableInstanceTypes"] as! [String: Any])
                    self.availableInstanceTypes = model
                }
                if dict.keys.contains("AvailableResourceCreation") {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableResourceCreation()
                    model.fromMap(dict["AvailableResourceCreation"] as! [String: Any])
                    self.availableResourceCreation = model
                }
                if dict.keys.contains("AvailableResources") {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableResources()
                    model.fromMap(dict["AvailableResources"] as! [String: Any])
                    self.availableResources = model
                }
                if dict.keys.contains("AvailableVolumeCategories") {
                    var model = DescribeZonesResponseBody.Zones.Zone.AvailableVolumeCategories()
                    model.fromMap(dict["AvailableVolumeCategories"] as! [String: Any])
                    self.availableVolumeCategories = model
                }
                if dict.keys.contains("DedicatedHostGenerations") {
                    var model = DescribeZonesResponseBody.Zones.Zone.DedicatedHostGenerations()
                    model.fromMap(dict["DedicatedHostGenerations"] as! [String: Any])
                    self.dedicatedHostGenerations = model
                }
                if dict.keys.contains("LocalName") {
                    self.localName = dict["LocalName"] as! String
                }
                if dict.keys.contains("ZoneId") {
                    self.zoneId = dict["ZoneId"] as! String
                }
                if dict.keys.contains("ZoneType") {
                    self.zoneType = dict["ZoneType"] as! String
                }
            }
        }
        public var zone: [DescribeZonesResponseBody.Zones.Zone]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.zone != nil {
                var tmp : [Any] = []
                for k in self.zone! {
                    tmp.append(k.toMap())
                }
                map["Zone"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Zone") {
                var tmp : [DescribeZonesResponseBody.Zones.Zone] = []
                for v in dict["Zone"] as! [Any] {
                    var model = DescribeZonesResponseBody.Zones.Zone()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.zone = tmp
            }
        }
    }
    public var requestId: String?

    public var zones: DescribeZonesResponseBody.Zones?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.zones?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.zones != nil {
            map["Zones"] = self.zones?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Zones") {
            var model = DescribeZonesResponseBody.Zones()
            model.fromMap(dict["Zones"] as! [String: Any])
            self.zones = model
        }
    }
}

public class DescribeZonesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DescribeZonesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DescribeZonesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachClassicLinkVpcRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class DetachClassicLinkVpcResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachClassicLinkVpcResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachClassicLinkVpcResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachClassicLinkVpcResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachDiskRequest : Tea.TeaModel {
    public var deleteWithInstance: Bool?

    public var diskId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeleteWithInstance") {
            self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DetachDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachInstanceRamRoleRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var ownerId: Int64?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DetachInstanceRamRoleResponseBody : Tea.TeaModel {
    public class DetachInstanceRamRoleResults : Tea.TeaModel {
        public class DetachInstanceRamRoleResult : Tea.TeaModel {
            public class InstanceRamRoleSets : Tea.TeaModel {
                public class InstanceRamRoleSet : Tea.TeaModel {
                    public var instanceId: String?

                    public var ramRoleName: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.instanceId != nil {
                            map["InstanceId"] = self.instanceId!
                        }
                        if self.ramRoleName != nil {
                            map["RamRoleName"] = self.ramRoleName!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("InstanceId") {
                            self.instanceId = dict["InstanceId"] as! String
                        }
                        if dict.keys.contains("RamRoleName") {
                            self.ramRoleName = dict["RamRoleName"] as! String
                        }
                    }
                }
                public var instanceRamRoleSet: [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets.InstanceRamRoleSet]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.instanceRamRoleSet != nil {
                        var tmp : [Any] = []
                        for k in self.instanceRamRoleSet! {
                            tmp.append(k.toMap())
                        }
                        map["InstanceRamRoleSet"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("InstanceRamRoleSet") {
                        var tmp : [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets.InstanceRamRoleSet] = []
                        for v in dict["InstanceRamRoleSet"] as! [Any] {
                            var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets.InstanceRamRoleSet()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.instanceRamRoleSet = tmp
                    }
                }
            }
            public var code: String?

            public var instanceId: String?

            public var instanceRamRoleSets: DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets?

            public var message: String?

            public var success: Bool?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.instanceRamRoleSets?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.instanceRamRoleSets != nil {
                    map["InstanceRamRoleSets"] = self.instanceRamRoleSets?.toMap()
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("InstanceRamRoleSets") {
                    var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult.InstanceRamRoleSets()
                    model.fromMap(dict["InstanceRamRoleSets"] as! [String: Any])
                    self.instanceRamRoleSets = model
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! Bool
                }
            }
        }
        public var detachInstanceRamRoleResult: [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.detachInstanceRamRoleResult != nil {
                var tmp : [Any] = []
                for k in self.detachInstanceRamRoleResult! {
                    tmp.append(k.toMap())
                }
                map["DetachInstanceRamRoleResult"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DetachInstanceRamRoleResult") {
                var tmp : [DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult] = []
                for v in dict["DetachInstanceRamRoleResult"] as! [Any] {
                    var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults.DetachInstanceRamRoleResult()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.detachInstanceRamRoleResult = tmp
            }
        }
    }
    public var detachInstanceRamRoleResults: DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults?

    public var failCount: Int32?

    public var ramRoleName: String?

    public var requestId: String?

    public var totalCount: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.detachInstanceRamRoleResults?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.detachInstanceRamRoleResults != nil {
            map["DetachInstanceRamRoleResults"] = self.detachInstanceRamRoleResults?.toMap()
        }
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DetachInstanceRamRoleResults") {
            var model = DetachInstanceRamRoleResponseBody.DetachInstanceRamRoleResults()
            model.fromMap(dict["DetachInstanceRamRoleResults"] as! [String: Any])
            self.detachInstanceRamRoleResults = model
        }
        if dict.keys.contains("FailCount") {
            self.failCount = dict["FailCount"] as! Int32
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int32
        }
    }
}

public class DetachInstanceRamRoleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachInstanceRamRoleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachInstanceRamRoleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachKeyPairRequest : Tea.TeaModel {
    public var instanceIds: String?

    public var keyPairName: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DetachKeyPairResponseBody : Tea.TeaModel {
    public class Results : Tea.TeaModel {
        public class Result : Tea.TeaModel {
            public var code: String?

            public var instanceId: String?

            public var message: String?

            public var success: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.success != nil {
                    map["Success"] = self.success!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("Success") {
                    self.success = dict["Success"] as! String
                }
            }
        }
        public var result: [DetachKeyPairResponseBody.Results.Result]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.result != nil {
                var tmp : [Any] = []
                for k in self.result! {
                    tmp.append(k.toMap())
                }
                map["Result"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Result") {
                var tmp : [DetachKeyPairResponseBody.Results.Result] = []
                for v in dict["Result"] as! [Any] {
                    var model = DetachKeyPairResponseBody.Results.Result()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.result = tmp
            }
        }
    }
    public var failCount: String?

    public var keyPairName: String?

    public var requestId: String?

    public var results: DetachKeyPairResponseBody.Results?

    public var totalCount: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.results?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.failCount != nil {
            map["FailCount"] = self.failCount!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.results != nil {
            map["Results"] = self.results?.toMap()
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FailCount") {
            self.failCount = dict["FailCount"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Results") {
            var model = DetachKeyPairResponseBody.Results()
            model.fromMap(dict["Results"] as! [String: Any])
            self.results = model
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! String
        }
    }
}

public class DetachKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DetachNetworkInterfaceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var trunkNetworkInstanceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.trunkNetworkInstanceId != nil {
            map["TrunkNetworkInstanceId"] = self.trunkNetworkInstanceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TrunkNetworkInstanceId") {
            self.trunkNetworkInstanceId = dict["TrunkNetworkInstanceId"] as! String
        }
    }
}

public class DetachNetworkInterfaceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DetachNetworkInterfaceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DetachNetworkInterfaceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DetachNetworkInterfaceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableActivationRequest : Tea.TeaModel {
    public var activationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activationId != nil {
            map["ActivationId"] = self.activationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActivationId") {
            self.activationId = dict["ActivationId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DisableActivationResponseBody : Tea.TeaModel {
    public class Activation : Tea.TeaModel {
        public var activationId: String?

        public var creationTime: String?

        public var deregisteredCount: Int32?

        public var description_: String?

        public var disabled: Bool?

        public var instanceCount: Int32?

        public var instanceName: String?

        public var ipAddressRange: String?

        public var registeredCount: Int32?

        public var timeToLiveInHours: Int64?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.activationId != nil {
                map["ActivationId"] = self.activationId!
            }
            if self.creationTime != nil {
                map["CreationTime"] = self.creationTime!
            }
            if self.deregisteredCount != nil {
                map["DeregisteredCount"] = self.deregisteredCount!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.disabled != nil {
                map["Disabled"] = self.disabled!
            }
            if self.instanceCount != nil {
                map["InstanceCount"] = self.instanceCount!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            if self.ipAddressRange != nil {
                map["IpAddressRange"] = self.ipAddressRange!
            }
            if self.registeredCount != nil {
                map["RegisteredCount"] = self.registeredCount!
            }
            if self.timeToLiveInHours != nil {
                map["TimeToLiveInHours"] = self.timeToLiveInHours!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ActivationId") {
                self.activationId = dict["ActivationId"] as! String
            }
            if dict.keys.contains("CreationTime") {
                self.creationTime = dict["CreationTime"] as! String
            }
            if dict.keys.contains("DeregisteredCount") {
                self.deregisteredCount = dict["DeregisteredCount"] as! Int32
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Disabled") {
                self.disabled = dict["Disabled"] as! Bool
            }
            if dict.keys.contains("InstanceCount") {
                self.instanceCount = dict["InstanceCount"] as! Int32
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
            if dict.keys.contains("IpAddressRange") {
                self.ipAddressRange = dict["IpAddressRange"] as! String
            }
            if dict.keys.contains("RegisteredCount") {
                self.registeredCount = dict["RegisteredCount"] as! Int32
            }
            if dict.keys.contains("TimeToLiveInHours") {
                self.timeToLiveInHours = dict["TimeToLiveInHours"] as! Int64
            }
        }
    }
    public var activation: DisableActivationResponseBody.Activation?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.activation?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.activation != nil {
            map["Activation"] = self.activation?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Activation") {
            var model = DisableActivationResponseBody.Activation()
            model.fromMap(dict["Activation"] as! [String: Any])
            self.activation = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableActivationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableActivationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableActivationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class DisableDiskEncryptionByDefaultRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class DisableDiskEncryptionByDefaultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class DisableDiskEncryptionByDefaultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: DisableDiskEncryptionByDefaultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = DisableDiskEncryptionByDefaultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnableDiskEncryptionByDefaultRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class EnableDiskEncryptionByDefaultResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnableDiskEncryptionByDefaultResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnableDiskEncryptionByDefaultResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnableDiskEncryptionByDefaultResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class EnablePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
    }
}

public class EnablePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class EnablePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: EnablePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = EnablePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportImageRequest : Tea.TeaModel {
    public var imageFormat: String?

    public var imageId: String?

    public var OSSBucket: String?

    public var OSSPrefix: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageFormat != nil {
            map["ImageFormat"] = self.imageFormat!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.OSSBucket != nil {
            map["OSSBucket"] = self.OSSBucket!
        }
        if self.OSSPrefix != nil {
            map["OSSPrefix"] = self.OSSPrefix!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageFormat") {
            self.imageFormat = dict["ImageFormat"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OSSBucket") {
            self.OSSBucket = dict["OSSBucket"] as! String
        }
        if dict.keys.contains("OSSPrefix") {
            self.OSSPrefix = dict["OSSPrefix"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoleName") {
            self.roleName = dict["RoleName"] as! String
        }
    }
}

public class ExportImageResponseBody : Tea.TeaModel {
    public var regionId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class ExportImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ExportSnapshotRequest : Tea.TeaModel {
    public var ossBucket: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleName: String?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ossBucket != nil {
            map["OssBucket"] = self.ossBucket!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OssBucket") {
            self.ossBucket = dict["OssBucket"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoleName") {
            self.roleName = dict["RoleName"] as! String
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class ExportSnapshotResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class ExportSnapshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ExportSnapshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ExportSnapshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceConsoleOutputRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeSymbols: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeSymbols != nil {
            map["RemoveSymbols"] = self.removeSymbols!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoveSymbols") {
            self.removeSymbols = dict["RemoveSymbols"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class GetInstanceConsoleOutputResponseBody : Tea.TeaModel {
    public var consoleOutput: String?

    public var instanceId: String?

    public var lastUpdateTime: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.consoleOutput != nil {
            map["ConsoleOutput"] = self.consoleOutput!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.lastUpdateTime != nil {
            map["LastUpdateTime"] = self.lastUpdateTime!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConsoleOutput") {
            self.consoleOutput = dict["ConsoleOutput"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("LastUpdateTime") {
            self.lastUpdateTime = dict["LastUpdateTime"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class GetInstanceConsoleOutputResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceConsoleOutputResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceConsoleOutputResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class GetInstanceScreenshotRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var wakeUp: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.wakeUp != nil {
            map["WakeUp"] = self.wakeUp!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("WakeUp") {
            self.wakeUp = dict["WakeUp"] as! Bool
        }
    }
}

public class GetInstanceScreenshotResponseBody : Tea.TeaModel {
    public var instanceId: String?

    public var requestId: String?

    public var screenshot: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.screenshot != nil {
            map["Screenshot"] = self.screenshot!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Screenshot") {
            self.screenshot = dict["Screenshot"] as! String
        }
    }
}

public class GetInstanceScreenshotResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: GetInstanceScreenshotResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = GetInstanceScreenshotResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportImageRequest : Tea.TeaModel {
    public class DiskDeviceMapping : Tea.TeaModel {
        public var device: String?

        public var diskImSize: Int32?

        public var diskImageSize: Int32?

        public var format: String?

        public var OSSBucket: String?

        public var OSSObject: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskImSize != nil {
                map["DiskImSize"] = self.diskImSize!
            }
            if self.diskImageSize != nil {
                map["DiskImageSize"] = self.diskImageSize!
            }
            if self.format != nil {
                map["Format"] = self.format!
            }
            if self.OSSBucket != nil {
                map["OSSBucket"] = self.OSSBucket!
            }
            if self.OSSObject != nil {
                map["OSSObject"] = self.OSSObject!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskImSize") {
                self.diskImSize = dict["DiskImSize"] as! Int32
            }
            if dict.keys.contains("DiskImageSize") {
                self.diskImageSize = dict["DiskImageSize"] as! Int32
            }
            if dict.keys.contains("Format") {
                self.format = dict["Format"] as! String
            }
            if dict.keys.contains("OSSBucket") {
                self.OSSBucket = dict["OSSBucket"] as! String
            }
            if dict.keys.contains("OSSObject") {
                self.OSSObject = dict["OSSObject"] as! String
            }
        }
    }
    public class Features : Tea.TeaModel {
        public var nvmeSupport: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nvmeSupport != nil {
                map["NvmeSupport"] = self.nvmeSupport!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NvmeSupport") {
                self.nvmeSupport = dict["NvmeSupport"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var architecture: String?

    public var bootMode: String?

    public var description_: String?

    public var detectionStrategy: String?

    public var diskDeviceMapping: [ImportImageRequest.DiskDeviceMapping]?

    public var dryRun: Bool?

    public var features: ImportImageRequest.Features?

    public var imageName: String?

    public var licenseType: String?

    public var OSType: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var roleName: String?

    public var storageLocationArn: String?

    public var tag: [ImportImageRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.features?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.bootMode != nil {
            map["BootMode"] = self.bootMode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.detectionStrategy != nil {
            map["DetectionStrategy"] = self.detectionStrategy!
        }
        if self.diskDeviceMapping != nil {
            var tmp : [Any] = []
            for k in self.diskDeviceMapping! {
                tmp.append(k.toMap())
            }
            map["DiskDeviceMapping"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.features != nil {
            map["Features"] = self.features?.toMap()
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.licenseType != nil {
            map["LicenseType"] = self.licenseType!
        }
        if self.OSType != nil {
            map["OSType"] = self.OSType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.roleName != nil {
            map["RoleName"] = self.roleName!
        }
        if self.storageLocationArn != nil {
            map["StorageLocationArn"] = self.storageLocationArn!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Architecture") {
            self.architecture = dict["Architecture"] as! String
        }
        if dict.keys.contains("BootMode") {
            self.bootMode = dict["BootMode"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DetectionStrategy") {
            self.detectionStrategy = dict["DetectionStrategy"] as! String
        }
        if dict.keys.contains("DiskDeviceMapping") {
            var tmp : [ImportImageRequest.DiskDeviceMapping] = []
            for v in dict["DiskDeviceMapping"] as! [Any] {
                var model = ImportImageRequest.DiskDeviceMapping()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.diskDeviceMapping = tmp
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("Features") {
            var model = ImportImageRequest.Features()
            model.fromMap(dict["Features"] as! [String: Any])
            self.features = model
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("LicenseType") {
            self.licenseType = dict["LicenseType"] as! String
        }
        if dict.keys.contains("OSType") {
            self.OSType = dict["OSType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RoleName") {
            self.roleName = dict["RoleName"] as! String
        }
        if dict.keys.contains("StorageLocationArn") {
            self.storageLocationArn = dict["StorageLocationArn"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ImportImageRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ImportImageRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ImportImageResponseBody : Tea.TeaModel {
    public var imageId: String?

    public var regionId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class ImportImageResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportImageResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportImageResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ImportKeyPairRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var keyPairName: String?

    public var ownerId: Int64?

    public var publicKeyBody: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [ImportKeyPairRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.publicKeyBody != nil {
            map["PublicKeyBody"] = self.publicKeyBody!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PublicKeyBody") {
            self.publicKeyBody = dict["PublicKeyBody"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [ImportKeyPairRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ImportKeyPairRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class ImportKeyPairResponseBody : Tea.TeaModel {
    public var keyPairFingerPrint: String?

    public var keyPairName: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.keyPairFingerPrint != nil {
            map["KeyPairFingerPrint"] = self.keyPairFingerPrint!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KeyPairFingerPrint") {
            self.keyPairFingerPrint = dict["KeyPairFingerPrint"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ImportKeyPairResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ImportKeyPairResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ImportKeyPairResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InstallCloudAssistantRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class InstallCloudAssistantResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InstallCloudAssistantResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InstallCloudAssistantResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InstallCloudAssistantResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class InvokeCommandRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var commandId: String?

    public var containerId: String?

    public var containerName: String?

    public var frequency: String?

    public var instanceId: [String]?

    public var launcher: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parameters: [String: Any]?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [InvokeCommandRequest.ResourceTag]?

    public var tag: [InvokeCommandRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var username: String?

    public var windowsPasswordName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("ContainerId") {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("ContainerName") {
            self.containerName = dict["ContainerName"] as! String
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("Launcher") {
            self.launcher = dict["Launcher"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepeatMode") {
            self.repeatMode = dict["RepeatMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceTag") {
            var tmp : [InvokeCommandRequest.ResourceTag] = []
            for v in dict["ResourceTag"] as! [Any] {
                var model = InvokeCommandRequest.ResourceTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceTag = tmp
        }
        if dict.keys.contains("Tag") {
            var tmp : [InvokeCommandRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = InvokeCommandRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TerminationMode") {
            self.terminationMode = dict["TerminationMode"] as! String
        }
        if dict.keys.contains("Timed") {
            self.timed = dict["Timed"] as! Bool
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
        if dict.keys.contains("WindowsPasswordName") {
            self.windowsPasswordName = dict["WindowsPasswordName"] as! String
        }
    }
}

public class InvokeCommandShrinkRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var commandId: String?

    public var containerId: String?

    public var containerName: String?

    public var frequency: String?

    public var instanceId: [String]?

    public var launcher: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parametersShrink: String?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [InvokeCommandShrinkRequest.ResourceTag]?

    public var tag: [InvokeCommandShrinkRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var username: String?

    public var windowsPasswordName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("ContainerId") {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("ContainerName") {
            self.containerName = dict["ContainerName"] as! String
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("Launcher") {
            self.launcher = dict["Launcher"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parametersShrink = dict["Parameters"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepeatMode") {
            self.repeatMode = dict["RepeatMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceTag") {
            var tmp : [InvokeCommandShrinkRequest.ResourceTag] = []
            for v in dict["ResourceTag"] as! [Any] {
                var model = InvokeCommandShrinkRequest.ResourceTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceTag = tmp
        }
        if dict.keys.contains("Tag") {
            var tmp : [InvokeCommandShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = InvokeCommandShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TerminationMode") {
            self.terminationMode = dict["TerminationMode"] as! String
        }
        if dict.keys.contains("Timed") {
            self.timed = dict["Timed"] as! Bool
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
        if dict.keys.contains("WindowsPasswordName") {
            self.windowsPasswordName = dict["WindowsPasswordName"] as! String
        }
    }
}

public class InvokeCommandResponseBody : Tea.TeaModel {
    public var invokeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class InvokeCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: InvokeCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = InvokeCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinResourceGroupRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class JoinResourceGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinResourceGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinResourceGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinResourceGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class JoinSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class JoinSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class JoinSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: JoinSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = JoinSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class LeaveSecurityGroupRequest : Tea.TeaModel {
    public var instanceId: String?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class LeaveSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class LeaveSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: LeaveSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = LeaveSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListPluginStatusRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var maxResults: Int32?

    public var name: String?

    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maxResults != nil {
            map["MaxResults"] = self.maxResults!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("MaxResults") {
            self.maxResults = dict["MaxResults"] as! Int32
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ListPluginStatusResponseBody : Tea.TeaModel {
    public class InstancePluginStatusSet : Tea.TeaModel {
        public class InstancePluginStatus : Tea.TeaModel {
            public class PluginStatusSet : Tea.TeaModel {
                public class PluginStatus : Tea.TeaModel {
                    public var firstHeartbeatTime: String?

                    public var lastHeartbeatTime: String?

                    public var pluginName: String?

                    public var pluginStatus: String?

                    public var pluginVersion: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.firstHeartbeatTime != nil {
                            map["FirstHeartbeatTime"] = self.firstHeartbeatTime!
                        }
                        if self.lastHeartbeatTime != nil {
                            map["LastHeartbeatTime"] = self.lastHeartbeatTime!
                        }
                        if self.pluginName != nil {
                            map["PluginName"] = self.pluginName!
                        }
                        if self.pluginStatus != nil {
                            map["PluginStatus"] = self.pluginStatus!
                        }
                        if self.pluginVersion != nil {
                            map["PluginVersion"] = self.pluginVersion!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("FirstHeartbeatTime") {
                            self.firstHeartbeatTime = dict["FirstHeartbeatTime"] as! String
                        }
                        if dict.keys.contains("LastHeartbeatTime") {
                            self.lastHeartbeatTime = dict["LastHeartbeatTime"] as! String
                        }
                        if dict.keys.contains("PluginName") {
                            self.pluginName = dict["PluginName"] as! String
                        }
                        if dict.keys.contains("PluginStatus") {
                            self.pluginStatus = dict["PluginStatus"] as! String
                        }
                        if dict.keys.contains("PluginVersion") {
                            self.pluginVersion = dict["PluginVersion"] as! String
                        }
                    }
                }
                public var pluginStatus: [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet.PluginStatus]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.pluginStatus != nil {
                        var tmp : [Any] = []
                        for k in self.pluginStatus! {
                            tmp.append(k.toMap())
                        }
                        map["PluginStatus"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("PluginStatus") {
                        var tmp : [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet.PluginStatus] = []
                        for v in dict["PluginStatus"] as! [Any] {
                            var model = ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet.PluginStatus()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.pluginStatus = tmp
                    }
                }
            }
            public var instanceId: String?

            public var pluginStatusSet: ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.pluginStatusSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.pluginStatusSet != nil {
                    map["PluginStatusSet"] = self.pluginStatusSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("PluginStatusSet") {
                    var model = ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus.PluginStatusSet()
                    model.fromMap(dict["PluginStatusSet"] as! [String: Any])
                    self.pluginStatusSet = model
                }
            }
        }
        public var instancePluginStatus: [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instancePluginStatus != nil {
                var tmp : [Any] = []
                for k in self.instancePluginStatus! {
                    tmp.append(k.toMap())
                }
                map["InstancePluginStatus"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstancePluginStatus") {
                var tmp : [ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus] = []
                for v in dict["InstancePluginStatus"] as! [Any] {
                    var model = ListPluginStatusResponseBody.InstancePluginStatusSet.InstancePluginStatus()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instancePluginStatus = tmp
            }
        }
    }
    public var instancePluginStatusSet: ListPluginStatusResponseBody.InstancePluginStatusSet?

    public var nextToken: String?

    public var pageNumber: Int64?

    public var pageSize: Int64?

    public var requestId: String?

    public var totalCount: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instancePluginStatusSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instancePluginStatusSet != nil {
            map["InstancePluginStatusSet"] = self.instancePluginStatusSet?.toMap()
        }
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.pageNumber != nil {
            map["PageNumber"] = self.pageNumber!
        }
        if self.pageSize != nil {
            map["PageSize"] = self.pageSize!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.totalCount != nil {
            map["TotalCount"] = self.totalCount!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstancePluginStatusSet") {
            var model = ListPluginStatusResponseBody.InstancePluginStatusSet()
            model.fromMap(dict["InstancePluginStatusSet"] as! [String: Any])
            self.instancePluginStatusSet = model
        }
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("PageNumber") {
            self.pageNumber = dict["PageNumber"] as! Int64
        }
        if dict.keys.contains("PageSize") {
            self.pageSize = dict["PageSize"] as! Int64
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TotalCount") {
            self.totalCount = dict["TotalCount"] as! Int64
        }
    }
}

public class ListPluginStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListPluginStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListPluginStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ListTagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class TagFilter : Tea.TeaModel {
        public var tagKey: String?

        public var tagValues: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagKey != nil {
                map["TagKey"] = self.tagKey!
            }
            if self.tagValues != nil {
                map["TagValues"] = self.tagValues!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagKey") {
                self.tagKey = dict["TagKey"] as! String
            }
            if dict.keys.contains("TagValues") {
                self.tagValues = dict["TagValues"] as! [String]
            }
        }
    }
    public var nextToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [ListTagResourcesRequest.Tag]?

    public var tagFilter: [ListTagResourcesRequest.TagFilter]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tagFilter != nil {
            var tmp : [Any] = []
            for k in self.tagFilter! {
                tmp.append(k.toMap())
            }
            map["TagFilter"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [ListTagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = ListTagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TagFilter") {
            var tmp : [ListTagResourcesRequest.TagFilter] = []
            for v in dict["TagFilter"] as! [Any] {
                var model = ListTagResourcesRequest.TagFilter()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tagFilter = tmp
        }
    }
}

public class ListTagResourcesResponseBody : Tea.TeaModel {
    public class TagResources : Tea.TeaModel {
        public class TagResource : Tea.TeaModel {
            public var resourceId: String?

            public var resourceType: String?

            public var tagKey: String?

            public var tagValue: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.resourceId != nil {
                    map["ResourceId"] = self.resourceId!
                }
                if self.resourceType != nil {
                    map["ResourceType"] = self.resourceType!
                }
                if self.tagKey != nil {
                    map["TagKey"] = self.tagKey!
                }
                if self.tagValue != nil {
                    map["TagValue"] = self.tagValue!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ResourceId") {
                    self.resourceId = dict["ResourceId"] as! String
                }
                if dict.keys.contains("ResourceType") {
                    self.resourceType = dict["ResourceType"] as! String
                }
                if dict.keys.contains("TagKey") {
                    self.tagKey = dict["TagKey"] as! String
                }
                if dict.keys.contains("TagValue") {
                    self.tagValue = dict["TagValue"] as! String
                }
            }
        }
        public var tagResource: [ListTagResourcesResponseBody.TagResources.TagResource]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tagResource != nil {
                var tmp : [Any] = []
                for k in self.tagResource! {
                    tmp.append(k.toMap())
                }
                map["TagResource"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TagResource") {
                var tmp : [ListTagResourcesResponseBody.TagResources.TagResource] = []
                for v in dict["TagResource"] as! [Any] {
                    var model = ListTagResourcesResponseBody.TagResources.TagResource()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.tagResource = tmp
            }
        }
    }
    public var nextToken: String?

    public var requestId: String?

    public var tagResources: ListTagResourcesResponseBody.TagResources?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.tagResources?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.nextToken != nil {
            map["NextToken"] = self.nextToken!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tagResources != nil {
            map["TagResources"] = self.tagResources?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NextToken") {
            self.nextToken = dict["NextToken"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TagResources") {
            var model = ListTagResourcesResponseBody.TagResources()
            model.fromMap(dict["TagResources"] as! [String: Any])
            self.tagResources = model
        }
    }
}

public class ListTagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ListTagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ListTagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAutoProvisioningGroupRequest : Tea.TeaModel {
    public class LaunchTemplateConfig : Tea.TeaModel {
        public var instanceType: String?

        public var maxPrice: Double?

        public var priority: Int32?

        public var vSwitchId: String?

        public var weightedCapacity: Double?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.maxPrice != nil {
                map["MaxPrice"] = self.maxPrice!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            if self.weightedCapacity != nil {
                map["WeightedCapacity"] = self.weightedCapacity!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("MaxPrice") {
                self.maxPrice = dict["MaxPrice"] as! Double
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! Int32
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
            if dict.keys.contains("WeightedCapacity") {
                self.weightedCapacity = dict["WeightedCapacity"] as! Double
            }
        }
    }
    public var autoProvisioningGroupId: String?

    public var autoProvisioningGroupName: String?

    public var defaultTargetCapacityType: String?

    public var excessCapacityTerminationPolicy: String?

    public var launchTemplateConfig: [ModifyAutoProvisioningGroupRequest.LaunchTemplateConfig]?

    public var maxSpotPrice: Double?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var payAsYouGoTargetCapacity: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var spotTargetCapacity: String?

    public var terminateInstancesWithExpiration: Bool?

    public var totalTargetCapacity: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoProvisioningGroupId != nil {
            map["AutoProvisioningGroupId"] = self.autoProvisioningGroupId!
        }
        if self.autoProvisioningGroupName != nil {
            map["AutoProvisioningGroupName"] = self.autoProvisioningGroupName!
        }
        if self.defaultTargetCapacityType != nil {
            map["DefaultTargetCapacityType"] = self.defaultTargetCapacityType!
        }
        if self.excessCapacityTerminationPolicy != nil {
            map["ExcessCapacityTerminationPolicy"] = self.excessCapacityTerminationPolicy!
        }
        if self.launchTemplateConfig != nil {
            var tmp : [Any] = []
            for k in self.launchTemplateConfig! {
                tmp.append(k.toMap())
            }
            map["LaunchTemplateConfig"] = tmp
        }
        if self.maxSpotPrice != nil {
            map["MaxSpotPrice"] = self.maxSpotPrice!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.payAsYouGoTargetCapacity != nil {
            map["PayAsYouGoTargetCapacity"] = self.payAsYouGoTargetCapacity!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.spotTargetCapacity != nil {
            map["SpotTargetCapacity"] = self.spotTargetCapacity!
        }
        if self.terminateInstancesWithExpiration != nil {
            map["TerminateInstancesWithExpiration"] = self.terminateInstancesWithExpiration!
        }
        if self.totalTargetCapacity != nil {
            map["TotalTargetCapacity"] = self.totalTargetCapacity!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoProvisioningGroupId") {
            self.autoProvisioningGroupId = dict["AutoProvisioningGroupId"] as! String
        }
        if dict.keys.contains("AutoProvisioningGroupName") {
            self.autoProvisioningGroupName = dict["AutoProvisioningGroupName"] as! String
        }
        if dict.keys.contains("DefaultTargetCapacityType") {
            self.defaultTargetCapacityType = dict["DefaultTargetCapacityType"] as! String
        }
        if dict.keys.contains("ExcessCapacityTerminationPolicy") {
            self.excessCapacityTerminationPolicy = dict["ExcessCapacityTerminationPolicy"] as! String
        }
        if dict.keys.contains("LaunchTemplateConfig") {
            var tmp : [ModifyAutoProvisioningGroupRequest.LaunchTemplateConfig] = []
            for v in dict["LaunchTemplateConfig"] as! [Any] {
                var model = ModifyAutoProvisioningGroupRequest.LaunchTemplateConfig()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.launchTemplateConfig = tmp
        }
        if dict.keys.contains("MaxSpotPrice") {
            self.maxSpotPrice = dict["MaxSpotPrice"] as! Double
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PayAsYouGoTargetCapacity") {
            self.payAsYouGoTargetCapacity = dict["PayAsYouGoTargetCapacity"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SpotTargetCapacity") {
            self.spotTargetCapacity = dict["SpotTargetCapacity"] as! String
        }
        if dict.keys.contains("TerminateInstancesWithExpiration") {
            self.terminateInstancesWithExpiration = dict["TerminateInstancesWithExpiration"] as! Bool
        }
        if dict.keys.contains("TotalTargetCapacity") {
            self.totalTargetCapacity = dict["TotalTargetCapacity"] as! String
        }
    }
}

public class ModifyAutoProvisioningGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAutoProvisioningGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoProvisioningGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAutoProvisioningGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAutoSnapshotPolicyRequest : Tea.TeaModel {
    public var dataDiskPolicyEnabled: Bool?

    public var dataDiskPolicyRetentionDays: Int32?

    public var dataDiskPolicyRetentionLastWeek: Bool?

    public var dataDiskPolicyTimePeriod: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var systemDiskPolicyEnabled: Bool?

    public var systemDiskPolicyRetentionDays: Int32?

    public var systemDiskPolicyRetentionLastWeek: Bool?

    public var systemDiskPolicyTimePeriod: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dataDiskPolicyEnabled != nil {
            map["DataDiskPolicyEnabled"] = self.dataDiskPolicyEnabled!
        }
        if self.dataDiskPolicyRetentionDays != nil {
            map["DataDiskPolicyRetentionDays"] = self.dataDiskPolicyRetentionDays!
        }
        if self.dataDiskPolicyRetentionLastWeek != nil {
            map["DataDiskPolicyRetentionLastWeek"] = self.dataDiskPolicyRetentionLastWeek!
        }
        if self.dataDiskPolicyTimePeriod != nil {
            map["DataDiskPolicyTimePeriod"] = self.dataDiskPolicyTimePeriod!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.systemDiskPolicyEnabled != nil {
            map["SystemDiskPolicyEnabled"] = self.systemDiskPolicyEnabled!
        }
        if self.systemDiskPolicyRetentionDays != nil {
            map["SystemDiskPolicyRetentionDays"] = self.systemDiskPolicyRetentionDays!
        }
        if self.systemDiskPolicyRetentionLastWeek != nil {
            map["SystemDiskPolicyRetentionLastWeek"] = self.systemDiskPolicyRetentionLastWeek!
        }
        if self.systemDiskPolicyTimePeriod != nil {
            map["SystemDiskPolicyTimePeriod"] = self.systemDiskPolicyTimePeriod!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DataDiskPolicyEnabled") {
            self.dataDiskPolicyEnabled = dict["DataDiskPolicyEnabled"] as! Bool
        }
        if dict.keys.contains("DataDiskPolicyRetentionDays") {
            self.dataDiskPolicyRetentionDays = dict["DataDiskPolicyRetentionDays"] as! Int32
        }
        if dict.keys.contains("DataDiskPolicyRetentionLastWeek") {
            self.dataDiskPolicyRetentionLastWeek = dict["DataDiskPolicyRetentionLastWeek"] as! Bool
        }
        if dict.keys.contains("DataDiskPolicyTimePeriod") {
            self.dataDiskPolicyTimePeriod = dict["DataDiskPolicyTimePeriod"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SystemDiskPolicyEnabled") {
            self.systemDiskPolicyEnabled = dict["SystemDiskPolicyEnabled"] as! Bool
        }
        if dict.keys.contains("SystemDiskPolicyRetentionDays") {
            self.systemDiskPolicyRetentionDays = dict["SystemDiskPolicyRetentionDays"] as! Int32
        }
        if dict.keys.contains("SystemDiskPolicyRetentionLastWeek") {
            self.systemDiskPolicyRetentionLastWeek = dict["SystemDiskPolicyRetentionLastWeek"] as! Bool
        }
        if dict.keys.contains("SystemDiskPolicyTimePeriod") {
            self.systemDiskPolicyTimePeriod = dict["SystemDiskPolicyTimePeriod"] as! Int32
        }
    }
}

public class ModifyAutoSnapshotPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAutoSnapshotPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoSnapshotPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAutoSnapshotPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyAutoSnapshotPolicyExRequest : Tea.TeaModel {
    public class CopyEncryptionConfiguration : Tea.TeaModel {
        public class Arn : Tea.TeaModel {
            public var assumeRoleFor: Int64?

            public var roleType: String?

            public var rolearn: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.assumeRoleFor != nil {
                    map["AssumeRoleFor"] = self.assumeRoleFor!
                }
                if self.roleType != nil {
                    map["RoleType"] = self.roleType!
                }
                if self.rolearn != nil {
                    map["Rolearn"] = self.rolearn!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("AssumeRoleFor") {
                    self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
                }
                if dict.keys.contains("RoleType") {
                    self.roleType = dict["RoleType"] as! String
                }
                if dict.keys.contains("Rolearn") {
                    self.rolearn = dict["Rolearn"] as! String
                }
            }
        }
        public var arn: [ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration.Arn]?

        public var encrypted: Bool?

        public var KMSKeyId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.arn != nil {
                var tmp : [Any] = []
                for k in self.arn! {
                    tmp.append(k.toMap())
                }
                map["Arn"] = tmp
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Arn") {
                var tmp : [ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration.Arn] = []
                for v in dict["Arn"] as! [Any] {
                    var model = ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration.Arn()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.arn = tmp
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! Bool
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
        }
    }
    public var copiedSnapshotsRetentionDays: Int32?

    public var copyEncryptionConfiguration: ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration?

    public var enableCrossRegionCopy: Bool?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetCopyRegions: String?

    public var autoSnapshotPolicyId: String?

    public var autoSnapshotPolicyName: String?

    public var regionId: String?

    public var repeatWeekdays: String?

    public var retentionDays: Int32?

    public var timePoints: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.copyEncryptionConfiguration?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.copiedSnapshotsRetentionDays != nil {
            map["CopiedSnapshotsRetentionDays"] = self.copiedSnapshotsRetentionDays!
        }
        if self.copyEncryptionConfiguration != nil {
            map["CopyEncryptionConfiguration"] = self.copyEncryptionConfiguration?.toMap()
        }
        if self.enableCrossRegionCopy != nil {
            map["EnableCrossRegionCopy"] = self.enableCrossRegionCopy!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetCopyRegions != nil {
            map["TargetCopyRegions"] = self.targetCopyRegions!
        }
        if self.autoSnapshotPolicyId != nil {
            map["autoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
        }
        if self.autoSnapshotPolicyName != nil {
            map["autoSnapshotPolicyName"] = self.autoSnapshotPolicyName!
        }
        if self.regionId != nil {
            map["regionId"] = self.regionId!
        }
        if self.repeatWeekdays != nil {
            map["repeatWeekdays"] = self.repeatWeekdays!
        }
        if self.retentionDays != nil {
            map["retentionDays"] = self.retentionDays!
        }
        if self.timePoints != nil {
            map["timePoints"] = self.timePoints!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CopiedSnapshotsRetentionDays") {
            self.copiedSnapshotsRetentionDays = dict["CopiedSnapshotsRetentionDays"] as! Int32
        }
        if dict.keys.contains("CopyEncryptionConfiguration") {
            var model = ModifyAutoSnapshotPolicyExRequest.CopyEncryptionConfiguration()
            model.fromMap(dict["CopyEncryptionConfiguration"] as! [String: Any])
            self.copyEncryptionConfiguration = model
        }
        if dict.keys.contains("EnableCrossRegionCopy") {
            self.enableCrossRegionCopy = dict["EnableCrossRegionCopy"] as! Bool
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TargetCopyRegions") {
            self.targetCopyRegions = dict["TargetCopyRegions"] as! String
        }
        if dict.keys.contains("autoSnapshotPolicyId") {
            self.autoSnapshotPolicyId = dict["autoSnapshotPolicyId"] as! String
        }
        if dict.keys.contains("autoSnapshotPolicyName") {
            self.autoSnapshotPolicyName = dict["autoSnapshotPolicyName"] as! String
        }
        if dict.keys.contains("regionId") {
            self.regionId = dict["regionId"] as! String
        }
        if dict.keys.contains("repeatWeekdays") {
            self.repeatWeekdays = dict["repeatWeekdays"] as! String
        }
        if dict.keys.contains("retentionDays") {
            self.retentionDays = dict["retentionDays"] as! Int32
        }
        if dict.keys.contains("timePoints") {
            self.timePoints = dict["timePoints"] as! String
        }
    }
}

public class ModifyAutoSnapshotPolicyExResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyAutoSnapshotPolicyExResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyAutoSnapshotPolicyExResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyAutoSnapshotPolicyExResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyBandwidthPackageSpecRequest : Tea.TeaModel {
    public var bandwidth: String?

    public var bandwidthPackageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyBandwidthPackageSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyBandwidthPackageSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyBandwidthPackageSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyBandwidthPackageSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCapacityReservationRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var privatePoolOptions: ModifyCapacityReservationRequest.PrivatePoolOptions?

    public var description_: String?

    public var endTime: String?

    public var endTimeType: String?

    public var instanceAmount: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var platform: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.endTimeType != nil {
            map["EndTimeType"] = self.endTimeType!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ModifyCapacityReservationRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("EndTimeType") {
            self.endTimeType = dict["EndTimeType"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ModifyCapacityReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCapacityReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCloudAssistantSettingsRequest : Tea.TeaModel {
    public class AgentUpgradeConfig : Tea.TeaModel {
        public var allowedUpgradeWindow: [String]?

        public var enabled: Bool?

        public var timeZone: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.allowedUpgradeWindow != nil {
                map["AllowedUpgradeWindow"] = self.allowedUpgradeWindow!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.timeZone != nil {
                map["TimeZone"] = self.timeZone!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AllowedUpgradeWindow") {
                self.allowedUpgradeWindow = dict["AllowedUpgradeWindow"] as! [String]
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("TimeZone") {
                self.timeZone = dict["TimeZone"] as! String
            }
        }
    }
    public class OssDeliveryConfig : Tea.TeaModel {
        public var bucketName: String?

        public var enabled: Bool?

        public var encryptionAlgorithm: String?

        public var encryptionKeyId: String?

        public var encryptionType: String?

        public var prefix_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.bucketName != nil {
                map["BucketName"] = self.bucketName!
            }
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.encryptionAlgorithm != nil {
                map["EncryptionAlgorithm"] = self.encryptionAlgorithm!
            }
            if self.encryptionKeyId != nil {
                map["EncryptionKeyId"] = self.encryptionKeyId!
            }
            if self.encryptionType != nil {
                map["EncryptionType"] = self.encryptionType!
            }
            if self.prefix_ != nil {
                map["Prefix"] = self.prefix_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("BucketName") {
                self.bucketName = dict["BucketName"] as! String
            }
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("EncryptionAlgorithm") {
                self.encryptionAlgorithm = dict["EncryptionAlgorithm"] as! String
            }
            if dict.keys.contains("EncryptionKeyId") {
                self.encryptionKeyId = dict["EncryptionKeyId"] as! String
            }
            if dict.keys.contains("EncryptionType") {
                self.encryptionType = dict["EncryptionType"] as! String
            }
            if dict.keys.contains("Prefix") {
                self.prefix_ = dict["Prefix"] as! String
            }
        }
    }
    public class SlsDeliveryConfig : Tea.TeaModel {
        public var enabled: Bool?

        public var logstoreName: String?

        public var projectName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enabled != nil {
                map["Enabled"] = self.enabled!
            }
            if self.logstoreName != nil {
                map["LogstoreName"] = self.logstoreName!
            }
            if self.projectName != nil {
                map["ProjectName"] = self.projectName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Enabled") {
                self.enabled = dict["Enabled"] as! Bool
            }
            if dict.keys.contains("LogstoreName") {
                self.logstoreName = dict["LogstoreName"] as! String
            }
            if dict.keys.contains("ProjectName") {
                self.projectName = dict["ProjectName"] as! String
            }
        }
    }
    public var agentUpgradeConfig: ModifyCloudAssistantSettingsRequest.AgentUpgradeConfig?

    public var ossDeliveryConfig: ModifyCloudAssistantSettingsRequest.OssDeliveryConfig?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var settingType: String?

    public var slsDeliveryConfig: ModifyCloudAssistantSettingsRequest.SlsDeliveryConfig?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.agentUpgradeConfig?.validate()
        try self.ossDeliveryConfig?.validate()
        try self.slsDeliveryConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentUpgradeConfig != nil {
            map["AgentUpgradeConfig"] = self.agentUpgradeConfig?.toMap()
        }
        if self.ossDeliveryConfig != nil {
            map["OssDeliveryConfig"] = self.ossDeliveryConfig?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.settingType != nil {
            map["SettingType"] = self.settingType!
        }
        if self.slsDeliveryConfig != nil {
            map["SlsDeliveryConfig"] = self.slsDeliveryConfig?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentUpgradeConfig") {
            var model = ModifyCloudAssistantSettingsRequest.AgentUpgradeConfig()
            model.fromMap(dict["AgentUpgradeConfig"] as! [String: Any])
            self.agentUpgradeConfig = model
        }
        if dict.keys.contains("OssDeliveryConfig") {
            var model = ModifyCloudAssistantSettingsRequest.OssDeliveryConfig()
            model.fromMap(dict["OssDeliveryConfig"] as! [String: Any])
            self.ossDeliveryConfig = model
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SettingType") {
            self.settingType = dict["SettingType"] as! String
        }
        if dict.keys.contains("SlsDeliveryConfig") {
            var model = ModifyCloudAssistantSettingsRequest.SlsDeliveryConfig()
            model.fromMap(dict["SlsDeliveryConfig"] as! [String: Any])
            self.slsDeliveryConfig = model
        }
    }
}

public class ModifyCloudAssistantSettingsShrinkRequest : Tea.TeaModel {
    public var agentUpgradeConfigShrink: String?

    public var ossDeliveryConfigShrink: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var settingType: String?

    public var slsDeliveryConfigShrink: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.agentUpgradeConfigShrink != nil {
            map["AgentUpgradeConfig"] = self.agentUpgradeConfigShrink!
        }
        if self.ossDeliveryConfigShrink != nil {
            map["OssDeliveryConfig"] = self.ossDeliveryConfigShrink!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.settingType != nil {
            map["SettingType"] = self.settingType!
        }
        if self.slsDeliveryConfigShrink != nil {
            map["SlsDeliveryConfig"] = self.slsDeliveryConfigShrink!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AgentUpgradeConfig") {
            self.agentUpgradeConfigShrink = dict["AgentUpgradeConfig"] as! String
        }
        if dict.keys.contains("OssDeliveryConfig") {
            self.ossDeliveryConfigShrink = dict["OssDeliveryConfig"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SettingType") {
            self.settingType = dict["SettingType"] as! String
        }
        if dict.keys.contains("SlsDeliveryConfig") {
            self.slsDeliveryConfigShrink = dict["SlsDeliveryConfig"] as! String
        }
    }
}

public class ModifyCloudAssistantSettingsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCloudAssistantSettingsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCloudAssistantSettingsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCloudAssistantSettingsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyCommandRequest : Tea.TeaModel {
    public var commandContent: String?

    public var commandId: String?

    public var description_: String?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var timeout: Int64?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Launcher") {
            self.launcher = dict["Launcher"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("WorkingDir") {
            self.workingDir = dict["WorkingDir"] as! String
        }
    }
}

public class ModifyCommandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAttributeRequest : Tea.TeaModel {
    public class NetworkAttributes : Tea.TeaModel {
        public var slbUdpTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.slbUdpTimeout != nil {
                map["SlbUdpTimeout"] = self.slbUdpTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("SlbUdpTimeout") {
                self.slbUdpTimeout = dict["SlbUdpTimeout"] as! Int32
            }
            if dict.keys.contains("UdpTimeout") {
                self.udpTimeout = dict["UdpTimeout"] as! Int32
            }
        }
    }
    public var networkAttributes: ModifyDedicatedHostAttributeRequest.NetworkAttributes?

    public var actionOnMaintenance: String?

    public var autoPlacement: String?

    public var cpuOverCommitRatio: Double?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var dedicatedHostName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.networkAttributes?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.networkAttributes != nil {
            map["NetworkAttributes"] = self.networkAttributes?.toMap()
        }
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.autoPlacement != nil {
            map["AutoPlacement"] = self.autoPlacement!
        }
        if self.cpuOverCommitRatio != nil {
            map["CpuOverCommitRatio"] = self.cpuOverCommitRatio!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.dedicatedHostName != nil {
            map["DedicatedHostName"] = self.dedicatedHostName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("NetworkAttributes") {
            var model = ModifyDedicatedHostAttributeRequest.NetworkAttributes()
            model.fromMap(dict["NetworkAttributes"] as! [String: Any])
            self.networkAttributes = model
        }
        if dict.keys.contains("ActionOnMaintenance") {
            self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
        }
        if dict.keys.contains("AutoPlacement") {
            self.autoPlacement = dict["AutoPlacement"] as! String
        }
        if dict.keys.contains("CpuOverCommitRatio") {
            self.cpuOverCommitRatio = dict["CpuOverCommitRatio"] as! Double
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DedicatedHostName") {
            self.dedicatedHostName = dict["DedicatedHostName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeRequest : Tea.TeaModel {
    public var autoReleaseTime: String?

    public var dedicatedHostId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostAutoReleaseTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAutoReleaseTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostAutoReleaseTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewWithEcs: String?

    public var dedicatedHostIds: String?

    public var duration: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewWithEcs != nil {
            map["AutoRenewWithEcs"] = self.autoRenewWithEcs!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewWithEcs") {
            self.autoRenewWithEcs = dict["AutoRenewWithEcs"] as! String
        }
        if dict.keys.contains("DedicatedHostIds") {
            self.dedicatedHostIds = dict["DedicatedHostIds"] as! String
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RenewalStatus") {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostClusterAttributeRequest : Tea.TeaModel {
    public var dedicatedHostClusterId: String?

    public var dedicatedHostClusterName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostClusterName != nil {
            map["DedicatedHostClusterName"] = self.dedicatedHostClusterName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostClusterName") {
            self.dedicatedHostClusterName = dict["DedicatedHostClusterName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostClusterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostClusterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostClusterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostClusterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDedicatedHostsChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var dedicatedHostChargeType: String?

    public var dedicatedHostIds: String?

    public var detailFee: Bool?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedHostChargeType != nil {
            map["DedicatedHostChargeType"] = self.dedicatedHostChargeType!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.detailFee != nil {
            map["DetailFee"] = self.detailFee!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DedicatedHostChargeType") {
            self.dedicatedHostChargeType = dict["DedicatedHostChargeType"] as! String
        }
        if dict.keys.contains("DedicatedHostIds") {
            self.dedicatedHostIds = dict["DedicatedHostIds"] as! String
        }
        if dict.keys.contains("DetailFee") {
            self.detailFee = dict["DetailFee"] as! Bool
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDedicatedHostsChargeTypeResponseBody : Tea.TeaModel {
    public class FeeOfInstances : Tea.TeaModel {
        public class FeeOfInstance : Tea.TeaModel {
            public var currency: String?

            public var fee: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.fee != nil {
                    map["Fee"] = self.fee!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("Fee") {
                    self.fee = dict["Fee"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var feeOfInstance: [ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances.FeeOfInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feeOfInstance != nil {
                var tmp : [Any] = []
                for k in self.feeOfInstance! {
                    tmp.append(k.toMap())
                }
                map["FeeOfInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FeeOfInstance") {
                var tmp : [ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances.FeeOfInstance] = []
                for v in dict["FeeOfInstance"] as! [Any] {
                    var model = ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances.FeeOfInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.feeOfInstance = tmp
            }
        }
    }
    public var feeOfInstances: ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.feeOfInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.feeOfInstances != nil {
            map["FeeOfInstances"] = self.feeOfInstances?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FeeOfInstances") {
            var model = ModifyDedicatedHostsChargeTypeResponseBody.FeeOfInstances()
            model.fromMap(dict["FeeOfInstances"] as! [String: Any])
            self.feeOfInstances = model
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDedicatedHostsChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDedicatedHostsChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDedicatedHostsChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDemandRequest : Tea.TeaModel {
    public var amount: Int32?

    public var clientToken: String?

    public var demandDescription: String?

    public var demandId: String?

    public var demandName: String?

    public var endTime: String?

    public var instanceChargeType: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.demandDescription != nil {
            map["DemandDescription"] = self.demandDescription!
        }
        if self.demandId != nil {
            map["DemandId"] = self.demandId!
        }
        if self.demandName != nil {
            map["DemandName"] = self.demandName!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DemandDescription") {
            self.demandDescription = dict["DemandDescription"] as! String
        }
        if dict.keys.contains("DemandId") {
            self.demandId = dict["DemandId"] as! String
        }
        if dict.keys.contains("DemandName") {
            self.demandName = dict["DemandName"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class ModifyDemandResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDemandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDemandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDemandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDeploymentSetAttributeRequest : Tea.TeaModel {
    public var deploymentSetId: String?

    public var deploymentSetName: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.deploymentSetName != nil {
            map["DeploymentSetName"] = self.deploymentSetName!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("DeploymentSetName") {
            self.deploymentSetName = dict["DeploymentSetName"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDeploymentSetAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDeploymentSetAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDeploymentSetAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDeploymentSetAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiagnosticMetricSetRequest : Tea.TeaModel {
    public var description_: String?

    public var metricIds: [String]?

    public var metricSetId: String?

    public var metricSetName: String?

    public var regionId: String?

    public var resourceType: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.metricIds != nil {
            map["MetricIds"] = self.metricIds!
        }
        if self.metricSetId != nil {
            map["MetricSetId"] = self.metricSetId!
        }
        if self.metricSetName != nil {
            map["MetricSetName"] = self.metricSetName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("MetricIds") {
            self.metricIds = dict["MetricIds"] as! [String]
        }
        if dict.keys.contains("MetricSetId") {
            self.metricSetId = dict["MetricSetId"] as! String
        }
        if dict.keys.contains("MetricSetName") {
            self.metricSetName = dict["MetricSetName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
    }
}

public class ModifyDiagnosticMetricSetResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDiagnosticMetricSetResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiagnosticMetricSetResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiagnosticMetricSetResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiskAttributeRequest : Tea.TeaModel {
    public var burstingEnabled: Bool?

    public var deleteAutoSnapshot: Bool?

    public var deleteWithInstance: Bool?

    public var description_: String?

    public var diskId: String?

    public var diskIds: [String]?

    public var diskName: String?

    public var enableAutoSnapshot: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.burstingEnabled != nil {
            map["BurstingEnabled"] = self.burstingEnabled!
        }
        if self.deleteAutoSnapshot != nil {
            map["DeleteAutoSnapshot"] = self.deleteAutoSnapshot!
        }
        if self.deleteWithInstance != nil {
            map["DeleteWithInstance"] = self.deleteWithInstance!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.diskName != nil {
            map["DiskName"] = self.diskName!
        }
        if self.enableAutoSnapshot != nil {
            map["EnableAutoSnapshot"] = self.enableAutoSnapshot!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BurstingEnabled") {
            self.burstingEnabled = dict["BurstingEnabled"] as! Bool
        }
        if dict.keys.contains("DeleteAutoSnapshot") {
            self.deleteAutoSnapshot = dict["DeleteAutoSnapshot"] as! Bool
        }
        if dict.keys.contains("DeleteWithInstance") {
            self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("DiskIds") {
            self.diskIds = dict["DiskIds"] as! [String]
        }
        if dict.keys.contains("DiskName") {
            self.diskName = dict["DiskName"] as! String
        }
        if dict.keys.contains("EnableAutoSnapshot") {
            self.enableAutoSnapshot = dict["EnableAutoSnapshot"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDiskAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDiskAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiskAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiskChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var diskChargeType: String?

    public var diskIds: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskChargeType != nil {
            map["DiskChargeType"] = self.diskChargeType!
        }
        if self.diskIds != nil {
            map["DiskIds"] = self.diskIds!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DiskChargeType") {
            self.diskChargeType = dict["DiskChargeType"] as! String
        }
        if dict.keys.contains("DiskIds") {
            self.diskIds = dict["DiskIds"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDiskChargeTypeResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDiskChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiskChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiskDefaultKMSKeyIdRequest : Tea.TeaModel {
    public var KMSKeyId: String?

    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDiskDefaultKMSKeyIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyDiskDefaultKMSKeyIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskDefaultKMSKeyIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiskDefaultKMSKeyIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiskDeploymentRequest : Tea.TeaModel {
    public var diskCategory: String?

    public var diskId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceLevel: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageClusterId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageClusterId != nil {
            map["StorageClusterId"] = self.storageClusterId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskCategory") {
            self.diskCategory = dict["DiskCategory"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageClusterId") {
            self.storageClusterId = dict["StorageClusterId"] as! String
        }
    }
}

public class ModifyDiskDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class ModifyDiskDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiskDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyDiskSpecRequest : Tea.TeaModel {
    public class PerformanceControlOptions : Tea.TeaModel {
        public var IOPS: Int32?

        public var recover: String?

        public var throughput: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.IOPS != nil {
                map["IOPS"] = self.IOPS!
            }
            if self.recover != nil {
                map["Recover"] = self.recover!
            }
            if self.throughput != nil {
                map["Throughput"] = self.throughput!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("IOPS") {
                self.IOPS = dict["IOPS"] as! Int32
            }
            if dict.keys.contains("Recover") {
                self.recover = dict["Recover"] as! String
            }
            if dict.keys.contains("Throughput") {
                self.throughput = dict["Throughput"] as! Int32
            }
        }
    }
    public var diskCategory: String?

    public var diskId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var performanceControlOptions: ModifyDiskSpecRequest.PerformanceControlOptions?

    public var performanceLevel: String?

    public var provisionedIops: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.performanceControlOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskCategory != nil {
            map["DiskCategory"] = self.diskCategory!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.performanceControlOptions != nil {
            map["PerformanceControlOptions"] = self.performanceControlOptions?.toMap()
        }
        if self.performanceLevel != nil {
            map["PerformanceLevel"] = self.performanceLevel!
        }
        if self.provisionedIops != nil {
            map["ProvisionedIops"] = self.provisionedIops!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskCategory") {
            self.diskCategory = dict["DiskCategory"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PerformanceControlOptions") {
            var model = ModifyDiskSpecRequest.PerformanceControlOptions()
            model.fromMap(dict["PerformanceControlOptions"] as! [String: Any])
            self.performanceControlOptions = model
        }
        if dict.keys.contains("PerformanceLevel") {
            self.performanceLevel = dict["PerformanceLevel"] as! String
        }
        if dict.keys.contains("ProvisionedIops") {
            self.provisionedIops = dict["ProvisionedIops"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyDiskSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class ModifyDiskSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyDiskSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyDiskSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyEipAddressAttributeRequest : Tea.TeaModel {
    public var allocationId: String?

    public var bandwidth: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.bandwidth != nil {
            map["Bandwidth"] = self.bandwidth!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("Bandwidth") {
            self.bandwidth = dict["Bandwidth"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyEipAddressAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyEipAddressAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyEipAddressAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyEipAddressAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyElasticityAssuranceRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var name: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.name != nil {
                map["Name"] = self.name!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("Name") {
                self.name = dict["Name"] as! String
            }
        }
    }
    public var privatePoolOptions: ModifyElasticityAssuranceRequest.PrivatePoolOptions?

    public var clientToken: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ModifyElasticityAssuranceRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyElasticityAssuranceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyElasticityAssuranceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyElasticityAssuranceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyElasticityAssuranceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyForwardEntryRequest : Tea.TeaModel {
    public var externalIp: String?

    public var externalPort: String?

    public var forwardEntryId: String?

    public var forwardTableId: String?

    public var internalIp: String?

    public var internalPort: String?

    public var ipProtocol: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.externalIp != nil {
            map["ExternalIp"] = self.externalIp!
        }
        if self.externalPort != nil {
            map["ExternalPort"] = self.externalPort!
        }
        if self.forwardEntryId != nil {
            map["ForwardEntryId"] = self.forwardEntryId!
        }
        if self.forwardTableId != nil {
            map["ForwardTableId"] = self.forwardTableId!
        }
        if self.internalIp != nil {
            map["InternalIp"] = self.internalIp!
        }
        if self.internalPort != nil {
            map["InternalPort"] = self.internalPort!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExternalIp") {
            self.externalIp = dict["ExternalIp"] as! String
        }
        if dict.keys.contains("ExternalPort") {
            self.externalPort = dict["ExternalPort"] as! String
        }
        if dict.keys.contains("ForwardEntryId") {
            self.forwardEntryId = dict["ForwardEntryId"] as! String
        }
        if dict.keys.contains("ForwardTableId") {
            self.forwardTableId = dict["ForwardTableId"] as! String
        }
        if dict.keys.contains("InternalIp") {
            self.internalIp = dict["InternalIp"] as! String
        }
        if dict.keys.contains("InternalPort") {
            self.internalPort = dict["InternalPort"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyForwardEntryResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyForwardEntryResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyForwardEntryResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyForwardEntryResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHaVipAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var haVipId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyHaVipAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyHaVipAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHaVipAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyHaVipAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyHpcClusterAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var hpcClusterId: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyHpcClusterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyHpcClusterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyHpcClusterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyHpcClusterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageAttributeRequest : Tea.TeaModel {
    public class Features : Tea.TeaModel {
        public var nvmeSupport: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.nvmeSupport != nil {
                map["NvmeSupport"] = self.nvmeSupport!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NvmeSupport") {
                self.nvmeSupport = dict["NvmeSupport"] as! String
            }
        }
    }
    public var bootMode: String?

    public var description_: String?

    public var features: ModifyImageAttributeRequest.Features?

    public var imageFamily: String?

    public var imageId: String?

    public var imageName: String?

    public var licenseType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var status: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.features?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bootMode != nil {
            map["BootMode"] = self.bootMode!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.features != nil {
            map["Features"] = self.features?.toMap()
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageName != nil {
            map["ImageName"] = self.imageName!
        }
        if self.licenseType != nil {
            map["LicenseType"] = self.licenseType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.status != nil {
            map["Status"] = self.status!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BootMode") {
            self.bootMode = dict["BootMode"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Features") {
            var model = ModifyImageAttributeRequest.Features()
            model.fromMap(dict["Features"] as! [String: Any])
            self.features = model
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageName") {
            self.imageName = dict["ImageName"] as! String
        }
        if dict.keys.contains("LicenseType") {
            self.licenseType = dict["LicenseType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Status") {
            self.status = dict["Status"] as! String
        }
    }
}

public class ModifyImageAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImageAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageShareGroupPermissionRequest : Tea.TeaModel {
    public var addGroup: [String]?

    public var removeGroup: [String]?

    public var imageId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addGroup != nil {
            map["AddGroup"] = self.addGroup!
        }
        if self.removeGroup != nil {
            map["RemoveGroup"] = self.removeGroup!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddGroup") {
            self.addGroup = dict["AddGroup"] as! [String]
        }
        if dict.keys.contains("RemoveGroup") {
            self.removeGroup = dict["RemoveGroup"] as! [String]
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyImageShareGroupPermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageShareGroupPermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageShareGroupPermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImageShareGroupPermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyImageSharePermissionRequest : Tea.TeaModel {
    public var addAccount: [String]?

    public var imageId: String?

    public var isPublic: Bool?

    public var launchPermission: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeAccount: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addAccount != nil {
            map["AddAccount"] = self.addAccount!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.isPublic != nil {
            map["IsPublic"] = self.isPublic!
        }
        if self.launchPermission != nil {
            map["LaunchPermission"] = self.launchPermission!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeAccount != nil {
            map["RemoveAccount"] = self.removeAccount!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddAccount") {
            self.addAccount = dict["AddAccount"] as! [String]
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("IsPublic") {
            self.isPublic = dict["IsPublic"] as! Bool
        }
        if dict.keys.contains("LaunchPermission") {
            self.launchPermission = dict["LaunchPermission"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoveAccount") {
            self.removeAccount = dict["RemoveAccount"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyImageSharePermissionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyImageSharePermissionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyImageSharePermissionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyImageSharePermissionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAttachmentAttributesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public var privatePoolOptions: ModifyInstanceAttachmentAttributesRequest.PrivatePoolOptions?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ModifyInstanceAttachmentAttributesRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceAttachmentAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAttachmentAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttachmentAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAttachmentAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAttributeRequest : Tea.TeaModel {
    public class CpuOptions : Tea.TeaModel {
        public var topologyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.topologyType != nil {
                map["TopologyType"] = self.topologyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TopologyType") {
                self.topologyType = dict["TopologyType"] as! String
            }
        }
    }
    public class PrivateDnsNameOptions : Tea.TeaModel {
        public var enableInstanceIdDnsAAAARecord: Bool?

        public var enableInstanceIdDnsARecord: Bool?

        public var enableIpDnsARecord: Bool?

        public var enableIpDnsPtrRecord: Bool?

        public var hostnameType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableInstanceIdDnsAAAARecord != nil {
                map["EnableInstanceIdDnsAAAARecord"] = self.enableInstanceIdDnsAAAARecord!
            }
            if self.enableInstanceIdDnsARecord != nil {
                map["EnableInstanceIdDnsARecord"] = self.enableInstanceIdDnsARecord!
            }
            if self.enableIpDnsARecord != nil {
                map["EnableIpDnsARecord"] = self.enableIpDnsARecord!
            }
            if self.enableIpDnsPtrRecord != nil {
                map["EnableIpDnsPtrRecord"] = self.enableIpDnsPtrRecord!
            }
            if self.hostnameType != nil {
                map["HostnameType"] = self.hostnameType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableInstanceIdDnsAAAARecord") {
                self.enableInstanceIdDnsAAAARecord = dict["EnableInstanceIdDnsAAAARecord"] as! Bool
            }
            if dict.keys.contains("EnableInstanceIdDnsARecord") {
                self.enableInstanceIdDnsARecord = dict["EnableInstanceIdDnsARecord"] as! Bool
            }
            if dict.keys.contains("EnableIpDnsARecord") {
                self.enableIpDnsARecord = dict["EnableIpDnsARecord"] as! Bool
            }
            if dict.keys.contains("EnableIpDnsPtrRecord") {
                self.enableIpDnsPtrRecord = dict["EnableIpDnsPtrRecord"] as! Bool
            }
            if dict.keys.contains("HostnameType") {
                self.hostnameType = dict["HostnameType"] as! String
            }
        }
    }
    public class RemoteConnectionOptions : Tea.TeaModel {
        public var password: String?

        public var type: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.password != nil {
                map["Password"] = self.password!
            }
            if self.type != nil {
                map["Type"] = self.type!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Password") {
                self.password = dict["Password"] as! String
            }
            if dict.keys.contains("Type") {
                self.type = dict["Type"] as! String
            }
        }
    }
    public var cpuOptions: ModifyInstanceAttributeRequest.CpuOptions?

    public var creditSpecification: String?

    public var deletionProtection: Bool?

    public var description_: String?

    public var enableJumboFrame: Bool?

    public var hostName: String?

    public var instanceId: String?

    public var instanceName: String?

    public var networkInterfaceQueueNumber: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var privateDnsNameOptions: ModifyInstanceAttributeRequest.PrivateDnsNameOptions?

    public var recyclable: Bool?

    public var remoteConnectionOptions: ModifyInstanceAttributeRequest.RemoteConnectionOptions?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupIds: [String]?

    public var userData: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cpuOptions?.validate()
        try self.privateDnsNameOptions?.validate()
        try self.remoteConnectionOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuOptions != nil {
            map["CpuOptions"] = self.cpuOptions?.toMap()
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableJumboFrame != nil {
            map["EnableJumboFrame"] = self.enableJumboFrame!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.networkInterfaceQueueNumber != nil {
            map["NetworkInterfaceQueueNumber"] = self.networkInterfaceQueueNumber!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.privateDnsNameOptions != nil {
            map["PrivateDnsNameOptions"] = self.privateDnsNameOptions?.toMap()
        }
        if self.recyclable != nil {
            map["Recyclable"] = self.recyclable!
        }
        if self.remoteConnectionOptions != nil {
            map["RemoteConnectionOptions"] = self.remoteConnectionOptions?.toMap()
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuOptions") {
            var model = ModifyInstanceAttributeRequest.CpuOptions()
            model.fromMap(dict["CpuOptions"] as! [String: Any])
            self.cpuOptions = model
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableJumboFrame") {
            self.enableJumboFrame = dict["EnableJumboFrame"] as! Bool
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("NetworkInterfaceQueueNumber") {
            self.networkInterfaceQueueNumber = dict["NetworkInterfaceQueueNumber"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PrivateDnsNameOptions") {
            var model = ModifyInstanceAttributeRequest.PrivateDnsNameOptions()
            model.fromMap(dict["PrivateDnsNameOptions"] as! [String: Any])
            self.privateDnsNameOptions = model
        }
        if dict.keys.contains("Recyclable") {
            self.recyclable = dict["Recyclable"] as! Bool
        }
        if dict.keys.contains("RemoteConnectionOptions") {
            var model = ModifyInstanceAttributeRequest.RemoteConnectionOptions()
            model.fromMap(dict["RemoteConnectionOptions"] as! [String: Any])
            self.remoteConnectionOptions = model
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAutoReleaseTimeRequest : Tea.TeaModel {
    public var autoReleaseTime: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceAutoReleaseTimeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAutoReleaseTimeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoReleaseTimeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAutoReleaseTimeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var duration: Int32?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.duration != nil {
            map["Duration"] = self.duration!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("Duration") {
            self.duration = dict["Duration"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RenewalStatus") {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceChargeTypeRequest : Tea.TeaModel {
    public var autoPay: Bool?

    public var clientToken: String?

    public var dryRun: Bool?

    public var includeDataDisks: Bool?

    public var instanceChargeType: String?

    public var instanceIds: String?

    public var isDetailFee: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.includeDataDisks != nil {
            map["IncludeDataDisks"] = self.includeDataDisks!
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceIds != nil {
            map["InstanceIds"] = self.instanceIds!
        }
        if self.isDetailFee != nil {
            map["IsDetailFee"] = self.isDetailFee!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("IncludeDataDisks") {
            self.includeDataDisks = dict["IncludeDataDisks"] as! Bool
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceIds") {
            self.instanceIds = dict["InstanceIds"] as! String
        }
        if dict.keys.contains("IsDetailFee") {
            self.isDetailFee = dict["IsDetailFee"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceChargeTypeResponseBody : Tea.TeaModel {
    public class FeeOfInstances : Tea.TeaModel {
        public class FeeOfInstance : Tea.TeaModel {
            public var currency: String?

            public var fee: String?

            public var instanceId: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.currency != nil {
                    map["Currency"] = self.currency!
                }
                if self.fee != nil {
                    map["Fee"] = self.fee!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Currency") {
                    self.currency = dict["Currency"] as! String
                }
                if dict.keys.contains("Fee") {
                    self.fee = dict["Fee"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
            }
        }
        public var feeOfInstance: [ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.feeOfInstance != nil {
                var tmp : [Any] = []
                for k in self.feeOfInstance! {
                    tmp.append(k.toMap())
                }
                map["FeeOfInstance"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("FeeOfInstance") {
                var tmp : [ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance] = []
                for v in dict["FeeOfInstance"] as! [Any] {
                    var model = ModifyInstanceChargeTypeResponseBody.FeeOfInstances.FeeOfInstance()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.feeOfInstance = tmp
            }
        }
    }
    public var feeOfInstances: ModifyInstanceChargeTypeResponseBody.FeeOfInstances?

    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.feeOfInstances?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.feeOfInstances != nil {
            map["FeeOfInstances"] = self.feeOfInstances?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("FeeOfInstances") {
            var model = ModifyInstanceChargeTypeResponseBody.FeeOfInstances()
            model.fromMap(dict["FeeOfInstances"] as! [String: Any])
            self.feeOfInstances = model
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceChargeTypeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceChargeTypeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceChargeTypeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceDeploymentRequest : Tea.TeaModel {
    public var affinity: String?

    public var dedicatedHostClusterId: String?

    public var dedicatedHostId: String?

    public var deploymentSetGroupNo: Int32?

    public var deploymentSetId: String?

    public var force: Bool?

    public var instanceId: String?

    public var instanceType: String?

    public var migrationType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removeFromDeploymentSet: Bool?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tenancy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.dedicatedHostClusterId != nil {
            map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.migrationType != nil {
            map["MigrationType"] = self.migrationType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeFromDeploymentSet != nil {
            map["RemoveFromDeploymentSet"] = self.removeFromDeploymentSet!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("DedicatedHostClusterId") {
            self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeploymentSetGroupNo") {
            self.deploymentSetGroupNo = dict["DeploymentSetGroupNo"] as! Int32
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MigrationType") {
            self.migrationType = dict["MigrationType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoveFromDeploymentSet") {
            self.removeFromDeploymentSet = dict["RemoveFromDeploymentSet"] as! Bool
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
    }
}

public class ModifyInstanceDeploymentResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceDeploymentResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceDeploymentResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceDeploymentResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceMaintenanceAttributesRequest : Tea.TeaModel {
    public class MaintenanceWindow : Tea.TeaModel {
        public var endTime: String?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public var actionOnMaintenance: String?

    public var instanceId: [String]?

    public var maintenanceWindow: [ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow]?

    public var notifyOnMaintenance: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.actionOnMaintenance != nil {
            map["ActionOnMaintenance"] = self.actionOnMaintenance!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.maintenanceWindow != nil {
            var tmp : [Any] = []
            for k in self.maintenanceWindow! {
                tmp.append(k.toMap())
            }
            map["MaintenanceWindow"] = tmp
        }
        if self.notifyOnMaintenance != nil {
            map["NotifyOnMaintenance"] = self.notifyOnMaintenance!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ActionOnMaintenance") {
            self.actionOnMaintenance = dict["ActionOnMaintenance"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("MaintenanceWindow") {
            var tmp : [ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow] = []
            for v in dict["MaintenanceWindow"] as! [Any] {
                var model = ModifyInstanceMaintenanceAttributesRequest.MaintenanceWindow()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.maintenanceWindow = tmp
        }
        if dict.keys.contains("NotifyOnMaintenance") {
            self.notifyOnMaintenance = dict["NotifyOnMaintenance"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceMaintenanceAttributesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceMaintenanceAttributesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceMaintenanceAttributesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceMaintenanceAttributesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceMetadataOptionsRequest : Tea.TeaModel {
    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var instanceId: String?

    public var instanceMetadataTags: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceMetadataTags != nil {
            map["InstanceMetadataTags"] = self.instanceMetadataTags!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceMetadataTags") {
            self.instanceMetadataTags = dict["InstanceMetadataTags"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceMetadataOptionsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceMetadataOptionsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceMetadataOptionsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceMetadataOptionsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceNetworkSpecRequest : Tea.TeaModel {
    public var allocatePublicIp: Bool?

    public var autoPay: Bool?

    public var clientToken: String?

    public var endTime: String?

    public var ISP: String?

    public var instanceId: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var networkChargeType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocatePublicIp != nil {
            map["AllocatePublicIp"] = self.allocatePublicIp!
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.ISP != nil {
            map["ISP"] = self.ISP!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.networkChargeType != nil {
            map["NetworkChargeType"] = self.networkChargeType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocatePublicIp") {
            self.allocatePublicIp = dict["AllocatePublicIp"] as! Bool
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("ISP") {
            self.ISP = dict["ISP"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("NetworkChargeType") {
            self.networkChargeType = dict["NetworkChargeType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ModifyInstanceNetworkSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceNetworkSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceNetworkSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceNetworkSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceSpecRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
        }
    }
    public class Temporary : Tea.TeaModel {
        public var endTime: String?

        public var internetMaxBandwidthOut: Int32?

        public var startTime: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.endTime != nil {
                map["EndTime"] = self.endTime!
            }
            if self.internetMaxBandwidthOut != nil {
                map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
            }
            if self.startTime != nil {
                map["StartTime"] = self.startTime!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EndTime") {
                self.endTime = dict["EndTime"] as! String
            }
            if dict.keys.contains("InternetMaxBandwidthOut") {
                self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
            }
            if dict.keys.contains("StartTime") {
                self.startTime = dict["StartTime"] as! String
            }
        }
    }
    public class Disk : Tea.TeaModel {
        public var category: String?

        public var diskId: String?

        public var performanceLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DiskId") {
                self.diskId = dict["DiskId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
        }
    }
    public var systemDisk: ModifyInstanceSpecRequest.SystemDisk?

    public var temporary: ModifyInstanceSpecRequest.Temporary?

    public var allowMigrateAcrossZone: Bool?

    public var async: Bool?

    public var clientToken: String?

    public var disk: [ModifyInstanceSpecRequest.Disk]?

    public var dryRun: Bool?

    public var instanceId: String?

    public var instanceType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var modifyMode: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
        try self.temporary?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.temporary != nil {
            map["Temporary"] = self.temporary?.toMap()
        }
        if self.allowMigrateAcrossZone != nil {
            map["AllowMigrateAcrossZone"] = self.allowMigrateAcrossZone!
        }
        if self.async != nil {
            map["Async"] = self.async!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disk != nil {
            var tmp : [Any] = []
            for k in self.disk! {
                tmp.append(k.toMap())
            }
            map["Disk"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.modifyMode != nil {
            map["ModifyMode"] = self.modifyMode!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SystemDisk") {
            var model = ModifyInstanceSpecRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Temporary") {
            var model = ModifyInstanceSpecRequest.Temporary()
            model.fromMap(dict["Temporary"] as! [String: Any])
            self.temporary = model
        }
        if dict.keys.contains("AllowMigrateAcrossZone") {
            self.allowMigrateAcrossZone = dict["AllowMigrateAcrossZone"] as! Bool
        }
        if dict.keys.contains("Async") {
            self.async = dict["Async"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Disk") {
            var tmp : [ModifyInstanceSpecRequest.Disk] = []
            for v in dict["Disk"] as! [Any] {
                var model = ModifyInstanceSpecRequest.Disk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.disk = tmp
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("ModifyMode") {
            self.modifyMode = dict["ModifyMode"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInstanceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceVncPasswdRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vncPassword: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vncPassword != nil {
            map["VncPassword"] = self.vncPassword!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VncPassword") {
            self.vncPassword = dict["VncPassword"] as! String
        }
    }
}

public class ModifyInstanceVncPasswdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceVncPasswdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceVncPasswdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceVncPasswdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInstanceVpcAttributeRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: [String]?

    public var vSwitchId: String?

    public var vpcId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! [String]
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
    }
}

public class ModifyInstanceVpcAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInstanceVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInstanceVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInstanceVpcAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyInvocationAttributeRequest : Tea.TeaModel {
    public var commandContent: String?

    public var contentEncoding: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var invokeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parameters: [String: Any]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("EnableParameter") {
            self.enableParameter = dict["EnableParameter"] as! Bool
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInvocationAttributeShrinkRequest : Tea.TeaModel {
    public var commandContent: String?

    public var contentEncoding: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var invokeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parametersShrink: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("EnableParameter") {
            self.enableParameter = dict["EnableParameter"] as! Bool
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parametersShrink = dict["Parameters"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyInvocationAttributeResponseBody : Tea.TeaModel {
    public var commandId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyInvocationAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyInvocationAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyInvocationAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyLaunchTemplateDefaultVersionRequest : Tea.TeaModel {
    public var defaultVersionNumber: Int64?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.defaultVersionNumber != nil {
            map["DefaultVersionNumber"] = self.defaultVersionNumber!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DefaultVersionNumber") {
            self.defaultVersionNumber = dict["DefaultVersionNumber"] as! Int64
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyLaunchTemplateDefaultVersionResponseBody : Tea.TeaModel {
    public var launchTemplateId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyLaunchTemplateDefaultVersionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyLaunchTemplateDefaultVersionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyLaunchTemplateDefaultVersionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyManagedInstanceRequest : Tea.TeaModel {
    public var instanceId: String?

    public var instanceName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyManagedInstanceResponseBody : Tea.TeaModel {
    public class Instance : Tea.TeaModel {
        public var instanceId: String?

        public var instanceName: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceId != nil {
                map["InstanceId"] = self.instanceId!
            }
            if self.instanceName != nil {
                map["InstanceName"] = self.instanceName!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceId") {
                self.instanceId = dict["InstanceId"] as! String
            }
            if dict.keys.contains("InstanceName") {
                self.instanceName = dict["InstanceName"] as! String
            }
        }
    }
    public var instance: ModifyManagedInstanceResponseBody.Instance?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instance?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instance != nil {
            map["Instance"] = self.instance?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Instance") {
            var model = ModifyManagedInstanceResponseBody.Instance()
            model.fromMap(dict["Instance"] as! [String: Any])
            self.instance = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyManagedInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyManagedInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyManagedInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyNetworkInterfaceAttributeRequest : Tea.TeaModel {
    public class ConnectionTrackingConfiguration : Tea.TeaModel {
        public var tcpClosedAndTimeWaitTimeout: Int32?

        public var tcpEstablishedTimeout: Int32?

        public var udpTimeout: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.tcpClosedAndTimeWaitTimeout != nil {
                map["TcpClosedAndTimeWaitTimeout"] = self.tcpClosedAndTimeWaitTimeout!
            }
            if self.tcpEstablishedTimeout != nil {
                map["TcpEstablishedTimeout"] = self.tcpEstablishedTimeout!
            }
            if self.udpTimeout != nil {
                map["UdpTimeout"] = self.udpTimeout!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("TcpClosedAndTimeWaitTimeout") {
                self.tcpClosedAndTimeWaitTimeout = dict["TcpClosedAndTimeWaitTimeout"] as! Int32
            }
            if dict.keys.contains("TcpEstablishedTimeout") {
                self.tcpEstablishedTimeout = dict["TcpEstablishedTimeout"] as! Int32
            }
            if dict.keys.contains("UdpTimeout") {
                self.udpTimeout = dict["UdpTimeout"] as! Int32
            }
        }
    }
    public class EnhancedNetwork : Tea.TeaModel {
        public var enableSriov: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableSriov != nil {
                map["EnableSriov"] = self.enableSriov!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableSriov") {
                self.enableSriov = dict["EnableSriov"] as! Bool
            }
        }
    }
    public class NetworkInterfaceTrafficConfig : Tea.TeaModel {
        public var networkInterfaceTrafficMode: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int32?

        public var rxQueueSize: Int32?

        public var txQueueSize: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            if self.rxQueueSize != nil {
                map["RxQueueSize"] = self.rxQueueSize!
            }
            if self.txQueueSize != nil {
                map["TxQueueSize"] = self.txQueueSize!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("QueueNumber") {
                self.queueNumber = dict["QueueNumber"] as! Int32
            }
            if dict.keys.contains("QueuePairNumber") {
                self.queuePairNumber = dict["QueuePairNumber"] as! Int32
            }
            if dict.keys.contains("RxQueueSize") {
                self.rxQueueSize = dict["RxQueueSize"] as! Int32
            }
            if dict.keys.contains("TxQueueSize") {
                self.txQueueSize = dict["TxQueueSize"] as! Int32
            }
        }
    }
    public var connectionTrackingConfiguration: ModifyNetworkInterfaceAttributeRequest.ConnectionTrackingConfiguration?

    public var deleteOnRelease: Bool?

    public var description_: String?

    public var enhancedNetwork: ModifyNetworkInterfaceAttributeRequest.EnhancedNetwork?

    public var networkInterfaceId: String?

    public var networkInterfaceName: String?

    public var networkInterfaceTrafficConfig: ModifyNetworkInterfaceAttributeRequest.NetworkInterfaceTrafficConfig?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var queueNumber: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var rxQueueSize: Int32?

    public var securityGroupId: [String]?

    public var sourceDestCheck: Bool?

    public var txQueueSize: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.connectionTrackingConfiguration?.validate()
        try self.enhancedNetwork?.validate()
        try self.networkInterfaceTrafficConfig?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.connectionTrackingConfiguration != nil {
            map["ConnectionTrackingConfiguration"] = self.connectionTrackingConfiguration?.toMap()
        }
        if self.deleteOnRelease != nil {
            map["DeleteOnRelease"] = self.deleteOnRelease!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enhancedNetwork != nil {
            map["EnhancedNetwork"] = self.enhancedNetwork?.toMap()
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.networkInterfaceName != nil {
            map["NetworkInterfaceName"] = self.networkInterfaceName!
        }
        if self.networkInterfaceTrafficConfig != nil {
            map["NetworkInterfaceTrafficConfig"] = self.networkInterfaceTrafficConfig?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.queueNumber != nil {
            map["QueueNumber"] = self.queueNumber!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.rxQueueSize != nil {
            map["RxQueueSize"] = self.rxQueueSize!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.sourceDestCheck != nil {
            map["SourceDestCheck"] = self.sourceDestCheck!
        }
        if self.txQueueSize != nil {
            map["TxQueueSize"] = self.txQueueSize!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConnectionTrackingConfiguration") {
            var model = ModifyNetworkInterfaceAttributeRequest.ConnectionTrackingConfiguration()
            model.fromMap(dict["ConnectionTrackingConfiguration"] as! [String: Any])
            self.connectionTrackingConfiguration = model
        }
        if dict.keys.contains("DeleteOnRelease") {
            self.deleteOnRelease = dict["DeleteOnRelease"] as! Bool
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnhancedNetwork") {
            var model = ModifyNetworkInterfaceAttributeRequest.EnhancedNetwork()
            model.fromMap(dict["EnhancedNetwork"] as! [String: Any])
            self.enhancedNetwork = model
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("NetworkInterfaceName") {
            self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
        }
        if dict.keys.contains("NetworkInterfaceTrafficConfig") {
            var model = ModifyNetworkInterfaceAttributeRequest.NetworkInterfaceTrafficConfig()
            model.fromMap(dict["NetworkInterfaceTrafficConfig"] as! [String: Any])
            self.networkInterfaceTrafficConfig = model
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("QueueNumber") {
            self.queueNumber = dict["QueueNumber"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RxQueueSize") {
            self.rxQueueSize = dict["RxQueueSize"] as! Int32
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! [String]
        }
        if dict.keys.contains("SourceDestCheck") {
            self.sourceDestCheck = dict["SourceDestCheck"] as! Bool
        }
        if dict.keys.contains("TxQueueSize") {
            self.txQueueSize = dict["TxQueueSize"] as! Int32
        }
    }
}

public class ModifyNetworkInterfaceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyNetworkInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyNetworkInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyNetworkInterfaceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPhysicalConnectionAttributeRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var lineOperator: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerLocation: String?

    public var physicalConnectionId: String?

    public var portType: String?

    public var redundantPhysicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var bandwidth: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.lineOperator != nil {
            map["LineOperator"] = self.lineOperator!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerLocation != nil {
            map["PeerLocation"] = self.peerLocation!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.portType != nil {
            map["PortType"] = self.portType!
        }
        if self.redundantPhysicalConnectionId != nil {
            map["RedundantPhysicalConnectionId"] = self.redundantPhysicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.bandwidth != nil {
            map["bandwidth"] = self.bandwidth!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LineOperator") {
            self.lineOperator = dict["LineOperator"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerLocation") {
            self.peerLocation = dict["PeerLocation"] as! String
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("PortType") {
            self.portType = dict["PortType"] as! String
        }
        if dict.keys.contains("RedundantPhysicalConnectionId") {
            self.redundantPhysicalConnectionId = dict["RedundantPhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("bandwidth") {
            self.bandwidth = dict["bandwidth"] as! Int32
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPhysicalConnectionAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPhysicalConnectionAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPhysicalConnectionAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPrefixListRequest : Tea.TeaModel {
    public class AddEntry : Tea.TeaModel {
        public var cidr: String?

        public var description_: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidr") {
                self.cidr = dict["Cidr"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
        }
    }
    public class RemoveEntry : Tea.TeaModel {
        public var cidr: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.cidr != nil {
                map["Cidr"] = self.cidr!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Cidr") {
                self.cidr = dict["Cidr"] as! String
            }
        }
    }
    public var addEntry: [ModifyPrefixListRequest.AddEntry]?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var prefixListId: String?

    public var prefixListName: String?

    public var regionId: String?

    public var removeEntry: [ModifyPrefixListRequest.RemoveEntry]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.addEntry != nil {
            var tmp : [Any] = []
            for k in self.addEntry! {
                tmp.append(k.toMap())
            }
            map["AddEntry"] = tmp
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.prefixListId != nil {
            map["PrefixListId"] = self.prefixListId!
        }
        if self.prefixListName != nil {
            map["PrefixListName"] = self.prefixListName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removeEntry != nil {
            var tmp : [Any] = []
            for k in self.removeEntry! {
                tmp.append(k.toMap())
            }
            map["RemoveEntry"] = tmp
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AddEntry") {
            var tmp : [ModifyPrefixListRequest.AddEntry] = []
            for v in dict["AddEntry"] as! [Any] {
                var model = ModifyPrefixListRequest.AddEntry()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.addEntry = tmp
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrefixListId") {
            self.prefixListId = dict["PrefixListId"] as! String
        }
        if dict.keys.contains("PrefixListName") {
            self.prefixListName = dict["PrefixListName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemoveEntry") {
            var tmp : [ModifyPrefixListRequest.RemoveEntry] = []
            for v in dict["RemoveEntry"] as! [Any] {
                var model = ModifyPrefixListRequest.RemoveEntry()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.removeEntry = tmp
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyPrefixListResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPrefixListResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPrefixListResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPrefixListResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyPrepayInstanceSpecRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var category: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
        }
    }
    public class Disk : Tea.TeaModel {
        public var category: String?

        public var diskId: String?

        public var performanceLevel: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DiskId") {
                self.diskId = dict["DiskId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
        }
    }
    public var systemDisk: ModifyPrepayInstanceSpecRequest.SystemDisk?

    public var autoPay: Bool?

    public var clientToken: String?

    public var disk: [ModifyPrepayInstanceSpecRequest.Disk]?

    public var endTime: String?

    public var instanceId: String?

    public var instanceType: String?

    public var migrateAcrossZone: Bool?

    public var modifyMode: String?

    public var operatorType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var rebootTime: String?

    public var rebootWhenFinished: Bool?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.disk != nil {
            var tmp : [Any] = []
            for k in self.disk! {
                tmp.append(k.toMap())
            }
            map["Disk"] = tmp
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.migrateAcrossZone != nil {
            map["MigrateAcrossZone"] = self.migrateAcrossZone!
        }
        if self.modifyMode != nil {
            map["ModifyMode"] = self.modifyMode!
        }
        if self.operatorType != nil {
            map["OperatorType"] = self.operatorType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.rebootTime != nil {
            map["RebootTime"] = self.rebootTime!
        }
        if self.rebootWhenFinished != nil {
            map["RebootWhenFinished"] = self.rebootWhenFinished!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SystemDisk") {
            var model = ModifyPrepayInstanceSpecRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Disk") {
            var tmp : [ModifyPrepayInstanceSpecRequest.Disk] = []
            for v in dict["Disk"] as! [Any] {
                var model = ModifyPrepayInstanceSpecRequest.Disk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.disk = tmp
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("MigrateAcrossZone") {
            self.migrateAcrossZone = dict["MigrateAcrossZone"] as! Bool
        }
        if dict.keys.contains("ModifyMode") {
            self.modifyMode = dict["ModifyMode"] as! String
        }
        if dict.keys.contains("OperatorType") {
            self.operatorType = dict["OperatorType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RebootTime") {
            self.rebootTime = dict["RebootTime"] as! String
        }
        if dict.keys.contains("RebootWhenFinished") {
            self.rebootWhenFinished = dict["RebootWhenFinished"] as! Bool
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyPrepayInstanceSpecResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyPrepayInstanceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyPrepayInstanceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyPrepayInstanceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyReservedInstanceAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: String?

    public var reservedInstanceName: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! String
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyReservedInstanceAttributeResponseBody : Tea.TeaModel {
    public var code: String?

    public var httpStatusCode: Int32?

    public var message: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.code != nil {
            map["Code"] = self.code!
        }
        if self.httpStatusCode != nil {
            map["HttpStatusCode"] = self.httpStatusCode!
        }
        if self.message != nil {
            map["Message"] = self.message!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Code") {
            self.code = dict["Code"] as! String
        }
        if dict.keys.contains("HttpStatusCode") {
            self.httpStatusCode = dict["HttpStatusCode"] as! Int32
        }
        if dict.keys.contains("Message") {
            self.message = dict["Message"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyReservedInstanceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstanceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyReservedInstanceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyReservedInstanceAutoRenewAttributeRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var renewalStatus: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.renewalStatus != nil {
            map["RenewalStatus"] = self.renewalStatus!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RenewalStatus") {
            self.renewalStatus = dict["RenewalStatus"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyReservedInstanceAutoRenewAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyReservedInstanceAutoRenewAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstanceAutoRenewAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyReservedInstanceAutoRenewAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyReservedInstancesRequest : Tea.TeaModel {
    public class Configuration : Tea.TeaModel {
        public var instanceAmount: Int32?

        public var instanceType: String?

        public var reservedInstanceName: String?

        public var scope: String?

        public var zoneId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceAmount != nil {
                map["InstanceAmount"] = self.instanceAmount!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.reservedInstanceName != nil {
                map["ReservedInstanceName"] = self.reservedInstanceName!
            }
            if self.scope != nil {
                map["Scope"] = self.scope!
            }
            if self.zoneId != nil {
                map["ZoneId"] = self.zoneId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceAmount") {
                self.instanceAmount = dict["InstanceAmount"] as! Int32
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("ReservedInstanceName") {
                self.reservedInstanceName = dict["ReservedInstanceName"] as! String
            }
            if dict.keys.contains("Scope") {
                self.scope = dict["Scope"] as! String
            }
            if dict.keys.contains("ZoneId") {
                self.zoneId = dict["ZoneId"] as! String
            }
        }
    }
    public var configuration: [ModifyReservedInstancesRequest.Configuration]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.configuration != nil {
            var tmp : [Any] = []
            for k in self.configuration! {
                tmp.append(k.toMap())
            }
            map["Configuration"] = tmp
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Configuration") {
            var tmp : [ModifyReservedInstancesRequest.Configuration] = []
            for v in dict["Configuration"] as! [Any] {
                var model = ModifyReservedInstancesRequest.Configuration()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.configuration = tmp
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ModifyReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstanceId") {
                self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var reservedInstanceIdSets: ModifyReservedInstancesResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstanceIdSets") {
            var model = ModifyReservedInstancesResponseBody.ReservedInstanceIdSets()
            model.fromMap(dict["ReservedInstanceIdSets"] as! [String: Any])
            self.reservedInstanceIdSets = model
        }
    }
}

public class ModifyReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyReservedInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var healthCheckSourceIp: String?

    public var healthCheckTargetIp: String?

    public var name: String?

    public var oppositeInterfaceId: String?

    public var oppositeInterfaceOwnerId: Int64?

    public var oppositeRouterId: String?

    public var oppositeRouterType: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.healthCheckSourceIp != nil {
            map["HealthCheckSourceIp"] = self.healthCheckSourceIp!
        }
        if self.healthCheckTargetIp != nil {
            map["HealthCheckTargetIp"] = self.healthCheckTargetIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.oppositeInterfaceId != nil {
            map["OppositeInterfaceId"] = self.oppositeInterfaceId!
        }
        if self.oppositeInterfaceOwnerId != nil {
            map["OppositeInterfaceOwnerId"] = self.oppositeInterfaceOwnerId!
        }
        if self.oppositeRouterId != nil {
            map["OppositeRouterId"] = self.oppositeRouterId!
        }
        if self.oppositeRouterType != nil {
            map["OppositeRouterType"] = self.oppositeRouterType!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("HealthCheckSourceIp") {
            self.healthCheckSourceIp = dict["HealthCheckSourceIp"] as! String
        }
        if dict.keys.contains("HealthCheckTargetIp") {
            self.healthCheckTargetIp = dict["HealthCheckTargetIp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OppositeInterfaceId") {
            self.oppositeInterfaceId = dict["OppositeInterfaceId"] as! String
        }
        if dict.keys.contains("OppositeInterfaceOwnerId") {
            self.oppositeInterfaceOwnerId = dict["OppositeInterfaceOwnerId"] as! Int64
        }
        if dict.keys.contains("OppositeRouterId") {
            self.oppositeRouterId = dict["OppositeRouterId"] as! String
        }
        if dict.keys.contains("OppositeRouterType") {
            self.oppositeRouterType = dict["OppositeRouterType"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
    }
}

public class ModifyRouterInterfaceAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyRouterInterfaceAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRouterInterfaceAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyRouterInterfaceSpecRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var routerInterfaceId: String?

    public var spec: String?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.routerInterfaceId != nil {
            map["RouterInterfaceId"] = self.routerInterfaceId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RouterInterfaceId") {
            self.routerInterfaceId = dict["RouterInterfaceId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
    }
}

public class ModifyRouterInterfaceSpecResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var spec: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.spec != nil {
            map["Spec"] = self.spec!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("Spec") {
            self.spec = dict["Spec"] as! String
        }
    }
}

public class ModifyRouterInterfaceSpecResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyRouterInterfaceSpecResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyRouterInterfaceSpecResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityGroupAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupName != nil {
            map["SecurityGroupName"] = self.securityGroupName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupName") {
            self.securityGroupName = dict["SecurityGroupName"] as! String
        }
    }
}

public class ModifySecurityGroupAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySecurityGroupAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySecurityGroupAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityGroupEgressRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var destGroupId: String?

    public var destGroupOwnerAccount: String?

    public var destGroupOwnerId: Int64?

    public var destPrefixListId: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: String?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.destGroupId != nil {
            map["DestGroupId"] = self.destGroupId!
        }
        if self.destGroupOwnerAccount != nil {
            map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
        }
        if self.destGroupOwnerId != nil {
            map["DestGroupOwnerId"] = self.destGroupOwnerId!
        }
        if self.destPrefixListId != nil {
            map["DestPrefixListId"] = self.destPrefixListId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("DestGroupId") {
            self.destGroupId = dict["DestGroupId"] as! String
        }
        if dict.keys.contains("DestGroupOwnerAccount") {
            self.destGroupOwnerAccount = dict["DestGroupOwnerAccount"] as! String
        }
        if dict.keys.contains("DestGroupOwnerId") {
            self.destGroupOwnerId = dict["DestGroupOwnerId"] as! Int64
        }
        if dict.keys.contains("DestPrefixListId") {
            self.destPrefixListId = dict["DestPrefixListId"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Ipv6DestCidrIp") {
            self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
        }
        if dict.keys.contains("Ipv6SourceCidrIp") {
            self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupRuleId") {
            self.securityGroupRuleId = dict["SecurityGroupRuleId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class ModifySecurityGroupEgressRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySecurityGroupEgressRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupEgressRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySecurityGroupEgressRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityGroupPolicyRequest : Tea.TeaModel {
    public var clientToken: String?

    public var innerAccessPolicy: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.innerAccessPolicy != nil {
            map["InnerAccessPolicy"] = self.innerAccessPolicy!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("InnerAccessPolicy") {
            self.innerAccessPolicy = dict["InnerAccessPolicy"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
    }
}

public class ModifySecurityGroupPolicyResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySecurityGroupPolicyResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupPolicyResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySecurityGroupPolicyResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySecurityGroupRuleRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: String?

    public var sourceCidrIp: String?

    public var sourceGroupId: String?

    public var sourceGroupOwnerAccount: String?

    public var sourceGroupOwnerId: Int64?

    public var sourcePortRange: String?

    public var sourcePrefixListId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourceGroupId != nil {
            map["SourceGroupId"] = self.sourceGroupId!
        }
        if self.sourceGroupOwnerAccount != nil {
            map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
        }
        if self.sourceGroupOwnerId != nil {
            map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.sourcePrefixListId != nil {
            map["SourcePrefixListId"] = self.sourcePrefixListId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Ipv6DestCidrIp") {
            self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
        }
        if dict.keys.contains("Ipv6SourceCidrIp") {
            self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupRuleId") {
            self.securityGroupRuleId = dict["SecurityGroupRuleId"] as! String
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourceGroupId") {
            self.sourceGroupId = dict["SourceGroupId"] as! String
        }
        if dict.keys.contains("SourceGroupOwnerAccount") {
            self.sourceGroupOwnerAccount = dict["SourceGroupOwnerAccount"] as! String
        }
        if dict.keys.contains("SourceGroupOwnerId") {
            self.sourceGroupOwnerId = dict["SourceGroupOwnerId"] as! Int64
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("SourcePrefixListId") {
            self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
        }
    }
}

public class ModifySecurityGroupRuleResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySecurityGroupRuleResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySecurityGroupRuleResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySecurityGroupRuleResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySnapshotAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var disableInstantAccess: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var retentionDays: Int32?

    public var snapshotId: String?

    public var snapshotName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.disableInstantAccess != nil {
            map["DisableInstantAccess"] = self.disableInstantAccess!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.retentionDays != nil {
            map["RetentionDays"] = self.retentionDays!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        if self.snapshotName != nil {
            map["SnapshotName"] = self.snapshotName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DisableInstantAccess") {
            self.disableInstantAccess = dict["DisableInstantAccess"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("RetentionDays") {
            self.retentionDays = dict["RetentionDays"] as! Int32
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
        if dict.keys.contains("SnapshotName") {
            self.snapshotName = dict["SnapshotName"] as! String
        }
    }
}

public class ModifySnapshotAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySnapshotAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnapshotAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySnapshotAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifySnapshotGroupRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotGroupId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotGroupId != nil {
            map["SnapshotGroupId"] = self.snapshotGroupId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotGroupId") {
            self.snapshotGroupId = dict["SnapshotGroupId"] as! String
        }
    }
}

public class ModifySnapshotGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifySnapshotGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifySnapshotGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifySnapshotGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyStorageCapacityUnitAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageCapacityUnitId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageCapacityUnitId != nil {
            map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageCapacityUnitId") {
            self.storageCapacityUnitId = dict["StorageCapacityUnitId"] as! String
        }
    }
}

public class ModifyStorageCapacityUnitAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyStorageCapacityUnitAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStorageCapacityUnitAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyStorageCapacityUnitAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyStorageSetAttributeRequest : Tea.TeaModel {
    public var clientToken: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var storageSetId: String?

    public var storageSetName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetName != nil {
            map["StorageSetName"] = self.storageSetName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetName") {
            self.storageSetName = dict["StorageSetName"] as! String
        }
    }
}

public class ModifyStorageSetAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyStorageSetAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyStorageSetAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyStorageSetAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyUserBusinessBehaviorRequest : Tea.TeaModel {
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var statusKey: String?

    public var statusValue: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.statusKey != nil {
            map["statusKey"] = self.statusKey!
        }
        if self.statusValue != nil {
            map["statusValue"] = self.statusValue!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("statusKey") {
            self.statusKey = dict["statusKey"] as! String
        }
        if dict.keys.contains("statusValue") {
            self.statusValue = dict["statusValue"] as! String
        }
    }
}

public class ModifyUserBusinessBehaviorResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyUserBusinessBehaviorResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyUserBusinessBehaviorResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyUserBusinessBehaviorResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVRouterAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var VRouterId: String?

    public var VRouterName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.VRouterId != nil {
            map["VRouterId"] = self.VRouterId!
        }
        if self.VRouterName != nil {
            map["VRouterName"] = self.VRouterName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VRouterId") {
            self.VRouterId = dict["VRouterId"] as! String
        }
        if dict.keys.contains("VRouterName") {
            self.VRouterName = dict["VRouterName"] as! String
        }
    }
}

public class ModifyVRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVRouterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVSwitchAttributeRequest : Tea.TeaModel {
    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var vSwitchId: String?

    public var vSwitchName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.vSwitchName != nil {
            map["VSwitchName"] = self.vSwitchName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("VSwitchName") {
            self.vSwitchName = dict["VSwitchName"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVSwitchAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVSwitchAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVSwitchAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVirtualBorderRouterAttributeRequest : Tea.TeaModel {
    public var circuitCode: String?

    public var clientToken: String?

    public var description_: String?

    public var localGatewayIp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var peerGatewayIp: String?

    public var peeringSubnetMask: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public var vlanId: Int32?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.circuitCode != nil {
            map["CircuitCode"] = self.circuitCode!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.localGatewayIp != nil {
            map["LocalGatewayIp"] = self.localGatewayIp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.peerGatewayIp != nil {
            map["PeerGatewayIp"] = self.peerGatewayIp!
        }
        if self.peeringSubnetMask != nil {
            map["PeeringSubnetMask"] = self.peeringSubnetMask!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        if self.vlanId != nil {
            map["VlanId"] = self.vlanId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CircuitCode") {
            self.circuitCode = dict["CircuitCode"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("LocalGatewayIp") {
            self.localGatewayIp = dict["LocalGatewayIp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PeerGatewayIp") {
            self.peerGatewayIp = dict["PeerGatewayIp"] as! String
        }
        if dict.keys.contains("PeeringSubnetMask") {
            self.peeringSubnetMask = dict["PeeringSubnetMask"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
        if dict.keys.contains("VlanId") {
            self.vlanId = dict["VlanId"] as! Int32
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVirtualBorderRouterAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVirtualBorderRouterAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVirtualBorderRouterAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ModifyVpcAttributeRequest : Tea.TeaModel {
    public var cidrBlock: String?

    public var description_: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vpcId: String?

    public var vpcName: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cidrBlock != nil {
            map["CidrBlock"] = self.cidrBlock!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vpcId != nil {
            map["VpcId"] = self.vpcId!
        }
        if self.vpcName != nil {
            map["VpcName"] = self.vpcName!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CidrBlock") {
            self.cidrBlock = dict["CidrBlock"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VpcId") {
            self.vpcId = dict["VpcId"] as! String
        }
        if dict.keys.contains("VpcName") {
            self.vpcName = dict["VpcName"] as! String
        }
    }
}

public class ModifyVpcAttributeResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ModifyVpcAttributeResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ModifyVpcAttributeResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ModifyVpcAttributeResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PurchaseElasticityAssuranceRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public var privatePoolOptions: PurchaseElasticityAssuranceRequest.PrivatePoolOptions?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = PurchaseElasticityAssuranceRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class PurchaseElasticityAssuranceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class PurchaseElasticityAssuranceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseElasticityAssuranceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PurchaseElasticityAssuranceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PurchaseReservedInstancesOfferingRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var description_: String?

    public var instanceAmount: Int32?

    public var instanceType: String?

    public var offeringType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var platform: String?

    public var regionId: String?

    public var reservedInstanceName: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var scope: String?

    public var startTime: String?

    public var tag: [PurchaseReservedInstancesOfferingRequest.Tag]?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.instanceAmount != nil {
            map["InstanceAmount"] = self.instanceAmount!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.offeringType != nil {
            map["OfferingType"] = self.offeringType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceName != nil {
            map["ReservedInstanceName"] = self.reservedInstanceName!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.scope != nil {
            map["Scope"] = self.scope!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("InstanceAmount") {
            self.instanceAmount = dict["InstanceAmount"] as! Int32
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OfferingType") {
            self.offeringType = dict["OfferingType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceName") {
            self.reservedInstanceName = dict["ReservedInstanceName"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Scope") {
            self.scope = dict["Scope"] as! String
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [PurchaseReservedInstancesOfferingRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = PurchaseReservedInstancesOfferingRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class PurchaseReservedInstancesOfferingResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstanceId") {
                self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
            }
        }
    }
    public var requestId: String?

    public var reservedInstanceIdSets: PurchaseReservedInstancesOfferingResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstanceIdSets") {
            var model = PurchaseReservedInstancesOfferingResponseBody.ReservedInstanceIdSets()
            model.fromMap(dict["ReservedInstanceIdSets"] as! [String: Any])
            self.reservedInstanceIdSets = model
        }
    }
}

public class PurchaseReservedInstancesOfferingResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseReservedInstancesOfferingResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PurchaseReservedInstancesOfferingResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class PurchaseStorageCapacityUnitRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var amount: Int32?

    public var capacity: Int32?

    public var clientToken: String?

    public var description_: String?

    public var fromApp: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public var tag: [PurchaseStorageCapacityUnitRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.capacity != nil {
            map["Capacity"] = self.capacity!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fromApp != nil {
            map["FromApp"] = self.fromApp!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("Capacity") {
            self.capacity = dict["Capacity"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FromApp") {
            self.fromApp = dict["FromApp"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [PurchaseStorageCapacityUnitRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = PurchaseStorageCapacityUnitRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class PurchaseStorageCapacityUnitResponseBody : Tea.TeaModel {
    public class StorageCapacityUnitIds : Tea.TeaModel {
        public var storageCapacityUnitId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.storageCapacityUnitId != nil {
                map["StorageCapacityUnitId"] = self.storageCapacityUnitId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("StorageCapacityUnitId") {
                self.storageCapacityUnitId = dict["StorageCapacityUnitId"] as! [String]
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var storageCapacityUnitIds: PurchaseStorageCapacityUnitResponseBody.StorageCapacityUnitIds?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.storageCapacityUnitIds?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.storageCapacityUnitIds != nil {
            map["StorageCapacityUnitIds"] = self.storageCapacityUnitIds?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("StorageCapacityUnitIds") {
            var model = PurchaseStorageCapacityUnitResponseBody.StorageCapacityUnitIds()
            model.fromMap(dict["StorageCapacityUnitIds"] as! [String: Any])
            self.storageCapacityUnitIds = model
        }
    }
}

public class PurchaseStorageCapacityUnitResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: PurchaseStorageCapacityUnitResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = PurchaseStorageCapacityUnitResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReActivateInstancesRequest : Tea.TeaModel {
    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReActivateInstancesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReActivateInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReActivateInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReActivateInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReInitDiskRequest : Tea.TeaModel {
    public var autoStartInstance: Bool?

    public var diskId: String?

    public var keyPairName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoStartInstance != nil {
            map["AutoStartInstance"] = self.autoStartInstance!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoStartInstance") {
            self.autoStartInstance = dict["AutoStartInstance"] as! Bool
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
    }
}

public class ReInitDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReInitDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReInitDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReInitDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootInstanceRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var forceStop: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ForceStop") {
            self.forceStop = dict["ForceStop"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RebootInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebootInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RebootInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var dryRun: Bool?

    public var forceReboot: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceReboot != nil {
            map["ForceReboot"] = self.forceReboot!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchOptimization") {
            self.batchOptimization = dict["BatchOptimization"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ForceReboot") {
            self.forceReboot = dict["ForceReboot"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RebootInstancesResponseBody : Tea.TeaModel {
    public class InstanceResponses : Tea.TeaModel {
        public class InstanceResponse : Tea.TeaModel {
            public var code: String?

            public var currentStatus: String?

            public var instanceId: String?

            public var message: String?

            public var previousStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.currentStatus != nil {
                    map["CurrentStatus"] = self.currentStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.previousStatus != nil {
                    map["PreviousStatus"] = self.previousStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CurrentStatus") {
                    self.currentStatus = dict["CurrentStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PreviousStatus") {
                    self.previousStatus = dict["PreviousStatus"] as! String
                }
            }
        }
        public var instanceResponse: [RebootInstancesResponseBody.InstanceResponses.InstanceResponse]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceResponse != nil {
                var tmp : [Any] = []
                for k in self.instanceResponse! {
                    tmp.append(k.toMap())
                }
                map["InstanceResponse"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceResponse") {
                var tmp : [RebootInstancesResponseBody.InstanceResponses.InstanceResponse] = []
                for v in dict["InstanceResponse"] as! [Any] {
                    var model = RebootInstancesResponseBody.InstanceResponses.InstanceResponse()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceResponse = tmp
            }
        }
    }
    public var instanceResponses: RebootInstancesResponseBody.InstanceResponses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceResponses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            map["InstanceResponses"] = self.instanceResponses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") {
            var model = RebootInstancesResponseBody.InstanceResponses()
            model.fromMap(dict["InstanceResponses"] as! [String: Any])
            self.instanceResponses = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RebootInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RebootInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RebootInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RecoverVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class RecoverVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RecoverVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RecoverVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RecoverVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RedeployDedicatedHostRequest : Tea.TeaModel {
    public var dedicatedHostId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RedeployDedicatedHostResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RedeployDedicatedHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedeployDedicatedHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RedeployDedicatedHostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RedeployInstanceRequest : Tea.TeaModel {
    public var forceStop: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ForceStop") {
            self.forceStop = dict["ForceStop"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RedeployInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var taskId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.taskId != nil {
            map["TaskId"] = self.taskId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TaskId") {
            self.taskId = dict["TaskId"] as! String
        }
    }
}

public class RedeployInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RedeployInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RedeployInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseCapacityReservationRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
        }
    }
    public var privatePoolOptions: ReleaseCapacityReservationRequest.PrivatePoolOptions?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = ReleaseCapacityReservationRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReleaseCapacityReservationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseCapacityReservationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseCapacityReservationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseCapacityReservationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseDedicatedHostRequest : Tea.TeaModel {
    public var dedicatedHostId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReleaseDedicatedHostResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseDedicatedHostResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseDedicatedHostResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseDedicatedHostResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleaseEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ReleaseEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleaseEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleaseEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleaseEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReleasePublicIpAddressRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var instanceId: String?

    public var publicIpAddress: String?

    public var regionId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.publicIpAddress != nil {
            map["PublicIpAddress"] = self.publicIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("PublicIpAddress") {
            self.publicIpAddress = dict["PublicIpAddress"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
    }
}

public class ReleasePublicIpAddressResponseBody : Tea.TeaModel {
    public var remainTimes: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.remainTimes != nil {
            map["RemainTimes"] = self.remainTimes!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RemainTimes") {
            self.remainTimes = dict["RemainTimes"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReleasePublicIpAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReleasePublicIpAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReleasePublicIpAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveBandwidthPackageIpsRequest : Tea.TeaModel {
    public var bandwidthPackageId: String?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var removedIpAddresses: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.bandwidthPackageId != nil {
            map["BandwidthPackageId"] = self.bandwidthPackageId!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.removedIpAddresses != nil {
            map["RemovedIpAddresses"] = self.removedIpAddresses!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BandwidthPackageId") {
            self.bandwidthPackageId = dict["BandwidthPackageId"] as! String
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RemovedIpAddresses") {
            self.removedIpAddresses = dict["RemovedIpAddresses"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RemoveBandwidthPackageIpsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveBandwidthPackageIpsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveBandwidthPackageIpsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveBandwidthPackageIpsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RemoveTagsRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tag: [RemoveTagsRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [RemoveTagsRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = RemoveTagsRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class RemoveTagsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RemoveTagsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RemoveTagsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RemoveTagsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewDedicatedHostsRequest : Tea.TeaModel {
    public var clientToken: String?

    public var dedicatedHostIds: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.dedicatedHostIds != nil {
            map["DedicatedHostIds"] = self.dedicatedHostIds!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DedicatedHostIds") {
            self.dedicatedHostIds = dict["DedicatedHostIds"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RenewDedicatedHostsResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewDedicatedHostsResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewDedicatedHostsResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewDedicatedHostsResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewElasticityAssurancesRequest : Tea.TeaModel {
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! [String]
            }
        }
    }
    public var privatePoolOptions: RenewElasticityAssurancesRequest.PrivatePoolOptions?

    public var autoPay: Bool?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("PrivatePoolOptions") {
            var model = RenewElasticityAssurancesRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RenewElasticityAssurancesResponseBody : Tea.TeaModel {
    public class PrivatePoolOptionsIdSet : Tea.TeaModel {
        public var privatePoolOptionsId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.privatePoolOptionsId != nil {
                map["PrivatePoolOptionsId"] = self.privatePoolOptionsId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("PrivatePoolOptionsId") {
                self.privatePoolOptionsId = dict["PrivatePoolOptionsId"] as! [String]
            }
        }
    }
    public var orderId: String?

    public var privatePoolOptionsIdSet: RenewElasticityAssurancesResponseBody.PrivatePoolOptionsIdSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.privatePoolOptionsIdSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.privatePoolOptionsIdSet != nil {
            map["PrivatePoolOptionsIdSet"] = self.privatePoolOptionsIdSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("PrivatePoolOptionsIdSet") {
            var model = RenewElasticityAssurancesResponseBody.PrivatePoolOptionsIdSet()
            model.fromMap(dict["PrivatePoolOptionsIdSet"] as! [String: Any])
            self.privatePoolOptionsIdSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewElasticityAssurancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewElasticityAssurancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewElasticityAssurancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewInstanceRequest : Tea.TeaModel {
    public var clientToken: String?

    public var expectedRenewDay: Int32?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.expectedRenewDay != nil {
            map["ExpectedRenewDay"] = self.expectedRenewDay!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ExpectedRenewDay") {
            self.expectedRenewDay = dict["ExpectedRenewDay"] as! Int32
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RenewInstanceResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RenewInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RenewReservedInstancesRequest : Tea.TeaModel {
    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var period: Int32?

    public var periodUnit: String?

    public var regionId: String?

    public var reservedInstanceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.reservedInstanceId != nil {
            map["ReservedInstanceId"] = self.reservedInstanceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ReservedInstanceId") {
            self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class RenewReservedInstancesResponseBody : Tea.TeaModel {
    public class ReservedInstanceIdSets : Tea.TeaModel {
        public var reservedInstanceId: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.reservedInstanceId != nil {
                map["ReservedInstanceId"] = self.reservedInstanceId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ReservedInstanceId") {
                self.reservedInstanceId = dict["ReservedInstanceId"] as! [String]
            }
        }
    }
    public var orderId: String?

    public var requestId: String?

    public var reservedInstanceIdSets: RenewReservedInstancesResponseBody.ReservedInstanceIdSets?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.reservedInstanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.reservedInstanceIdSets != nil {
            map["ReservedInstanceIdSets"] = self.reservedInstanceIdSets?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("ReservedInstanceIdSets") {
            var model = RenewReservedInstancesResponseBody.ReservedInstanceIdSets()
            model.fromMap(dict["ReservedInstanceIdSets"] as! [String: Any])
            self.reservedInstanceIdSets = model
        }
    }
}

public class RenewReservedInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RenewReservedInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RenewReservedInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReplaceSystemDiskRequest : Tea.TeaModel {
    public class SystemDisk : Tea.TeaModel {
        public var size: Int32?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.size != nil {
                map["Size"] = self.size!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
        }
    }
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssumeRoleFor") {
                self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
            if dict.keys.contains("Rolearn") {
                self.rolearn = dict["Rolearn"] as! String
            }
        }
    }
    public var systemDisk: ReplaceSystemDiskRequest.SystemDisk?

    public var architecture: String?

    public var arn: [ReplaceSystemDiskRequest.Arn]?

    public var clientToken: String?

    public var diskId: String?

    public var encryptAlgorithm: String?

    public var encrypted: Bool?

    public var imageId: String?

    public var instanceId: String?

    public var KMSKeyId: String?

    public var keyPairName: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var platform: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var useAdditionalService: Bool?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.systemDisk?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.architecture != nil {
            map["Architecture"] = self.architecture!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.encryptAlgorithm != nil {
            map["EncryptAlgorithm"] = self.encryptAlgorithm!
        }
        if self.encrypted != nil {
            map["Encrypted"] = self.encrypted!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.KMSKeyId != nil {
            map["KMSKeyId"] = self.KMSKeyId!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.platform != nil {
            map["Platform"] = self.platform!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.useAdditionalService != nil {
            map["UseAdditionalService"] = self.useAdditionalService!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("SystemDisk") {
            var model = ReplaceSystemDiskRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Architecture") {
            self.architecture = dict["Architecture"] as! String
        }
        if dict.keys.contains("Arn") {
            var tmp : [ReplaceSystemDiskRequest.Arn] = []
            for v in dict["Arn"] as! [Any] {
                var model = ReplaceSystemDiskRequest.Arn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.arn = tmp
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("EncryptAlgorithm") {
            self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
        }
        if dict.keys.contains("Encrypted") {
            self.encrypted = dict["Encrypted"] as! Bool
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("KMSKeyId") {
            self.KMSKeyId = dict["KMSKeyId"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Platform") {
            self.platform = dict["Platform"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("UseAdditionalService") {
            self.useAdditionalService = dict["UseAdditionalService"] as! Bool
        }
    }
}

public class ReplaceSystemDiskResponseBody : Tea.TeaModel {
    public var diskId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReplaceSystemDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReplaceSystemDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReplaceSystemDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ReportInstancesStatusRequest : Tea.TeaModel {
    public var description_: String?

    public var device: [String]?

    public var diskId: [String]?

    public var endTime: String?

    public var instanceId: [String]?

    public var issueCategory: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var reason: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var startTime: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.device != nil {
            map["Device"] = self.device!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.endTime != nil {
            map["EndTime"] = self.endTime!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.issueCategory != nil {
            map["IssueCategory"] = self.issueCategory!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.reason != nil {
            map["Reason"] = self.reason!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.startTime != nil {
            map["StartTime"] = self.startTime!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("Device") {
            self.device = dict["Device"] as! [String]
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! [String]
        }
        if dict.keys.contains("EndTime") {
            self.endTime = dict["EndTime"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("IssueCategory") {
            self.issueCategory = dict["IssueCategory"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Reason") {
            self.reason = dict["Reason"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StartTime") {
            self.startTime = dict["StartTime"] as! String
        }
    }
}

public class ReportInstancesStatusResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ReportInstancesStatusResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ReportInstancesStatusResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ReportInstancesStatusResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDiskRequest : Tea.TeaModel {
    public var diskId: String?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var snapshotId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.snapshotId != nil {
            map["SnapshotId"] = self.snapshotId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SnapshotId") {
            self.snapshotId = dict["SnapshotId"] as! String
        }
    }
}

public class ResetDiskResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDiskDefaultKMSKeyIdRequest : Tea.TeaModel {
    public var regionId: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ResetDiskDefaultKMSKeyIdResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetDiskDefaultKMSKeyIdResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDiskDefaultKMSKeyIdResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetDiskDefaultKMSKeyIdResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResetDisksRequest : Tea.TeaModel {
    public class Disk : Tea.TeaModel {
        public var diskId: String?

        public var snapshotId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.diskId != nil {
                map["DiskId"] = self.diskId!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DiskId") {
                self.diskId = dict["DiskId"] as! String
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
        }
    }
    public var disk: [ResetDisksRequest.Disk]?

    public var dryRun: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.disk != nil {
            var tmp : [Any] = []
            for k in self.disk! {
                tmp.append(k.toMap())
            }
            map["Disk"] = tmp
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Disk") {
            var tmp : [ResetDisksRequest.Disk] = []
            for v in dict["Disk"] as! [Any] {
                var model = ResetDisksRequest.Disk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.disk = tmp
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class ResetDisksResponseBody : Tea.TeaModel {
    public class OperationProgressSet : Tea.TeaModel {
        public class OperationProgress : Tea.TeaModel {
            public class RelatedItemSet : Tea.TeaModel {
                public class RelatedItem : Tea.TeaModel {
                    public var name: String?

                    public var value: String?

                    public override init() {
                        super.init()
                    }

                    public init(_ dict: [String: Any]) {
                        super.init()
                        self.fromMap(dict)
                    }

                    public override func validate() throws -> Void {
                    }

                    public override func toMap() -> [String : Any] {
                        var map = super.toMap()
                        if self.name != nil {
                            map["Name"] = self.name!
                        }
                        if self.value != nil {
                            map["Value"] = self.value!
                        }
                        return map
                    }

                    public override func fromMap(_ dict: [String: Any]) -> Void {
                        if dict.keys.contains("Name") {
                            self.name = dict["Name"] as! String
                        }
                        if dict.keys.contains("Value") {
                            self.value = dict["Value"] as! String
                        }
                    }
                }
                public var relatedItem: [ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem]?

                public override init() {
                    super.init()
                }

                public init(_ dict: [String: Any]) {
                    super.init()
                    self.fromMap(dict)
                }

                public override func validate() throws -> Void {
                }

                public override func toMap() -> [String : Any] {
                    var map = super.toMap()
                    if self.relatedItem != nil {
                        var tmp : [Any] = []
                        for k in self.relatedItem! {
                            tmp.append(k.toMap())
                        }
                        map["RelatedItem"] = tmp
                    }
                    return map
                }

                public override func fromMap(_ dict: [String: Any]) -> Void {
                    if dict.keys.contains("RelatedItem") {
                        var tmp : [ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem] = []
                        for v in dict["RelatedItem"] as! [Any] {
                            var model = ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet.RelatedItem()
                            if v != nil {
                                model.fromMap(v as! [String: Any])
                            }
                            tmp.append(model)
                        }
                        self.relatedItem = tmp
                    }
                }
            }
            public var errorCode: String?

            public var errorMsg: String?

            public var operationStatus: String?

            public var relatedItemSet: ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
                try self.relatedItemSet?.validate()
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.errorCode != nil {
                    map["ErrorCode"] = self.errorCode!
                }
                if self.errorMsg != nil {
                    map["ErrorMsg"] = self.errorMsg!
                }
                if self.operationStatus != nil {
                    map["OperationStatus"] = self.operationStatus!
                }
                if self.relatedItemSet != nil {
                    map["RelatedItemSet"] = self.relatedItemSet?.toMap()
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("ErrorCode") {
                    self.errorCode = dict["ErrorCode"] as! String
                }
                if dict.keys.contains("ErrorMsg") {
                    self.errorMsg = dict["ErrorMsg"] as! String
                }
                if dict.keys.contains("OperationStatus") {
                    self.operationStatus = dict["OperationStatus"] as! String
                }
                if dict.keys.contains("RelatedItemSet") {
                    var model = ResetDisksResponseBody.OperationProgressSet.OperationProgress.RelatedItemSet()
                    model.fromMap(dict["RelatedItemSet"] as! [String: Any])
                    self.relatedItemSet = model
                }
            }
        }
        public var operationProgress: [ResetDisksResponseBody.OperationProgressSet.OperationProgress]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.operationProgress != nil {
                var tmp : [Any] = []
                for k in self.operationProgress! {
                    tmp.append(k.toMap())
                }
                map["OperationProgress"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("OperationProgress") {
                var tmp : [ResetDisksResponseBody.OperationProgressSet.OperationProgress] = []
                for v in dict["OperationProgress"] as! [Any] {
                    var model = ResetDisksResponseBody.OperationProgressSet.OperationProgress()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.operationProgress = tmp
            }
        }
    }
    public var operationProgressSet: ResetDisksResponseBody.OperationProgressSet?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.operationProgressSet?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.operationProgressSet != nil {
            map["OperationProgressSet"] = self.operationProgressSet?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OperationProgressSet") {
            var model = ResetDisksResponseBody.OperationProgressSet()
            model.fromMap(dict["OperationProgressSet"] as! [String: Any])
            self.operationProgressSet = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResetDisksResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResetDisksResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResetDisksResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class ResizeDiskRequest : Tea.TeaModel {
    public var clientToken: String?

    public var diskId: String?

    public var newSize: Int32?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var type: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.diskId != nil {
            map["DiskId"] = self.diskId!
        }
        if self.newSize != nil {
            map["NewSize"] = self.newSize!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("DiskId") {
            self.diskId = dict["DiskId"] as! String
        }
        if dict.keys.contains("NewSize") {
            self.newSize = dict["NewSize"] as! Int32
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
    }
}

public class ResizeDiskResponseBody : Tea.TeaModel {
    public var orderId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class ResizeDiskResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: ResizeDiskResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = ResizeDiskResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeSecurityGroupRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourceGroupId: String?

        public var sourceGroupOwnerAccount: String?

        public var sourceGroupOwnerId: Int64?

        public var sourcePortRange: String?

        public var sourcePrefixListId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourceGroupId != nil {
                map["SourceGroupId"] = self.sourceGroupId!
            }
            if self.sourceGroupOwnerAccount != nil {
                map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
            }
            if self.sourceGroupOwnerId != nil {
                map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            if self.sourcePrefixListId != nil {
                map["SourcePrefixListId"] = self.sourcePrefixListId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestCidrIp") {
                self.destCidrIp = dict["DestCidrIp"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Ipv6DestCidrIp") {
                self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
            }
            if dict.keys.contains("Ipv6SourceCidrIp") {
                self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
            }
            if dict.keys.contains("NicType") {
                self.nicType = dict["NicType"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
            if dict.keys.contains("SourceGroupId") {
                self.sourceGroupId = dict["SourceGroupId"] as! String
            }
            if dict.keys.contains("SourceGroupOwnerAccount") {
                self.sourceGroupOwnerAccount = dict["SourceGroupOwnerAccount"] as! String
            }
            if dict.keys.contains("SourceGroupOwnerId") {
                self.sourceGroupOwnerId = dict["SourceGroupOwnerId"] as! Int64
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
            if dict.keys.contains("SourcePrefixListId") {
                self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [RevokeSecurityGroupRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: [String]?

    public var sourceCidrIp: String?

    public var sourceGroupId: String?

    public var sourceGroupOwnerAccount: String?

    public var sourceGroupOwnerId: Int64?

    public var sourcePortRange: String?

    public var sourcePrefixListId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourceGroupId != nil {
            map["SourceGroupId"] = self.sourceGroupId!
        }
        if self.sourceGroupOwnerAccount != nil {
            map["SourceGroupOwnerAccount"] = self.sourceGroupOwnerAccount!
        }
        if self.sourceGroupOwnerId != nil {
            map["SourceGroupOwnerId"] = self.sourceGroupOwnerId!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        if self.sourcePrefixListId != nil {
            map["SourcePrefixListId"] = self.sourcePrefixListId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Ipv6DestCidrIp") {
            self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
        }
        if dict.keys.contains("Ipv6SourceCidrIp") {
            self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Permissions") {
            var tmp : [RevokeSecurityGroupRequest.Permissions] = []
            for v in dict["Permissions"] as! [Any] {
                var model = RevokeSecurityGroupRequest.Permissions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.permissions = tmp
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupRuleId") {
            self.securityGroupRuleId = dict["SecurityGroupRuleId"] as! [String]
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourceGroupId") {
            self.sourceGroupId = dict["SourceGroupId"] as! String
        }
        if dict.keys.contains("SourceGroupOwnerAccount") {
            self.sourceGroupOwnerAccount = dict["SourceGroupOwnerAccount"] as! String
        }
        if dict.keys.contains("SourceGroupOwnerId") {
            self.sourceGroupOwnerId = dict["SourceGroupOwnerId"] as! Int64
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
        if dict.keys.contains("SourcePrefixListId") {
            self.sourcePrefixListId = dict["SourcePrefixListId"] as! String
        }
    }
}

public class RevokeSecurityGroupResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeSecurityGroupResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeSecurityGroupResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RevokeSecurityGroupEgressRequest : Tea.TeaModel {
    public class Permissions : Tea.TeaModel {
        public var description_: String?

        public var destCidrIp: String?

        public var destGroupId: String?

        public var destGroupOwnerAccount: String?

        public var destGroupOwnerId: String?

        public var destPrefixListId: String?

        public var ipProtocol: String?

        public var ipv6DestCidrIp: String?

        public var ipv6SourceCidrIp: String?

        public var nicType: String?

        public var policy: String?

        public var portRange: String?

        public var priority: String?

        public var sourceCidrIp: String?

        public var sourcePortRange: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.destCidrIp != nil {
                map["DestCidrIp"] = self.destCidrIp!
            }
            if self.destGroupId != nil {
                map["DestGroupId"] = self.destGroupId!
            }
            if self.destGroupOwnerAccount != nil {
                map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
            }
            if self.destGroupOwnerId != nil {
                map["DestGroupOwnerId"] = self.destGroupOwnerId!
            }
            if self.destPrefixListId != nil {
                map["DestPrefixListId"] = self.destPrefixListId!
            }
            if self.ipProtocol != nil {
                map["IpProtocol"] = self.ipProtocol!
            }
            if self.ipv6DestCidrIp != nil {
                map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
            }
            if self.ipv6SourceCidrIp != nil {
                map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
            }
            if self.nicType != nil {
                map["NicType"] = self.nicType!
            }
            if self.policy != nil {
                map["Policy"] = self.policy!
            }
            if self.portRange != nil {
                map["PortRange"] = self.portRange!
            }
            if self.priority != nil {
                map["Priority"] = self.priority!
            }
            if self.sourceCidrIp != nil {
                map["SourceCidrIp"] = self.sourceCidrIp!
            }
            if self.sourcePortRange != nil {
                map["SourcePortRange"] = self.sourcePortRange!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DestCidrIp") {
                self.destCidrIp = dict["DestCidrIp"] as! String
            }
            if dict.keys.contains("DestGroupId") {
                self.destGroupId = dict["DestGroupId"] as! String
            }
            if dict.keys.contains("DestGroupOwnerAccount") {
                self.destGroupOwnerAccount = dict["DestGroupOwnerAccount"] as! String
            }
            if dict.keys.contains("DestGroupOwnerId") {
                self.destGroupOwnerId = dict["DestGroupOwnerId"] as! String
            }
            if dict.keys.contains("DestPrefixListId") {
                self.destPrefixListId = dict["DestPrefixListId"] as! String
            }
            if dict.keys.contains("IpProtocol") {
                self.ipProtocol = dict["IpProtocol"] as! String
            }
            if dict.keys.contains("Ipv6DestCidrIp") {
                self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
            }
            if dict.keys.contains("Ipv6SourceCidrIp") {
                self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
            }
            if dict.keys.contains("NicType") {
                self.nicType = dict["NicType"] as! String
            }
            if dict.keys.contains("Policy") {
                self.policy = dict["Policy"] as! String
            }
            if dict.keys.contains("PortRange") {
                self.portRange = dict["PortRange"] as! String
            }
            if dict.keys.contains("Priority") {
                self.priority = dict["Priority"] as! String
            }
            if dict.keys.contains("SourceCidrIp") {
                self.sourceCidrIp = dict["SourceCidrIp"] as! String
            }
            if dict.keys.contains("SourcePortRange") {
                self.sourcePortRange = dict["SourcePortRange"] as! String
            }
        }
    }
    public var clientToken: String?

    public var description_: String?

    public var destCidrIp: String?

    public var destGroupId: String?

    public var destGroupOwnerAccount: String?

    public var destGroupOwnerId: Int64?

    public var destPrefixListId: String?

    public var ipProtocol: String?

    public var ipv6DestCidrIp: String?

    public var ipv6SourceCidrIp: String?

    public var nicType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var permissions: [RevokeSecurityGroupEgressRequest.Permissions]?

    public var policy: String?

    public var portRange: String?

    public var priority: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityGroupId: String?

    public var securityGroupRuleId: [String]?

    public var sourceCidrIp: String?

    public var sourcePortRange: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.destCidrIp != nil {
            map["DestCidrIp"] = self.destCidrIp!
        }
        if self.destGroupId != nil {
            map["DestGroupId"] = self.destGroupId!
        }
        if self.destGroupOwnerAccount != nil {
            map["DestGroupOwnerAccount"] = self.destGroupOwnerAccount!
        }
        if self.destGroupOwnerId != nil {
            map["DestGroupOwnerId"] = self.destGroupOwnerId!
        }
        if self.destPrefixListId != nil {
            map["DestPrefixListId"] = self.destPrefixListId!
        }
        if self.ipProtocol != nil {
            map["IpProtocol"] = self.ipProtocol!
        }
        if self.ipv6DestCidrIp != nil {
            map["Ipv6DestCidrIp"] = self.ipv6DestCidrIp!
        }
        if self.ipv6SourceCidrIp != nil {
            map["Ipv6SourceCidrIp"] = self.ipv6SourceCidrIp!
        }
        if self.nicType != nil {
            map["NicType"] = self.nicType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.permissions != nil {
            var tmp : [Any] = []
            for k in self.permissions! {
                tmp.append(k.toMap())
            }
            map["Permissions"] = tmp
        }
        if self.policy != nil {
            map["Policy"] = self.policy!
        }
        if self.portRange != nil {
            map["PortRange"] = self.portRange!
        }
        if self.priority != nil {
            map["Priority"] = self.priority!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupRuleId != nil {
            map["SecurityGroupRuleId"] = self.securityGroupRuleId!
        }
        if self.sourceCidrIp != nil {
            map["SourceCidrIp"] = self.sourceCidrIp!
        }
        if self.sourcePortRange != nil {
            map["SourcePortRange"] = self.sourcePortRange!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DestCidrIp") {
            self.destCidrIp = dict["DestCidrIp"] as! String
        }
        if dict.keys.contains("DestGroupId") {
            self.destGroupId = dict["DestGroupId"] as! String
        }
        if dict.keys.contains("DestGroupOwnerAccount") {
            self.destGroupOwnerAccount = dict["DestGroupOwnerAccount"] as! String
        }
        if dict.keys.contains("DestGroupOwnerId") {
            self.destGroupOwnerId = dict["DestGroupOwnerId"] as! Int64
        }
        if dict.keys.contains("DestPrefixListId") {
            self.destPrefixListId = dict["DestPrefixListId"] as! String
        }
        if dict.keys.contains("IpProtocol") {
            self.ipProtocol = dict["IpProtocol"] as! String
        }
        if dict.keys.contains("Ipv6DestCidrIp") {
            self.ipv6DestCidrIp = dict["Ipv6DestCidrIp"] as! String
        }
        if dict.keys.contains("Ipv6SourceCidrIp") {
            self.ipv6SourceCidrIp = dict["Ipv6SourceCidrIp"] as! String
        }
        if dict.keys.contains("NicType") {
            self.nicType = dict["NicType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Permissions") {
            var tmp : [RevokeSecurityGroupEgressRequest.Permissions] = []
            for v in dict["Permissions"] as! [Any] {
                var model = RevokeSecurityGroupEgressRequest.Permissions()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.permissions = tmp
        }
        if dict.keys.contains("Policy") {
            self.policy = dict["Policy"] as! String
        }
        if dict.keys.contains("PortRange") {
            self.portRange = dict["PortRange"] as! String
        }
        if dict.keys.contains("Priority") {
            self.priority = dict["Priority"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupRuleId") {
            self.securityGroupRuleId = dict["SecurityGroupRuleId"] as! [String]
        }
        if dict.keys.contains("SourceCidrIp") {
            self.sourceCidrIp = dict["SourceCidrIp"] as! String
        }
        if dict.keys.contains("SourcePortRange") {
            self.sourcePortRange = dict["SourcePortRange"] as! String
        }
    }
}

public class RevokeSecurityGroupEgressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RevokeSecurityGroupEgressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RevokeSecurityGroupEgressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RevokeSecurityGroupEgressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunCommandRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var commandContent: String?

    public var containerId: String?

    public var containerName: String?

    public var contentEncoding: String?

    public var description_: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var keepCommand: Bool?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parameters: [String: Any]?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [RunCommandRequest.ResourceTag]?

    public var tag: [RunCommandRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var type: String?

    public var username: String?

    public var windowsPasswordName: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keepCommand != nil {
            map["KeepCommand"] = self.keepCommand!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parameters != nil {
            map["Parameters"] = self.parameters!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("ContainerId") {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("ContainerName") {
            self.containerName = dict["ContainerName"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableParameter") {
            self.enableParameter = dict["EnableParameter"] as! Bool
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("KeepCommand") {
            self.keepCommand = dict["KeepCommand"] as! Bool
        }
        if dict.keys.contains("Launcher") {
            self.launcher = dict["Launcher"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parameters = dict["Parameters"] as! [String: Any]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepeatMode") {
            self.repeatMode = dict["RepeatMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceTag") {
            var tmp : [RunCommandRequest.ResourceTag] = []
            for v in dict["ResourceTag"] as! [Any] {
                var model = RunCommandRequest.ResourceTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceTag = tmp
        }
        if dict.keys.contains("Tag") {
            var tmp : [RunCommandRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = RunCommandRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TerminationMode") {
            self.terminationMode = dict["TerminationMode"] as! String
        }
        if dict.keys.contains("Timed") {
            self.timed = dict["Timed"] as! Bool
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
        if dict.keys.contains("WindowsPasswordName") {
            self.windowsPasswordName = dict["WindowsPasswordName"] as! String
        }
        if dict.keys.contains("WorkingDir") {
            self.workingDir = dict["WorkingDir"] as! String
        }
    }
}

public class RunCommandShrinkRequest : Tea.TeaModel {
    public class ResourceTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var commandContent: String?

    public var containerId: String?

    public var containerName: String?

    public var contentEncoding: String?

    public var description_: String?

    public var enableParameter: Bool?

    public var frequency: String?

    public var instanceId: [String]?

    public var keepCommand: Bool?

    public var launcher: String?

    public var name: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var parametersShrink: String?

    public var regionId: String?

    public var repeatMode: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceTag: [RunCommandShrinkRequest.ResourceTag]?

    public var tag: [RunCommandShrinkRequest.Tag]?

    public var terminationMode: String?

    public var timed: Bool?

    public var timeout: Int64?

    public var type: String?

    public var username: String?

    public var windowsPasswordName: String?

    public var workingDir: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.commandContent != nil {
            map["CommandContent"] = self.commandContent!
        }
        if self.containerId != nil {
            map["ContainerId"] = self.containerId!
        }
        if self.containerName != nil {
            map["ContainerName"] = self.containerName!
        }
        if self.contentEncoding != nil {
            map["ContentEncoding"] = self.contentEncoding!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.enableParameter != nil {
            map["EnableParameter"] = self.enableParameter!
        }
        if self.frequency != nil {
            map["Frequency"] = self.frequency!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.keepCommand != nil {
            map["KeepCommand"] = self.keepCommand!
        }
        if self.launcher != nil {
            map["Launcher"] = self.launcher!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.parametersShrink != nil {
            map["Parameters"] = self.parametersShrink!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.repeatMode != nil {
            map["RepeatMode"] = self.repeatMode!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceTag != nil {
            var tmp : [Any] = []
            for k in self.resourceTag! {
                tmp.append(k.toMap())
            }
            map["ResourceTag"] = tmp
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.terminationMode != nil {
            map["TerminationMode"] = self.terminationMode!
        }
        if self.timed != nil {
            map["Timed"] = self.timed!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        if self.type != nil {
            map["Type"] = self.type!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        if self.windowsPasswordName != nil {
            map["WindowsPasswordName"] = self.windowsPasswordName!
        }
        if self.workingDir != nil {
            map["WorkingDir"] = self.workingDir!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CommandContent") {
            self.commandContent = dict["CommandContent"] as! String
        }
        if dict.keys.contains("ContainerId") {
            self.containerId = dict["ContainerId"] as! String
        }
        if dict.keys.contains("ContainerName") {
            self.containerName = dict["ContainerName"] as! String
        }
        if dict.keys.contains("ContentEncoding") {
            self.contentEncoding = dict["ContentEncoding"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("EnableParameter") {
            self.enableParameter = dict["EnableParameter"] as! Bool
        }
        if dict.keys.contains("Frequency") {
            self.frequency = dict["Frequency"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("KeepCommand") {
            self.keepCommand = dict["KeepCommand"] as! Bool
        }
        if dict.keys.contains("Launcher") {
            self.launcher = dict["Launcher"] as! String
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Parameters") {
            self.parametersShrink = dict["Parameters"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("RepeatMode") {
            self.repeatMode = dict["RepeatMode"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceTag") {
            var tmp : [RunCommandShrinkRequest.ResourceTag] = []
            for v in dict["ResourceTag"] as! [Any] {
                var model = RunCommandShrinkRequest.ResourceTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.resourceTag = tmp
        }
        if dict.keys.contains("Tag") {
            var tmp : [RunCommandShrinkRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = RunCommandShrinkRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TerminationMode") {
            self.terminationMode = dict["TerminationMode"] as! String
        }
        if dict.keys.contains("Timed") {
            self.timed = dict["Timed"] as! Bool
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
        if dict.keys.contains("Type") {
            self.type = dict["Type"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
        if dict.keys.contains("WindowsPasswordName") {
            self.windowsPasswordName = dict["WindowsPasswordName"] as! String
        }
        if dict.keys.contains("WorkingDir") {
            self.workingDir = dict["WorkingDir"] as! String
        }
    }
}

public class RunCommandResponseBody : Tea.TeaModel {
    public var commandId: String?

    public var invokeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandId != nil {
            map["CommandId"] = self.commandId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandId") {
            self.commandId = dict["CommandId"] as! String
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class RunCommandResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunCommandResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunCommandResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class RunInstancesRequest : Tea.TeaModel {
    public class CpuOptions : Tea.TeaModel {
        public var core: Int32?

        public var numa: String?

        public var threadsPerCore: Int32?

        public var topologyType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.core != nil {
                map["Core"] = self.core!
            }
            if self.numa != nil {
                map["Numa"] = self.numa!
            }
            if self.threadsPerCore != nil {
                map["ThreadsPerCore"] = self.threadsPerCore!
            }
            if self.topologyType != nil {
                map["TopologyType"] = self.topologyType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Core") {
                self.core = dict["Core"] as! Int32
            }
            if dict.keys.contains("Numa") {
                self.numa = dict["Numa"] as! String
            }
            if dict.keys.contains("ThreadsPerCore") {
                self.threadsPerCore = dict["ThreadsPerCore"] as! Int32
            }
            if dict.keys.contains("TopologyType") {
                self.topologyType = dict["TopologyType"] as! String
            }
        }
    }
    public class HibernationOptions : Tea.TeaModel {
        public var configured: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.configured != nil {
                map["Configured"] = self.configured!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Configured") {
                self.configured = dict["Configured"] as! Bool
            }
        }
    }
    public class PrivatePoolOptions : Tea.TeaModel {
        public var id: String?

        public var matchCriteria: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.id != nil {
                map["Id"] = self.id!
            }
            if self.matchCriteria != nil {
                map["MatchCriteria"] = self.matchCriteria!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Id") {
                self.id = dict["Id"] as! String
            }
            if dict.keys.contains("MatchCriteria") {
                self.matchCriteria = dict["MatchCriteria"] as! String
            }
        }
    }
    public class SchedulerOptions : Tea.TeaModel {
        public var dedicatedHostClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.dedicatedHostClusterId != nil {
                map["DedicatedHostClusterId"] = self.dedicatedHostClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DedicatedHostClusterId") {
                self.dedicatedHostClusterId = dict["DedicatedHostClusterId"] as! String
            }
        }
    }
    public class SecurityOptions : Tea.TeaModel {
        public var confidentialComputingMode: String?

        public var trustedSystemMode: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.confidentialComputingMode != nil {
                map["ConfidentialComputingMode"] = self.confidentialComputingMode!
            }
            if self.trustedSystemMode != nil {
                map["TrustedSystemMode"] = self.trustedSystemMode!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("ConfidentialComputingMode") {
                self.confidentialComputingMode = dict["ConfidentialComputingMode"] as! String
            }
            if dict.keys.contains("TrustedSystemMode") {
                self.trustedSystemMode = dict["TrustedSystemMode"] as! String
            }
        }
    }
    public class SystemDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var category: String?

        public var description_: String?

        public var diskName: String?

        public var performanceLevel: String?

        public var size: String?

        public var burstingEnabled: Bool?

        public var encryptAlgorithm: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var provisionedIops: Int64?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class Arn : Tea.TeaModel {
        public var assumeRoleFor: Int64?

        public var roleType: String?

        public var rolearn: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.assumeRoleFor != nil {
                map["AssumeRoleFor"] = self.assumeRoleFor!
            }
            if self.roleType != nil {
                map["RoleType"] = self.roleType!
            }
            if self.rolearn != nil {
                map["Rolearn"] = self.rolearn!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AssumeRoleFor") {
                self.assumeRoleFor = dict["AssumeRoleFor"] as! Int64
            }
            if dict.keys.contains("RoleType") {
                self.roleType = dict["RoleType"] as! String
            }
            if dict.keys.contains("Rolearn") {
                self.rolearn = dict["Rolearn"] as! String
            }
        }
    }
    public class DataDisk : Tea.TeaModel {
        public var autoSnapshotPolicyId: String?

        public var burstingEnabled: Bool?

        public var category: String?

        public var deleteWithInstance: Bool?

        public var description_: String?

        public var device: String?

        public var diskName: String?

        public var encryptAlgorithm: String?

        public var encrypted: String?

        public var KMSKeyId: String?

        public var performanceLevel: String?

        public var provisionedIops: Int64?

        public var size: Int32?

        public var snapshotId: String?

        public var storageClusterId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.autoSnapshotPolicyId != nil {
                map["AutoSnapshotPolicyId"] = self.autoSnapshotPolicyId!
            }
            if self.burstingEnabled != nil {
                map["BurstingEnabled"] = self.burstingEnabled!
            }
            if self.category != nil {
                map["Category"] = self.category!
            }
            if self.deleteWithInstance != nil {
                map["DeleteWithInstance"] = self.deleteWithInstance!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.device != nil {
                map["Device"] = self.device!
            }
            if self.diskName != nil {
                map["DiskName"] = self.diskName!
            }
            if self.encryptAlgorithm != nil {
                map["EncryptAlgorithm"] = self.encryptAlgorithm!
            }
            if self.encrypted != nil {
                map["Encrypted"] = self.encrypted!
            }
            if self.KMSKeyId != nil {
                map["KMSKeyId"] = self.KMSKeyId!
            }
            if self.performanceLevel != nil {
                map["PerformanceLevel"] = self.performanceLevel!
            }
            if self.provisionedIops != nil {
                map["ProvisionedIops"] = self.provisionedIops!
            }
            if self.size != nil {
                map["Size"] = self.size!
            }
            if self.snapshotId != nil {
                map["SnapshotId"] = self.snapshotId!
            }
            if self.storageClusterId != nil {
                map["StorageClusterId"] = self.storageClusterId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("AutoSnapshotPolicyId") {
                self.autoSnapshotPolicyId = dict["AutoSnapshotPolicyId"] as! String
            }
            if dict.keys.contains("BurstingEnabled") {
                self.burstingEnabled = dict["BurstingEnabled"] as! Bool
            }
            if dict.keys.contains("Category") {
                self.category = dict["Category"] as! String
            }
            if dict.keys.contains("DeleteWithInstance") {
                self.deleteWithInstance = dict["DeleteWithInstance"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("Device") {
                self.device = dict["Device"] as! String
            }
            if dict.keys.contains("DiskName") {
                self.diskName = dict["DiskName"] as! String
            }
            if dict.keys.contains("EncryptAlgorithm") {
                self.encryptAlgorithm = dict["EncryptAlgorithm"] as! String
            }
            if dict.keys.contains("Encrypted") {
                self.encrypted = dict["Encrypted"] as! String
            }
            if dict.keys.contains("KMSKeyId") {
                self.KMSKeyId = dict["KMSKeyId"] as! String
            }
            if dict.keys.contains("PerformanceLevel") {
                self.performanceLevel = dict["PerformanceLevel"] as! String
            }
            if dict.keys.contains("ProvisionedIops") {
                self.provisionedIops = dict["ProvisionedIops"] as! Int64
            }
            if dict.keys.contains("Size") {
                self.size = dict["Size"] as! Int32
            }
            if dict.keys.contains("SnapshotId") {
                self.snapshotId = dict["SnapshotId"] as! String
            }
            if dict.keys.contains("StorageClusterId") {
                self.storageClusterId = dict["StorageClusterId"] as! String
            }
        }
    }
    public class ImageOptions : Tea.TeaModel {
        public var loginAsNonRoot: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.loginAsNonRoot != nil {
                map["LoginAsNonRoot"] = self.loginAsNonRoot!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("LoginAsNonRoot") {
                self.loginAsNonRoot = dict["LoginAsNonRoot"] as! Bool
            }
        }
    }
    public class NetworkInterface : Tea.TeaModel {
        public var deleteOnRelease: Bool?

        public var description_: String?

        public var instanceType: String?

        public var ipv6Address: [String]?

        public var ipv6AddressCount: Int64?

        public var networkCardIndex: Int32?

        public var networkInterfaceId: String?

        public var networkInterfaceName: String?

        public var networkInterfaceTrafficMode: String?

        public var primaryIpAddress: String?

        public var queueNumber: Int32?

        public var queuePairNumber: Int64?

        public var rxQueueSize: Int32?

        public var securityGroupId: String?

        public var securityGroupIds: [String]?

        public var txQueueSize: Int32?

        public var vSwitchId: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.deleteOnRelease != nil {
                map["DeleteOnRelease"] = self.deleteOnRelease!
            }
            if self.description_ != nil {
                map["Description"] = self.description_!
            }
            if self.instanceType != nil {
                map["InstanceType"] = self.instanceType!
            }
            if self.ipv6Address != nil {
                map["Ipv6Address"] = self.ipv6Address!
            }
            if self.ipv6AddressCount != nil {
                map["Ipv6AddressCount"] = self.ipv6AddressCount!
            }
            if self.networkCardIndex != nil {
                map["NetworkCardIndex"] = self.networkCardIndex!
            }
            if self.networkInterfaceId != nil {
                map["NetworkInterfaceId"] = self.networkInterfaceId!
            }
            if self.networkInterfaceName != nil {
                map["NetworkInterfaceName"] = self.networkInterfaceName!
            }
            if self.networkInterfaceTrafficMode != nil {
                map["NetworkInterfaceTrafficMode"] = self.networkInterfaceTrafficMode!
            }
            if self.primaryIpAddress != nil {
                map["PrimaryIpAddress"] = self.primaryIpAddress!
            }
            if self.queueNumber != nil {
                map["QueueNumber"] = self.queueNumber!
            }
            if self.queuePairNumber != nil {
                map["QueuePairNumber"] = self.queuePairNumber!
            }
            if self.rxQueueSize != nil {
                map["RxQueueSize"] = self.rxQueueSize!
            }
            if self.securityGroupId != nil {
                map["SecurityGroupId"] = self.securityGroupId!
            }
            if self.securityGroupIds != nil {
                map["SecurityGroupIds"] = self.securityGroupIds!
            }
            if self.txQueueSize != nil {
                map["TxQueueSize"] = self.txQueueSize!
            }
            if self.vSwitchId != nil {
                map["VSwitchId"] = self.vSwitchId!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("DeleteOnRelease") {
                self.deleteOnRelease = dict["DeleteOnRelease"] as! Bool
            }
            if dict.keys.contains("Description") {
                self.description_ = dict["Description"] as! String
            }
            if dict.keys.contains("InstanceType") {
                self.instanceType = dict["InstanceType"] as! String
            }
            if dict.keys.contains("Ipv6Address") {
                self.ipv6Address = dict["Ipv6Address"] as! [String]
            }
            if dict.keys.contains("Ipv6AddressCount") {
                self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int64
            }
            if dict.keys.contains("NetworkCardIndex") {
                self.networkCardIndex = dict["NetworkCardIndex"] as! Int32
            }
            if dict.keys.contains("NetworkInterfaceId") {
                self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
            }
            if dict.keys.contains("NetworkInterfaceName") {
                self.networkInterfaceName = dict["NetworkInterfaceName"] as! String
            }
            if dict.keys.contains("NetworkInterfaceTrafficMode") {
                self.networkInterfaceTrafficMode = dict["NetworkInterfaceTrafficMode"] as! String
            }
            if dict.keys.contains("PrimaryIpAddress") {
                self.primaryIpAddress = dict["PrimaryIpAddress"] as! String
            }
            if dict.keys.contains("QueueNumber") {
                self.queueNumber = dict["QueueNumber"] as! Int32
            }
            if dict.keys.contains("QueuePairNumber") {
                self.queuePairNumber = dict["QueuePairNumber"] as! Int64
            }
            if dict.keys.contains("RxQueueSize") {
                self.rxQueueSize = dict["RxQueueSize"] as! Int32
            }
            if dict.keys.contains("SecurityGroupId") {
                self.securityGroupId = dict["SecurityGroupId"] as! String
            }
            if dict.keys.contains("SecurityGroupIds") {
                self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
            }
            if dict.keys.contains("TxQueueSize") {
                self.txQueueSize = dict["TxQueueSize"] as! Int32
            }
            if dict.keys.contains("VSwitchId") {
                self.vSwitchId = dict["VSwitchId"] as! String
            }
        }
    }
    public class NetworkOptions : Tea.TeaModel {
        public var enableJumboFrame: Bool?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableJumboFrame != nil {
                map["EnableJumboFrame"] = self.enableJumboFrame!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableJumboFrame") {
                self.enableJumboFrame = dict["EnableJumboFrame"] as! Bool
            }
        }
    }
    public class PrivateDnsNameOptions : Tea.TeaModel {
        public var enableInstanceIdDnsAAAARecord: Bool?

        public var enableInstanceIdDnsARecord: Bool?

        public var enableIpDnsARecord: Bool?

        public var enableIpDnsPtrRecord: Bool?

        public var hostnameType: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.enableInstanceIdDnsAAAARecord != nil {
                map["EnableInstanceIdDnsAAAARecord"] = self.enableInstanceIdDnsAAAARecord!
            }
            if self.enableInstanceIdDnsARecord != nil {
                map["EnableInstanceIdDnsARecord"] = self.enableInstanceIdDnsARecord!
            }
            if self.enableIpDnsARecord != nil {
                map["EnableIpDnsARecord"] = self.enableIpDnsARecord!
            }
            if self.enableIpDnsPtrRecord != nil {
                map["EnableIpDnsPtrRecord"] = self.enableIpDnsPtrRecord!
            }
            if self.hostnameType != nil {
                map["HostnameType"] = self.hostnameType!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("EnableInstanceIdDnsAAAARecord") {
                self.enableInstanceIdDnsAAAARecord = dict["EnableInstanceIdDnsAAAARecord"] as! Bool
            }
            if dict.keys.contains("EnableInstanceIdDnsARecord") {
                self.enableInstanceIdDnsARecord = dict["EnableInstanceIdDnsARecord"] as! Bool
            }
            if dict.keys.contains("EnableIpDnsARecord") {
                self.enableIpDnsARecord = dict["EnableIpDnsARecord"] as! Bool
            }
            if dict.keys.contains("EnableIpDnsPtrRecord") {
                self.enableIpDnsPtrRecord = dict["EnableIpDnsPtrRecord"] as! Bool
            }
            if dict.keys.contains("HostnameType") {
                self.hostnameType = dict["HostnameType"] as! String
            }
        }
    }
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var cpuOptions: RunInstancesRequest.CpuOptions?

    public var hibernationOptions: RunInstancesRequest.HibernationOptions?

    public var privatePoolOptions: RunInstancesRequest.PrivatePoolOptions?

    public var schedulerOptions: RunInstancesRequest.SchedulerOptions?

    public var securityOptions: RunInstancesRequest.SecurityOptions?

    public var systemDisk: RunInstancesRequest.SystemDisk?

    public var affinity: String?

    public var amount: Int32?

    public var arn: [RunInstancesRequest.Arn]?

    public var autoPay: Bool?

    public var autoReleaseTime: String?

    public var autoRenew: Bool?

    public var autoRenewPeriod: Int32?

    public var clientToken: String?

    public var creditSpecification: String?

    public var dataDisk: [RunInstancesRequest.DataDisk]?

    public var dedicatedHostId: String?

    public var deletionProtection: Bool?

    public var deploymentSetGroupNo: Int32?

    public var deploymentSetId: String?

    public var description_: String?

    public var dryRun: Bool?

    public var hostName: String?

    public var hostNames: [String]?

    public var hpcClusterId: String?

    public var httpEndpoint: String?

    public var httpPutResponseHopLimit: Int32?

    public var httpTokens: String?

    public var imageFamily: String?

    public var imageId: String?

    public var imageOptions: RunInstancesRequest.ImageOptions?

    public var instanceChargeType: String?

    public var instanceName: String?

    public var instanceType: String?

    public var internetChargeType: String?

    public var internetMaxBandwidthIn: Int32?

    public var internetMaxBandwidthOut: Int32?

    public var ioOptimized: String?

    public var ipv6Address: [String]?

    public var ipv6AddressCount: Int32?

    public var isp: String?

    public var keyPairName: String?

    public var launchTemplateId: String?

    public var launchTemplateName: String?

    public var launchTemplateVersion: Int64?

    public var minAmount: Int32?

    public var networkInterface: [RunInstancesRequest.NetworkInterface]?

    public var networkInterfaceQueueNumber: Int32?

    public var networkOptions: RunInstancesRequest.NetworkOptions?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var password: String?

    public var passwordInherit: Bool?

    public var period: Int32?

    public var periodUnit: String?

    public var privateDnsNameOptions: RunInstancesRequest.PrivateDnsNameOptions?

    public var privateIpAddress: String?

    public var ramRoleName: String?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var securityEnhancementStrategy: String?

    public var securityGroupId: String?

    public var securityGroupIds: [String]?

    public var spotDuration: Int32?

    public var spotInterruptionBehavior: String?

    public var spotPriceLimit: Double?

    public var spotStrategy: String?

    public var storageSetId: String?

    public var storageSetPartitionNumber: Int32?

    public var tag: [RunInstancesRequest.Tag]?

    public var tenancy: String?

    public var uniqueSuffix: Bool?

    public var userData: String?

    public var vSwitchId: String?

    public var zoneId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.cpuOptions?.validate()
        try self.hibernationOptions?.validate()
        try self.privatePoolOptions?.validate()
        try self.schedulerOptions?.validate()
        try self.securityOptions?.validate()
        try self.systemDisk?.validate()
        try self.imageOptions?.validate()
        try self.networkOptions?.validate()
        try self.privateDnsNameOptions?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.cpuOptions != nil {
            map["CpuOptions"] = self.cpuOptions?.toMap()
        }
        if self.hibernationOptions != nil {
            map["HibernationOptions"] = self.hibernationOptions?.toMap()
        }
        if self.privatePoolOptions != nil {
            map["PrivatePoolOptions"] = self.privatePoolOptions?.toMap()
        }
        if self.schedulerOptions != nil {
            map["SchedulerOptions"] = self.schedulerOptions?.toMap()
        }
        if self.securityOptions != nil {
            map["SecurityOptions"] = self.securityOptions?.toMap()
        }
        if self.systemDisk != nil {
            map["SystemDisk"] = self.systemDisk?.toMap()
        }
        if self.affinity != nil {
            map["Affinity"] = self.affinity!
        }
        if self.amount != nil {
            map["Amount"] = self.amount!
        }
        if self.arn != nil {
            var tmp : [Any] = []
            for k in self.arn! {
                tmp.append(k.toMap())
            }
            map["Arn"] = tmp
        }
        if self.autoPay != nil {
            map["AutoPay"] = self.autoPay!
        }
        if self.autoReleaseTime != nil {
            map["AutoReleaseTime"] = self.autoReleaseTime!
        }
        if self.autoRenew != nil {
            map["AutoRenew"] = self.autoRenew!
        }
        if self.autoRenewPeriod != nil {
            map["AutoRenewPeriod"] = self.autoRenewPeriod!
        }
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.creditSpecification != nil {
            map["CreditSpecification"] = self.creditSpecification!
        }
        if self.dataDisk != nil {
            var tmp : [Any] = []
            for k in self.dataDisk! {
                tmp.append(k.toMap())
            }
            map["DataDisk"] = tmp
        }
        if self.dedicatedHostId != nil {
            map["DedicatedHostId"] = self.dedicatedHostId!
        }
        if self.deletionProtection != nil {
            map["DeletionProtection"] = self.deletionProtection!
        }
        if self.deploymentSetGroupNo != nil {
            map["DeploymentSetGroupNo"] = self.deploymentSetGroupNo!
        }
        if self.deploymentSetId != nil {
            map["DeploymentSetId"] = self.deploymentSetId!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.hostName != nil {
            map["HostName"] = self.hostName!
        }
        if self.hostNames != nil {
            map["HostNames"] = self.hostNames!
        }
        if self.hpcClusterId != nil {
            map["HpcClusterId"] = self.hpcClusterId!
        }
        if self.httpEndpoint != nil {
            map["HttpEndpoint"] = self.httpEndpoint!
        }
        if self.httpPutResponseHopLimit != nil {
            map["HttpPutResponseHopLimit"] = self.httpPutResponseHopLimit!
        }
        if self.httpTokens != nil {
            map["HttpTokens"] = self.httpTokens!
        }
        if self.imageFamily != nil {
            map["ImageFamily"] = self.imageFamily!
        }
        if self.imageId != nil {
            map["ImageId"] = self.imageId!
        }
        if self.imageOptions != nil {
            map["ImageOptions"] = self.imageOptions?.toMap()
        }
        if self.instanceChargeType != nil {
            map["InstanceChargeType"] = self.instanceChargeType!
        }
        if self.instanceName != nil {
            map["InstanceName"] = self.instanceName!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.internetChargeType != nil {
            map["InternetChargeType"] = self.internetChargeType!
        }
        if self.internetMaxBandwidthIn != nil {
            map["InternetMaxBandwidthIn"] = self.internetMaxBandwidthIn!
        }
        if self.internetMaxBandwidthOut != nil {
            map["InternetMaxBandwidthOut"] = self.internetMaxBandwidthOut!
        }
        if self.ioOptimized != nil {
            map["IoOptimized"] = self.ioOptimized!
        }
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6AddressCount != nil {
            map["Ipv6AddressCount"] = self.ipv6AddressCount!
        }
        if self.isp != nil {
            map["Isp"] = self.isp!
        }
        if self.keyPairName != nil {
            map["KeyPairName"] = self.keyPairName!
        }
        if self.launchTemplateId != nil {
            map["LaunchTemplateId"] = self.launchTemplateId!
        }
        if self.launchTemplateName != nil {
            map["LaunchTemplateName"] = self.launchTemplateName!
        }
        if self.launchTemplateVersion != nil {
            map["LaunchTemplateVersion"] = self.launchTemplateVersion!
        }
        if self.minAmount != nil {
            map["MinAmount"] = self.minAmount!
        }
        if self.networkInterface != nil {
            var tmp : [Any] = []
            for k in self.networkInterface! {
                tmp.append(k.toMap())
            }
            map["NetworkInterface"] = tmp
        }
        if self.networkInterfaceQueueNumber != nil {
            map["NetworkInterfaceQueueNumber"] = self.networkInterfaceQueueNumber!
        }
        if self.networkOptions != nil {
            map["NetworkOptions"] = self.networkOptions?.toMap()
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.password != nil {
            map["Password"] = self.password!
        }
        if self.passwordInherit != nil {
            map["PasswordInherit"] = self.passwordInherit!
        }
        if self.period != nil {
            map["Period"] = self.period!
        }
        if self.periodUnit != nil {
            map["PeriodUnit"] = self.periodUnit!
        }
        if self.privateDnsNameOptions != nil {
            map["PrivateDnsNameOptions"] = self.privateDnsNameOptions?.toMap()
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.ramRoleName != nil {
            map["RamRoleName"] = self.ramRoleName!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.securityEnhancementStrategy != nil {
            map["SecurityEnhancementStrategy"] = self.securityEnhancementStrategy!
        }
        if self.securityGroupId != nil {
            map["SecurityGroupId"] = self.securityGroupId!
        }
        if self.securityGroupIds != nil {
            map["SecurityGroupIds"] = self.securityGroupIds!
        }
        if self.spotDuration != nil {
            map["SpotDuration"] = self.spotDuration!
        }
        if self.spotInterruptionBehavior != nil {
            map["SpotInterruptionBehavior"] = self.spotInterruptionBehavior!
        }
        if self.spotPriceLimit != nil {
            map["SpotPriceLimit"] = self.spotPriceLimit!
        }
        if self.spotStrategy != nil {
            map["SpotStrategy"] = self.spotStrategy!
        }
        if self.storageSetId != nil {
            map["StorageSetId"] = self.storageSetId!
        }
        if self.storageSetPartitionNumber != nil {
            map["StorageSetPartitionNumber"] = self.storageSetPartitionNumber!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.tenancy != nil {
            map["Tenancy"] = self.tenancy!
        }
        if self.uniqueSuffix != nil {
            map["UniqueSuffix"] = self.uniqueSuffix!
        }
        if self.userData != nil {
            map["UserData"] = self.userData!
        }
        if self.vSwitchId != nil {
            map["VSwitchId"] = self.vSwitchId!
        }
        if self.zoneId != nil {
            map["ZoneId"] = self.zoneId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CpuOptions") {
            var model = RunInstancesRequest.CpuOptions()
            model.fromMap(dict["CpuOptions"] as! [String: Any])
            self.cpuOptions = model
        }
        if dict.keys.contains("HibernationOptions") {
            var model = RunInstancesRequest.HibernationOptions()
            model.fromMap(dict["HibernationOptions"] as! [String: Any])
            self.hibernationOptions = model
        }
        if dict.keys.contains("PrivatePoolOptions") {
            var model = RunInstancesRequest.PrivatePoolOptions()
            model.fromMap(dict["PrivatePoolOptions"] as! [String: Any])
            self.privatePoolOptions = model
        }
        if dict.keys.contains("SchedulerOptions") {
            var model = RunInstancesRequest.SchedulerOptions()
            model.fromMap(dict["SchedulerOptions"] as! [String: Any])
            self.schedulerOptions = model
        }
        if dict.keys.contains("SecurityOptions") {
            var model = RunInstancesRequest.SecurityOptions()
            model.fromMap(dict["SecurityOptions"] as! [String: Any])
            self.securityOptions = model
        }
        if dict.keys.contains("SystemDisk") {
            var model = RunInstancesRequest.SystemDisk()
            model.fromMap(dict["SystemDisk"] as! [String: Any])
            self.systemDisk = model
        }
        if dict.keys.contains("Affinity") {
            self.affinity = dict["Affinity"] as! String
        }
        if dict.keys.contains("Amount") {
            self.amount = dict["Amount"] as! Int32
        }
        if dict.keys.contains("Arn") {
            var tmp : [RunInstancesRequest.Arn] = []
            for v in dict["Arn"] as! [Any] {
                var model = RunInstancesRequest.Arn()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.arn = tmp
        }
        if dict.keys.contains("AutoPay") {
            self.autoPay = dict["AutoPay"] as! Bool
        }
        if dict.keys.contains("AutoReleaseTime") {
            self.autoReleaseTime = dict["AutoReleaseTime"] as! String
        }
        if dict.keys.contains("AutoRenew") {
            self.autoRenew = dict["AutoRenew"] as! Bool
        }
        if dict.keys.contains("AutoRenewPeriod") {
            self.autoRenewPeriod = dict["AutoRenewPeriod"] as! Int32
        }
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("CreditSpecification") {
            self.creditSpecification = dict["CreditSpecification"] as! String
        }
        if dict.keys.contains("DataDisk") {
            var tmp : [RunInstancesRequest.DataDisk] = []
            for v in dict["DataDisk"] as! [Any] {
                var model = RunInstancesRequest.DataDisk()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.dataDisk = tmp
        }
        if dict.keys.contains("DedicatedHostId") {
            self.dedicatedHostId = dict["DedicatedHostId"] as! String
        }
        if dict.keys.contains("DeletionProtection") {
            self.deletionProtection = dict["DeletionProtection"] as! Bool
        }
        if dict.keys.contains("DeploymentSetGroupNo") {
            self.deploymentSetGroupNo = dict["DeploymentSetGroupNo"] as! Int32
        }
        if dict.keys.contains("DeploymentSetId") {
            self.deploymentSetId = dict["DeploymentSetId"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("HostName") {
            self.hostName = dict["HostName"] as! String
        }
        if dict.keys.contains("HostNames") {
            self.hostNames = dict["HostNames"] as! [String]
        }
        if dict.keys.contains("HpcClusterId") {
            self.hpcClusterId = dict["HpcClusterId"] as! String
        }
        if dict.keys.contains("HttpEndpoint") {
            self.httpEndpoint = dict["HttpEndpoint"] as! String
        }
        if dict.keys.contains("HttpPutResponseHopLimit") {
            self.httpPutResponseHopLimit = dict["HttpPutResponseHopLimit"] as! Int32
        }
        if dict.keys.contains("HttpTokens") {
            self.httpTokens = dict["HttpTokens"] as! String
        }
        if dict.keys.contains("ImageFamily") {
            self.imageFamily = dict["ImageFamily"] as! String
        }
        if dict.keys.contains("ImageId") {
            self.imageId = dict["ImageId"] as! String
        }
        if dict.keys.contains("ImageOptions") {
            var model = RunInstancesRequest.ImageOptions()
            model.fromMap(dict["ImageOptions"] as! [String: Any])
            self.imageOptions = model
        }
        if dict.keys.contains("InstanceChargeType") {
            self.instanceChargeType = dict["InstanceChargeType"] as! String
        }
        if dict.keys.contains("InstanceName") {
            self.instanceName = dict["InstanceName"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("InternetChargeType") {
            self.internetChargeType = dict["InternetChargeType"] as! String
        }
        if dict.keys.contains("InternetMaxBandwidthIn") {
            self.internetMaxBandwidthIn = dict["InternetMaxBandwidthIn"] as! Int32
        }
        if dict.keys.contains("InternetMaxBandwidthOut") {
            self.internetMaxBandwidthOut = dict["InternetMaxBandwidthOut"] as! Int32
        }
        if dict.keys.contains("IoOptimized") {
            self.ioOptimized = dict["IoOptimized"] as! String
        }
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("Ipv6AddressCount") {
            self.ipv6AddressCount = dict["Ipv6AddressCount"] as! Int32
        }
        if dict.keys.contains("Isp") {
            self.isp = dict["Isp"] as! String
        }
        if dict.keys.contains("KeyPairName") {
            self.keyPairName = dict["KeyPairName"] as! String
        }
        if dict.keys.contains("LaunchTemplateId") {
            self.launchTemplateId = dict["LaunchTemplateId"] as! String
        }
        if dict.keys.contains("LaunchTemplateName") {
            self.launchTemplateName = dict["LaunchTemplateName"] as! String
        }
        if dict.keys.contains("LaunchTemplateVersion") {
            self.launchTemplateVersion = dict["LaunchTemplateVersion"] as! Int64
        }
        if dict.keys.contains("MinAmount") {
            self.minAmount = dict["MinAmount"] as! Int32
        }
        if dict.keys.contains("NetworkInterface") {
            var tmp : [RunInstancesRequest.NetworkInterface] = []
            for v in dict["NetworkInterface"] as! [Any] {
                var model = RunInstancesRequest.NetworkInterface()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.networkInterface = tmp
        }
        if dict.keys.contains("NetworkInterfaceQueueNumber") {
            self.networkInterfaceQueueNumber = dict["NetworkInterfaceQueueNumber"] as! Int32
        }
        if dict.keys.contains("NetworkOptions") {
            var model = RunInstancesRequest.NetworkOptions()
            model.fromMap(dict["NetworkOptions"] as! [String: Any])
            self.networkOptions = model
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("Password") {
            self.password = dict["Password"] as! String
        }
        if dict.keys.contains("PasswordInherit") {
            self.passwordInherit = dict["PasswordInherit"] as! Bool
        }
        if dict.keys.contains("Period") {
            self.period = dict["Period"] as! Int32
        }
        if dict.keys.contains("PeriodUnit") {
            self.periodUnit = dict["PeriodUnit"] as! String
        }
        if dict.keys.contains("PrivateDnsNameOptions") {
            var model = RunInstancesRequest.PrivateDnsNameOptions()
            model.fromMap(dict["PrivateDnsNameOptions"] as! [String: Any])
            self.privateDnsNameOptions = model
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! String
        }
        if dict.keys.contains("RamRoleName") {
            self.ramRoleName = dict["RamRoleName"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("SecurityEnhancementStrategy") {
            self.securityEnhancementStrategy = dict["SecurityEnhancementStrategy"] as! String
        }
        if dict.keys.contains("SecurityGroupId") {
            self.securityGroupId = dict["SecurityGroupId"] as! String
        }
        if dict.keys.contains("SecurityGroupIds") {
            self.securityGroupIds = dict["SecurityGroupIds"] as! [String]
        }
        if dict.keys.contains("SpotDuration") {
            self.spotDuration = dict["SpotDuration"] as! Int32
        }
        if dict.keys.contains("SpotInterruptionBehavior") {
            self.spotInterruptionBehavior = dict["SpotInterruptionBehavior"] as! String
        }
        if dict.keys.contains("SpotPriceLimit") {
            self.spotPriceLimit = dict["SpotPriceLimit"] as! Double
        }
        if dict.keys.contains("SpotStrategy") {
            self.spotStrategy = dict["SpotStrategy"] as! String
        }
        if dict.keys.contains("StorageSetId") {
            self.storageSetId = dict["StorageSetId"] as! String
        }
        if dict.keys.contains("StorageSetPartitionNumber") {
            self.storageSetPartitionNumber = dict["StorageSetPartitionNumber"] as! Int32
        }
        if dict.keys.contains("Tag") {
            var tmp : [RunInstancesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = RunInstancesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("Tenancy") {
            self.tenancy = dict["Tenancy"] as! String
        }
        if dict.keys.contains("UniqueSuffix") {
            self.uniqueSuffix = dict["UniqueSuffix"] as! Bool
        }
        if dict.keys.contains("UserData") {
            self.userData = dict["UserData"] as! String
        }
        if dict.keys.contains("VSwitchId") {
            self.vSwitchId = dict["VSwitchId"] as! String
        }
        if dict.keys.contains("ZoneId") {
            self.zoneId = dict["ZoneId"] as! String
        }
    }
}

public class RunInstancesResponseBody : Tea.TeaModel {
    public class InstanceIdSets : Tea.TeaModel {
        public var instanceIdSet: [String]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceIdSet != nil {
                map["InstanceIdSet"] = self.instanceIdSet!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceIdSet") {
                self.instanceIdSet = dict["InstanceIdSet"] as! [String]
            }
        }
    }
    public var instanceIdSets: RunInstancesResponseBody.InstanceIdSets?

    public var orderId: String?

    public var requestId: String?

    public var tradePrice: Double?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceIdSets?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceIdSets != nil {
            map["InstanceIdSets"] = self.instanceIdSets?.toMap()
        }
        if self.orderId != nil {
            map["OrderId"] = self.orderId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.tradePrice != nil {
            map["TradePrice"] = self.tradePrice!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceIdSets") {
            var model = RunInstancesResponseBody.InstanceIdSets()
            model.fromMap(dict["InstanceIdSets"] as! [String: Any])
            self.instanceIdSets = model
        }
        if dict.keys.contains("OrderId") {
            self.orderId = dict["OrderId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("TradePrice") {
            self.tradePrice = dict["TradePrice"] as! Double
        }
    }
}

public class RunInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: RunInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = RunInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class SendFileRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var content: String?

    public var contentType: String?

    public var description_: String?

    public var fileGroup: String?

    public var fileMode: String?

    public var fileOwner: String?

    public var instanceId: [String]?

    public var name: String?

    public var overwrite: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceGroupId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var tag: [SendFileRequest.Tag]?

    public var targetDir: String?

    public var timeout: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.content != nil {
            map["Content"] = self.content!
        }
        if self.contentType != nil {
            map["ContentType"] = self.contentType!
        }
        if self.description_ != nil {
            map["Description"] = self.description_!
        }
        if self.fileGroup != nil {
            map["FileGroup"] = self.fileGroup!
        }
        if self.fileMode != nil {
            map["FileMode"] = self.fileMode!
        }
        if self.fileOwner != nil {
            map["FileOwner"] = self.fileOwner!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.name != nil {
            map["Name"] = self.name!
        }
        if self.overwrite != nil {
            map["Overwrite"] = self.overwrite!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceGroupId != nil {
            map["ResourceGroupId"] = self.resourceGroupId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        if self.targetDir != nil {
            map["TargetDir"] = self.targetDir!
        }
        if self.timeout != nil {
            map["Timeout"] = self.timeout!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Content") {
            self.content = dict["Content"] as! String
        }
        if dict.keys.contains("ContentType") {
            self.contentType = dict["ContentType"] as! String
        }
        if dict.keys.contains("Description") {
            self.description_ = dict["Description"] as! String
        }
        if dict.keys.contains("FileGroup") {
            self.fileGroup = dict["FileGroup"] as! String
        }
        if dict.keys.contains("FileMode") {
            self.fileMode = dict["FileMode"] as! String
        }
        if dict.keys.contains("FileOwner") {
            self.fileOwner = dict["FileOwner"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("Name") {
            self.name = dict["Name"] as! String
        }
        if dict.keys.contains("Overwrite") {
            self.overwrite = dict["Overwrite"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceGroupId") {
            self.resourceGroupId = dict["ResourceGroupId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("Tag") {
            var tmp : [SendFileRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = SendFileRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
        if dict.keys.contains("TargetDir") {
            self.targetDir = dict["TargetDir"] as! String
        }
        if dict.keys.contains("Timeout") {
            self.timeout = dict["Timeout"] as! Int64
        }
    }
}

public class SendFileResponseBody : Tea.TeaModel {
    public var invokeId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class SendFileResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: SendFileResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = SendFileResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartImagePipelineExecutionRequest : Tea.TeaModel {
    public class TemplateTag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var clientToken: String?

    public var imagePipelineId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var templateTag: [StartImagePipelineExecutionRequest.TemplateTag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.imagePipelineId != nil {
            map["ImagePipelineId"] = self.imagePipelineId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.templateTag != nil {
            var tmp : [Any] = []
            for k in self.templateTag! {
                tmp.append(k.toMap())
            }
            map["TemplateTag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("ImagePipelineId") {
            self.imagePipelineId = dict["ImagePipelineId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TemplateTag") {
            var tmp : [StartImagePipelineExecutionRequest.TemplateTag] = []
            for v in dict["TemplateTag"] as! [Any] {
                var model = StartImagePipelineExecutionRequest.TemplateTag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.templateTag = tmp
        }
    }
}

public class StartImagePipelineExecutionResponseBody : Tea.TeaModel {
    public var executionId: String?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.executionId != nil {
            map["ExecutionId"] = self.executionId!
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ExecutionId") {
            self.executionId = dict["ExecutionId"] as! String
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartImagePipelineExecutionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartImagePipelineExecutionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartImagePipelineExecutionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstanceRequest : Tea.TeaModel {
    public var dryRun: Bool?

    public var initLocalDisk: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.initLocalDisk != nil {
            map["InitLocalDisk"] = self.initLocalDisk!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InitLocalDisk") {
            self.initLocalDisk = dict["InitLocalDisk"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class StartInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var dryRun: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchOptimization") {
            self.batchOptimization = dict["BatchOptimization"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class StartInstancesResponseBody : Tea.TeaModel {
    public class InstanceResponses : Tea.TeaModel {
        public class InstanceResponse : Tea.TeaModel {
            public var code: String?

            public var currentStatus: String?

            public var instanceId: String?

            public var message: String?

            public var previousStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.currentStatus != nil {
                    map["CurrentStatus"] = self.currentStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.previousStatus != nil {
                    map["PreviousStatus"] = self.previousStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CurrentStatus") {
                    self.currentStatus = dict["CurrentStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PreviousStatus") {
                    self.previousStatus = dict["PreviousStatus"] as! String
                }
            }
        }
        public var instanceResponse: [StartInstancesResponseBody.InstanceResponses.InstanceResponse]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceResponse != nil {
                var tmp : [Any] = []
                for k in self.instanceResponse! {
                    tmp.append(k.toMap())
                }
                map["InstanceResponse"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceResponse") {
                var tmp : [StartInstancesResponseBody.InstanceResponses.InstanceResponse] = []
                for v in dict["InstanceResponse"] as! [Any] {
                    var model = StartInstancesResponseBody.InstanceResponses.InstanceResponse()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceResponse = tmp
            }
        }
    }
    public var instanceResponses: StartInstancesResponseBody.InstanceResponses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceResponses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            map["InstanceResponses"] = self.instanceResponses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") {
            var model = StartInstancesResponseBody.InstanceResponses()
            model.fromMap(dict["InstanceResponses"] as! [String: Any])
            self.instanceResponses = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StartInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StartTerminalSessionRequest : Tea.TeaModel {
    public var commandLine: String?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var portNumber: Int32?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var targetServer: String?

    public var username: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.commandLine != nil {
            map["CommandLine"] = self.commandLine!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.portNumber != nil {
            map["PortNumber"] = self.portNumber!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.targetServer != nil {
            map["TargetServer"] = self.targetServer!
        }
        if self.username != nil {
            map["Username"] = self.username!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("CommandLine") {
            self.commandLine = dict["CommandLine"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PortNumber") {
            self.portNumber = dict["PortNumber"] as! Int32
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("TargetServer") {
            self.targetServer = dict["TargetServer"] as! String
        }
        if dict.keys.contains("Username") {
            self.username = dict["Username"] as! String
        }
    }
}

public class StartTerminalSessionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public var securityToken: String?

    public var sessionId: String?

    public var webSocketUrl: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        if self.securityToken != nil {
            map["SecurityToken"] = self.securityToken!
        }
        if self.sessionId != nil {
            map["SessionId"] = self.sessionId!
        }
        if self.webSocketUrl != nil {
            map["WebSocketUrl"] = self.webSocketUrl!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
        if dict.keys.contains("SecurityToken") {
            self.securityToken = dict["SecurityToken"] as! String
        }
        if dict.keys.contains("SessionId") {
            self.sessionId = dict["SessionId"] as! String
        }
        if dict.keys.contains("WebSocketUrl") {
            self.webSocketUrl = dict["WebSocketUrl"] as! String
        }
    }
}

public class StartTerminalSessionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StartTerminalSessionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StartTerminalSessionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInstanceRequest : Tea.TeaModel {
    public var confirmStop: Bool?

    public var dryRun: Bool?

    public var forceStop: Bool?

    public var hibernate: Bool?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var stoppedMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.confirmStop != nil {
            map["ConfirmStop"] = self.confirmStop!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.hibernate != nil {
            map["Hibernate"] = self.hibernate!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ConfirmStop") {
            self.confirmStop = dict["ConfirmStop"] as! Bool
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ForceStop") {
            self.forceStop = dict["ForceStop"] as! Bool
        }
        if dict.keys.contains("Hibernate") {
            self.hibernate = dict["Hibernate"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StoppedMode") {
            self.stoppedMode = dict["StoppedMode"] as! String
        }
    }
}

public class StopInstanceResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInstanceResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstanceResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopInstanceResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInstancesRequest : Tea.TeaModel {
    public var batchOptimization: String?

    public var dryRun: Bool?

    public var forceStop: Bool?

    public var instanceId: [String]?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var stoppedMode: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.batchOptimization != nil {
            map["BatchOptimization"] = self.batchOptimization!
        }
        if self.dryRun != nil {
            map["DryRun"] = self.dryRun!
        }
        if self.forceStop != nil {
            map["ForceStop"] = self.forceStop!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.stoppedMode != nil {
            map["StoppedMode"] = self.stoppedMode!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("BatchOptimization") {
            self.batchOptimization = dict["BatchOptimization"] as! String
        }
        if dict.keys.contains("DryRun") {
            self.dryRun = dict["DryRun"] as! Bool
        }
        if dict.keys.contains("ForceStop") {
            self.forceStop = dict["ForceStop"] as! Bool
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("StoppedMode") {
            self.stoppedMode = dict["StoppedMode"] as! String
        }
    }
}

public class StopInstancesResponseBody : Tea.TeaModel {
    public class InstanceResponses : Tea.TeaModel {
        public class InstanceResponse : Tea.TeaModel {
            public var code: String?

            public var currentStatus: String?

            public var instanceId: String?

            public var message: String?

            public var previousStatus: String?

            public override init() {
                super.init()
            }

            public init(_ dict: [String: Any]) {
                super.init()
                self.fromMap(dict)
            }

            public override func validate() throws -> Void {
            }

            public override func toMap() -> [String : Any] {
                var map = super.toMap()
                if self.code != nil {
                    map["Code"] = self.code!
                }
                if self.currentStatus != nil {
                    map["CurrentStatus"] = self.currentStatus!
                }
                if self.instanceId != nil {
                    map["InstanceId"] = self.instanceId!
                }
                if self.message != nil {
                    map["Message"] = self.message!
                }
                if self.previousStatus != nil {
                    map["PreviousStatus"] = self.previousStatus!
                }
                return map
            }

            public override func fromMap(_ dict: [String: Any]) -> Void {
                if dict.keys.contains("Code") {
                    self.code = dict["Code"] as! String
                }
                if dict.keys.contains("CurrentStatus") {
                    self.currentStatus = dict["CurrentStatus"] as! String
                }
                if dict.keys.contains("InstanceId") {
                    self.instanceId = dict["InstanceId"] as! String
                }
                if dict.keys.contains("Message") {
                    self.message = dict["Message"] as! String
                }
                if dict.keys.contains("PreviousStatus") {
                    self.previousStatus = dict["PreviousStatus"] as! String
                }
            }
        }
        public var instanceResponse: [StopInstancesResponseBody.InstanceResponses.InstanceResponse]?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.instanceResponse != nil {
                var tmp : [Any] = []
                for k in self.instanceResponse! {
                    tmp.append(k.toMap())
                }
                map["InstanceResponse"] = tmp
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("InstanceResponse") {
                var tmp : [StopInstancesResponseBody.InstanceResponses.InstanceResponse] = []
                for v in dict["InstanceResponse"] as! [Any] {
                    var model = StopInstancesResponseBody.InstanceResponses.InstanceResponse()
                    if v != nil {
                        model.fromMap(v as! [String: Any])
                    }
                    tmp.append(model)
                }
                self.instanceResponse = tmp
            }
        }
    }
    public var instanceResponses: StopInstancesResponseBody.InstanceResponses?

    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.instanceResponses?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceResponses != nil {
            map["InstanceResponses"] = self.instanceResponses?.toMap()
        }
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceResponses") {
            var model = StopInstancesResponseBody.InstanceResponses()
            model.fromMap(dict["InstanceResponses"] as! [String: Any])
            self.instanceResponses = model
        }
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInstancesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInstancesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopInstancesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class StopInvocationRequest : Tea.TeaModel {
    public var instanceId: [String]?

    public var invokeId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.invokeId != nil {
            map["InvokeId"] = self.invokeId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! [String]
        }
        if dict.keys.contains("InvokeId") {
            self.invokeId = dict["InvokeId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class StopInvocationResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class StopInvocationResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: StopInvocationResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = StopInvocationResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TagResourcesRequest : Tea.TeaModel {
    public class Tag : Tea.TeaModel {
        public var key: String?

        public var value: String?

        public override init() {
            super.init()
        }

        public init(_ dict: [String: Any]) {
            super.init()
            self.fromMap(dict)
        }

        public override func validate() throws -> Void {
        }

        public override func toMap() -> [String : Any] {
            var map = super.toMap()
            if self.key != nil {
                map["Key"] = self.key!
            }
            if self.value != nil {
                map["Value"] = self.value!
            }
            return map
        }

        public override func fromMap(_ dict: [String: Any]) -> Void {
            if dict.keys.contains("Key") {
                self.key = dict["Key"] as! String
            }
            if dict.keys.contains("Value") {
                self.value = dict["Value"] as! String
            }
        }
    }
    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceType: String?

    public var tag: [TagResourcesRequest.Tag]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tag != nil {
            var tmp : [Any] = []
            for k in self.tag! {
                tmp.append(k.toMap())
            }
            map["Tag"] = tmp
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("Tag") {
            var tmp : [TagResourcesRequest.Tag] = []
            for v in dict["Tag"] as! [Any] {
                var model = TagResourcesRequest.Tag()
                if v != nil {
                    model.fromMap(v as! [String: Any])
                }
                tmp.append(model)
            }
            self.tag = tmp
        }
    }
}

public class TagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminatePhysicalConnectionRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var physicalConnectionId: String?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.physicalConnectionId != nil {
            map["PhysicalConnectionId"] = self.physicalConnectionId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PhysicalConnectionId") {
            self.physicalConnectionId = dict["PhysicalConnectionId"] as! String
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
    }
}

public class TerminatePhysicalConnectionResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TerminatePhysicalConnectionResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminatePhysicalConnectionResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminatePhysicalConnectionResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class TerminateVirtualBorderRouterRequest : Tea.TeaModel {
    public var clientToken: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var userCidr: String?

    public var vbrId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.userCidr != nil {
            map["UserCidr"] = self.userCidr!
        }
        if self.vbrId != nil {
            map["VbrId"] = self.vbrId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("UserCidr") {
            self.userCidr = dict["UserCidr"] as! String
        }
        if dict.keys.contains("VbrId") {
            self.vbrId = dict["VbrId"] as! String
        }
    }
}

public class TerminateVirtualBorderRouterResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class TerminateVirtualBorderRouterResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: TerminateVirtualBorderRouterResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = TerminateVirtualBorderRouterResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassignIpv6AddressesRequest : Tea.TeaModel {
    public var ipv6Address: [String]?

    public var ipv6Prefix: [String]?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv6Address != nil {
            map["Ipv6Address"] = self.ipv6Address!
        }
        if self.ipv6Prefix != nil {
            map["Ipv6Prefix"] = self.ipv6Prefix!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv6Address") {
            self.ipv6Address = dict["Ipv6Address"] as! [String]
        }
        if dict.keys.contains("Ipv6Prefix") {
            self.ipv6Prefix = dict["Ipv6Prefix"] as! [String]
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassignIpv6AddressesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassignIpv6AddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassignIpv6AddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassignIpv6AddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassignPrivateIpAddressesRequest : Tea.TeaModel {
    public var ipv4Prefix: [String]?

    public var networkInterfaceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var privateIpAddress: [String]?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.ipv4Prefix != nil {
            map["Ipv4Prefix"] = self.ipv4Prefix!
        }
        if self.networkInterfaceId != nil {
            map["NetworkInterfaceId"] = self.networkInterfaceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.privateIpAddress != nil {
            map["PrivateIpAddress"] = self.privateIpAddress!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("Ipv4Prefix") {
            self.ipv4Prefix = dict["Ipv4Prefix"] as! [String]
        }
        if dict.keys.contains("NetworkInterfaceId") {
            self.networkInterfaceId = dict["NetworkInterfaceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("PrivateIpAddress") {
            self.privateIpAddress = dict["PrivateIpAddress"] as! [String]
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassignPrivateIpAddressesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassignPrivateIpAddressesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassignPrivateIpAddressesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassignPrivateIpAddressesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateEipAddressRequest : Tea.TeaModel {
    public var allocationId: String?

    public var instanceId: String?

    public var instanceType: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.allocationId != nil {
            map["AllocationId"] = self.allocationId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.instanceType != nil {
            map["InstanceType"] = self.instanceType!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("AllocationId") {
            self.allocationId = dict["AllocationId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("InstanceType") {
            self.instanceType = dict["InstanceType"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassociateEipAddressResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateEipAddressResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateEipAddressResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateEipAddressResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UnassociateHaVipRequest : Tea.TeaModel {
    public var clientToken: String?

    public var force: String?

    public var haVipId: String?

    public var instanceId: String?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.clientToken != nil {
            map["ClientToken"] = self.clientToken!
        }
        if self.force != nil {
            map["Force"] = self.force!
        }
        if self.haVipId != nil {
            map["HaVipId"] = self.haVipId!
        }
        if self.instanceId != nil {
            map["InstanceId"] = self.instanceId!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("ClientToken") {
            self.clientToken = dict["ClientToken"] as! String
        }
        if dict.keys.contains("Force") {
            self.force = dict["Force"] as! String
        }
        if dict.keys.contains("HaVipId") {
            self.haVipId = dict["HaVipId"] as! String
        }
        if dict.keys.contains("InstanceId") {
            self.instanceId = dict["InstanceId"] as! String
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
    }
}

public class UnassociateHaVipResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UnassociateHaVipResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UnassociateHaVipResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UnassociateHaVipResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}

public class UntagResourcesRequest : Tea.TeaModel {
    public var all: Bool?

    public var ownerAccount: String?

    public var ownerId: Int64?

    public var regionId: String?

    public var resourceId: [String]?

    public var resourceOwnerAccount: String?

    public var resourceOwnerId: Int64?

    public var resourceType: String?

    public var tagKey: [String]?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.all != nil {
            map["All"] = self.all!
        }
        if self.ownerAccount != nil {
            map["OwnerAccount"] = self.ownerAccount!
        }
        if self.ownerId != nil {
            map["OwnerId"] = self.ownerId!
        }
        if self.regionId != nil {
            map["RegionId"] = self.regionId!
        }
        if self.resourceId != nil {
            map["ResourceId"] = self.resourceId!
        }
        if self.resourceOwnerAccount != nil {
            map["ResourceOwnerAccount"] = self.resourceOwnerAccount!
        }
        if self.resourceOwnerId != nil {
            map["ResourceOwnerId"] = self.resourceOwnerId!
        }
        if self.resourceType != nil {
            map["ResourceType"] = self.resourceType!
        }
        if self.tagKey != nil {
            map["TagKey"] = self.tagKey!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("All") {
            self.all = dict["All"] as! Bool
        }
        if dict.keys.contains("OwnerAccount") {
            self.ownerAccount = dict["OwnerAccount"] as! String
        }
        if dict.keys.contains("OwnerId") {
            self.ownerId = dict["OwnerId"] as! Int64
        }
        if dict.keys.contains("RegionId") {
            self.regionId = dict["RegionId"] as! String
        }
        if dict.keys.contains("ResourceId") {
            self.resourceId = dict["ResourceId"] as! [String]
        }
        if dict.keys.contains("ResourceOwnerAccount") {
            self.resourceOwnerAccount = dict["ResourceOwnerAccount"] as! String
        }
        if dict.keys.contains("ResourceOwnerId") {
            self.resourceOwnerId = dict["ResourceOwnerId"] as! Int64
        }
        if dict.keys.contains("ResourceType") {
            self.resourceType = dict["ResourceType"] as! String
        }
        if dict.keys.contains("TagKey") {
            self.tagKey = dict["TagKey"] as! [String]
        }
    }
}

public class UntagResourcesResponseBody : Tea.TeaModel {
    public var requestId: String?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.requestId != nil {
            map["RequestId"] = self.requestId!
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("RequestId") {
            self.requestId = dict["RequestId"] as! String
        }
    }
}

public class UntagResourcesResponse : Tea.TeaModel {
    public var headers: [String: String]?

    public var statusCode: Int32?

    public var body: UntagResourcesResponseBody?

    public override init() {
        super.init()
    }

    public init(_ dict: [String: Any]) {
        super.init()
        self.fromMap(dict)
    }

    public override func validate() throws -> Void {
        try self.body?.validate()
    }

    public override func toMap() -> [String : Any] {
        var map = super.toMap()
        if self.headers != nil {
            map["headers"] = self.headers!
        }
        if self.statusCode != nil {
            map["statusCode"] = self.statusCode!
        }
        if self.body != nil {
            map["body"] = self.body?.toMap()
        }
        return map
    }

    public override func fromMap(_ dict: [String: Any]) -> Void {
        if dict.keys.contains("headers") {
            self.headers = dict["headers"] as! [String: String]
        }
        if dict.keys.contains("statusCode") {
            self.statusCode = dict["statusCode"] as! Int32
        }
        if dict.keys.contains("body") {
            var model = UntagResourcesResponseBody()
            model.fromMap(dict["body"] as! [String: Any])
            self.body = model
        }
    }
}
